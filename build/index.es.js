import { __makeTemplateObject, __assign, __extends, __spreadArray, __rest, __awaiter, __generator, __read } from 'tslib';
import { jsx, jsxs, Fragment as Fragment$1 } from '@emotion/react/jsx-runtime';
import { css as css$1, createElement, Global } from '@emotion/react';
import styled$1 from '@emotion/styled';
import { motion, AnimatePresence } from 'framer-motion';
import * as React from 'react';
import React__default, { useEffect, useLayoutEffect, forwardRef, useState, useRef, useContext, useCallback, useMemo, Fragment as Fragment$2, createRef, useDebugValue, createElement as createElement$1, createContext } from 'react';
import { Source, visit, print, BREAK, parse } from 'graphql';
import cookie from 'js-cookie';
import { useRouter } from 'next/router';
import { useSelector, useDispatch } from 'react-redux';
import NextImage from 'next/image';
import NextLink from 'next/link';
import lodash from 'lodash';
import { v4 } from 'uuid';
import { request } from 'graphql-request';
import Head from 'next/head';
import ReactDOM from 'react-dom';

var TextStyle$2 = function (props) { return css$1(templateObject_1$1s || (templateObject_1$1s = __makeTemplateObject(["\n  line-height: 150%;\n  font-family: ", ";\n  color: ", ";\n  text-align: ", ";\n  padding: ", ";\n  margin: ", ";\n  width: ", ";\n  max-width: ", ";\n  font-size: ", ";\n  font-weight: ", ";\n  text-decoration: ", ";\n  cursor: ", ";\n  * {\n    cursor: ", ";\n  }\n\n  ", ";\n"], ["\n  line-height: 150%;\n  font-family: ", ";\n  color: ", ";\n  text-align: ", ";\n  padding: ", ";\n  margin: ", ";\n  width: ", ";\n  max-width: ", ";\n  font-size: ", ";\n  font-weight: ", ";\n  text-decoration: ", ";\n  cursor: ", ";\n  * {\n    cursor: ", ";\n  }\n\n  ", ";\n"])), (props === null || props === void 0 ? void 0 : props.font) || "'Montserrat', sans-serif", (props === null || props === void 0 ? void 0 : props.color) || "#202124", (props === null || props === void 0 ? void 0 : props.align) || "left", (props === null || props === void 0 ? void 0 : props.padding) || "0px 0px 0px 0px", (props === null || props === void 0 ? void 0 : props.margin) || "0px 0px 0px 0px", (props === null || props === void 0 ? void 0 : props.width) || "max-content", (props === null || props === void 0 ? void 0 : props.maxWidth) || "100%", (props === null || props === void 0 ? void 0 : props.fontSize) || "14px", (props === null || props === void 0 ? void 0 : props.fontWeight) || 500, (props === null || props === void 0 ? void 0 : props.textDecoration) || "none", (props === null || props === void 0 ? void 0 : props.cursor) || "pointer", (props === null || props === void 0 ? void 0 : props.cursor) || "pointer", props === null || props === void 0 ? void 0 : props.customCSS); };
var TextStyledDefault = styled$1(motion.span)(templateObject_2$11 || (templateObject_2$11 = __makeTemplateObject(["\n  ", "\n"], ["\n  ", "\n"])), function (props) { return TextStyle$2(props); });
var TextStyledA = styled$1(motion.a)(templateObject_3$S || (templateObject_3$S = __makeTemplateObject(["\n  ", "\n"], ["\n  ", "\n"])), function (props) { return TextStyle$2(props); });
var TextStyledP = styled$1(motion.p)(templateObject_4$E || (templateObject_4$E = __makeTemplateObject(["\n  ", "\n"], ["\n  ", "\n"])), function (props) { return TextStyle$2(props); });
var TextStyledH1 = styled$1(motion.h1)(templateObject_5$s || (templateObject_5$s = __makeTemplateObject(["\n  ", "\n"], ["\n  ", "\n"])), function (props) { return TextStyle$2(props); });
var TextStyledH2 = styled$1(motion.h2)(templateObject_6$l || (templateObject_6$l = __makeTemplateObject(["\n  ", "\n"], ["\n  ", "\n"])), function (props) { return TextStyle$2(props); });
var TextStyledH3 = styled$1(motion.h3)(templateObject_7$h || (templateObject_7$h = __makeTemplateObject(["\n  ", "\n"], ["\n  ", "\n"])), function (props) { return TextStyle$2(props); });
var TextStyledH4 = styled$1(motion.h4)(templateObject_8$b || (templateObject_8$b = __makeTemplateObject(["\n  ", "\n"], ["\n  ", "\n"])), function (props) { return TextStyle$2(props); });
var TextStyledH5 = styled$1(motion.h5)(templateObject_9$9 || (templateObject_9$9 = __makeTemplateObject(["\n  ", "\n"], ["\n  ", "\n"])), function (props) { return TextStyle$2(props); });
var TextStyledH6 = styled$1(motion.h6)(templateObject_10$8 || (templateObject_10$8 = __makeTemplateObject(["\n  ", "\n"], ["\n  ", "\n"])), function (props) { return TextStyle$2(props); });
var templateObject_1$1s, templateObject_2$11, templateObject_3$S, templateObject_4$E, templateObject_5$s, templateObject_6$l, templateObject_7$h, templateObject_8$b, templateObject_9$9, templateObject_10$8;

var Text$2 = function (props) {
    var children = props.children, as = props.as;
    switch (as) {
        case 'a':
            return jsx(TextStyledA, __assign({}, props, { children: children }));
        case 'p':
            return jsx(TextStyledP, __assign({}, props, { children: children }));
        case 'h1':
            return jsx(TextStyledH1, __assign({}, props, { children: children }));
        case 'h2':
            return jsx(TextStyledH2, __assign({}, props, { children: children }));
        case 'h3':
            return jsx(TextStyledH3, __assign({}, props, { children: children }));
        case 'h4':
            return jsx(TextStyledH4, __assign({}, props, { children: children }));
        case 'h5':
            return jsx(TextStyledH5, __assign({}, props, { children: children }));
        case 'h6':
            return jsx(TextStyledH6, __assign({}, props, { children: children }));
        default:
            return jsx(TextStyledDefault, __assign({}, props, { children: children }));
    }
};

var AtomWrapperStyled = function (props) { return css$1(templateObject_1$1r || (templateObject_1$1r = __makeTemplateObject(["\n  display: flex;\n  width: ", ";\n  max-width: ", ";\n  border: ", ";\n  outline: ", ";\n  min-height: ", ";\n  gap: ", ";\n  max-height: ", ";\n  height: ", ";\n  flex-direction: ", ";\n  justify-content: ", ";\n  align-items: ", ";\n  background-image: ", ";\n  background-color: ", ";\n  background-position: center;\n  background-size: ", ";\n  padding: ", ";\n  margin: ", ";\n  flex-wrap: ", ";\n  ", ";\n  border-radius: ", ";\n  ", ";\n  z-index: ", ";\n  position: ", ";\n  cursor: ", ";\n  mix-blend-mode: ", ";\n\n  ", ";\n"], ["\n  display: flex;\n  width: ", ";\n  max-width: ", ";\n  border: ", ";\n  outline: ", ";\n  min-height: ", ";\n  gap: ", ";\n  max-height: ", ";\n  height: ", ";\n  flex-direction: ", ";\n  justify-content: ", ";\n  align-items: ", ";\n  background-image: ", ";\n  background-color: ", ";\n  background-position: center;\n  background-size: ", ";\n  padding: ", ";\n  margin: ", ";\n  flex-wrap: ", ";\n  ", ";\n  border-radius: ", ";\n  ", ";\n  z-index: ", ";\n  position: ", ";\n  cursor: ", ";\n  mix-blend-mode: ", ";\n\n  ", ";\n"])), (props === null || props === void 0 ? void 0 : props.width) || "100%", (props === null || props === void 0 ? void 0 : props.maxWidth) || "100%", (props === null || props === void 0 ? void 0 : props.border) || "none", (props === null || props === void 0 ? void 0 : props.outline) || "none", (props === null || props === void 0 ? void 0 : props.minHeight) || "initial", (props === null || props === void 0 ? void 0 : props.gap) || "0", (props === null || props === void 0 ? void 0 : props.maxHeight) || "initial", (props === null || props === void 0 ? void 0 : props.height) || "max-content", (props === null || props === void 0 ? void 0 : props.flexDirection) || "column", (props === null || props === void 0 ? void 0 : props.justifyContent) || "center", (props === null || props === void 0 ? void 0 : props.alignItems) || "flex-start", props === null || props === void 0 ? void 0 : props.backgroundImage, (props === null || props === void 0 ? void 0 : props.backgroundColor) || "transparent", (props === null || props === void 0 ? void 0 : props.backgroundSize) || "cover", (props === null || props === void 0 ? void 0 : props.padding) || "0px 0px 0px 0px", (props === null || props === void 0 ? void 0 : props.margin) || "0px 0px 0px 0px", (props === null || props === void 0 ? void 0 : props.flexWrap) || "nowrap", (props === null || props === void 0 ? void 0 : props.shadow) && "box-shadow: 0px 10px 20px #00000029", (props === null || props === void 0 ? void 0 : props.borderRadius) || "0px", "overflow-x:".concat(props === null || props === void 0 ? void 0 : props.overflowX), (props === null || props === void 0 ? void 0 : props.zIndex) || "0", (props === null || props === void 0 ? void 0 : props.position) || "static", (props === null || props === void 0 ? void 0 : props.cursor) || "default", (props === null || props === void 0 ? void 0 : props.mixBlendMode) || "normal", props === null || props === void 0 ? void 0 : props.customCSS); };
var AtomWrapperDefaultStyled = styled$1(motion.div)(templateObject_2$10 || (templateObject_2$10 = __makeTemplateObject(["\n  ", ";\n"], ["\n  ", ";\n"])), function (props) { return AtomWrapperStyled(props); });
var AtomWrapperFormStyled = styled$1(motion.form)(templateObject_3$R || (templateObject_3$R = __makeTemplateObject(["\n  ", ";\n"], ["\n  ", ";\n"])), function (props) { return AtomWrapperStyled(props); });
var AtomWrapperSectionStyled = styled$1(motion.section)(templateObject_4$D || (templateObject_4$D = __makeTemplateObject(["\n  ", ";\n"], ["\n  ", ";\n"])), function (props) { return AtomWrapperStyled(props); });
var AtomWrapperLiStyled = styled$1(motion.li)(templateObject_5$r || (templateObject_5$r = __makeTemplateObject(["\n  ", ";\n"], ["\n  ", ";\n"])), function (props) { return AtomWrapperStyled(props); });
var templateObject_1$1r, templateObject_2$10, templateObject_3$R, templateObject_4$D, templateObject_5$r;

var DefaultAnimation$2 = {
    transition: {
        default: { duration: 0.3 },
    },
    initial: { opacity: 0 },
    animate: { opacity: 1 },
    exit: { opacity: 0 },
};
var Wrapper$2 = function (props) {
    var children = props.children, refObject = props.refObject, as = props.as;
    switch (as) {
        case 'form':
            return (jsx(AtomWrapperFormStyled, __assign({ ref: refObject }, DefaultAnimation$2, props, { children: children })));
        case 'section':
            return (jsx(AtomWrapperSectionStyled, __assign({ ref: refObject }, DefaultAnimation$2, props, { children: children })));
        case 'li':
            return (jsx(AtomWrapperLiStyled, __assign({ ref: refObject }, DefaultAnimation$2, props, { children: children })));
        default:
            return (jsx(AtomWrapperDefaultStyled, __assign({ ref: refObject }, DefaultAnimation$2, props, { children: children })));
    }
};

var AtomBanner = function (props) {
    var title = props.title, description = props.description, componentsProps = props.componentsProps, children = props.children;
    return (jsx(Wrapper$2, __assign({ backgroundColor: "#f5f5f5", maxWidth: "100%", alignItems: "center", customCSS: css$1(templateObject_1$1q || (templateObject_1$1q = __makeTemplateObject(["\n        @media only screen and (max-width: 980px) {\n          padding: 40px 30px;\n        }\n      "], ["\n        @media only screen and (max-width: 980px) {\n          padding: 40px 30px;\n        }\n      "]))) }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.containerProps, { children: jsxs(Wrapper$2, __assign({ maxWidth: "1440px", alignItems: "flex-start", padding: "50px 90px", customCSS: css$1(templateObject_2$$ || (templateObject_2$$ = __makeTemplateObject(["\n          @media only screen and (max-width: 980px) {\n            align-items: center;\n            padding: 0px 0px;\n          }\n        "], ["\n          @media only screen and (max-width: 980px) {\n            align-items: center;\n            padding: 0px 0px;\n          }\n        "]))) }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperProps, { children: [title && (jsx(Text$2, __assign({ fontSize: "38px", color: "white", align: "center", fontWeight: 500, as: "h1", customCSS: css$1(templateObject_3$Q || (templateObject_3$Q = __makeTemplateObject(["\n              @media only screen and (max-width: 520px) {\n                font-size: 36px;\n              }\n            "], ["\n              @media only screen and (max-width: 520px) {\n                font-size: 36px;\n              }\n            "]))) }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.titleProps, { dangerouslySetInnerHTML: {
                        __html: title,
                    } }))), description && (jsx(Text$2, __assign({ fontSize: "20px", color: "white", align: "center", fontWeight: 500, as: "h1", padding: "5px 0px", customCSS: css$1(templateObject_4$C || (templateObject_4$C = __makeTemplateObject(["\n              @media only screen and (max-width: 520px) {\n                font-size: 18px;\n              }\n            "], ["\n              @media only screen and (max-width: 520px) {\n                font-size: 18px;\n              }\n            "]))) }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.descriptionProps, { children: description }))), children] })) })));
};
var templateObject_1$1q, templateObject_2$$, templateObject_3$Q, templateObject_4$C;

var ButtonStyled$2 = styled$1(motion.button)(templateObject_2$_ || (templateObject_2$_ = __makeTemplateObject(["\n  width: ", ";\n  height: ", ";\n  color: ", ";\n  background-color: ", ";\n  background-image: ", ";\n  padding: ", ";\n  margin: ", ";\n  cursor: ", ";\n  text-shadow: ", ";\n  font-size: ", ";\n  font-family: ", ";\n  font-weight: ", ";\n  border: ", ";\n  border-radius: ", ";\n  line-height: 150%;\n  ", "\n\n  ", ";\n"], ["\n  width: ", ";\n  height: ", ";\n  color: ", ";\n  background-color: ", ";\n  background-image: ", ";\n  padding: ", ";\n  margin: ", ";\n  cursor: ", ";\n  text-shadow: ", ";\n  font-size: ", ";\n  font-family: ", ";\n  font-weight: ", ";\n  border: ", ";\n  border-radius: ", ";\n  line-height: 150%;\n  ", "\n\n  ", ";\n"])), function (_a) {
    var width = _a.width;
    return width || "max-content";
}, function (_a) {
    var height = _a.height;
    return height || "max-content";
}, function (_a) {
    var color = _a.color;
    return color || "#ffffff";
}, function (_a) {
    var backgroundColor = _a.backgroundColor;
    return backgroundColor || "#fe6a6a";
}, function (_a) {
    var backgroundImage = _a.backgroundImage;
    return backgroundImage || "none";
}, function (_a) {
    var padding = _a.padding;
    return padding || "8px 30px";
}, function (_a) {
    var margin = _a.margin;
    return margin || "0px 0px 0px 0px";
}, function (_a) {
    var cursor = _a.cursor;
    return cursor || "pointer";
}, function (_a) {
    var textShadow = _a.textShadow;
    return textShadow || "none";
}, function (_a) {
    var fontSize = _a.fontSize;
    return fontSize || "12px";
}, function (_a) {
    var font = _a.font;
    return font || "'Montserrat', sans-serif";
}, function (_a) {
    var fontWeight = _a.fontWeight;
    return fontWeight || '600';
}, function (_a) {
    var border = _a.border;
    return border || "none";
}, function (_a) {
    var borderRadius = _a.borderRadius;
    return borderRadius || "4px";
}, function (_a) {
    var disabled = _a.disabled;
    return disabled && css$1(templateObject_1$1p || (templateObject_1$1p = __makeTemplateObject(["\n      background-color: #e6e6e6;\n      color: #7e7e7e;\n    "], ["\n      background-color: #e6e6e6;\n      color: #7e7e7e;\n    "])));
}, function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
var templateObject_1$1p, templateObject_2$_;

var LoaderContainer = styled$1.div(templateObject_3$P || (templateObject_3$P = __makeTemplateObject(["\n  ", ";\n  background-image: ", ";\n  background-size: cover;\n  background-attachment: fixed;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  .lds-ring {\n    display: inline-block;\n    position: relative;\n    width: 80px;\n    height: 80px;\n  }\n  .lds-ring div {\n    box-sizing: border-box;\n    display: block;\n    position: absolute;\n    width: 64px;\n    height: 64px;\n    margin: 8px;\n    border: ", " solid\n      ", ";\n    border-radius: 50%;\n    animation: lds-ring 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;\n    border-color: ", " transparent\n      transparent transparent;\n  }\n  .lds-ring div:nth-of-type(1) {\n    animation-delay: -0.45s;\n  }\n  .lds-ring div:nth-of-type(2) {\n    animation-delay: -0.3s;\n  }\n  .lds-ring div:nth-of-type(3) {\n    animation-delay: -0.15s;\n  }\n  @keyframes lds-ring {\n    0% {\n      transform: rotate(0deg);\n    }\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n  ", ";\n"], ["\n  ", ";\n  background-image: ", ";\n  background-size: cover;\n  background-attachment: fixed;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  .lds-ring {\n    display: inline-block;\n    position: relative;\n    width: 80px;\n    height: 80px;\n  }\n  .lds-ring div {\n    box-sizing: border-box;\n    display: block;\n    position: absolute;\n    width: 64px;\n    height: 64px;\n    margin: 8px;\n    border: ", " solid\n      ", ";\n    border-radius: 50%;\n    animation: lds-ring 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;\n    border-color: ", " transparent\n      transparent transparent;\n  }\n  .lds-ring div:nth-of-type(1) {\n    animation-delay: -0.45s;\n  }\n  .lds-ring div:nth-of-type(2) {\n    animation-delay: -0.3s;\n  }\n  .lds-ring div:nth-of-type(3) {\n    animation-delay: -0.15s;\n  }\n  @keyframes lds-ring {\n    0% {\n      transform: rotate(0deg);\n    }\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n  ", ";\n"])), function (_a) {
    var type = _a.type, width = _a.width, height = _a.height, backgroundColor = _a.backgroundColor;
    return type === 'small'
        ? css$1(templateObject_1$1o || (templateObject_1$1o = __makeTemplateObject(["\n          width: ", ";\n          height: ", ";\n          background-color: ", ";\n        "], ["\n          width: ", ";\n          height: ", ";\n          background-color: ", ";\n        "])), width || 'max-content', height || 'max-content', backgroundColor || 'transparent') : css$1(templateObject_2$Z || (templateObject_2$Z = __makeTemplateObject(["\n          width: 100%;\n          height: 100vh;\n          position: fixed;\n          z-index: 9999;\n          backdrop-filter: blur(12px);\n          top: 0;\n          left: 0;\n          background-color: ", ";\n        "], ["\n          width: 100%;\n          height: 100vh;\n          position: fixed;\n          z-index: 9999;\n          backdrop-filter: blur(12px);\n          top: 0;\n          left: 0;\n          background-color: ", ";\n        "])), backgroundColor || 'white');
}, function (_a) {
    var backgroundImage = _a.backgroundImage;
    return backgroundImage || "none";
}, function (_a) {
    var widthLoader = _a.widthLoader;
    return widthLoader || '8px';
}, function (_a) {
    var colorLoading = _a.colorLoading;
    return colorLoading || "#fe6a6a";
}, function (_a) {
    var colorLoading = _a.colorLoading;
    return colorLoading || "#fe6a6a";
}, function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
var templateObject_1$1o, templateObject_2$Z, templateObject_3$P;

var Loader = function (props) {
    var isLoading = props.isLoading;
    return isLoading ? (jsx(LoaderContainer, __assign({}, props, { children: jsxs("div", __assign({ className: "lds-ring" }, { children: [jsx("div", {}), jsx("div", {}), jsx("div", {}), jsx("div", {})] })) }))) : null;
};

var Animation$e = {
    whileHover: { scale: 1.02, transition: { duration: 0.3 } },
    whileTap: { scale: 0.98, opacity: 0.8 },
};
var AtomButton = function (props) {
    var children = props.children, disabled = props.disabled, refObject = props.refObject, loading = props.loading;
    return (jsx(ButtonStyled$2, __assign({ ref: refObject }, (disabled ? {} : Animation$e), props, { children: loading ? (jsx(Loader, { isLoading: true, type: "small", colorLoading: "white", widthLoader: "2px", customCSS: css$1(templateObject_1$1n || (templateObject_1$1n = __makeTemplateObject(["\n            width: 100%;\n            .lds-ring {\n              width: 15px;\n              height: 15px;\n              div {\n                margin: 1px 2px;\n                width: 14px;\n                height: 14px;\n              }\n            }\n          "], ["\n            width: 100%;\n            .lds-ring {\n              width: 15px;\n              height: 15px;\n              div {\n                margin: 1px 2px;\n                width: 14px;\n                height: 14px;\n              }\n            }\n          "]))) })) : (jsx(Fragment$1, { children: children || "Text Default" })) })));
};
var templateObject_1$1n;

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var win;

if (typeof window$1 !== "undefined") {
    win = window$1;
} else if (typeof commonjsGlobal !== "undefined") {
    win = commonjsGlobal;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

var window_1$1 = win;

var window$1 = window_1$1;

/**
 * SSR Window 4.0.2
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2021, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: December 13, 2021
 */
/* eslint-disable no-param-reassign */
function isObject$4(obj) {
    return (obj !== null &&
        typeof obj === 'object' &&
        'constructor' in obj &&
        obj.constructor === Object);
}
function extend$2(target = {}, src = {}) {
    Object.keys(src).forEach((key) => {
        if (typeof target[key] === 'undefined')
            target[key] = src[key];
        else if (isObject$4(src[key]) &&
            isObject$4(target[key]) &&
            Object.keys(src[key]).length > 0) {
            extend$2(target[key], src[key]);
        }
    });
}

const ssrDocument = {
    body: {},
    addEventListener() { },
    removeEventListener() { },
    activeElement: {
        blur() { },
        nodeName: '',
    },
    querySelector() {
        return null;
    },
    querySelectorAll() {
        return [];
    },
    getElementById() {
        return null;
    },
    createEvent() {
        return {
            initEvent() { },
        };
    },
    createElement() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute() { },
            getElementsByTagName() {
                return [];
            },
        };
    },
    createElementNS() {
        return {};
    },
    importNode() {
        return null;
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
};
function getDocument() {
    const doc = typeof document !== 'undefined' ? document : {};
    extend$2(doc, ssrDocument);
    return doc;
}

const ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: '',
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
    history: {
        replaceState() { },
        pushState() { },
        go() { },
        back() { },
    },
    CustomEvent: function CustomEvent() {
        return this;
    },
    addEventListener() { },
    removeEventListener() { },
    getComputedStyle() {
        return {
            getPropertyValue() {
                return '';
            },
        };
    },
    Image() { },
    Date() { },
    screen: {},
    setTimeout() { },
    clearTimeout() { },
    matchMedia() {
        return {};
    },
    requestAnimationFrame(callback) {
        if (typeof setTimeout === 'undefined') {
            callback();
            return null;
        }
        return setTimeout(callback, 0);
    },
    cancelAnimationFrame(id) {
        if (typeof setTimeout === 'undefined') {
            return;
        }
        clearTimeout(id);
    },
};
function getWindow() {
    const win = typeof window$1 !== 'undefined' ? window$1 : {};
    extend$2(win, ssrWindow);
    return win;
}

/**
 * Dom7 4.0.4
 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
 * https://framework7.io/docs/dom7.html
 *
 * Copyright 2022, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: January 11, 2022
 */

/* eslint-disable no-proto */
function makeReactive(obj) {
  const proto = obj.__proto__;
  Object.defineProperty(obj, '__proto__', {
    get() {
      return proto;
    },

    set(value) {
      proto.__proto__ = value;
    }

  });
}

class Dom7 extends Array {
  constructor(items) {
    if (typeof items === 'number') {
      super(items);
    } else {
      super(...(items || []));
      makeReactive(this);
    }
  }

}

function arrayFlat(arr = []) {
  const res = [];
  arr.forEach(el => {
    if (Array.isArray(el)) {
      res.push(...arrayFlat(el));
    } else {
      res.push(el);
    }
  });
  return res;
}
function arrayFilter(arr, callback) {
  return Array.prototype.filter.call(arr, callback);
}
function arrayUnique(arr) {
  const uniqueArray = [];

  for (let i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
  }

  return uniqueArray;
}

// eslint-disable-next-line

function qsa(selector, context) {
  if (typeof selector !== 'string') {
    return [selector];
  }

  const a = [];
  const res = context.querySelectorAll(selector);

  for (let i = 0; i < res.length; i += 1) {
    a.push(res[i]);
  }

  return a;
}

function $$1(selector, context) {
  const window = getWindow();
  const document = getDocument();
  let arr = [];

  if (!context && selector instanceof Dom7) {
    return selector;
  }

  if (!selector) {
    return new Dom7(arr);
  }

  if (typeof selector === 'string') {
    const html = selector.trim();

    if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
      let toCreate = 'div';
      if (html.indexOf('<li') === 0) toCreate = 'ul';
      if (html.indexOf('<tr') === 0) toCreate = 'tbody';
      if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
      if (html.indexOf('<tbody') === 0) toCreate = 'table';
      if (html.indexOf('<option') === 0) toCreate = 'select';
      const tempParent = document.createElement(toCreate);
      tempParent.innerHTML = html;

      for (let i = 0; i < tempParent.childNodes.length; i += 1) {
        arr.push(tempParent.childNodes[i]);
      }
    } else {
      arr = qsa(selector.trim(), context || document);
    } // arr = qsa(selector, document);

  } else if (selector.nodeType || selector === window || selector === document) {
    arr.push(selector);
  } else if (Array.isArray(selector)) {
    if (selector instanceof Dom7) return selector;
    arr = selector;
  }

  return new Dom7(arrayUnique(arr));
}

$$1.fn = Dom7.prototype;

// eslint-disable-next-line

function addClass(...classes) {
  const classNames = arrayFlat(classes.map(c => c.split(' ')));
  this.forEach(el => {
    el.classList.add(...classNames);
  });
  return this;
}

function removeClass(...classes) {
  const classNames = arrayFlat(classes.map(c => c.split(' ')));
  this.forEach(el => {
    el.classList.remove(...classNames);
  });
  return this;
}

function toggleClass(...classes) {
  const classNames = arrayFlat(classes.map(c => c.split(' ')));
  this.forEach(el => {
    classNames.forEach(className => {
      el.classList.toggle(className);
    });
  });
}

function hasClass(...classes) {
  const classNames = arrayFlat(classes.map(c => c.split(' ')));
  return arrayFilter(this, el => {
    return classNames.filter(className => el.classList.contains(className)).length > 0;
  }).length > 0;
}

function attr$1(attrs, value) {
  if (arguments.length === 1 && typeof attrs === 'string') {
    // Get attr
    if (this[0]) return this[0].getAttribute(attrs);
    return undefined;
  } // Set attrs


  for (let i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      // String
      this[i].setAttribute(attrs, value);
    } else {
      // Object
      for (const attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }

  return this;
}

function removeAttr(attr) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr);
  }

  return this;
}

function transform(transform) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.transform = transform;
  }

  return this;
}

function transition$1(duration) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.transitionDuration = typeof duration !== 'string' ? `${duration}ms` : duration;
  }

  return this;
}

function on(...args) {
  let [eventType, targetSelector, listener, capture] = args;

  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }

  if (!capture) capture = false;

  function handleLiveEvent(e) {
    const target = e.target;
    if (!target) return;
    const eventData = e.target.dom7EventData || [];

    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }

    if ($$1(target).is(targetSelector)) listener.apply(target, eventData);else {
      const parents = $$1(target).parents(); // eslint-disable-line

      for (let k = 0; k < parents.length; k += 1) {
        if ($$1(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
      }
    }
  }

  function handleEvent(e) {
    const eventData = e && e.target ? e.target.dom7EventData || [] : [];

    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }

    listener.apply(this, eventData);
  }

  const events = eventType.split(' ');
  let j;

  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];

    if (!targetSelector) {
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7Listeners) el.dom7Listeners = {};
        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
        el.dom7Listeners[event].push({
          listener,
          proxyListener: handleEvent
        });
        el.addEventListener(event, handleEvent, capture);
      }
    } else {
      // Live events
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
        el.dom7LiveListeners[event].push({
          listener,
          proxyListener: handleLiveEvent
        });
        el.addEventListener(event, handleLiveEvent, capture);
      }
    }
  }

  return this;
}

function off(...args) {
  let [eventType, targetSelector, listener, capture] = args;

  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }

  if (!capture) capture = false;
  const events = eventType.split(' ');

  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];

    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let handlers;

      if (!targetSelector && el.dom7Listeners) {
        handlers = el.dom7Listeners[event];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers = el.dom7LiveListeners[event];
      }

      if (handlers && handlers.length) {
        for (let k = handlers.length - 1; k >= 0; k -= 1) {
          const handler = handlers[k];

          if (listener && handler.listener === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (!listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          }
        }
      }
    }
  }

  return this;
}

function trigger(...args) {
  const window = getWindow();
  const events = args[0].split(' ');
  const eventData = args[1];

  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];

    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];

      if (window.CustomEvent) {
        const evt = new window.CustomEvent(event, {
          detail: eventData,
          bubbles: true,
          cancelable: true
        });
        el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
        el.dispatchEvent(evt);
        el.dom7EventData = [];
        delete el.dom7EventData;
      }
    }
  }

  return this;
}

function transitionEnd$1(callback) {
  const dom = this;

  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    dom.off('transitionend', fireCallBack);
  }

  if (callback) {
    dom.on('transitionend', fireCallBack);
  }

  return this;
}

function outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      const styles = this.styles();
      return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
    }

    return this[0].offsetWidth;
  }

  return null;
}

function outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      const styles = this.styles();
      return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
    }

    return this[0].offsetHeight;
  }

  return null;
}

function offset() {
  if (this.length > 0) {
    const window = getWindow();
    const document = getDocument();
    const el = this[0];
    const box = el.getBoundingClientRect();
    const body = document.body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop = el === window ? window.scrollY : el.scrollTop;
    const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
    return {
      top: box.top + scrollTop - clientTop,
      left: box.left + scrollLeft - clientLeft
    };
  }

  return null;
}

function styles() {
  const window = getWindow();
  if (this[0]) return window.getComputedStyle(this[0], null);
  return {};
}

function css(props, value) {
  const window = getWindow();
  let i;

  if (arguments.length === 1) {
    if (typeof props === 'string') {
      // .css('width')
      if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      // .css({ width: '100px' })
      for (i = 0; i < this.length; i += 1) {
        for (const prop in props) {
          this[i].style[prop] = props[prop];
        }
      }

      return this;
    }
  }

  if (arguments.length === 2 && typeof props === 'string') {
    // .css('width', '100px')
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props] = value;
    }

    return this;
  }

  return this;
}

function each(callback) {
  if (!callback) return this;
  this.forEach((el, index) => {
    callback.apply(el, [el, index]);
  });
  return this;
}

function filter(callback) {
  const result = arrayFilter(this, callback);
  return $$1(result);
}

function html(html) {
  if (typeof html === 'undefined') {
    return this[0] ? this[0].innerHTML : null;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html;
  }

  return this;
}

function text$2(text) {
  if (typeof text === 'undefined') {
    return this[0] ? this[0].textContent.trim() : null;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].textContent = text;
  }

  return this;
}

function is(selector) {
  const window = getWindow();
  const document = getDocument();
  const el = this[0];
  let compareWith;
  let i;
  if (!el || typeof selector === 'undefined') return false;

  if (typeof selector === 'string') {
    if (el.matches) return el.matches(selector);
    if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
    if (el.msMatchesSelector) return el.msMatchesSelector(selector);
    compareWith = $$1(selector);

    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }

    return false;
  }

  if (selector === document) {
    return el === document;
  }

  if (selector === window) {
    return el === window;
  }

  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;

    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }

    return false;
  }

  return false;
}

function index() {
  let child = this[0];
  let i;

  if (child) {
    i = 0; // eslint-disable-next-line

    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }

    return i;
  }

  return undefined;
}

function eq(index) {
  if (typeof index === 'undefined') return this;
  const length = this.length;

  if (index > length - 1) {
    return $$1([]);
  }

  if (index < 0) {
    const returnIndex = length + index;
    if (returnIndex < 0) return $$1([]);
    return $$1([this[returnIndex]]);
  }

  return $$1([this[index]]);
}

function append$1(...els) {
  let newChild;
  const document = getDocument();

  for (let k = 0; k < els.length; k += 1) {
    newChild = els[k];

    for (let i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = newChild;

        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (let j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }

  return this;
}

function prepend(newChild) {
  const document = getDocument();
  let i;
  let j;

  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === 'string') {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = newChild;

      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }

  return this;
}

function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && $$1(this[0].nextElementSibling).is(selector)) {
        return $$1([this[0].nextElementSibling]);
      }

      return $$1([]);
    }

    if (this[0].nextElementSibling) return $$1([this[0].nextElementSibling]);
    return $$1([]);
  }

  return $$1([]);
}

function nextAll(selector) {
  const nextEls = [];
  let el = this[0];
  if (!el) return $$1([]);

  while (el.nextElementSibling) {
    const next = el.nextElementSibling; // eslint-disable-line

    if (selector) {
      if ($$1(next).is(selector)) nextEls.push(next);
    } else nextEls.push(next);

    el = next;
  }

  return $$1(nextEls);
}

function prev(selector) {
  if (this.length > 0) {
    const el = this[0];

    if (selector) {
      if (el.previousElementSibling && $$1(el.previousElementSibling).is(selector)) {
        return $$1([el.previousElementSibling]);
      }

      return $$1([]);
    }

    if (el.previousElementSibling) return $$1([el.previousElementSibling]);
    return $$1([]);
  }

  return $$1([]);
}

function prevAll(selector) {
  const prevEls = [];
  let el = this[0];
  if (!el) return $$1([]);

  while (el.previousElementSibling) {
    const prev = el.previousElementSibling; // eslint-disable-line

    if (selector) {
      if ($$1(prev).is(selector)) prevEls.push(prev);
    } else prevEls.push(prev);

    el = prev;
  }

  return $$1(prevEls);
}

function parent(selector) {
  const parents = []; // eslint-disable-line

  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if ($$1(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
      } else {
        parents.push(this[i].parentNode);
      }
    }
  }

  return $$1(parents);
}

function parents(selector) {
  const parents = []; // eslint-disable-line

  for (let i = 0; i < this.length; i += 1) {
    let parent = this[i].parentNode; // eslint-disable-line

    while (parent) {
      if (selector) {
        if ($$1(parent).is(selector)) parents.push(parent);
      } else {
        parents.push(parent);
      }

      parent = parent.parentNode;
    }
  }

  return $$1(parents);
}

function closest(selector) {
  let closest = this; // eslint-disable-line

  if (typeof selector === 'undefined') {
    return $$1([]);
  }

  if (!closest.is(selector)) {
    closest = closest.parents(selector).eq(0);
  }

  return closest;
}

function find$1(selector) {
  const foundElements = [];

  for (let i = 0; i < this.length; i += 1) {
    const found = this[i].querySelectorAll(selector);

    for (let j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }

  return $$1(foundElements);
}

function children$1(selector) {
  const children = []; // eslint-disable-line

  for (let i = 0; i < this.length; i += 1) {
    const childNodes = this[i].children;

    for (let j = 0; j < childNodes.length; j += 1) {
      if (!selector || $$1(childNodes[j]).is(selector)) {
        children.push(childNodes[j]);
      }
    }
  }

  return $$1(children);
}

function remove$1() {
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
  }

  return this;
}

const Methods = {
  addClass,
  removeClass,
  hasClass,
  toggleClass,
  attr: attr$1,
  removeAttr,
  transform,
  transition: transition$1,
  on,
  off,
  trigger,
  transitionEnd: transitionEnd$1,
  outerWidth,
  outerHeight,
  styles,
  offset,
  css,
  each,
  html,
  text: text$2,
  is,
  index,
  eq,
  append: append$1,
  prepend,
  next,
  nextAll,
  prev,
  prevAll,
  parent,
  parents,
  closest,
  find: find$1,
  children: children$1,
  filter,
  remove: remove$1
};
Object.keys(Methods).forEach(methodName => {
  Object.defineProperty($$1.fn, methodName, {
    value: Methods[methodName],
    writable: true
  });
});

function deleteProps$1(obj) {
  const object = obj;
  Object.keys(object).forEach(key => {
    try {
      object[key] = null;
    } catch (e) {// no getter for object
    }

    try {
      delete object[key];
    } catch (e) {// something got wrong
    }
  });
}

function nextTick(callback, delay = 0) {
  return setTimeout(callback, delay);
}

function now$1() {
  return Date.now();
}

function getComputedStyle$1(el) {
  const window = getWindow();
  let style;

  if (window.getComputedStyle) {
    style = window.getComputedStyle(el, null);
  }

  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }

  if (!style) {
    style = el.style;
  }

  return style;
}

function getTranslate(el, axis = 'x') {
  const window = getWindow();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = getComputedStyle$1(el);

  if (window.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;

    if (curTransform.split(',').length > 6) {
      curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
    } // Some old versions of Webkit choke when 'none' is passed; pass
    // empty string instead in this case


    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
    matrix = transformMatrix.toString().split(',');
  }

  if (axis === 'x') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
    else curTransform = parseFloat(matrix[4]);
  }

  if (axis === 'y') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
    else curTransform = parseFloat(matrix[5]);
  }

  return curTransform || 0;
}

function isObject$3(o) {
  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}

function isNode(node) {
  // eslint-disable-next-line
  if (typeof window$1 !== 'undefined' && typeof window$1.HTMLElement !== 'undefined') {
    return node instanceof HTMLElement;
  }

  return node && (node.nodeType === 1 || node.nodeType === 11);
}

function extend$1(...args) {
  const to = Object(args[0]);
  const noExtend = ['__proto__', 'constructor', 'prototype'];

  for (let i = 1; i < args.length; i += 1) {
    const nextSource = args[i];

    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);

      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

        if (desc !== undefined && desc.enumerable) {
          if (isObject$3(to[nextKey]) && isObject$3(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend$1(to[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject$3(to[nextKey]) && isObject$3(nextSource[nextKey])) {
            to[nextKey] = {};

            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend$1(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }

  return to;
}

function setCSSProperty(el, varName, varValue) {
  el.style.setProperty(varName, varValue);
}

function animateCSSModeScroll({
  swiper,
  targetPosition,
  side
}) {
  const window = getWindow();
  const startPosition = -swiper.translate;
  let startTime = null;
  let time;
  const duration = swiper.params.speed;
  swiper.wrapperEl.style.scrollSnapType = 'none';
  window.cancelAnimationFrame(swiper.cssModeFrameID);
  const dir = targetPosition > startPosition ? 'next' : 'prev';

  const isOutOfBound = (current, target) => {
    return dir === 'next' && current >= target || dir === 'prev' && current <= target;
  };

  const animate = () => {
    time = new Date().getTime();

    if (startTime === null) {
      startTime = time;
    }

    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);

    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }

    swiper.wrapperEl.scrollTo({
      [side]: currentPosition
    });

    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper.wrapperEl.style.overflow = 'hidden';
      swiper.wrapperEl.style.scrollSnapType = '';
      setTimeout(() => {
        swiper.wrapperEl.style.overflow = '';
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      });
      window.cancelAnimationFrame(swiper.cssModeFrameID);
      return;
    }

    swiper.cssModeFrameID = window.requestAnimationFrame(animate);
  };

  animate();
}

let support;

function calcSupport() {
  const window = getWindow();
  const document = getDocument();
  return {
    smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,
    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
    passiveListener: function checkPassiveListener() {
      let supportsPassive = false;

      try {
        const opts = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line
          get() {
            supportsPassive = true;
          }

        });
        window.addEventListener('testPassiveListener', null, opts);
      } catch (e) {// No support
      }

      return supportsPassive;
    }(),
    gestures: function checkGestures() {
      return 'ongesturestart' in window;
    }()
  };
}

function getSupport() {
  if (!support) {
    support = calcSupport();
  }

  return support;
}

let deviceCached;

function calcDevice({
  userAgent
} = {}) {
  const support = getSupport();
  const window = getWindow();
  const platform = window.navigator.platform;
  const ua = userAgent || window.navigator.userAgent;
  const device = {
    ios: false,
    android: false
  };
  const screenWidth = window.screen.width;
  const screenHeight = window.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform === 'Win32';
  let macos = platform === 'MacIntel'; // iPadOs 13 fix

  const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

  if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, '13_0_0'];
    macos = false;
  } // Android


  if (android && !windows) {
    device.os = 'android';
    device.android = true;
  }

  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  } // Export object


  return device;
}

function getDevice(overrides = {}) {
  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }

  return deviceCached;
}

let browser;

function calcBrowser() {
  const window = getWindow();

  function isSafari() {
    const ua = window.navigator.userAgent.toLowerCase();
    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
  }

  return {
    isSafari: isSafari(),
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
  };
}

function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }

  return browser;
}

function Resize$1({
  swiper,
  on,
  emit
}) {
  const window = getWindow();
  let observer = null;

  const resizeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('beforeResize');
    emit('resize');
  };

  const createObserver = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    observer = new ResizeObserver(entries => {
      const {
        width,
        height
      } = swiper;
      let newWidth = width;
      let newHeight = height;
      entries.forEach(({
        contentBoxSize,
        contentRect,
        target
      }) => {
        if (target && target !== swiper.el) return;
        newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
        newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
      });

      if (newWidth !== width || newHeight !== height) {
        resizeHandler();
      }
    });
    observer.observe(swiper.el);
  };

  const removeObserver = () => {
    if (observer && observer.unobserve && swiper.el) {
      observer.unobserve(swiper.el);
      observer = null;
    }
  };

  const orientationChangeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('orientationchange');
  };

  on('init', () => {
    if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
      createObserver();
      return;
    }

    window.addEventListener('resize', resizeHandler);
    window.addEventListener('orientationchange', orientationChangeHandler);
  });
  on('destroy', () => {
    removeObserver();
    window.removeEventListener('resize', resizeHandler);
    window.removeEventListener('orientationchange', orientationChangeHandler);
  });
}

function Observer({
  swiper,
  extendParams,
  on,
  emit
}) {
  const observers = [];
  const window = getWindow();

  const attach = (target, options = {}) => {
    const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
    const observer = new ObserverFunc(mutations => {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (mutations.length === 1) {
        emit('observerUpdate', mutations[0]);
        return;
      }

      const observerUpdate = function observerUpdate() {
        emit('observerUpdate', mutations[0]);
      };

      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(observerUpdate);
      } else {
        window.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData
    });
    observers.push(observer);
  };

  const init = () => {
    if (!swiper.params.observer) return;

    if (swiper.params.observeParents) {
      const containerParents = swiper.$el.parents();

      for (let i = 0; i < containerParents.length; i += 1) {
        attach(containerParents[i]);
      }
    } // Observe container


    attach(swiper.$el[0], {
      childList: swiper.params.observeSlideChildren
    }); // Observe wrapper

    attach(swiper.$wrapperEl[0], {
      attributes: false
    });
  };

  const destroy = () => {
    observers.forEach(observer => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };

  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  });
  on('init', init);
  on('destroy', destroy);
}

/* eslint-disable no-underscore-dangle */
var eventsEmitter = {
  on(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    events.split(' ').forEach(event => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  },

  once(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;

    function onceHandler(...args) {
      self.off(events, onceHandler);

      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }

      handler.apply(self, args);
    }

    onceHandler.__emitterProxy = handler;
    return self.on(events, onceHandler, priority);
  },

  onAny(handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';

    if (self.eventsAnyListeners.indexOf(handler) < 0) {
      self.eventsAnyListeners[method](handler);
    }

    return self;
  },

  offAny(handler) {
    const self = this;
    if (!self.eventsAnyListeners) return self;
    const index = self.eventsAnyListeners.indexOf(handler);

    if (index >= 0) {
      self.eventsAnyListeners.splice(index, 1);
    }

    return self;
  },

  off(events, handler) {
    const self = this;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach(event => {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  },

  emit(...args) {
    const self = this;
    if (!self.eventsListeners) return self;
    let events;
    let data;
    let context;

    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }

    data.unshift(context);
    const eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach(event => {
      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
        self.eventsAnyListeners.forEach(eventHandler => {
          eventHandler.apply(context, [event, ...data]);
        });
      }

      if (self.eventsListeners && self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(eventHandler => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }

};

function updateSize() {
  const swiper = this;
  let width;
  let height;
  const $el = swiper.$el;

  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }

  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }

  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  } // Subtract paddings


  width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
  height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
  if (Number.isNaN(width)) width = 0;
  if (Number.isNaN(height)) height = 0;
  Object.assign(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height
  });
}

function updateSlides() {
  const swiper = this;

  function getDirectionLabel(property) {
    if (swiper.isHorizontal()) {
      return property;
    } // prettier-ignore


    return {
      'width': 'height',
      'margin-top': 'margin-left',
      'margin-bottom ': 'margin-right',
      'margin-left': 'margin-top',
      'margin-right': 'margin-bottom',
      'padding-left': 'padding-top',
      'padding-right': 'padding-bottom',
      'marginRight': 'marginBottom'
    }[property];
  }

  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
  }

  const params = swiper.params;
  const {
    $wrapperEl,
    size: swiperSize,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;

  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }

  let offsetAfter = params.slidesOffsetAfter;

  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }

  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.slidesGrid.length;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;

  if (typeof swiperSize === 'undefined') {
    return;
  }

  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
  }

  swiper.virtualSize = -spaceBetween; // reset margins

  if (rtl) slides.css({
    marginLeft: '',
    marginBottom: '',
    marginTop: ''
  });else slides.css({
    marginRight: '',
    marginBottom: '',
    marginTop: ''
  }); // reset cssMode offsets

  if (params.centeredSlides && params.cssMode) {
    setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');
    setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');
  }

  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;

  if (gridEnabled) {
    swiper.grid.initSlides(slidesLength);
  } // Calc slides


  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
    return typeof params.breakpoints[key].slidesPerView !== 'undefined';
  }).length > 0;

  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    const slide = slides.eq(i);

    if (gridEnabled) {
      swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
    }

    if (slide.css('display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      if (shouldResetSlideSize) {
        slides[i].style[getDirectionLabel('width')] = ``;
      }

      const slideStyles = getComputedStyle(slide[0]);
      const currentTransform = slide[0].style.transform;
      const currentWebKitTransform = slide[0].style.webkitTransform;

      if (currentTransform) {
        slide[0].style.transform = 'none';
      }

      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = 'none';
      }

      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
      } else {
        // eslint-disable-next-line
        const width = getDirectionPropertyValue(slideStyles, 'width');
        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
        const boxSizing = slideStyles.getPropertyValue('box-sizing');

        if (boxSizing && boxSizing === 'border-box') {
          slideSize = width + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth
          } = slide[0];
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }

      if (currentTransform) {
        slide[0].style.transform = currentTransform;
      }

      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = currentWebKitTransform;
      }

      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);

      if (slides[i]) {
        slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
      }
    }

    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }

    slidesSizesGrid.push(slideSize);

    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }

    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }

  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;

  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    $wrapperEl.css({
      width: `${swiper.virtualSize + params.spaceBetween}px`
    });
  }

  if (params.setWrapperSize) {
    $wrapperEl.css({
      [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`
    });
  }

  if (gridEnabled) {
    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
  } // Remove last grid elements depending on width


  if (!params.centeredSlides) {
    const newSlidesGrid = [];

    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);

      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }

    snapGrid = newSlidesGrid;

    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }

  if (snapGrid.length === 0) snapGrid = [0];

  if (params.spaceBetween !== 0) {
    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
    slides.filter((_, slideIndex) => {
      if (!params.cssMode) return true;

      if (slideIndex === slides.length - 1) {
        return false;
      }

      return true;
    }).css({
      [key]: `${spaceBetween}px`
    });
  }

  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    const maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map(snap => {
      if (snap < 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }

  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;

    if (allSlidesSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }

  Object.assign(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });

  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
    setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    const addToSnapGrid = -swiper.snapGrid[0];
    const addToSlidesGrid = -swiper.slidesGrid[0];
    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
    swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
  }

  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }

  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }

  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }

  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
}

function updateAutoHeight(speed) {
  const swiper = this;
  const activeSlides = [];
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  let newHeight = 0;
  let i;

  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }

  const getSlideByIndex = index => {
    if (isVirtual) {
      return swiper.slides.filter(el => parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index)[0];
    }

    return swiper.slides.eq(index)[0];
  }; // Find slides currently in view


  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      swiper.visibleSlides.each(slide => {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        const index = swiper.activeIndex + i;
        if (index > swiper.slides.length && !isVirtual) break;
        activeSlides.push(getSlideByIndex(index));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  } // Find new height from highest slide in view


  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  } // Update Height


  if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);
}

function updateSlidesOffset() {
  const swiper = this;
  const slides = swiper.slides;

  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
}

function updateSlidesProgress(translate = this && this.translate || 0) {
  const swiper = this;
  const params = swiper.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper;
  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
  let offsetCenter = -translate;
  if (rtl) offsetCenter = translate; // Visible Slides

  slides.removeClass(params.slideVisibleClass);
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];

  for (let i = 0; i < slides.length; i += 1) {
    const slide = slides[i];
    let slideOffset = slide.swiperSlideOffset;

    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }

    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

    if (isVisible) {
      swiper.visibleSlides.push(slide);
      swiper.visibleSlidesIndexes.push(i);
      slides.eq(i).addClass(params.slideVisibleClass);
    }

    slide.progress = rtl ? -slideProgress : slideProgress;
    slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }

  swiper.visibleSlides = $$1(swiper.visibleSlides);
}

function updateProgress(translate) {
  const swiper = this;

  if (typeof translate === 'undefined') {
    const multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }

  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd
  } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;

  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / translatesDiff;
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }

  Object.assign(swiper, {
    progress,
    isBeginning,
    isEnd
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }

  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }

  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit('fromEdge');
  }

  swiper.emit('progress', progress);
}

function updateSlidesClasses() {
  const swiper = this;
  const {
    slides,
    params,
    $wrapperEl,
    activeIndex,
    realIndex
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
  let activeSlide;

  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
  } else {
    activeSlide = slides.eq(activeIndex);
  } // Active classes


  activeSlide.addClass(params.slideActiveClass);

  if (params.loop) {
    // Duplicate to all looped slides
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
    }
  } // Next Slide


  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);

  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  } // Prev Slide


  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);

  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }

  if (params.loop) {
    // Duplicate to all looped slides
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
    }

    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
    }
  }

  swiper.emitSlidesClasses();
}

function updateActiveIndex(newActiveIndex) {
  const swiper = this;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    slidesGrid,
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;

  if (typeof activeIndex === 'undefined') {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    } // Normalize slideIndex


    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
    }
  }

  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }

  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }

    return;
  } // Get real index


  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
  Object.assign(swiper, {
    snapIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');

  if (previousRealIndex !== realIndex) {
    swiper.emit('realIndexChange');
  }

  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    swiper.emit('slideChange');
  }
}

function updateClickedSlide(e) {
  const swiper = this;
  const params = swiper.params;
  const slide = $$1(e.target).closest(`.${params.slideClass}`)[0];
  let slideFound = false;
  let slideIndex;

  if (slide) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }

  if (slide && slideFound) {
    swiper.clickedSlide = slide;

    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt($$1(slide).attr('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }

  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

var update$1 = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};

function getSwiperTranslate(axis = this.isHorizontal() ? 'x' : 'y') {
  const swiper = this;
  const {
    params,
    rtlTranslate: rtl,
    translate,
    $wrapperEl
  } = swiper;

  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }

  if (params.cssMode) {
    return translate;
  }

  let currentTranslate = getTranslate($wrapperEl[0], axis);
  if (rtl) currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}

function setTranslate(translate, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl,
    params,
    $wrapperEl,
    wrapperEl,
    progress
  } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;

  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }

  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }

  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
  }

  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
  }

  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }

  swiper.emit('setTranslate', swiper.translate, byController);
}

function minTranslate() {
  return -this.snapGrid[0];
}

function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}

function translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
  const swiper = this;
  const {
    params,
    wrapperEl
  } = swiper;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }

  const minTranslate = swiper.minTranslate();
  const maxTranslate = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

  swiper.updateProgress(newTranslate);

  if (params.cssMode) {
    const isH = swiper.isHorizontal();

    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: -newTranslate,
          side: isH ? 'left' : 'top'
        });
        return true;
      }

      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: -newTranslate,
        behavior: 'smooth'
      });
    }

    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);

    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);

    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }

    if (!swiper.animating) {
      swiper.animating = true;

      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;

          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }

      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
    }
  }

  return true;
}

var translate = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};

function setTransition(duration, byController) {
  const swiper = this;

  if (!swiper.params.cssMode) {
    swiper.$wrapperEl.transition(duration);
  }

  swiper.emit('setTransition', duration, byController);
}

function transitionEmit({
  swiper,
  runCallbacks,
  direction,
  step
}) {
  const {
    activeIndex,
    previousIndex
  } = swiper;
  let dir = direction;

  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }

  swiper.emit(`transition${step}`);

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit(`slideResetTransition${step}`);
      return;
    }

    swiper.emit(`slideChangeTransition${step}`);

    if (dir === 'next') {
      swiper.emit(`slideNextTransition${step}`);
    } else {
      swiper.emit(`slidePrevTransition${step}`);
    }
  }
}

function transitionStart(runCallbacks = true, direction) {
  const swiper = this;
  const {
    params
  } = swiper;
  if (params.cssMode) return;

  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }

  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: 'Start'
  });
}

function transitionEnd(runCallbacks = true, direction) {
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: 'End'
  });
}

var transition = {
  setTransition,
  transitionStart,
  transitionEnd
};

function slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
  if (typeof index !== 'number' && typeof index !== 'string') {
    throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);
  }

  if (typeof index === 'string') {
    /**
     * The `index` argument converted from `string` to `number`.
     * @type {number}
     */
    const indexAsNumber = parseInt(index, 10);
    /**
     * Determines whether the `index` argument is a valid `number`
     * after being converted from the `string` type.
     * @type {boolean}
     */

    const isValidNumber = isFinite(indexAsNumber);

    if (!isValidNumber) {
      throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
    } // Knowing that the converted `index` is a valid number,
    // we can update the original argument's value.


    index = indexAsNumber;
  }

  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper;

  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
    return false;
  }

  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  const translate = -snapGrid[snapIndex]; // Update progress

  swiper.updateProgress(translate); // Normalize slideIndex

  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      const normalizedTranslate = -Math.floor(translate * 100);
      const normalizedGrid = Math.floor(slidesGrid[i] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i;
      }
    }
  } // Directions locks


  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
      return false;
    }

    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) return false;
    }
  }

  let direction;
  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
    swiper.updateActiveIndex(slideIndex); // Update Height

    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }

    swiper.updateSlidesClasses();

    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }

    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }

    return false;
  }

  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    const t = rtl ? translate : -translate;

    if (speed === 0) {
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

      if (isVirtual) {
        swiper.wrapperEl.style.scrollSnapType = 'none';
        swiper._immediateVirtual = true;
      }

      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;

      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper.wrapperEl.style.scrollSnapType = '';
          swiper._swiperImmediateVirtual = false;
        });
      }
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: t,
          side: isH ? 'left' : 'top'
        });
        return true;
      }

      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: t,
        behavior: 'smooth'
      });
    }

    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    swiper.transitionEnd(runCallbacks, direction);
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);

    if (!swiper.animating) {
      swiper.animating = true;

      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }

      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
    }
  }

  return true;
}

function slideToLoop(index = 0, speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let newIndex = index;

  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }

  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    animating,
    enabled,
    params
  } = swiper;
  if (!enabled) return swiper;
  let perGroup = params.slidesPerGroup;

  if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
  }

  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;

  if (params.loop) {
    if (animating && params.loopPreventsSlide) return false;
    swiper.loopFix(); // eslint-disable-next-line

    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }

  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    params,
    animating,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled) return swiper;

  if (params.loop) {
    if (animating && params.loopPreventsSlide) return false;
    swiper.loopFix(); // eslint-disable-next-line

    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }

  const translate = rtlTranslate ? swiper.translate : -swiper.translate;

  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }

  const normalizedTranslate = normalize(translate);
  const normalizedSnapGrid = snapGrid.map(val => normalize(val));
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

  if (typeof prevSnap === 'undefined' && params.cssMode) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        // prevSnap = snap;
        prevSnapIndex = snapIndex;
      }
    });

    if (typeof prevSnapIndex !== 'undefined') {
      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }

  let prevIndex = 0;

  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;

    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }

  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {
  const swiper = this;
  let index = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

  if (translate >= swiper.snapGrid[snapIndex]) {
    // The current translate is on or after the current snap index, so the choice
    // is between the current index and the one after it.
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];

    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    // The current translate is before the current snap index, so the choice
    // is between the current index and the one before it.
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];

    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }

  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index, speed, runCallbacks, internal);
}

function slideToClickedSlide() {
  const swiper = this;
  const {
    params,
    $wrapperEl
  } = swiper;
  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;

  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt($$1(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
        nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
      nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};

function loopCreate() {
  const swiper = this;
  const document = getDocument();
  const {
    params,
    $wrapperEl
  } = swiper; // Remove duplicated slides

  const $selector = $$1($wrapperEl.children()[0].parentNode);
  $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
  let slides = $selector.children(`.${params.slideClass}`);

  if (params.loopFillGroupWithBlank) {
    const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

    if (blankSlidesNum !== params.slidesPerGroup) {
      for (let i = 0; i < blankSlidesNum; i += 1) {
        const blankNode = $$1(document.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
        $selector.append(blankNode);
      }

      slides = $selector.children(`.${params.slideClass}`);
    }
  }

  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
  swiper.loopedSlides += params.loopAdditionalSlides;

  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }

  const prependSlides = [];
  const appendSlides = [];
  slides.each((el, index) => {
    const slide = $$1(el);

    if (index < swiper.loopedSlides) {
      appendSlides.push(el);
    }

    if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
      prependSlides.push(el);
    }

    slide.attr('data-swiper-slide-index', index);
  });

  for (let i = 0; i < appendSlides.length; i += 1) {
    $selector.append($$1(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }

  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
    $selector.prepend($$1(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}

function loopFix() {
  const swiper = this;
  swiper.emit('beforeLoopFix');
  const {
    activeIndex,
    slides,
    loopedSlides,
    allowSlidePrev,
    allowSlideNext,
    snapGrid,
    rtlTranslate: rtl
  } = swiper;
  let newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  const snapTranslate = -snapGrid[activeIndex];
  const diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

  if (activeIndex < loopedSlides) {
    newIndex = slides.length - loopedSlides * 3 + activeIndex;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);

    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if (activeIndex >= slides.length - loopedSlides) {
    // Fix For Positive Oversliding
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);

    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }

  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  swiper.emit('loopFix');
}

function loopDestroy() {
  const swiper = this;
  const {
    $wrapperEl,
    params,
    slides
  } = swiper;
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
  slides.removeAttr('data-swiper-slide-index');
}

var loop$1 = {
  loopCreate,
  loopFix,
  loopDestroy
};

function setGrabCursor(moving) {
  const swiper = this;
  if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
  const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
  el.style.cursor = 'move';
  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
  el.style.cursor = moving ? 'grabbing' : 'grab';
}

function unsetGrabCursor() {
  const swiper = this;

  if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }

  swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
}

var grabCursor = {
  setGrabCursor,
  unsetGrabCursor
};

function closestElement(selector, base = this) {
  function __closestFrom(el) {
    if (!el || el === getDocument() || el === getWindow()) return null;
    if (el.assignedSlot) el = el.assignedSlot;
    const found = el.closest(selector);
    return found || __closestFrom(el.getRootNode().host);
  }

  return __closestFrom(base);
}

function onTouchStart(event) {
  const swiper = this;
  const document = getDocument();
  const window = getWindow();
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    enabled
  } = swiper;
  if (!enabled) return;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }

  if (!swiper.animating && params.cssMode && params.loop) {
    swiper.loopFix();
  }

  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  let $targetEl = $$1(e.target);

  if (params.touchEventsTarget === 'wrapper') {
    if (!$targetEl.closest(swiper.wrapperEl).length) return;
  }

  data.isTouchEvent = e.type === 'touchstart';
  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return; // change target el for shadow root component

  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';

  if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
    $targetEl = $$1(event.path[0]);
  }

  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
  const isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element

  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {
    swiper.allowClick = true;
    return;
  }

  if (params.swipeHandler) {
    if (!$targetEl.closest(params.swipeHandler)[0]) return;
  }

  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === 'prevent') {
      event.preventDefault();
    } else {
      return;
    }
  }

  Object.assign(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = now$1();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;

  if (e.type !== 'touchstart') {
    let preventDefault = true;
    if ($targetEl.is(data.focusableElements)) preventDefault = false;

    if (document.activeElement && $$1(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
      document.activeElement.blur();
    }

    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
      e.preventDefault();
    }
  }

  swiper.emit('touchStart', e);
}

function onTouchMove(event) {
  const document = getDocument();
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper;
  if (!enabled) return;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;

  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }

    return;
  }

  if (data.isTouchEvent && e.type !== 'touchmove') return;
  const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
  const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
  const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }

  if (!swiper.allowTouchMove) {
    // isMoved = true;
    swiper.allowClick = false;

    if (data.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = now$1();
    }

    return;
  }

  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }

  if (data.isTouchEvent && document.activeElement) {
    if (e.target === document.activeElement && $$1(e.target).is(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }

  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }

  if (e.targetTouches && e.targetTouches.length > 1) return;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;

  if (typeof data.isScrolling === 'undefined') {
    let touchAngle;

    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }

  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }

  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }

  if (data.isScrolling) {
    data.isTouched = false;
    return;
  }

  if (!data.startMoving) {
    return;
  }

  swiper.allowClick = false;

  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }

  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }

  if (!data.isMoved) {
    if (params.loop && !params.cssMode) {
      swiper.loopFix();
    }

    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);

    if (swiper.animating) {
      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
    }

    data.allowMomentumBounce = false; // Grab Cursor

    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }

    swiper.emit('sliderFirstMove', e);
  }

  swiper.emit('sliderMove', e);
  data.isMoved = true;
  let diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) diff = -diff;
  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  data.currentTranslate = diff + data.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;

  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }

  if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
  }

  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  } // Directions locks


  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }

  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }

  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  } // Threshold


  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }

  if (!params.followFinger || params.cssMode) return; // Update active index in free mode

  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }

  if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
    swiper.freeMode.onTouchMove();
  } // Update progress


  swiper.updateProgress(data.currentTranslate); // Update translate

  swiper.setTranslate(data.currentTranslate);
}

function onTouchEnd(event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper;
  if (!enabled) return;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;

  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }

  data.allowTouchCallbacks = false;

  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }

    data.isMoved = false;
    data.startMoving = false;
    return;
  } // Return Grab Cursor


  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  } // Time diff


  const touchEndTime = now$1();
  const timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

  if (swiper.allowClick) {
    swiper.updateClickedSlide(e);
    swiper.emit('tap click', e);

    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }

  data.lastClickTime = now$1();
  nextTick(() => {
    if (!swiper.destroyed) swiper.allowClick = true;
  });

  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }

  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  let currentPos;

  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }

  if (params.cssMode) {
    return;
  }

  if (swiper.params.freeMode && params.freeMode.enabled) {
    swiper.freeMode.onTouchEnd({
      currentPos
    });
    return;
  } // Find current slide


  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];

  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

    if (typeof slidesGrid[i + increment] !== 'undefined') {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  } // Find current slide size


  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
    }

    if (swiper.swipeDirection === 'prev') {
      if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(stopIndex + increment);
      }

      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}

function onResize() {
  const swiper = this;
  const {
    params,
    el
  } = swiper;
  if (el && el.offsetWidth === 0) return; // Breakpoints

  if (params.breakpoints) {
    swiper.setBreakpoint();
  } // Save locks


  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper; // Disable locks on resize

  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();

  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    swiper.slideTo(swiper.activeIndex, 0, false, true);
  }

  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    swiper.autoplay.run();
  } // Return locks after resize


  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;

  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

function onClick(e) {
  const swiper = this;
  if (!swiper.enabled) return;

  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();

    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

function onScroll() {
  const swiper = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled) return;
  swiper.previousTranslate = swiper.translate;

  if (swiper.isHorizontal()) {
    swiper.translate = -wrapperEl.scrollLeft;
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  } // eslint-disable-next-line


  if (swiper.translate === -0) swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }

  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }

  swiper.emit('setTranslate', swiper.translate, false);
}

let dummyEventAttached = false;

function dummyEventListener() {}

const events = (swiper, method) => {
  const document = getDocument();
  const {
    params,
    touchEvents,
    el,
    wrapperEl,
    device,
    support
  } = swiper;
  const capture = !!params.nested;
  const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
  const swiperMethod = method; // Touch Events

  if (!support.touch) {
    el[domMethod](touchEvents.start, swiper.onTouchStart, false);
    document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
    document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
  } else {
    const passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
    el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
      passive: false,
      capture
    } : capture);
    el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);

    if (touchEvents.cancel) {
      el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
    }
  } // Prevent Links Clicks


  if (params.preventClicks || params.preventClicksPropagation) {
    el[domMethod]('click', swiper.onClick, true);
  }

  if (params.cssMode) {
    wrapperEl[domMethod]('scroll', swiper.onScroll);
  } // Resize handler


  if (params.updateOnWindowResize) {
    swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
  } else {
    swiper[swiperMethod]('observerUpdate', onResize, true);
  }
};

function attachEvents() {
  const swiper = this;
  const document = getDocument();
  const {
    params,
    support
  } = swiper;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);

  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }

  swiper.onClick = onClick.bind(swiper);

  if (support.touch && !dummyEventAttached) {
    document.addEventListener('touchstart', dummyEventListener);
    dummyEventAttached = true;
  }

  events(swiper, 'on');
}

function detachEvents() {
  const swiper = this;
  events(swiper, 'off');
}

var events$1 = {
  attachEvents,
  detachEvents
};

const isGridEnabled = (swiper, params) => {
  return swiper.grid && params.grid && params.grid.rows > 1;
};

function setBreakpoint() {
  const swiper = this;
  const {
    activeIndex,
    initialized,
    loopedSlides = 0,
    params,
    $el
  } = swiper;
  const breakpoints = params.breakpoints;
  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

  const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
  const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
  const breakpointParams = breakpointOnlyParams || swiper.originalParams;
  const wasMultiRow = isGridEnabled(swiper, params);
  const isMultiRow = isGridEnabled(swiper, breakpointParams);
  const wasEnabled = params.enabled;

  if (wasMultiRow && !isMultiRow) {
    $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    $el.addClass(`${params.containerModifierClass}grid`);

    if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
      $el.addClass(`${params.containerModifierClass}grid-column`);
    }

    swiper.emitContainerClasses();
  }

  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

  if (directionChanged && initialized) {
    swiper.changeDirection();
  }

  extend$1(swiper.params, breakpointParams);
  const isEnabled = swiper.params.enabled;
  Object.assign(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });

  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }

  swiper.currentBreakpoint = breakpoint;
  swiper.emit('_beforeBreakpoint', breakpointParams);

  if (needsReLoop && initialized) {
    swiper.loopDestroy();
    swiper.loopCreate();
    swiper.updateSlides();
    swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
  }

  swiper.emit('breakpoint', breakpointParams);
}

function getBreakpoint(breakpoints, base = 'window', containerEl) {
  if (!breakpoints || base === 'container' && !containerEl) return undefined;
  let breakpoint = false;
  const window = getWindow();
  const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
  const points = Object.keys(breakpoints).map(point => {
    if (typeof point === 'string' && point.indexOf('@') === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = currentHeight * minRatio;
      return {
        value,
        point
      };
    }

    return {
      value: point,
      point
    };
  });
  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));

  for (let i = 0; i < points.length; i += 1) {
    const {
      point,
      value
    } = points[i];

    if (base === 'window') {
      if (window.matchMedia(`(min-width: ${value}px)`).matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }

  return breakpoint || 'max';
}

var breakpoints = {
  setBreakpoint,
  getBreakpoint
};

function prepareClasses(entries, prefix) {
  const resultClasses = [];
  entries.forEach(item => {
    if (typeof item === 'object') {
      Object.keys(item).forEach(classNames => {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === 'string') {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}

function addClasses() {
  const swiper = this;
  const {
    classNames,
    params,
    rtl,
    $el,
    device,
    support
  } = swiper; // prettier-ignore

  const suffixes = prepareClasses(['initialized', params.direction, {
    'pointer-events': !support.touch
  }, {
    'free-mode': swiper.params.freeMode && params.freeMode.enabled
  }, {
    'autoheight': params.autoHeight
  }, {
    'rtl': rtl
  }, {
    'grid': params.grid && params.grid.rows > 1
  }, {
    'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
  }, {
    'android': device.android
  }, {
    'ios': device.ios
  }, {
    'css-mode': params.cssMode
  }, {
    'centered': params.cssMode && params.centeredSlides
  }], params.containerModifierClass);
  classNames.push(...suffixes);
  $el.addClass([...classNames].join(' '));
  swiper.emitContainerClasses();
}

function removeClasses() {
  const swiper = this;
  const {
    $el,
    classNames
  } = swiper;
  $el.removeClass(classNames.join(' '));
  swiper.emitContainerClasses();
}

var classes = {
  addClasses,
  removeClasses
};

function loadImage$1(imageEl, src, srcset, sizes, checkForComplete, callback) {
  const window = getWindow();
  let image;

  function onReady() {
    if (callback) callback();
  }

  const isPicture = $$1(imageEl).parent('picture')[0];

  if (!isPicture && (!imageEl.complete || !checkForComplete)) {
    if (src) {
      image = new window.Image();
      image.onload = onReady;
      image.onerror = onReady;

      if (sizes) {
        image.sizes = sizes;
      }

      if (srcset) {
        image.srcset = srcset;
      }

      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    // image already loaded...
    onReady();
  }
}

function preloadImages() {
  const swiper = this;
  swiper.imagesToLoad = swiper.$el.find('img');

  function onReady() {
    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady) swiper.update();
      swiper.emit('imagesReady');
    }
  }

  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
    const imageEl = swiper.imagesToLoad[i];
    swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
  }
}

var images = {
  loadImage: loadImage$1,
  preloadImages
};

function checkOverflow() {
  const swiper = this;
  const {
    isLocked: wasLocked,
    params
  } = swiper;
  const {
    slidesOffsetBefore
  } = params;

  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper.slides.length - 1;
    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper.isLocked = swiper.size > lastSlideRightEdge;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }

  if (params.allowSlideNext === true) {
    swiper.allowSlideNext = !swiper.isLocked;
  }

  if (params.allowSlidePrev === true) {
    swiper.allowSlidePrev = !swiper.isLocked;
  }

  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
  }

  if (wasLocked !== swiper.isLocked) {
    swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
  }
}

var checkOverflow$1 = {
  checkOverflow
};

var defaults$1 = {
  init: true,
  direction: 'horizontal',
  touchEventsTarget: 'wrapper',
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  enabled: true,
  focusableElements: 'input, select, option, textarea, button, video, label',
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: 'slide',
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
  // Breakpoints
  breakpoints: undefined,
  breakpointsBase: 'window',
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: true,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // Images
  preloadImages: true,
  updateOnImagesReady: true,
  // loop
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopFillGroupWithBlank: false,
  loopPreventsSlide: true,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  // NS
  containerModifierClass: 'swiper-',
  // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-invisible-blank',
  slideActiveClass: 'swiper-slide-active',
  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideDuplicateClass: 'swiper-slide-duplicate',
  slideNextClass: 'swiper-slide-next',
  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
  slidePrevClass: 'swiper-slide-prev',
  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
  wrapperClass: 'swiper-wrapper',
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
};

function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj = {}) {
    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];

    if (typeof moduleParams !== 'object' || moduleParams === null) {
      extend$1(allModulesParams, obj);
      return;
    }

    if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
      params[moduleParamName] = {
        auto: true
      };
    }

    if (!(moduleParamName in params && 'enabled' in moduleParams)) {
      extend$1(allModulesParams, obj);
      return;
    }

    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true
      };
    }

    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }

    if (!params[moduleParamName]) params[moduleParamName] = {
      enabled: false
    };
    extend$1(allModulesParams, obj);
  };
}

/* eslint no-param-reassign: "off" */
const prototypes = {
  eventsEmitter,
  update: update$1,
  translate,
  transition,
  slide,
  loop: loop$1,
  grabCursor,
  events: events$1,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes,
  images
};
const extendedDefaults = {};

class Swiper$1 {
  constructor(...args) {
    let el;
    let params;

    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
      params = args[0];
    } else {
      [el, params] = args;
    }

    if (!params) params = {};
    params = extend$1({}, params);
    if (el && !params.el) params.el = el;

    if (params.el && $$1(params.el).length > 1) {
      const swipers = [];
      $$1(params.el).each(containerEl => {
        const newParams = extend$1({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper$1(newParams));
      });
      return swipers;
    } // Swiper Instance


    const swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport();
    swiper.device = getDevice({
      userAgent: params.userAgent
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];
    swiper.modules = [...swiper.__modules__];

    if (params.modules && Array.isArray(params.modules)) {
      swiper.modules.push(...params.modules);
    }

    const allModulesParams = {};
    swiper.modules.forEach(mod => {
      mod({
        swiper,
        extendParams: moduleExtendParams(params, allModulesParams),
        on: swiper.on.bind(swiper),
        once: swiper.once.bind(swiper),
        off: swiper.off.bind(swiper),
        emit: swiper.emit.bind(swiper)
      });
    }); // Extend defaults with modules params

    const swiperParams = extend$1({}, defaults$1, allModulesParams); // Extend defaults with passed params

    swiper.params = extend$1({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = extend$1({}, swiper.params);
    swiper.passedParams = extend$1({}, params); // add event listeners

    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach(eventName => {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }

    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    } // Save Dom lib


    swiper.$ = $$1; // Extend Swiper

    Object.assign(swiper, {
      enabled: swiper.params.enabled,
      el,
      // Classes
      classNames: [],
      // Slides
      slides: $$1(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],

      // isDirection
      isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },

      isVertical() {
        return swiper.params.direction === 'vertical';
      },

      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      // Touch Events
      touchEvents: function touchEvents() {
        const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
        const desktop = ['pointerdown', 'pointermove', 'pointerup'];
        swiper.touchEventsTouch = {
          start: touch[0],
          move: touch[1],
          end: touch[2],
          cancel: touch[3]
        };
        swiper.touchEventsDesktop = {
          start: desktop[0],
          move: desktop[1],
          end: desktop[2]
        };
        return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
      }(),
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        focusableElements: swiper.params.focusableElements,
        // Last click time
        lastClickTime: now$1(),
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        isTouchEvent: undefined,
        startMoving: undefined
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper.emit('_swiper'); // Init

    if (swiper.params.init) {
      swiper.init();
    } // Return app instance


    return swiper;
  }

  enable() {
    const swiper = this;
    if (swiper.enabled) return;
    swiper.enabled = true;

    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }

    swiper.emit('enable');
  }

  disable() {
    const swiper = this;
    if (!swiper.enabled) return;
    swiper.enabled = false;

    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }

    swiper.emit('disable');
  }

  setProgress(progress, speed) {
    const swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min = swiper.minTranslate();
    const max = swiper.maxTranslate();
    const current = (max - min) * progress + min;
    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }

  emitContainerClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const cls = swiper.el.className.split(' ').filter(className => {
      return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit('_containerClasses', cls.join(' '));
  }

  getSlideClasses(slideEl) {
    const swiper = this;
    return slideEl.className.split(' ').filter(className => {
      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(' ');
  }

  emitSlidesClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const updates = [];
    swiper.slides.each(slideEl => {
      const classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      });
      swiper.emit('_slideClass', slideEl, classNames);
    });
    swiper.emit('_slideClasses', updates);
  }

  slidesPerViewDynamic(view = 'current', exact = false) {
    const swiper = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper;
    let spv = 1;

    if (params.centeredSlides) {
      let slideSize = slides[activeIndex].swiperSlideSize;
      let breakLoop;

      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }

      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      // eslint-disable-next-line
      if (view === 'current') {
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;

          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        // previous
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;

          if (slideInView) {
            spv += 1;
          }
        }
      }
    }

    return spv;
  }

  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed) return;
    const {
      snapGrid,
      params
    } = swiper; // Breakpoints

    if (params.breakpoints) {
      swiper.setBreakpoint();
    }

    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();

    function setTranslate() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    let translated;

    if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
      setTranslate();

      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }

      if (!translated) {
        setTranslate();
      }
    }

    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }

    swiper.emit('update');
  }

  changeDirection(newDirection, needUpdate = true) {
    const swiper = this;
    const currentDirection = swiper.params.direction;

    if (!newDirection) {
      // eslint-disable-next-line
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }

    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
      return swiper;
    }

    swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.each(slideEl => {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });
    swiper.emit('changeDirection');
    if (needUpdate) swiper.update();
    return swiper;
  }

  mount(el) {
    const swiper = this;
    if (swiper.mounted) return true; // Find el

    const $el = $$1(el || swiper.params.el);
    el = $el[0];

    if (!el) {
      return false;
    }

    el.swiper = swiper;

    const getWrapperSelector = () => {
      return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
    };

    const getWrapper = () => {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        const res = $$1(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items

        res.children = options => $el.children(options);

        return res;
      }

      return $el.children(getWrapperSelector());
    }; // Find Wrapper


    let $wrapperEl = getWrapper();

    if ($wrapperEl.length === 0 && swiper.params.createElements) {
      const document = getDocument();
      const wrapper = document.createElement('div');
      $wrapperEl = $$1(wrapper);
      wrapper.className = swiper.params.wrapperClass;
      $el.append(wrapper);
      $el.children(`.${swiper.params.slideClass}`).each(slideEl => {
        $wrapperEl.append(slideEl);
      });
    }

    Object.assign(swiper, {
      $el,
      el,
      $wrapperEl,
      wrapperEl: $wrapperEl[0],
      mounted: true,
      // RTL
      rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      wrongRTL: $wrapperEl.css('display') === '-webkit-box'
    });
    return true;
  }

  init(el) {
    const swiper = this;
    if (swiper.initialized) return swiper;
    const mounted = swiper.mount(el);
    if (mounted === false) return swiper;
    swiper.emit('beforeInit'); // Set breakpoint

    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    } // Add Classes


    swiper.addClasses(); // Create loop

    if (swiper.params.loop) {
      swiper.loopCreate();
    } // Update size


    swiper.updateSize(); // Update slides

    swiper.updateSlides();

    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    } // Set Grab Cursor


    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }

    if (swiper.params.preloadImages) {
      swiper.preloadImages();
    } // Slide To Initial Slide


    if (swiper.params.loop) {
      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    } // Attach events


    swiper.attachEvents(); // Init Flag

    swiper.initialized = true; // Emit

    swiper.emit('init');
    swiper.emit('afterInit');
    return swiper;
  }

  destroy(deleteInstance = true, cleanStyles = true) {
    const swiper = this;
    const {
      params,
      $el,
      $wrapperEl,
      slides
    } = swiper;

    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }

    swiper.emit('beforeDestroy'); // Init Flag

    swiper.initialized = false; // Detach events

    swiper.detachEvents(); // Destroy loop

    if (params.loop) {
      swiper.loopDestroy();
    } // Cleanup styles


    if (cleanStyles) {
      swiper.removeClasses();
      $el.removeAttr('style');
      $wrapperEl.removeAttr('style');

      if (slides && slides.length) {
        slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
      }
    }

    swiper.emit('destroy'); // Detach emitter events

    Object.keys(swiper.eventsListeners).forEach(eventName => {
      swiper.off(eventName);
    });

    if (deleteInstance !== false) {
      swiper.$el[0].swiper = null;
      deleteProps$1(swiper);
    }

    swiper.destroyed = true;
    return null;
  }

  static extendDefaults(newDefaults) {
    extend$1(extendedDefaults, newDefaults);
  }

  static get extendedDefaults() {
    return extendedDefaults;
  }

  static get defaults() {
    return defaults$1;
  }

  static installModule(mod) {
    if (!Swiper$1.prototype.__modules__) Swiper$1.prototype.__modules__ = [];
    const modules = Swiper$1.prototype.__modules__;

    if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
      modules.push(mod);
    }
  }

  static use(module) {
    if (Array.isArray(module)) {
      module.forEach(m => Swiper$1.installModule(m));
      return Swiper$1;
    }

    Swiper$1.installModule(module);
    return Swiper$1;
  }

}

Object.keys(prototypes).forEach(prototypeGroup => {
  Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
    Swiper$1.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper$1.use([Resize$1, Observer]);

function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
  const document = getDocument();

  if (swiper.params.createElements) {
    Object.keys(checkProps).forEach(key => {
      if (!params[key] && params.auto === true) {
        let element = swiper.$el.children(`.${checkProps[key]}`)[0];

        if (!element) {
          element = document.createElement('div');
          element.className = checkProps[key];
          swiper.$el.append(element);
        }

        params[key] = element;
        originalParams[key] = element;
      }
    });
  }

  return params;
}

function Navigation({
  swiper,
  extendParams,
  on,
  emit
}) {
  extendParams({
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock'
    }
  });
  swiper.navigation = {
    nextEl: null,
    $nextEl: null,
    prevEl: null,
    $prevEl: null
  };

  function getEl(el) {
    let $el;

    if (el) {
      $el = $$1(el);

      if (swiper.params.uniqueNavElements && typeof el === 'string' && $el.length > 1 && swiper.$el.find(el).length === 1) {
        $el = swiper.$el.find(el);
      }
    }

    return $el;
  }

  function toggleEl($el, disabled) {
    const params = swiper.params.navigation;

    if ($el && $el.length > 0) {
      $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);
      if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;

      if (swiper.params.watchOverflow && swiper.enabled) {
        $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }
    }
  }

  function update() {
    // Update Navigation Buttons
    if (swiper.params.loop) return;
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;
    toggleEl($prevEl, swiper.isBeginning);
    toggleEl($nextEl, swiper.isEnd);
  }

  function onPrevClick(e) {
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop) return;
    swiper.slidePrev();
  }

  function onNextClick(e) {
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop) return;
    swiper.slideNext();
  }

  function init() {
    const params = swiper.params.navigation;
    swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
      nextEl: 'swiper-button-next',
      prevEl: 'swiper-button-prev'
    });
    if (!(params.nextEl || params.prevEl)) return;
    const $nextEl = getEl(params.nextEl);
    const $prevEl = getEl(params.prevEl);

    if ($nextEl && $nextEl.length > 0) {
      $nextEl.on('click', onNextClick);
    }

    if ($prevEl && $prevEl.length > 0) {
      $prevEl.on('click', onPrevClick);
    }

    Object.assign(swiper.navigation, {
      $nextEl,
      nextEl: $nextEl && $nextEl[0],
      $prevEl,
      prevEl: $prevEl && $prevEl[0]
    });

    if (!swiper.enabled) {
      if ($nextEl) $nextEl.addClass(params.lockClass);
      if ($prevEl) $prevEl.addClass(params.lockClass);
    }
  }

  function destroy() {
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;

    if ($nextEl && $nextEl.length) {
      $nextEl.off('click', onNextClick);
      $nextEl.removeClass(swiper.params.navigation.disabledClass);
    }

    if ($prevEl && $prevEl.length) {
      $prevEl.off('click', onPrevClick);
      $prevEl.removeClass(swiper.params.navigation.disabledClass);
    }
  }

  on('init', () => {
    init();
    update();
  });
  on('toEdge fromEdge lock unlock', () => {
    update();
  });
  on('destroy', () => {
    destroy();
  });
  on('enable disable', () => {
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;

    if ($nextEl) {
      $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
    }

    if ($prevEl) {
      $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
    }
  });
  on('click', (_s, e) => {
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;
    const targetEl = e.target;

    if (swiper.params.navigation.hideOnClick && !$$1(targetEl).is($prevEl) && !$$1(targetEl).is($nextEl)) {
      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
      let isHidden;

      if ($nextEl) {
        isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
      } else if ($prevEl) {
        isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
      }

      if (isHidden === true) {
        emit('navigationShow');
      } else {
        emit('navigationHide');
      }

      if ($nextEl) {
        $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
      }

      if ($prevEl) {
        $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
      }
    }
  });
  Object.assign(swiper.navigation, {
    update,
    init,
    destroy
  });
}

function classesToSelector(classes = '') {
  return `.${classes.trim().replace(/([\.:!\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.')}`;
}

function Pagination({
  swiper,
  extendParams,
  on,
  emit
}) {
  const pfx = 'swiper-pagination';
  extendParams({
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets',
      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: number => number,
      formatFractionTotal: number => number,
      bulletClass: `${pfx}-bullet`,
      bulletActiveClass: `${pfx}-bullet-active`,
      modifierClass: `${pfx}-`,
      currentClass: `${pfx}-current`,
      totalClass: `${pfx}-total`,
      hiddenClass: `${pfx}-hidden`,
      progressbarFillClass: `${pfx}-progressbar-fill`,
      progressbarOppositeClass: `${pfx}-progressbar-opposite`,
      clickableClass: `${pfx}-clickable`,
      lockClass: `${pfx}-lock`,
      horizontalClass: `${pfx}-horizontal`,
      verticalClass: `${pfx}-vertical`
    }
  });
  swiper.pagination = {
    el: null,
    $el: null,
    bullets: []
  };
  let bulletSize;
  let dynamicBulletIndex = 0;

  function isPaginationDisabled() {
    return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;
  }

  function setSideBullets($bulletEl, position) {
    const {
      bulletActiveClass
    } = swiper.params.pagination;
    $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
  }

  function update() {
    // Render || Update Pagination bullets/items
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const $el = swiper.pagination.$el; // Current/Total

    let current;
    const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

    if (swiper.params.loop) {
      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

      if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
        current -= slidesLength - swiper.loopedSlides * 2;
      }

      if (current > total - 1) current -= total;
      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
    } else {
      current = swiper.activeIndex || 0;
    } // Types


    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;

      if (params.dynamicBullets) {
        bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
        $el.css(swiper.isHorizontal() ? 'width' : 'height', `${bulletSize * (params.dynamicMainBullets + 4)}px`);

        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
          dynamicBulletIndex += current - swiper.previousIndex;

          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
            dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (dynamicBulletIndex < 0) {
            dynamicBulletIndex = 0;
          }
        }

        firstIndex = current - dynamicBulletIndex;
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }

      bullets.removeClass(['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`).join(' '));

      if ($el.length > 1) {
        bullets.each(bullet => {
          const $bullet = $$1(bullet);
          const bulletIndex = $bullet.index();

          if (bulletIndex === current) {
            $bullet.addClass(params.bulletActiveClass);
          }

          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              $bullet.addClass(`${params.bulletActiveClass}-main`);
            }

            if (bulletIndex === firstIndex) {
              setSideBullets($bullet, 'prev');
            }

            if (bulletIndex === lastIndex) {
              setSideBullets($bullet, 'next');
            }
          }
        });
      } else {
        const $bullet = bullets.eq(current);
        const bulletIndex = $bullet.index();
        $bullet.addClass(params.bulletActiveClass);

        if (params.dynamicBullets) {
          const $firstDisplayedBullet = bullets.eq(firstIndex);
          const $lastDisplayedBullet = bullets.eq(lastIndex);

          for (let i = firstIndex; i <= lastIndex; i += 1) {
            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
          }

          if (swiper.params.loop) {
            if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
              for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
              }

              bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
            } else {
              setSideBullets($firstDisplayedBullet, 'prev');
              setSideBullets($lastDisplayedBullet, 'next');
            }
          } else {
            setSideBullets($firstDisplayedBullet, 'prev');
            setSideBullets($lastDisplayedBullet, 'next');
          }
        }
      }

      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
        const offsetProp = rtl ? 'right' : 'left';
        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
      }
    }

    if (params.type === 'fraction') {
      $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
      $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
    }

    if (params.type === 'progressbar') {
      let progressbarDirection;

      if (params.progressbarOpposite) {
        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
      } else {
        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
      }

      const scale = (current + 1) / total;
      let scaleX = 1;
      let scaleY = 1;

      if (progressbarDirection === 'horizontal') {
        scaleX = scale;
      } else {
        scaleY = scale;
      }

      $el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
    }

    if (params.type === 'custom' && params.renderCustom) {
      $el.html(params.renderCustom(swiper, current + 1, total));
      emit('paginationRender', $el[0]);
    } else {
      emit('paginationUpdate', $el[0]);
    }

    if (swiper.params.watchOverflow && swiper.enabled) {
      $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
  }

  function render() {
    // Render Container
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const $el = swiper.pagination.$el;
    let paginationHTML = '';

    if (params.type === 'bullets') {
      let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

      if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {
        numberOfBullets = slidesLength;
      }

      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }

      $el.html(paginationHTML);
      swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
    }

    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
      }

      $el.html(paginationHTML);
    }

    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }

      $el.html(paginationHTML);
    }

    if (params.type !== 'custom') {
      emit('paginationRender', swiper.pagination.$el[0]);
    }
  }

  function init() {
    swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
      el: 'swiper-pagination'
    });
    const params = swiper.params.pagination;
    if (!params.el) return;
    let $el = $$1(params.el);
    if ($el.length === 0) return;

    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
      $el = swiper.$el.find(params.el); // check if it belongs to another nested Swiper

      if ($el.length > 1) {
        $el = $el.filter(el => {
          if ($$1(el).parents('.swiper')[0] !== swiper.el) return false;
          return true;
        });
      }
    }

    if (params.type === 'bullets' && params.clickable) {
      $el.addClass(params.clickableClass);
    }

    $el.addClass(params.modifierClass + params.type);
    $el.addClass(params.modifierClass + swiper.params.direction);

    if (params.type === 'bullets' && params.dynamicBullets) {
      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
      dynamicBulletIndex = 0;

      if (params.dynamicMainBullets < 1) {
        params.dynamicMainBullets = 1;
      }
    }

    if (params.type === 'progressbar' && params.progressbarOpposite) {
      $el.addClass(params.progressbarOppositeClass);
    }

    if (params.clickable) {
      $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
        e.preventDefault();
        let index = $$1(this).index() * swiper.params.slidesPerGroup;
        if (swiper.params.loop) index += swiper.loopedSlides;
        swiper.slideTo(index);
      });
    }

    Object.assign(swiper.pagination, {
      $el,
      el: $el[0]
    });

    if (!swiper.enabled) {
      $el.addClass(params.lockClass);
    }
  }

  function destroy() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    const $el = swiper.pagination.$el;
    $el.removeClass(params.hiddenClass);
    $el.removeClass(params.modifierClass + params.type);
    $el.removeClass(params.modifierClass + swiper.params.direction);
    if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);

    if (params.clickable) {
      $el.off('click', classesToSelector(params.bulletClass));
    }
  }

  on('init', () => {
    init();
    render();
    update();
  });
  on('activeIndexChange', () => {
    if (swiper.params.loop) {
      update();
    } else if (typeof swiper.snapIndex === 'undefined') {
      update();
    }
  });
  on('snapIndexChange', () => {
    if (!swiper.params.loop) {
      update();
    }
  });
  on('slidesLengthChange', () => {
    if (swiper.params.loop) {
      render();
      update();
    }
  });
  on('snapGridLengthChange', () => {
    if (!swiper.params.loop) {
      render();
      update();
    }
  });
  on('destroy', () => {
    destroy();
  });
  on('enable disable', () => {
    const {
      $el
    } = swiper.pagination;

    if ($el) {
      $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
    }
  });
  on('lock unlock', () => {
    update();
  });
  on('click', (_s, e) => {
    const targetEl = e.target;
    const {
      $el
    } = swiper.pagination;

    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el.length > 0 && !$$1(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
      const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);

      if (isHidden === true) {
        emit('paginationShow');
      } else {
        emit('paginationHide');
      }

      $el.toggleClass(swiper.params.pagination.hiddenClass);
    }
  });
  Object.assign(swiper.pagination, {
    render,
    update,
    init,
    destroy
  });
}

function Scrollbar({
  swiper,
  extendParams,
  on,
  emit
}) {
  const document = getDocument();
  let isTouched = false;
  let timeout = null;
  let dragTimeout = null;
  let dragStartPos;
  let dragSize;
  let trackSize;
  let divider;
  extendParams({
    scrollbar: {
      el: null,
      dragSize: 'auto',
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: 'swiper-scrollbar-lock',
      dragClass: 'swiper-scrollbar-drag'
    }
  });
  swiper.scrollbar = {
    el: null,
    dragEl: null,
    $el: null,
    $dragEl: null
  };

  function setTranslate() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const {
      scrollbar,
      rtlTranslate: rtl,
      progress
    } = swiper;
    const {
      $dragEl,
      $el
    } = scrollbar;
    const params = swiper.params.scrollbar;
    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;

    if (rtl) {
      newPos = -newPos;

      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }

    if (swiper.isHorizontal()) {
      $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
      $dragEl[0].style.width = `${newSize}px`;
    } else {
      $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
      $dragEl[0].style.height = `${newSize}px`;
    }

    if (params.hide) {
      clearTimeout(timeout);
      $el[0].style.opacity = 1;
      timeout = setTimeout(() => {
        $el[0].style.opacity = 0;
        $el.transition(400);
      }, 1000);
    }
  }

  function setTransition(duration) {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    swiper.scrollbar.$dragEl.transition(duration);
  }

  function updateSize() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const {
      scrollbar
    } = swiper;
    const {
      $dragEl,
      $el
    } = scrollbar;
    $dragEl[0].style.width = '';
    $dragEl[0].style.height = '';
    trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
    divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));

    if (swiper.params.scrollbar.dragSize === 'auto') {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }

    if (swiper.isHorizontal()) {
      $dragEl[0].style.width = `${dragSize}px`;
    } else {
      $dragEl[0].style.height = `${dragSize}px`;
    }

    if (divider >= 1) {
      $el[0].style.display = 'none';
    } else {
      $el[0].style.display = '';
    }

    if (swiper.params.scrollbar.hide) {
      $el[0].style.opacity = 0;
    }

    if (swiper.params.watchOverflow && swiper.enabled) {
      scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
    }
  }

  function getPointerPosition(e) {
    if (swiper.isHorizontal()) {
      return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
    }

    return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
  }

  function setDragPosition(e) {
    const {
      scrollbar,
      rtlTranslate: rtl
    } = swiper;
    const {
      $el
    } = scrollbar;
    let positionRatio;
    positionRatio = (getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);

    if (rtl) {
      positionRatio = 1 - positionRatio;
    }

    const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }

  function onDragStart(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      $wrapperEl
    } = swiper;
    const {
      $el,
      $dragEl
    } = scrollbar;
    isTouched = true;
    dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
    e.preventDefault();
    e.stopPropagation();
    $wrapperEl.transition(100);
    $dragEl.transition(100);
    setDragPosition(e);
    clearTimeout(dragTimeout);
    $el.transition(0);

    if (params.hide) {
      $el.css('opacity', 1);
    }

    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css('scroll-snap-type', 'none');
    }

    emit('scrollbarDragStart', e);
  }

  function onDragMove(e) {
    const {
      scrollbar,
      $wrapperEl
    } = swiper;
    const {
      $el,
      $dragEl
    } = scrollbar;
    if (!isTouched) return;
    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
    setDragPosition(e);
    $wrapperEl.transition(0);
    $el.transition(0);
    $dragEl.transition(0);
    emit('scrollbarDragMove', e);
  }

  function onDragEnd(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      $wrapperEl
    } = swiper;
    const {
      $el
    } = scrollbar;
    if (!isTouched) return;
    isTouched = false;

    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css('scroll-snap-type', '');
      $wrapperEl.transition('');
    }

    if (params.hide) {
      clearTimeout(dragTimeout);
      dragTimeout = nextTick(() => {
        $el.css('opacity', 0);
        $el.transition(400);
      }, 1000);
    }

    emit('scrollbarDragEnd', e);

    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  }

  function events(method) {
    const {
      scrollbar,
      touchEventsTouch,
      touchEventsDesktop,
      params,
      support
    } = swiper;
    const $el = scrollbar.$el;
    const target = $el[0];
    const activeListener = support.passiveListener && params.passiveListeners ? {
      passive: false,
      capture: false
    } : false;
    const passiveListener = support.passiveListener && params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    if (!target) return;
    const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';

    if (!support.touch) {
      target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
      document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
      document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
    } else {
      target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
      target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
      target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
    }
  }

  function enableDraggable() {
    if (!swiper.params.scrollbar.el) return;
    events('on');
  }

  function disableDraggable() {
    if (!swiper.params.scrollbar.el) return;
    events('off');
  }

  function init() {
    const {
      scrollbar,
      $el: $swiperEl
    } = swiper;
    swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
      el: 'swiper-scrollbar'
    });
    const params = swiper.params.scrollbar;
    if (!params.el) return;
    let $el = $$1(params.el);

    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
      $el = $swiperEl.find(params.el);
    }

    let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);

    if ($dragEl.length === 0) {
      $dragEl = $$1(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
      $el.append($dragEl);
    }

    Object.assign(scrollbar, {
      $el,
      el: $el[0],
      $dragEl,
      dragEl: $dragEl[0]
    });

    if (params.draggable) {
      enableDraggable();
    }

    if ($el) {
      $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
    }
  }

  function destroy() {
    disableDraggable();
  }

  on('init', () => {
    init();
    updateSize();
    setTranslate();
  });
  on('update resize observerUpdate lock unlock', () => {
    updateSize();
  });
  on('setTranslate', () => {
    setTranslate();
  });
  on('setTransition', (_s, duration) => {
    setTransition(duration);
  });
  on('enable disable', () => {
    const {
      $el
    } = swiper.scrollbar;

    if ($el) {
      $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
    }
  });
  on('destroy', () => {
    destroy();
  });
  Object.assign(swiper.scrollbar, {
    updateSize,
    setTranslate,
    init,
    destroy
  });
}

function A11y({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    a11y: {
      enabled: true,
      notificationClass: 'swiper-notification',
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      paginationBulletMessage: 'Go to slide {{index}}',
      slideLabelMessage: '{{index}} / {{slidesLength}}',
      containerMessage: null,
      containerRoleDescriptionMessage: null,
      itemRoleDescriptionMessage: null,
      slideRole: 'group'
    }
  });
  let liveRegion = null;

  function notify(message) {
    const notification = liveRegion;
    if (notification.length === 0) return;
    notification.html('');
    notification.html(message);
  }

  function getRandomNumber(size = 16) {
    const randomChar = () => Math.round(16 * Math.random()).toString(16);

    return 'x'.repeat(size).replace(/x/g, randomChar);
  }

  function makeElFocusable($el) {
    $el.attr('tabIndex', '0');
  }

  function makeElNotFocusable($el) {
    $el.attr('tabIndex', '-1');
  }

  function addElRole($el, role) {
    $el.attr('role', role);
  }

  function addElRoleDescription($el, description) {
    $el.attr('aria-roledescription', description);
  }

  function addElControls($el, controls) {
    $el.attr('aria-controls', controls);
  }

  function addElLabel($el, label) {
    $el.attr('aria-label', label);
  }

  function addElId($el, id) {
    $el.attr('id', id);
  }

  function addElLive($el, live) {
    $el.attr('aria-live', live);
  }

  function disableEl($el) {
    $el.attr('aria-disabled', true);
  }

  function enableEl($el) {
    $el.attr('aria-disabled', false);
  }

  function onEnterOrSpaceKey(e) {
    if (e.keyCode !== 13 && e.keyCode !== 32) return;
    const params = swiper.params.a11y;
    const $targetEl = $$1(e.target);

    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
      if (!(swiper.isEnd && !swiper.params.loop)) {
        swiper.slideNext();
      }

      if (swiper.isEnd) {
        notify(params.lastSlideMessage);
      } else {
        notify(params.nextSlideMessage);
      }
    }

    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
      if (!(swiper.isBeginning && !swiper.params.loop)) {
        swiper.slidePrev();
      }

      if (swiper.isBeginning) {
        notify(params.firstSlideMessage);
      } else {
        notify(params.prevSlideMessage);
      }
    }

    if (swiper.pagination && $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))) {
      $targetEl[0].click();
    }
  }

  function updateNavigation() {
    if (swiper.params.loop || !swiper.navigation) return;
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        disableEl($prevEl);
        makeElNotFocusable($prevEl);
      } else {
        enableEl($prevEl);
        makeElFocusable($prevEl);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        disableEl($nextEl);
        makeElNotFocusable($nextEl);
      } else {
        enableEl($nextEl);
        makeElFocusable($nextEl);
      }
    }
  }

  function hasPagination() {
    return swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length;
  }

  function updatePagination() {
    const params = swiper.params.a11y;

    if (hasPagination()) {
      swiper.pagination.bullets.each(bulletEl => {
        const $bulletEl = $$1(bulletEl);
        makeElFocusable($bulletEl);

        if (!swiper.params.pagination.renderBullet) {
          addElRole($bulletEl, 'button');
          addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
        }
      });
    }
  }

  const initNavEl = ($el, wrapperId, message) => {
    makeElFocusable($el);

    if ($el[0].tagName !== 'BUTTON') {
      addElRole($el, 'button');
      $el.on('keydown', onEnterOrSpaceKey);
    }

    addElLabel($el, message);
    addElControls($el, wrapperId);
  };

  function init() {
    const params = swiper.params.a11y;
    swiper.$el.append(liveRegion); // Container

    const $containerEl = swiper.$el;

    if (params.containerRoleDescriptionMessage) {
      addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
    }

    if (params.containerMessage) {
      addElLabel($containerEl, params.containerMessage);
    } // Wrapper


    const $wrapperEl = swiper.$wrapperEl;
    const wrapperId = $wrapperEl.attr('id') || `swiper-wrapper-${getRandomNumber(16)}`;
    const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
    addElId($wrapperEl, wrapperId);
    addElLive($wrapperEl, live); // Slide

    if (params.itemRoleDescriptionMessage) {
      addElRoleDescription($$1(swiper.slides), params.itemRoleDescriptionMessage);
    }

    addElRole($$1(swiper.slides), params.slideRole);
    const slidesLength = swiper.params.loop ? swiper.slides.filter(el => !el.classList.contains(swiper.params.slideDuplicateClass)).length : swiper.slides.length;
    swiper.slides.each((slideEl, index) => {
      const $slideEl = $$1(slideEl);
      const slideIndex = swiper.params.loop ? parseInt($slideEl.attr('data-swiper-slide-index'), 10) : index;
      const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
      addElLabel($slideEl, ariaLabelMessage);
    }); // Navigation

    let $nextEl;
    let $prevEl;

    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }

    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }

    if ($nextEl && $nextEl.length) {
      initNavEl($nextEl, wrapperId, params.nextSlideMessage);
    }

    if ($prevEl && $prevEl.length) {
      initNavEl($prevEl, wrapperId, params.prevSlideMessage);
    } // Pagination


    if (hasPagination()) {
      swiper.pagination.$el.on('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
    }
  }

  function destroy() {
    if (liveRegion && liveRegion.length > 0) liveRegion.remove();
    let $nextEl;
    let $prevEl;

    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }

    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }

    if ($nextEl) {
      $nextEl.off('keydown', onEnterOrSpaceKey);
    }

    if ($prevEl) {
      $prevEl.off('keydown', onEnterOrSpaceKey);
    } // Pagination


    if (hasPagination()) {
      swiper.pagination.$el.off('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
    }
  }

  on('beforeInit', () => {
    liveRegion = $$1(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`);
  });
  on('afterInit', () => {
    if (!swiper.params.a11y.enabled) return;
    init();
    updateNavigation();
  });
  on('toEdge', () => {
    if (!swiper.params.a11y.enabled) return;
    updateNavigation();
  });
  on('fromEdge', () => {
    if (!swiper.params.a11y.enabled) return;
    updateNavigation();
  });
  on('paginationUpdate', () => {
    if (!swiper.params.a11y.enabled) return;
    updatePagination();
  });
  on('destroy', () => {
    if (!swiper.params.a11y.enabled) return;
    destroy();
  });
}

/* eslint no-underscore-dangle: "off" */
function Autoplay({
  swiper,
  extendParams,
  on,
  emit
}) {
  let timeout;
  swiper.autoplay = {
    running: false,
    paused: false
  };
  extendParams({
    autoplay: {
      enabled: false,
      delay: 3000,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false,
      pauseOnMouseEnter: false
    }
  });

  function run() {
    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
    let delay = swiper.params.autoplay.delay;

    if ($activeSlideEl.attr('data-swiper-autoplay')) {
      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
    }

    clearTimeout(timeout);
    timeout = nextTick(() => {
      let autoplayResult;

      if (swiper.params.autoplay.reverseDirection) {
        if (swiper.params.loop) {
          swiper.loopFix();
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          emit('autoplay');
        } else if (!swiper.isBeginning) {
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
          emit('autoplay');
        } else {
          stop();
        }
      } else if (swiper.params.loop) {
        swiper.loopFix();
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        emit('autoplay');
      } else if (!swiper.isEnd) {
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        emit('autoplay');
      } else if (!swiper.params.autoplay.stopOnLastSlide) {
        autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
        emit('autoplay');
      } else {
        stop();
      }

      if (swiper.params.cssMode && swiper.autoplay.running) run();else if (autoplayResult === false) {
        run();
      }
    }, delay);
  }

  function start() {
    if (typeof timeout !== 'undefined') return false;
    if (swiper.autoplay.running) return false;
    swiper.autoplay.running = true;
    emit('autoplayStart');
    run();
    return true;
  }

  function stop() {
    if (!swiper.autoplay.running) return false;
    if (typeof timeout === 'undefined') return false;

    if (timeout) {
      clearTimeout(timeout);
      timeout = undefined;
    }

    swiper.autoplay.running = false;
    emit('autoplayStop');
    return true;
  }

  function pause(speed) {
    if (!swiper.autoplay.running) return;
    if (swiper.autoplay.paused) return;
    if (timeout) clearTimeout(timeout);
    swiper.autoplay.paused = true;

    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
      swiper.autoplay.paused = false;
      run();
    } else {
      ['transitionend', 'webkitTransitionEnd'].forEach(event => {
        swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
      });
    }
  }

  function onVisibilityChange() {
    const document = getDocument();

    if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
      pause();
    }

    if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
      run();
      swiper.autoplay.paused = false;
    }
  }

  function onTransitionEnd(e) {
    if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
    if (e.target !== swiper.$wrapperEl[0]) return;
    ['transitionend', 'webkitTransitionEnd'].forEach(event => {
      swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
    });
    swiper.autoplay.paused = false;

    if (!swiper.autoplay.running) {
      stop();
    } else {
      run();
    }
  }

  function onMouseEnter() {
    if (swiper.params.autoplay.disableOnInteraction) {
      stop();
    } else {
      pause();
    }

    ['transitionend', 'webkitTransitionEnd'].forEach(event => {
      swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
    });
  }

  function onMouseLeave() {
    if (swiper.params.autoplay.disableOnInteraction) {
      return;
    }

    swiper.autoplay.paused = false;
    run();
  }

  function attachMouseEvents() {
    if (swiper.params.autoplay.pauseOnMouseEnter) {
      swiper.$el.on('mouseenter', onMouseEnter);
      swiper.$el.on('mouseleave', onMouseLeave);
    }
  }

  function detachMouseEvents() {
    swiper.$el.off('mouseenter', onMouseEnter);
    swiper.$el.off('mouseleave', onMouseLeave);
  }

  on('init', () => {
    if (swiper.params.autoplay.enabled) {
      start();
      const document = getDocument();
      document.addEventListener('visibilitychange', onVisibilityChange);
      attachMouseEvents();
    }
  });
  on('beforeTransitionStart', (_s, speed, internal) => {
    if (swiper.autoplay.running) {
      if (internal || !swiper.params.autoplay.disableOnInteraction) {
        swiper.autoplay.pause(speed);
      } else {
        stop();
      }
    }
  });
  on('sliderFirstMove', () => {
    if (swiper.autoplay.running) {
      if (swiper.params.autoplay.disableOnInteraction) {
        stop();
      } else {
        pause();
      }
    }
  });
  on('touchEnd', () => {
    if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
      run();
    }
  });
  on('destroy', () => {
    detachMouseEvents();

    if (swiper.autoplay.running) {
      stop();
    }

    const document = getDocument();
    document.removeEventListener('visibilitychange', onVisibilityChange);
  });
  Object.assign(swiper.autoplay, {
    pause,
    run,
    start,
    stop
  });
}

function effectInit(params) {
  const {
    effect,
    swiper,
    on,
    setTranslate,
    setTransition,
    overwriteParams,
    perspective
  } = params;
  on('beforeInit', () => {
    if (swiper.params.effect !== effect) return;
    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);

    if (perspective && perspective()) {
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
    }

    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
    Object.assign(swiper.params, overwriteParamsResult);
    Object.assign(swiper.originalParams, overwriteParamsResult);
  });
  on('setTranslate', () => {
    if (swiper.params.effect !== effect) return;
    setTranslate();
  });
  on('setTransition', (_s, duration) => {
    if (swiper.params.effect !== effect) return;
    setTransition(duration);
  });
}

function effectTarget(effectParams, $slideEl) {
  if (effectParams.transformEl) {
    return $slideEl.find(effectParams.transformEl).css({
      'backface-visibility': 'hidden',
      '-webkit-backface-visibility': 'hidden'
    });
  }

  return $slideEl;
}

function effectVirtualTransitionEnd({
  swiper,
  duration,
  transformEl,
  allSlides
}) {
  const {
    slides,
    activeIndex,
    $wrapperEl
  } = swiper;

  if (swiper.params.virtualTranslate && duration !== 0) {
    let eventTriggered = false;
    let $transitionEndTarget;

    if (allSlides) {
      $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;
    } else {
      $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);
    }

    $transitionEndTarget.transitionEnd(() => {
      if (eventTriggered) return;
      if (!swiper || swiper.destroyed) return;
      eventTriggered = true;
      swiper.animating = false;
      const triggerEvents = ['webkitTransitionEnd', 'transitionend'];

      for (let i = 0; i < triggerEvents.length; i += 1) {
        $wrapperEl.trigger(triggerEvents[i]);
      }
    });
  }
}

function EffectFade({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    fadeEffect: {
      crossFade: false,
      transformEl: null
    }
  });

  const setTranslate = () => {
    const {
      slides
    } = swiper;
    const params = swiper.params.fadeEffect;

    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = swiper.slides.eq(i);
      const offset = $slideEl[0].swiperSlideOffset;
      let tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      let ty = 0;

      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }

      const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
      const $targetEl = effectTarget(params, $slideEl);
      $targetEl.css({
        opacity: slideOpacity
      }).transform(`translate3d(${tx}px, ${ty}px, 0px)`);
    }
  };

  const setTransition = duration => {
    const {
      transformEl
    } = swiper.params.fadeEffect;
    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
    $transitionElements.transition(duration);
    effectVirtualTransitionEnd({
      swiper,
      duration,
      transformEl,
      allSlides: true
    });
  };

  effectInit({
    effect: 'fade',
    swiper,
    on,
    setTranslate,
    setTransition,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      spaceBetween: 0,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}

function isObject$2(o) {
  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}

function extend(target, src) {
  const noExtend = ['__proto__', 'constructor', 'prototype'];
  Object.keys(src).filter(key => noExtend.indexOf(key) < 0).forEach(key => {
    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$2(src[key]) && isObject$2(target[key]) && Object.keys(src[key]).length > 0) {
      if (src[key].__swiper__) target[key] = src[key];else extend(target[key], src[key]);
    } else {
      target[key] = src[key];
    }
  });
}

function needsNavigation(params = {}) {
  return params.navigation && typeof params.navigation.nextEl === 'undefined' && typeof params.navigation.prevEl === 'undefined';
}

function needsPagination(params = {}) {
  return params.pagination && typeof params.pagination.el === 'undefined';
}

function needsScrollbar(params = {}) {
  return params.scrollbar && typeof params.scrollbar.el === 'undefined';
}

function uniqueClasses(classNames = '') {
  const classes = classNames.split(' ').map(c => c.trim()).filter(c => !!c);
  const unique = [];
  classes.forEach(c => {
    if (unique.indexOf(c) < 0) unique.push(c);
  });
  return unique.join(' ');
}

/* underscore in name -> watch for changes */
const paramsList = ['modules', 'init', '_direction', 'touchEventsTarget', 'initialSlide', '_speed', 'cssMode', 'updateOnWindowResize', 'resizeObserver', 'nested', 'focusableElements', '_enabled', '_width', '_height', 'preventInteractionOnTransition', 'userAgent', 'url', '_edgeSwipeDetection', '_edgeSwipeThreshold', '_freeMode', '_autoHeight', 'setWrapperSize', 'virtualTranslate', '_effect', 'breakpoints', '_spaceBetween', '_slidesPerView', '_grid', '_slidesPerGroup', '_slidesPerGroupSkip', '_slidesPerGroupAuto', '_centeredSlides', '_centeredSlidesBounds', '_slidesOffsetBefore', '_slidesOffsetAfter', 'normalizeSlideIndex', '_centerInsufficientSlides', '_watchOverflow', 'roundLengths', 'touchRatio', 'touchAngle', 'simulateTouch', '_shortSwipes', '_longSwipes', 'longSwipesRatio', 'longSwipesMs', '_followFinger', 'allowTouchMove', '_threshold', 'touchMoveStopPropagation', 'touchStartPreventDefault', 'touchStartForcePreventDefault', 'touchReleaseOnEdges', 'uniqueNavElements', '_resistance', '_resistanceRatio', '_watchSlidesProgress', '_grabCursor', 'preventClicks', 'preventClicksPropagation', '_slideToClickedSlide', '_preloadImages', 'updateOnImagesReady', '_loop', '_loopAdditionalSlides', '_loopedSlides', '_loopFillGroupWithBlank', 'loopPreventsSlide', '_allowSlidePrev', '_allowSlideNext', '_swipeHandler', '_noSwiping', 'noSwipingClass', 'noSwipingSelector', 'passiveListeners', 'containerModifierClass', 'slideClass', 'slideBlankClass', 'slideActiveClass', 'slideDuplicateActiveClass', 'slideVisibleClass', 'slideDuplicateClass', 'slideNextClass', 'slideDuplicateNextClass', 'slidePrevClass', 'slideDuplicatePrevClass', 'wrapperClass', 'runCallbacksOnInit', 'observer', 'observeParents', 'observeSlideChildren', // modules
'a11y', 'autoplay', '_controller', 'coverflowEffect', 'cubeEffect', 'fadeEffect', 'flipEffect', 'creativeEffect', 'cardsEffect', 'hashNavigation', 'history', 'keyboard', 'lazy', 'mousewheel', '_navigation', '_pagination', 'parallax', '_scrollbar', '_thumbs', 'virtual', 'zoom'];

function getParams(obj = {}) {
  const params = {
    on: {}
  };
  const events = {};
  const passedParams = {};
  extend(params, Swiper$1.defaults);
  extend(params, Swiper$1.extendedDefaults);
  params._emitClasses = true;
  params.init = false;
  const rest = {};
  const allowedParams = paramsList.map(key => key.replace(/_/, ''));
  Object.keys(obj).forEach(key => {
    if (allowedParams.indexOf(key) >= 0) {
      if (isObject$2(obj[key])) {
        params[key] = {};
        passedParams[key] = {};
        extend(params[key], obj[key]);
        extend(passedParams[key], obj[key]);
      } else {
        params[key] = obj[key];
        passedParams[key] = obj[key];
      }
    } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === 'function') {
      events[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
    } else {
      rest[key] = obj[key];
    }
  });
  ['navigation', 'pagination', 'scrollbar'].forEach(key => {
    if (params[key] === true) params[key] = {};
    if (params[key] === false) delete params[key];
  });
  return {
    params,
    passedParams,
    rest,
    events
  };
}

function initSwiper(swiperParams) {
  return new Swiper$1(swiperParams);
}

function mountSwiper({
  el,
  nextEl,
  prevEl,
  paginationEl,
  scrollbarEl,
  swiper
}, swiperParams) {
  if (needsNavigation(swiperParams) && nextEl && prevEl) {
    swiper.params.navigation.nextEl = nextEl;
    swiper.originalParams.navigation.nextEl = nextEl;
    swiper.params.navigation.prevEl = prevEl;
    swiper.originalParams.navigation.prevEl = prevEl;
  }

  if (needsPagination(swiperParams) && paginationEl) {
    swiper.params.pagination.el = paginationEl;
    swiper.originalParams.pagination.el = paginationEl;
  }

  if (needsScrollbar(swiperParams) && scrollbarEl) {
    swiper.params.scrollbar.el = scrollbarEl;
    swiper.originalParams.scrollbar.el = scrollbarEl;
  }

  swiper.init(el);
}

function calcLoopedSlides(slides, swiperParams) {
  let slidesPerViewParams = swiperParams.slidesPerView;

  if (swiperParams.breakpoints) {
    const breakpoint = Swiper$1.prototype.getBreakpoint(swiperParams.breakpoints);
    const breakpointOnlyParams = breakpoint in swiperParams.breakpoints ? swiperParams.breakpoints[breakpoint] : undefined;

    if (breakpointOnlyParams && breakpointOnlyParams.slidesPerView) {
      slidesPerViewParams = breakpointOnlyParams.slidesPerView;
    }
  }

  let loopedSlides = Math.ceil(parseFloat(swiperParams.loopedSlides || slidesPerViewParams, 10));
  loopedSlides += swiperParams.loopAdditionalSlides;

  if (loopedSlides > slides.length) {
    loopedSlides = slides.length;
  }

  return loopedSlides;
}

function renderLoop(swiper, slides, swiperParams) {
  const modifiedSlides = slides.map((child, index) => {
    return /*#__PURE__*/React__default.cloneElement(child, {
      swiper,
      'data-swiper-slide-index': index
    });
  });

  function duplicateSlide(child, index, position) {
    return /*#__PURE__*/React__default.cloneElement(child, {
      key: `${child.key}-duplicate-${index}-${position}`,
      className: `${child.props.className || ''} ${swiperParams.slideDuplicateClass}`
    });
  }

  if (swiperParams.loopFillGroupWithBlank) {
    const blankSlidesNum = swiperParams.slidesPerGroup - modifiedSlides.length % swiperParams.slidesPerGroup;

    if (blankSlidesNum !== swiperParams.slidesPerGroup) {
      for (let i = 0; i < blankSlidesNum; i += 1) {
        const blankSlide = /*#__PURE__*/React__default.createElement("div", {
          className: `${swiperParams.slideClass} ${swiperParams.slideBlankClass}`
        });
        modifiedSlides.push(blankSlide);
      }
    }
  }

  if (swiperParams.slidesPerView === 'auto' && !swiperParams.loopedSlides) {
    swiperParams.loopedSlides = modifiedSlides.length;
  }

  const loopedSlides = calcLoopedSlides(modifiedSlides, swiperParams);
  const prependSlides = [];
  const appendSlides = [];
  modifiedSlides.forEach((child, index) => {
    if (index < loopedSlides) {
      appendSlides.push(duplicateSlide(child, index, 'prepend'));
    }

    if (index < modifiedSlides.length && index >= modifiedSlides.length - loopedSlides) {
      prependSlides.push(duplicateSlide(child, index, 'append'));
    }
  });

  if (swiper) {
    swiper.loopedSlides = loopedSlides;
  }

  return [...prependSlides, ...modifiedSlides, ...appendSlides];
}

function getChangedParams(swiperParams, oldParams, children, oldChildren) {
  const keys = [];
  if (!oldParams) return keys;

  const addKey = key => {
    if (keys.indexOf(key) < 0) keys.push(key);
  };

  const oldChildrenKeys = oldChildren.map(child => child.key);
  const childrenKeys = children.map(child => child.key);
  if (oldChildrenKeys.join('') !== childrenKeys.join('')) addKey('children');
  if (oldChildren.length !== children.length) addKey('children');
  const watchParams = paramsList.filter(key => key[0] === '_').map(key => key.replace(/_/, ''));
  watchParams.forEach(key => {
    if (key in swiperParams && key in oldParams) {
      if (isObject$2(swiperParams[key]) && isObject$2(oldParams[key])) {
        const newKeys = Object.keys(swiperParams[key]);
        const oldKeys = Object.keys(oldParams[key]);

        if (newKeys.length !== oldKeys.length) {
          addKey(key);
        } else {
          newKeys.forEach(newKey => {
            if (swiperParams[key][newKey] !== oldParams[key][newKey]) {
              addKey(key);
            }
          });
          oldKeys.forEach(oldKey => {
            if (swiperParams[key][oldKey] !== oldParams[key][oldKey]) addKey(key);
          });
        }
      } else if (swiperParams[key] !== oldParams[key]) {
        addKey(key);
      }
    }
  });
  return keys;
}

function processChildren(c) {
  const slides = [];
  React__default.Children.toArray(c).forEach(child => {
    if (child.type && child.type.displayName === 'SwiperSlide') {
      slides.push(child);
    } else if (child.props && child.props.children) {
      processChildren(child.props.children).forEach(slide => slides.push(slide));
    }
  });
  return slides;
}

function getChildren(c) {
  const slides = [];
  const slots = {
    'container-start': [],
    'container-end': [],
    'wrapper-start': [],
    'wrapper-end': []
  };
  React__default.Children.toArray(c).forEach(child => {
    if (child.type && child.type.displayName === 'SwiperSlide') {
      slides.push(child);
    } else if (child.props && child.props.slot && slots[child.props.slot]) {
      slots[child.props.slot].push(child);
    } else if (child.props && child.props.children) {
      const foundSlides = processChildren(child.props.children);

      if (foundSlides.length > 0) {
        foundSlides.forEach(slide => slides.push(slide));
      } else {
        slots['container-end'].push(child);
      }
    } else {
      slots['container-end'].push(child);
    }
  });
  return {
    slides,
    slots
  };
}

function updateSwiper({
  swiper,
  slides,
  passedParams,
  changedParams,
  nextEl,
  prevEl,
  scrollbarEl,
  paginationEl
}) {
  const updateParams = changedParams.filter(key => key !== 'children' && key !== 'direction');
  const {
    params: currentParams,
    pagination,
    navigation,
    scrollbar,
    virtual,
    thumbs
  } = swiper;
  let needThumbsInit;
  let needControllerInit;
  let needPaginationInit;
  let needScrollbarInit;
  let needNavigationInit;

  if (changedParams.includes('thumbs') && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {
    needThumbsInit = true;
  }

  if (changedParams.includes('controller') && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
    needControllerInit = true;
  }

  if (changedParams.includes('pagination') && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
    needPaginationInit = true;
  }

  if (changedParams.includes('scrollbar') && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
    needScrollbarInit = true;
  }

  if (changedParams.includes('navigation') && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
    needNavigationInit = true;
  }

  const destroyModule = mod => {
    if (!swiper[mod]) return;
    swiper[mod].destroy();

    if (mod === 'navigation') {
      currentParams[mod].prevEl = undefined;
      currentParams[mod].nextEl = undefined;
      swiper[mod].prevEl = undefined;
      swiper[mod].nextEl = undefined;
    } else {
      currentParams[mod].el = undefined;
      swiper[mod].el = undefined;
    }
  };

  updateParams.forEach(key => {
    if (isObject$2(currentParams[key]) && isObject$2(passedParams[key])) {
      extend(currentParams[key], passedParams[key]);
    } else {
      const newValue = passedParams[key];

      if ((newValue === true || newValue === false) && (key === 'navigation' || key === 'pagination' || key === 'scrollbar')) {
        if (newValue === false) {
          destroyModule(key);
        }
      } else {
        currentParams[key] = passedParams[key];
      }
    }
  });

  if (changedParams.includes('children') && virtual && currentParams.virtual.enabled) {
    virtual.slides = slides;
    virtual.update(true);
  } else if (changedParams.includes('children') && swiper.lazy && swiper.params.lazy.enabled) {
    swiper.lazy.load();
  }

  if (needThumbsInit) {
    const initialized = thumbs.init();
    if (initialized) thumbs.update(true);
  }

  if (needControllerInit) {
    swiper.controller.control = currentParams.controller.control;
  }

  if (needPaginationInit) {
    if (paginationEl) currentParams.pagination.el = paginationEl;
    pagination.init();
    pagination.render();
    pagination.update();
  }

  if (needScrollbarInit) {
    if (scrollbarEl) currentParams.scrollbar.el = scrollbarEl;
    scrollbar.init();
    scrollbar.updateSize();
    scrollbar.setTranslate();
  }

  if (needNavigationInit) {
    if (nextEl) currentParams.navigation.nextEl = nextEl;
    if (prevEl) currentParams.navigation.prevEl = prevEl;
    navigation.init();
    navigation.update();
  }

  if (changedParams.includes('allowSlideNext')) {
    swiper.allowSlideNext = passedParams.allowSlideNext;
  }

  if (changedParams.includes('allowSlidePrev')) {
    swiper.allowSlidePrev = passedParams.allowSlidePrev;
  }

  if (changedParams.includes('direction')) {
    swiper.changeDirection(passedParams.direction, false);
  }

  swiper.update();
}

function updateOnVirtualData(swiper) {
  if (!swiper || swiper.destroyed || !swiper.params.virtual || swiper.params.virtual && !swiper.params.virtual.enabled) return;
  swiper.updateSlides();
  swiper.updateProgress();
  swiper.updateSlidesClasses();

  if (swiper.lazy && swiper.params.lazy.enabled) {
    swiper.lazy.load();
  }

  if (swiper.parallax && swiper.params.parallax && swiper.params.parallax.enabled) {
    swiper.parallax.setTranslate();
  }
}

function renderVirtual(swiper, slides, virtualData) {
  if (!virtualData) return null;
  const style = swiper.isHorizontal() ? {
    [swiper.rtlTranslate ? 'right' : 'left']: `${virtualData.offset}px`
  } : {
    top: `${virtualData.offset}px`
  };
  return slides.filter((child, index) => index >= virtualData.from && index <= virtualData.to).map(child => {
    return /*#__PURE__*/React__default.cloneElement(child, {
      swiper,
      style
    });
  });
}

function useIsomorphicLayoutEffect(callback, deps) {
  // eslint-disable-next-line
  if (typeof window$1 === 'undefined') return useEffect(callback, deps);
  return useLayoutEffect(callback, deps);
}

function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }
const Swiper = /*#__PURE__*/forwardRef(({
  className,
  tag: Tag = 'div',
  wrapperTag: WrapperTag = 'div',
  children,
  onSwiper,
  ...rest
} = {}, externalElRef) => {
  let eventsAssigned = false;
  const [containerClasses, setContainerClasses] = useState('swiper');
  const [virtualData, setVirtualData] = useState(null);
  const [breakpointChanged, setBreakpointChanged] = useState(false);
  const initializedRef = useRef(false);
  const swiperElRef = useRef(null);
  const swiperRef = useRef(null);
  const oldPassedParamsRef = useRef(null);
  const oldSlides = useRef(null);
  const nextElRef = useRef(null);
  const prevElRef = useRef(null);
  const paginationElRef = useRef(null);
  const scrollbarElRef = useRef(null);
  const {
    params: swiperParams,
    passedParams,
    rest: restProps,
    events
  } = getParams(rest);
  const {
    slides,
    slots
  } = getChildren(children);

  const onBeforeBreakpoint = () => {
    setBreakpointChanged(!breakpointChanged);
  };

  Object.assign(swiperParams.on, {
    _containerClasses(swiper, classes) {
      setContainerClasses(classes);
    }

  });

  if (!swiperElRef.current) {
    // init swiper
    Object.assign(swiperParams.on, events);
    eventsAssigned = true;
    swiperRef.current = initSwiper(swiperParams);

    swiperRef.current.loopCreate = () => {};

    swiperRef.current.loopDestroy = () => {};

    if (swiperParams.loop) {
      swiperRef.current.loopedSlides = calcLoopedSlides(slides, swiperParams);
    }

    if (swiperRef.current.virtual && swiperRef.current.params.virtual.enabled) {
      swiperRef.current.virtual.slides = slides;
      const extendWith = {
        cache: false,
        slides,
        renderExternal: setVirtualData,
        renderExternalUpdate: false
      };
      extend(swiperRef.current.params.virtual, extendWith);
      extend(swiperRef.current.originalParams.virtual, extendWith);
    }
  } // Listen for breakpoints change


  if (swiperRef.current) {
    swiperRef.current.on('_beforeBreakpoint', onBeforeBreakpoint);
  }

  const attachEvents = () => {
    if (eventsAssigned || !events || !swiperRef.current) return;
    Object.keys(events).forEach(eventName => {
      swiperRef.current.on(eventName, events[eventName]);
    });
  };

  const detachEvents = () => {
    if (!events || !swiperRef.current) return;
    Object.keys(events).forEach(eventName => {
      swiperRef.current.off(eventName, events[eventName]);
    });
  };

  useEffect(() => {
    return () => {
      if (swiperRef.current) swiperRef.current.off('_beforeBreakpoint', onBeforeBreakpoint);
    };
  }); // set initialized flag

  useEffect(() => {
    if (!initializedRef.current && swiperRef.current) {
      swiperRef.current.emitSlidesClasses();
      initializedRef.current = true;
    }
  }); // mount swiper

  useIsomorphicLayoutEffect(() => {
    if (externalElRef) {
      externalElRef.current = swiperElRef.current;
    }

    if (!swiperElRef.current) return;
    mountSwiper({
      el: swiperElRef.current,
      nextEl: nextElRef.current,
      prevEl: prevElRef.current,
      paginationEl: paginationElRef.current,
      scrollbarEl: scrollbarElRef.current,
      swiper: swiperRef.current
    }, swiperParams);
    if (onSwiper) onSwiper(swiperRef.current); // eslint-disable-next-line

    return () => {
      if (swiperRef.current && !swiperRef.current.destroyed) {
        swiperRef.current.destroy(true, false);
      }
    };
  }, []); // watch for params change

  useIsomorphicLayoutEffect(() => {
    attachEvents();
    const changedParams = getChangedParams(passedParams, oldPassedParamsRef.current, slides, oldSlides.current);
    oldPassedParamsRef.current = passedParams;
    oldSlides.current = slides;

    if (changedParams.length && swiperRef.current && !swiperRef.current.destroyed) {
      updateSwiper({
        swiper: swiperRef.current,
        slides,
        passedParams,
        changedParams,
        nextEl: nextElRef.current,
        prevEl: prevElRef.current,
        scrollbarEl: scrollbarElRef.current,
        paginationEl: paginationElRef.current
      });
    }

    return () => {
      detachEvents();
    };
  }); // update on virtual update

  useIsomorphicLayoutEffect(() => {
    updateOnVirtualData(swiperRef.current);
  }, [virtualData]); // bypass swiper instance to slides

  function renderSlides() {
    if (swiperParams.virtual) {
      return renderVirtual(swiperRef.current, slides, virtualData);
    }

    if (!swiperParams.loop || swiperRef.current && swiperRef.current.destroyed) {
      return slides.map(child => {
        return /*#__PURE__*/React__default.cloneElement(child, {
          swiper: swiperRef.current
        });
      });
    }

    return renderLoop(swiperRef.current, slides, swiperParams);
  }

  return /*#__PURE__*/React__default.createElement(Tag, _extends$1({
    ref: swiperElRef,
    className: uniqueClasses(`${containerClasses}${className ? ` ${className}` : ''}`)
  }, restProps), slots['container-start'], needsNavigation(swiperParams) && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("div", {
    ref: prevElRef,
    className: "swiper-button-prev"
  }), /*#__PURE__*/React__default.createElement("div", {
    ref: nextElRef,
    className: "swiper-button-next"
  })), needsScrollbar(swiperParams) && /*#__PURE__*/React__default.createElement("div", {
    ref: scrollbarElRef,
    className: "swiper-scrollbar"
  }), needsPagination(swiperParams) && /*#__PURE__*/React__default.createElement("div", {
    ref: paginationElRef,
    className: "swiper-pagination"
  }), /*#__PURE__*/React__default.createElement(WrapperTag, {
    className: "swiper-wrapper"
  }, slots['wrapper-start'], renderSlides(), slots['wrapper-end']), slots['container-end']);
});
Swiper.displayName = 'Swiper';

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const SwiperSlide = /*#__PURE__*/forwardRef(({
  tag: Tag = 'div',
  children,
  className = '',
  swiper,
  zoom,
  virtualIndex,
  ...rest
} = {}, externalRef) => {
  const slideElRef = useRef(null);
  const [slideClasses, setSlideClasses] = useState('swiper-slide');

  function updateClasses(_s, el, classNames) {
    if (el === slideElRef.current) {
      setSlideClasses(classNames);
    }
  }

  useIsomorphicLayoutEffect(() => {
    if (externalRef) {
      externalRef.current = slideElRef.current;
    }

    if (!slideElRef.current || !swiper) {
      return;
    }

    if (swiper.destroyed) {
      if (slideClasses !== 'swiper-slide') {
        setSlideClasses('swiper-slide');
      }

      return;
    }

    swiper.on('_slideClass', updateClasses); // eslint-disable-next-line

    return () => {
      if (!swiper) return;
      swiper.off('_slideClass', updateClasses);
    };
  });
  useIsomorphicLayoutEffect(() => {
    if (swiper && slideElRef.current) {
      setSlideClasses(swiper.getSlideClasses(slideElRef.current));
    }
  }, [swiper]);
  let slideData;

  if (typeof children === 'function') {
    slideData = {
      isActive: slideClasses.indexOf('swiper-slide-active') >= 0 || slideClasses.indexOf('swiper-slide-duplicate-active') >= 0,
      isVisible: slideClasses.indexOf('swiper-slide-visible') >= 0,
      isDuplicate: slideClasses.indexOf('swiper-slide-duplicate') >= 0,
      isPrev: slideClasses.indexOf('swiper-slide-prev') >= 0 || slideClasses.indexOf('swiper-slide-duplicate-prev') >= 0,
      isNext: slideClasses.indexOf('swiper-slide-next') >= 0 || slideClasses.indexOf('swiper-slide-duplicate-next') >= 0
    };
  }

  const renderChildren = () => {
    return typeof children === 'function' ? children(slideData) : children;
  };

  return /*#__PURE__*/React__default.createElement(Tag, _extends({
    ref: slideElRef,
    className: uniqueClasses(`${slideClasses}${className ? ` ${className}` : ''}`),
    "data-swiper-slide-index": virtualIndex
  }, rest), zoom ? /*#__PURE__*/React__default.createElement("div", {
    className: "swiper-zoom-container",
    "data-swiper-zoom": typeof zoom === 'number' ? zoom : undefined
  }, renderChildren()) : renderChildren());
});
SwiperSlide.displayName = 'SwiperSlide';

var SwiperStyles = css$1(templateObject_1$1m || (templateObject_1$1m = __makeTemplateObject(["\n  @font-face {\n    font-family: 'swiper-icons';\n    src: url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA');\n    font-weight: 400;\n    font-style: normal;\n  }\n  :root {\n    --swiper-theme-color: white;\n  }\n  .swiper {\n    margin-left: auto;\n    margin-right: auto;\n    position: relative;\n    overflow: hidden;\n    list-style: none;\n    padding: 0;\n    /* Fix of Webkit flickering */\n    z-index: 1;\n  }\n  .swiper-vertical > .swiper-wrapper {\n    flex-direction: column;\n  }\n  .swiper-wrapper {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    z-index: 1;\n    display: flex;\n    transition-property: transform;\n    box-sizing: content-box;\n  }\n  .swiper-android .swiper-slide,\n  .swiper-wrapper {\n    transform: translate3d(0px, 0, 0);\n  }\n  .swiper-pointer-events {\n    touch-action: pan-y;\n  }\n  .swiper-pointer-events.swiper-vertical {\n    touch-action: pan-x;\n  }\n  .swiper-slide {\n    flex-shrink: 0;\n    width: 100%;\n    height: 100%;\n    position: relative;\n    transition-property: transform;\n  }\n  .swiper-slide-invisible-blank {\n    visibility: hidden;\n  }\n  /* Auto Height */\n  .swiper-autoheight,\n  .swiper-autoheight .swiper-slide {\n    height: auto;\n  }\n  .swiper-autoheight .swiper-wrapper {\n    align-items: flex-start;\n    transition-property: transform, height;\n  }\n  /* 3D Effects */\n  .swiper-3d,\n  .swiper-3d.swiper-css-mode .swiper-wrapper {\n    perspective: 1200px;\n  }\n  .swiper-3d .swiper-wrapper,\n  .swiper-3d .swiper-slide,\n  .swiper-3d .swiper-slide-shadow,\n  .swiper-3d .swiper-slide-shadow-left,\n  .swiper-3d .swiper-slide-shadow-right,\n  .swiper-3d .swiper-slide-shadow-top,\n  .swiper-3d .swiper-slide-shadow-bottom,\n  .swiper-3d .swiper-cube-shadow {\n    transform-style: preserve-3d;\n  }\n  .swiper-3d .swiper-slide-shadow,\n  .swiper-3d .swiper-slide-shadow-left,\n  .swiper-3d .swiper-slide-shadow-right,\n  .swiper-3d .swiper-slide-shadow-top,\n  .swiper-3d .swiper-slide-shadow-bottom {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    z-index: 10;\n  }\n  .swiper-3d .swiper-slide-shadow {\n    background: rgba(0, 0, 0, 0.15);\n  }\n  .swiper-3d .swiper-slide-shadow-left {\n    background-image: linear-gradient(\n      to left,\n      rgba(0, 0, 0, 0.5),\n      rgba(0, 0, 0, 0)\n    );\n  }\n  .swiper-3d .swiper-slide-shadow-right {\n    background-image: linear-gradient(\n      to right,\n      rgba(0, 0, 0, 0.5),\n      rgba(0, 0, 0, 0)\n    );\n  }\n  .swiper-3d .swiper-slide-shadow-top {\n    background-image: linear-gradient(\n      to top,\n      rgba(0, 0, 0, 0.5),\n      rgba(0, 0, 0, 0)\n    );\n  }\n  .swiper-3d .swiper-slide-shadow-bottom {\n    background-image: linear-gradient(\n      to bottom,\n      rgba(0, 0, 0, 0.5),\n      rgba(0, 0, 0, 0)\n    );\n  }\n  /* CSS Mode */\n  .swiper-css-mode > .swiper-wrapper {\n    overflow: auto;\n    scrollbar-width: none;\n    /* For Firefox */\n    -ms-overflow-style: none;\n    /* For Internet Explorer and Edge */\n  }\n  .swiper-css-mode > .swiper-wrapper::-webkit-scrollbar {\n    display: none;\n  }\n  .swiper-css-mode > .swiper-wrapper > .swiper-slide {\n    scroll-snap-align: start start;\n  }\n  .swiper-horizontal.swiper-css-mode > .swiper-wrapper {\n    scroll-snap-type: x mandatory;\n  }\n  .swiper-vertical.swiper-css-mode > .swiper-wrapper {\n    scroll-snap-type: y mandatory;\n  }\n  .swiper-centered > .swiper-wrapper::before {\n    content: '';\n    flex-shrink: 0;\n    order: 9999;\n  }\n  .swiper-centered.swiper-horizontal\n    > .swiper-wrapper\n    > .swiper-slide:first-of-type {\n    margin-inline-start: var(--swiper-centered-offset-before);\n  }\n  .swiper-centered.swiper-horizontal > .swiper-wrapper::before {\n    height: 100%;\n    min-height: 1px;\n    width: var(--swiper-centered-offset-after);\n  }\n  .swiper-centered.swiper-vertical\n    > .swiper-wrapper\n    > .swiper-slide:first-of-type {\n    margin-block-start: var(--swiper-centered-offset-before);\n  }\n  .swiper-centered.swiper-vertical > .swiper-wrapper::before {\n    width: 100%;\n    min-width: 1px;\n    height: var(--swiper-centered-offset-after);\n  }\n  .swiper-centered > .swiper-wrapper > .swiper-slide {\n    scroll-snap-align: center center;\n  }\n  .swiper-virtual.swiper-css-mode .swiper-wrapper::after {\n    content: '';\n    position: absolute;\n    left: 0;\n    top: 0;\n    pointer-events: none;\n  }\n  .swiper-virtual.swiper-css-mode.swiper-horizontal .swiper-wrapper::after {\n    height: 1px;\n    width: var(--swiper-virtual-size);\n  }\n  .swiper-virtual.swiper-css-mode.swiper-vertical .swiper-wrapper::after {\n    width: 1px;\n    height: var(--swiper-virtual-size);\n  }\n  :root {\n    --swiper-navigation-size: 44px;\n    /*\n  --swiper-navigation-color: var(--swiper-theme-color);\n  */\n  }\n  .swiper-button-prev,\n  .swiper-button-next {\n    position: absolute;\n    top: 50%;\n    width: calc(var(--swiper-navigation-size) / 44 * 27);\n    height: var(--swiper-navigation-size);\n    margin-top: calc(0px - (var(--swiper-navigation-size) / 2));\n    z-index: 10;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    color: var(--swiper-navigation-color, var(--swiper-theme-color));\n  }\n  .swiper-button-prev.swiper-button-disabled,\n  .swiper-button-next.swiper-button-disabled {\n    opacity: 0.35;\n    cursor: auto;\n    pointer-events: none;\n  }\n  .swiper-button-prev:after,\n  .swiper-button-next:after {\n    font-family: swiper-icons;\n    font-size: var(--swiper-navigation-size);\n    text-transform: none !important;\n    letter-spacing: 0;\n    text-transform: none;\n    font-variant: initial;\n    line-height: 1;\n  }\n  .swiper-button-prev,\n  .swiper-rtl .swiper-button-next {\n    z-index: 100;\n    top: 60%;\n    left: 7%;\n    right: auto;\n  }\n  .swiper-button-prev:after,\n  .swiper-rtl .swiper-button-next:after {\n    content: 'prev';\n  }\n  .swiper-button-next,\n  .swiper-rtl .swiper-button-prev {\n    top: 60%;\n    z-index: 100;\n    right: 7%;\n    left: auto;\n  }\n  .swiper-button-next:after,\n  .swiper-rtl .swiper-button-prev:after {\n    content: 'next';\n  }\n  .swiper-button-lock {\n    display: none;\n  }\n  :root {\n    /*\n  --swiper-pagination-color: var(--swiper-theme-color);\n  */\n  }\n  .swiper-pagination {\n    position: absolute;\n    text-align: center;\n    transition: 300ms opacity;\n    transform: translate3d(0, 0, 0);\n    z-index: 10;\n  }\n  .swiper-pagination.swiper-pagination-hidden {\n    opacity: 0;\n  }\n  /* Common Styles */\n  .swiper-pagination-fraction,\n  .swiper-pagination-custom,\n  .swiper-horizontal > .swiper-pagination-bullets,\n  .swiper-pagination-bullets.swiper-pagination-horizontal {\n    bottom: 20px;\n    left: 0;\n    width: 100%;\n  }\n  /* Bullets */\n  .swiper-pagination-bullets-dynamic {\n    overflow: hidden;\n    font-size: 0;\n  }\n  .swiper-pagination-bullets-dynamic .swiper-pagination-bullet {\n    transform: scale(0.33);\n    position: relative;\n  }\n  .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active {\n    transform: scale(1);\n  }\n  .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main {\n    transform: scale(1);\n  }\n  .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev {\n    transform: scale(0.66);\n  }\n  .swiper-pagination-bullets-dynamic\n    .swiper-pagination-bullet-active-prev-prev {\n    transform: scale(0.33);\n  }\n  .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next {\n    transform: scale(0.66);\n  }\n  .swiper-pagination-bullets-dynamic\n    .swiper-pagination-bullet-active-next-next {\n    transform: scale(0.33);\n  }\n  .swiper-pagination-bullet {\n    width: 8px;\n    height: 8px;\n    display: inline-block;\n    border-radius: 50%;\n    background: #000;\n    opacity: 0.2;\n  }\n  button.swiper-pagination-bullet {\n    border: none;\n    margin: 0;\n    padding: 0;\n    box-shadow: none;\n    -webkit-appearance: none;\n    appearance: none;\n  }\n  .swiper-pagination-clickable .swiper-pagination-bullet {\n    cursor: pointer;\n  }\n  .swiper-pagination-bullet:only-child {\n    display: none !important;\n  }\n  .swiper-pagination-bullet-active {\n    opacity: 1;\n    background: var(--swiper-pagination-color, var(--swiper-theme-color));\n  }\n  .swiper-vertical > .swiper-pagination-bullets,\n  .swiper-pagination-vertical.swiper-pagination-bullets {\n    right: 10px;\n    top: 50%;\n    transform: translate3d(0px, -50%, 0);\n  }\n  .swiper-vertical > .swiper-pagination-bullets .swiper-pagination-bullet,\n  .swiper-pagination-vertical.swiper-pagination-bullets\n    .swiper-pagination-bullet {\n    margin: 6px 0;\n    display: block;\n  }\n  .swiper-vertical\n    > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic,\n  .swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic {\n    top: 50%;\n    transform: translateY(-50%);\n    width: 8px;\n  }\n  .swiper-vertical\n    > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic\n    .swiper-pagination-bullet,\n  .swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic\n    .swiper-pagination-bullet {\n    display: inline-block;\n    transition: 200ms transform, 200ms top;\n  }\n  .swiper-horizontal > .swiper-pagination-bullets .swiper-pagination-bullet,\n  .swiper-pagination-horizontal.swiper-pagination-bullets\n    .swiper-pagination-bullet {\n    margin: 0 4px;\n  }\n  .swiper-horizontal\n    > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic,\n  .swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic {\n    left: 50%;\n    transform: translateX(-50%);\n    white-space: nowrap;\n  }\n  .swiper-horizontal\n    > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic\n    .swiper-pagination-bullet,\n  .swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic\n    .swiper-pagination-bullet {\n    transition: 200ms transform, 200ms left;\n  }\n  .swiper-horizontal.swiper-rtl\n    > .swiper-pagination-bullets-dynamic\n    .swiper-pagination-bullet {\n    transition: 200ms transform, 200ms right;\n  }\n  /* Progress */\n  .swiper-pagination-progressbar {\n    background: rgba(0, 0, 0, 0.25);\n    position: absolute;\n  }\n  .swiper-pagination-progressbar .swiper-pagination-progressbar-fill {\n    background: var(--swiper-pagination-color, var(--swiper-theme-color));\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    transform: scale(0);\n    transform-origin: left top;\n  }\n  .swiper-rtl\n    .swiper-pagination-progressbar\n    .swiper-pagination-progressbar-fill {\n    transform-origin: right top;\n  }\n  .swiper-horizontal > .swiper-pagination-progressbar,\n  .swiper-pagination-progressbar.swiper-pagination-horizontal,\n  .swiper-vertical\n    > .swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,\n  .swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite {\n    width: 100%;\n    height: 4px;\n    left: 0;\n    top: 0;\n  }\n  .swiper-vertical > .swiper-pagination-progressbar,\n  .swiper-pagination-progressbar.swiper-pagination-vertical,\n  .swiper-horizontal\n    > .swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,\n  .swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite {\n    width: 4px;\n    height: 100%;\n    left: 0;\n    top: 0;\n  }\n  .swiper-pagination-lock {\n    display: none;\n  }\n  /* Scrollbar */\n  .swiper-scrollbar {\n    border-radius: 10px;\n    position: relative;\n    -ms-touch-action: none;\n    touch-action: none;\n    background: rgba(0, 0, 0, 0.1);\n  }\n  .swiper-horizontal > .swiper-scrollbar {\n    position: absolute;\n    left: 1%;\n    bottom: 3px;\n    z-index: 50;\n    height: 5px;\n    width: 98%;\n  }\n  .swiper-vertical > .swiper-scrollbar {\n    position: absolute;\n    right: 3px;\n    top: 1%;\n    z-index: 50;\n    width: 5px;\n    height: 98%;\n  }\n  .swiper-scrollbar-drag {\n    height: 100%;\n    width: 100%;\n    position: relative;\n    background: rgba(0, 0, 0, 0.5);\n    border-radius: 10px;\n    left: 0;\n    top: 0;\n  }\n  .swiper-scrollbar-cursor-drag {\n    cursor: move;\n  }\n  .swiper-scrollbar-lock {\n    display: none;\n  }\n  .swiper-zoom-container {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    text-align: center;\n  }\n  .swiper-zoom-container > img,\n  .swiper-zoom-container > svg,\n  .swiper-zoom-container > canvas {\n    max-width: 100%;\n    max-height: 100%;\n    object-fit: contain;\n  }\n  .swiper-slide-zoomed {\n    cursor: move;\n  }\n  /* Preloader */\n  :root {\n    /*\n  --swiper-preloader-color: var(--swiper-theme-color);\n  */\n  }\n  .swiper-lazy-preloader {\n    width: 42px;\n    height: 42px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    margin-left: -21px;\n    margin-top: -21px;\n    z-index: 10;\n    transform-origin: 50%;\n    animation: swiper-preloader-spin 1s infinite linear;\n    box-sizing: border-box;\n    border: 4px solid var(--swiper-preloader-color, var(--swiper-theme-color));\n    border-radius: 50%;\n    border-top-color: transparent;\n  }\n  .swiper-lazy-preloader-white {\n    --swiper-preloader-color: #fff;\n  }\n  .swiper-lazy-preloader-black {\n    --swiper-preloader-color: #000;\n  }\n  @keyframes swiper-preloader-spin {\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n  /* a11y */\n  .swiper .swiper-notification {\n    position: absolute;\n    left: 0;\n    top: 0;\n    pointer-events: none;\n    opacity: 0;\n    z-index: -1000;\n  }\n  .swiper-free-mode > .swiper-wrapper {\n    transition-timing-function: ease-out;\n    margin: 0 auto;\n  }\n  .swiper-grid > .swiper-wrapper {\n    flex-wrap: wrap;\n  }\n  .swiper-grid-column > .swiper-wrapper {\n    flex-wrap: wrap;\n    flex-direction: column;\n  }\n  .swiper-fade.swiper-free-mode .swiper-slide {\n    transition-timing-function: ease-out;\n  }\n  .swiper-fade .swiper-slide {\n    pointer-events: none;\n    transition-property: opacity;\n  }\n  .swiper-fade .swiper-slide .swiper-slide {\n    pointer-events: none;\n  }\n  .swiper-fade .swiper-slide-active,\n  .swiper-fade .swiper-slide-active .swiper-slide-active {\n    pointer-events: auto;\n  }\n  .swiper-cube {\n    overflow: visible;\n  }\n  .swiper-cube .swiper-slide {\n    pointer-events: none;\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden;\n    z-index: 1;\n    visibility: hidden;\n    transform-origin: 0 0;\n    width: 100%;\n    height: 100%;\n  }\n  .swiper-cube .swiper-slide .swiper-slide {\n    pointer-events: none;\n  }\n  .swiper-cube.swiper-rtl .swiper-slide {\n    transform-origin: 100% 0;\n  }\n  .swiper-cube .swiper-slide-active,\n  .swiper-cube .swiper-slide-active .swiper-slide-active {\n    pointer-events: auto;\n  }\n  .swiper-cube .swiper-slide-active,\n  .swiper-cube .swiper-slide-next,\n  .swiper-cube .swiper-slide-prev,\n  .swiper-cube .swiper-slide-next + .swiper-slide {\n    pointer-events: auto;\n    visibility: visible;\n  }\n  .swiper-cube .swiper-slide-shadow-top,\n  .swiper-cube .swiper-slide-shadow-bottom,\n  .swiper-cube .swiper-slide-shadow-left,\n  .swiper-cube .swiper-slide-shadow-right {\n    z-index: 0;\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden;\n  }\n  .swiper-cube .swiper-cube-shadow {\n    position: absolute;\n    left: 0;\n    bottom: 0px;\n    width: 100%;\n    height: 100%;\n    opacity: 0.6;\n    z-index: 0;\n  }\n  .swiper-cube .swiper-cube-shadow:before {\n    content: '';\n    background: #000;\n    position: absolute;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    right: 0;\n    filter: blur(50px);\n  }\n  .swiper-flip {\n    overflow: visible;\n  }\n  .swiper-flip .swiper-slide {\n    pointer-events: none;\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden;\n    z-index: 1;\n  }\n  .swiper-flip .swiper-slide .swiper-slide {\n    pointer-events: none;\n  }\n  .swiper-flip .swiper-slide-active,\n  .swiper-flip .swiper-slide-active .swiper-slide-active {\n    pointer-events: auto;\n  }\n  .swiper-flip .swiper-slide-shadow-top,\n  .swiper-flip .swiper-slide-shadow-bottom,\n  .swiper-flip .swiper-slide-shadow-left,\n  .swiper-flip .swiper-slide-shadow-right {\n    z-index: 0;\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden;\n  }\n  .swiper-creative .swiper-slide {\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden;\n    overflow: hidden;\n    transition-property: transform, opacity, height;\n  }\n  .swiper-cards {\n    overflow: visible;\n  }\n  .swiper-cards .swiper-slide {\n    transform-origin: center bottom;\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden;\n    overflow: hidden;\n  }\n"], ["\n  @font-face {\n    font-family: 'swiper-icons';\n    src: url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA');\n    font-weight: 400;\n    font-style: normal;\n  }\n  :root {\n    --swiper-theme-color: white;\n  }\n  .swiper {\n    margin-left: auto;\n    margin-right: auto;\n    position: relative;\n    overflow: hidden;\n    list-style: none;\n    padding: 0;\n    /* Fix of Webkit flickering */\n    z-index: 1;\n  }\n  .swiper-vertical > .swiper-wrapper {\n    flex-direction: column;\n  }\n  .swiper-wrapper {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    z-index: 1;\n    display: flex;\n    transition-property: transform;\n    box-sizing: content-box;\n  }\n  .swiper-android .swiper-slide,\n  .swiper-wrapper {\n    transform: translate3d(0px, 0, 0);\n  }\n  .swiper-pointer-events {\n    touch-action: pan-y;\n  }\n  .swiper-pointer-events.swiper-vertical {\n    touch-action: pan-x;\n  }\n  .swiper-slide {\n    flex-shrink: 0;\n    width: 100%;\n    height: 100%;\n    position: relative;\n    transition-property: transform;\n  }\n  .swiper-slide-invisible-blank {\n    visibility: hidden;\n  }\n  /* Auto Height */\n  .swiper-autoheight,\n  .swiper-autoheight .swiper-slide {\n    height: auto;\n  }\n  .swiper-autoheight .swiper-wrapper {\n    align-items: flex-start;\n    transition-property: transform, height;\n  }\n  /* 3D Effects */\n  .swiper-3d,\n  .swiper-3d.swiper-css-mode .swiper-wrapper {\n    perspective: 1200px;\n  }\n  .swiper-3d .swiper-wrapper,\n  .swiper-3d .swiper-slide,\n  .swiper-3d .swiper-slide-shadow,\n  .swiper-3d .swiper-slide-shadow-left,\n  .swiper-3d .swiper-slide-shadow-right,\n  .swiper-3d .swiper-slide-shadow-top,\n  .swiper-3d .swiper-slide-shadow-bottom,\n  .swiper-3d .swiper-cube-shadow {\n    transform-style: preserve-3d;\n  }\n  .swiper-3d .swiper-slide-shadow,\n  .swiper-3d .swiper-slide-shadow-left,\n  .swiper-3d .swiper-slide-shadow-right,\n  .swiper-3d .swiper-slide-shadow-top,\n  .swiper-3d .swiper-slide-shadow-bottom {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    z-index: 10;\n  }\n  .swiper-3d .swiper-slide-shadow {\n    background: rgba(0, 0, 0, 0.15);\n  }\n  .swiper-3d .swiper-slide-shadow-left {\n    background-image: linear-gradient(\n      to left,\n      rgba(0, 0, 0, 0.5),\n      rgba(0, 0, 0, 0)\n    );\n  }\n  .swiper-3d .swiper-slide-shadow-right {\n    background-image: linear-gradient(\n      to right,\n      rgba(0, 0, 0, 0.5),\n      rgba(0, 0, 0, 0)\n    );\n  }\n  .swiper-3d .swiper-slide-shadow-top {\n    background-image: linear-gradient(\n      to top,\n      rgba(0, 0, 0, 0.5),\n      rgba(0, 0, 0, 0)\n    );\n  }\n  .swiper-3d .swiper-slide-shadow-bottom {\n    background-image: linear-gradient(\n      to bottom,\n      rgba(0, 0, 0, 0.5),\n      rgba(0, 0, 0, 0)\n    );\n  }\n  /* CSS Mode */\n  .swiper-css-mode > .swiper-wrapper {\n    overflow: auto;\n    scrollbar-width: none;\n    /* For Firefox */\n    -ms-overflow-style: none;\n    /* For Internet Explorer and Edge */\n  }\n  .swiper-css-mode > .swiper-wrapper::-webkit-scrollbar {\n    display: none;\n  }\n  .swiper-css-mode > .swiper-wrapper > .swiper-slide {\n    scroll-snap-align: start start;\n  }\n  .swiper-horizontal.swiper-css-mode > .swiper-wrapper {\n    scroll-snap-type: x mandatory;\n  }\n  .swiper-vertical.swiper-css-mode > .swiper-wrapper {\n    scroll-snap-type: y mandatory;\n  }\n  .swiper-centered > .swiper-wrapper::before {\n    content: '';\n    flex-shrink: 0;\n    order: 9999;\n  }\n  .swiper-centered.swiper-horizontal\n    > .swiper-wrapper\n    > .swiper-slide:first-of-type {\n    margin-inline-start: var(--swiper-centered-offset-before);\n  }\n  .swiper-centered.swiper-horizontal > .swiper-wrapper::before {\n    height: 100%;\n    min-height: 1px;\n    width: var(--swiper-centered-offset-after);\n  }\n  .swiper-centered.swiper-vertical\n    > .swiper-wrapper\n    > .swiper-slide:first-of-type {\n    margin-block-start: var(--swiper-centered-offset-before);\n  }\n  .swiper-centered.swiper-vertical > .swiper-wrapper::before {\n    width: 100%;\n    min-width: 1px;\n    height: var(--swiper-centered-offset-after);\n  }\n  .swiper-centered > .swiper-wrapper > .swiper-slide {\n    scroll-snap-align: center center;\n  }\n  .swiper-virtual.swiper-css-mode .swiper-wrapper::after {\n    content: '';\n    position: absolute;\n    left: 0;\n    top: 0;\n    pointer-events: none;\n  }\n  .swiper-virtual.swiper-css-mode.swiper-horizontal .swiper-wrapper::after {\n    height: 1px;\n    width: var(--swiper-virtual-size);\n  }\n  .swiper-virtual.swiper-css-mode.swiper-vertical .swiper-wrapper::after {\n    width: 1px;\n    height: var(--swiper-virtual-size);\n  }\n  :root {\n    --swiper-navigation-size: 44px;\n    /*\n  --swiper-navigation-color: var(--swiper-theme-color);\n  */\n  }\n  .swiper-button-prev,\n  .swiper-button-next {\n    position: absolute;\n    top: 50%;\n    width: calc(var(--swiper-navigation-size) / 44 * 27);\n    height: var(--swiper-navigation-size);\n    margin-top: calc(0px - (var(--swiper-navigation-size) / 2));\n    z-index: 10;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    color: var(--swiper-navigation-color, var(--swiper-theme-color));\n  }\n  .swiper-button-prev.swiper-button-disabled,\n  .swiper-button-next.swiper-button-disabled {\n    opacity: 0.35;\n    cursor: auto;\n    pointer-events: none;\n  }\n  .swiper-button-prev:after,\n  .swiper-button-next:after {\n    font-family: swiper-icons;\n    font-size: var(--swiper-navigation-size);\n    text-transform: none !important;\n    letter-spacing: 0;\n    text-transform: none;\n    font-variant: initial;\n    line-height: 1;\n  }\n  .swiper-button-prev,\n  .swiper-rtl .swiper-button-next {\n    z-index: 100;\n    top: 60%;\n    left: 7%;\n    right: auto;\n  }\n  .swiper-button-prev:after,\n  .swiper-rtl .swiper-button-next:after {\n    content: 'prev';\n  }\n  .swiper-button-next,\n  .swiper-rtl .swiper-button-prev {\n    top: 60%;\n    z-index: 100;\n    right: 7%;\n    left: auto;\n  }\n  .swiper-button-next:after,\n  .swiper-rtl .swiper-button-prev:after {\n    content: 'next';\n  }\n  .swiper-button-lock {\n    display: none;\n  }\n  :root {\n    /*\n  --swiper-pagination-color: var(--swiper-theme-color);\n  */\n  }\n  .swiper-pagination {\n    position: absolute;\n    text-align: center;\n    transition: 300ms opacity;\n    transform: translate3d(0, 0, 0);\n    z-index: 10;\n  }\n  .swiper-pagination.swiper-pagination-hidden {\n    opacity: 0;\n  }\n  /* Common Styles */\n  .swiper-pagination-fraction,\n  .swiper-pagination-custom,\n  .swiper-horizontal > .swiper-pagination-bullets,\n  .swiper-pagination-bullets.swiper-pagination-horizontal {\n    bottom: 20px;\n    left: 0;\n    width: 100%;\n  }\n  /* Bullets */\n  .swiper-pagination-bullets-dynamic {\n    overflow: hidden;\n    font-size: 0;\n  }\n  .swiper-pagination-bullets-dynamic .swiper-pagination-bullet {\n    transform: scale(0.33);\n    position: relative;\n  }\n  .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active {\n    transform: scale(1);\n  }\n  .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main {\n    transform: scale(1);\n  }\n  .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev {\n    transform: scale(0.66);\n  }\n  .swiper-pagination-bullets-dynamic\n    .swiper-pagination-bullet-active-prev-prev {\n    transform: scale(0.33);\n  }\n  .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next {\n    transform: scale(0.66);\n  }\n  .swiper-pagination-bullets-dynamic\n    .swiper-pagination-bullet-active-next-next {\n    transform: scale(0.33);\n  }\n  .swiper-pagination-bullet {\n    width: 8px;\n    height: 8px;\n    display: inline-block;\n    border-radius: 50%;\n    background: #000;\n    opacity: 0.2;\n  }\n  button.swiper-pagination-bullet {\n    border: none;\n    margin: 0;\n    padding: 0;\n    box-shadow: none;\n    -webkit-appearance: none;\n    appearance: none;\n  }\n  .swiper-pagination-clickable .swiper-pagination-bullet {\n    cursor: pointer;\n  }\n  .swiper-pagination-bullet:only-child {\n    display: none !important;\n  }\n  .swiper-pagination-bullet-active {\n    opacity: 1;\n    background: var(--swiper-pagination-color, var(--swiper-theme-color));\n  }\n  .swiper-vertical > .swiper-pagination-bullets,\n  .swiper-pagination-vertical.swiper-pagination-bullets {\n    right: 10px;\n    top: 50%;\n    transform: translate3d(0px, -50%, 0);\n  }\n  .swiper-vertical > .swiper-pagination-bullets .swiper-pagination-bullet,\n  .swiper-pagination-vertical.swiper-pagination-bullets\n    .swiper-pagination-bullet {\n    margin: 6px 0;\n    display: block;\n  }\n  .swiper-vertical\n    > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic,\n  .swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic {\n    top: 50%;\n    transform: translateY(-50%);\n    width: 8px;\n  }\n  .swiper-vertical\n    > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic\n    .swiper-pagination-bullet,\n  .swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic\n    .swiper-pagination-bullet {\n    display: inline-block;\n    transition: 200ms transform, 200ms top;\n  }\n  .swiper-horizontal > .swiper-pagination-bullets .swiper-pagination-bullet,\n  .swiper-pagination-horizontal.swiper-pagination-bullets\n    .swiper-pagination-bullet {\n    margin: 0 4px;\n  }\n  .swiper-horizontal\n    > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic,\n  .swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic {\n    left: 50%;\n    transform: translateX(-50%);\n    white-space: nowrap;\n  }\n  .swiper-horizontal\n    > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic\n    .swiper-pagination-bullet,\n  .swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic\n    .swiper-pagination-bullet {\n    transition: 200ms transform, 200ms left;\n  }\n  .swiper-horizontal.swiper-rtl\n    > .swiper-pagination-bullets-dynamic\n    .swiper-pagination-bullet {\n    transition: 200ms transform, 200ms right;\n  }\n  /* Progress */\n  .swiper-pagination-progressbar {\n    background: rgba(0, 0, 0, 0.25);\n    position: absolute;\n  }\n  .swiper-pagination-progressbar .swiper-pagination-progressbar-fill {\n    background: var(--swiper-pagination-color, var(--swiper-theme-color));\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    transform: scale(0);\n    transform-origin: left top;\n  }\n  .swiper-rtl\n    .swiper-pagination-progressbar\n    .swiper-pagination-progressbar-fill {\n    transform-origin: right top;\n  }\n  .swiper-horizontal > .swiper-pagination-progressbar,\n  .swiper-pagination-progressbar.swiper-pagination-horizontal,\n  .swiper-vertical\n    > .swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,\n  .swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite {\n    width: 100%;\n    height: 4px;\n    left: 0;\n    top: 0;\n  }\n  .swiper-vertical > .swiper-pagination-progressbar,\n  .swiper-pagination-progressbar.swiper-pagination-vertical,\n  .swiper-horizontal\n    > .swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,\n  .swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite {\n    width: 4px;\n    height: 100%;\n    left: 0;\n    top: 0;\n  }\n  .swiper-pagination-lock {\n    display: none;\n  }\n  /* Scrollbar */\n  .swiper-scrollbar {\n    border-radius: 10px;\n    position: relative;\n    -ms-touch-action: none;\n    touch-action: none;\n    background: rgba(0, 0, 0, 0.1);\n  }\n  .swiper-horizontal > .swiper-scrollbar {\n    position: absolute;\n    left: 1%;\n    bottom: 3px;\n    z-index: 50;\n    height: 5px;\n    width: 98%;\n  }\n  .swiper-vertical > .swiper-scrollbar {\n    position: absolute;\n    right: 3px;\n    top: 1%;\n    z-index: 50;\n    width: 5px;\n    height: 98%;\n  }\n  .swiper-scrollbar-drag {\n    height: 100%;\n    width: 100%;\n    position: relative;\n    background: rgba(0, 0, 0, 0.5);\n    border-radius: 10px;\n    left: 0;\n    top: 0;\n  }\n  .swiper-scrollbar-cursor-drag {\n    cursor: move;\n  }\n  .swiper-scrollbar-lock {\n    display: none;\n  }\n  .swiper-zoom-container {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    text-align: center;\n  }\n  .swiper-zoom-container > img,\n  .swiper-zoom-container > svg,\n  .swiper-zoom-container > canvas {\n    max-width: 100%;\n    max-height: 100%;\n    object-fit: contain;\n  }\n  .swiper-slide-zoomed {\n    cursor: move;\n  }\n  /* Preloader */\n  :root {\n    /*\n  --swiper-preloader-color: var(--swiper-theme-color);\n  */\n  }\n  .swiper-lazy-preloader {\n    width: 42px;\n    height: 42px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    margin-left: -21px;\n    margin-top: -21px;\n    z-index: 10;\n    transform-origin: 50%;\n    animation: swiper-preloader-spin 1s infinite linear;\n    box-sizing: border-box;\n    border: 4px solid var(--swiper-preloader-color, var(--swiper-theme-color));\n    border-radius: 50%;\n    border-top-color: transparent;\n  }\n  .swiper-lazy-preloader-white {\n    --swiper-preloader-color: #fff;\n  }\n  .swiper-lazy-preloader-black {\n    --swiper-preloader-color: #000;\n  }\n  @keyframes swiper-preloader-spin {\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n  /* a11y */\n  .swiper .swiper-notification {\n    position: absolute;\n    left: 0;\n    top: 0;\n    pointer-events: none;\n    opacity: 0;\n    z-index: -1000;\n  }\n  .swiper-free-mode > .swiper-wrapper {\n    transition-timing-function: ease-out;\n    margin: 0 auto;\n  }\n  .swiper-grid > .swiper-wrapper {\n    flex-wrap: wrap;\n  }\n  .swiper-grid-column > .swiper-wrapper {\n    flex-wrap: wrap;\n    flex-direction: column;\n  }\n  .swiper-fade.swiper-free-mode .swiper-slide {\n    transition-timing-function: ease-out;\n  }\n  .swiper-fade .swiper-slide {\n    pointer-events: none;\n    transition-property: opacity;\n  }\n  .swiper-fade .swiper-slide .swiper-slide {\n    pointer-events: none;\n  }\n  .swiper-fade .swiper-slide-active,\n  .swiper-fade .swiper-slide-active .swiper-slide-active {\n    pointer-events: auto;\n  }\n  .swiper-cube {\n    overflow: visible;\n  }\n  .swiper-cube .swiper-slide {\n    pointer-events: none;\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden;\n    z-index: 1;\n    visibility: hidden;\n    transform-origin: 0 0;\n    width: 100%;\n    height: 100%;\n  }\n  .swiper-cube .swiper-slide .swiper-slide {\n    pointer-events: none;\n  }\n  .swiper-cube.swiper-rtl .swiper-slide {\n    transform-origin: 100% 0;\n  }\n  .swiper-cube .swiper-slide-active,\n  .swiper-cube .swiper-slide-active .swiper-slide-active {\n    pointer-events: auto;\n  }\n  .swiper-cube .swiper-slide-active,\n  .swiper-cube .swiper-slide-next,\n  .swiper-cube .swiper-slide-prev,\n  .swiper-cube .swiper-slide-next + .swiper-slide {\n    pointer-events: auto;\n    visibility: visible;\n  }\n  .swiper-cube .swiper-slide-shadow-top,\n  .swiper-cube .swiper-slide-shadow-bottom,\n  .swiper-cube .swiper-slide-shadow-left,\n  .swiper-cube .swiper-slide-shadow-right {\n    z-index: 0;\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden;\n  }\n  .swiper-cube .swiper-cube-shadow {\n    position: absolute;\n    left: 0;\n    bottom: 0px;\n    width: 100%;\n    height: 100%;\n    opacity: 0.6;\n    z-index: 0;\n  }\n  .swiper-cube .swiper-cube-shadow:before {\n    content: '';\n    background: #000;\n    position: absolute;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    right: 0;\n    filter: blur(50px);\n  }\n  .swiper-flip {\n    overflow: visible;\n  }\n  .swiper-flip .swiper-slide {\n    pointer-events: none;\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden;\n    z-index: 1;\n  }\n  .swiper-flip .swiper-slide .swiper-slide {\n    pointer-events: none;\n  }\n  .swiper-flip .swiper-slide-active,\n  .swiper-flip .swiper-slide-active .swiper-slide-active {\n    pointer-events: auto;\n  }\n  .swiper-flip .swiper-slide-shadow-top,\n  .swiper-flip .swiper-slide-shadow-bottom,\n  .swiper-flip .swiper-slide-shadow-left,\n  .swiper-flip .swiper-slide-shadow-right {\n    z-index: 0;\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden;\n  }\n  .swiper-creative .swiper-slide {\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden;\n    overflow: hidden;\n    transition-property: transform, opacity, height;\n  }\n  .swiper-cards {\n    overflow: visible;\n  }\n  .swiper-cards .swiper-slide {\n    transform-origin: center bottom;\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden;\n    overflow: hidden;\n  }\n"])));
var templateObject_1$1m;

Swiper$1.use([Pagination, Scrollbar, A11y, Autoplay, EffectFade, Navigation]);
var AtomCarrousell = function (props) {
    var height = props.height, width = props.width, customCSS = props.customCSS, swiperProps = props.swiperProps, children = props.children, direction = props.direction, slidesPerView = props.slidesPerView, acentColor = props.acentColor, slides = props.slides;
    return (jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_1$1l || (templateObject_1$1l = __makeTemplateObject(["\n        ", "\n        .swiper {\n          width: ", ";\n          height: ", ";\n        }\n        .swiper-slide {\n          text-align: center;\n          font-size: 18px;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n        }\n\n        .swiper-pagination-bullet-active {\n          background-color: ", ";\n        }\n        .swiper-slide img {\n          width: 100%;\n          height: 100%;\n          object-fit: cover;\n        }\n        .swiper-button-prev {\n          ::after {\n            font-size: 42px;\n            color: ", ";\n          }\n          top: 50%;\n          left: 3%;\n        }\n        .swiper-button-next {\n          ::after {\n            font-size: 42px;\n            color: ", ";\n          }\n          top: 50%;\n          right: 3%;\n        }\n        ", "\n      "], ["\n        ", "\n        .swiper {\n          width: ", ";\n          height: ", ";\n        }\n        .swiper-slide {\n          text-align: center;\n          font-size: 18px;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n        }\n\n        .swiper-pagination-bullet-active {\n          background-color: ", ";\n        }\n        .swiper-slide img {\n          width: 100%;\n          height: 100%;\n          object-fit: cover;\n        }\n        .swiper-button-prev {\n          ::after {\n            font-size: 42px;\n            color: ", ";\n          }\n          top: 50%;\n          left: 3%;\n        }\n        .swiper-button-next {\n          ::after {\n            font-size: 42px;\n            color: ", ";\n          }\n          top: 50%;\n          right: 3%;\n        }\n        ", "\n      "])), SwiperStyles, width || "100%", height || "100vh", acentColor !== null && acentColor !== void 0 ? acentColor : "white", acentColor !== null && acentColor !== void 0 ? acentColor : "#ebebebeb", acentColor !== null && acentColor !== void 0 ? acentColor : "#ebebebeb", customCSS) }, { children: jsxs(Swiper, __assign({ direction: direction || 'horizontal', autoplay: {
                delay: 6000,
            }, navigation: direction !== 'vertical', loop: true, pagination: {
                clickable: true,
            }, slidesPerView: slidesPerView || 1 }, swiperProps, { children: [slides === null || slides === void 0 ? void 0 : slides.map(function (item) { return (jsx(SwiperSlide, { children: item }, item === null || item === void 0 ? void 0 : item.key)); }), children === null || children === void 0 ? void 0 : children.map(function (item) { return (jsx(SwiperSlide, { children: item }, item === null || item === void 0 ? void 0 : item.key)); })] })) })));
};
var templateObject_1$1l;

var genericMessage = "Invariant Violation";
var _a$4 = Object.setPrototypeOf, setPrototypeOf = _a$4 === void 0 ? function (obj, proto) {
    obj.__proto__ = proto;
    return obj;
} : _a$4;
var InvariantError = /** @class */ (function (_super) {
    __extends(InvariantError, _super);
    function InvariantError(message) {
        if (message === void 0) { message = genericMessage; }
        var _this = _super.call(this, typeof message === "number"
            ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)"
            : message) || this;
        _this.framesToPop = 1;
        _this.name = genericMessage;
        setPrototypeOf(_this, InvariantError.prototype);
        return _this;
    }
    return InvariantError;
}(Error));
function invariant(condition, message) {
    if (!condition) {
        throw new InvariantError(message);
    }
}
var verbosityLevels = ["debug", "log", "warn", "error", "silent"];
var verbosityLevel = verbosityLevels.indexOf("log");
function wrapConsoleMethod(name) {
    return function () {
        if (verbosityLevels.indexOf(name) >= verbosityLevel) {
            // Default to console.log if this host environment happens not to provide
            // all the console.* methods we need.
            var method = console[name] || console.log;
            return method.apply(console, arguments);
        }
    };
}
(function (invariant) {
    invariant.debug = wrapConsoleMethod("debug");
    invariant.log = wrapConsoleMethod("log");
    invariant.warn = wrapConsoleMethod("warn");
    invariant.error = wrapConsoleMethod("error");
})(invariant || (invariant = {}));

function maybe$1(thunk) {
    try {
        return thunk();
    }
    catch (_a) { }
}

var global$1 = (maybe$1(function () { return globalThis; }) ||
    maybe$1(function () { return window$1; }) ||
    maybe$1(function () { return self; }) ||
    maybe$1(function () { return global; }) || maybe$1(function () { return maybe$1.constructor("return this")(); }));

var __ = "__";
var GLOBAL_KEY = [__, __].join("DEV");
function getDEV() {
    try {
        return Boolean(__DEV__);
    }
    catch (_a) {
        Object.defineProperty(global$1, GLOBAL_KEY, {
            value: maybe$1(function () { return process.env.NODE_ENV; }) !== "production",
            enumerable: false,
            configurable: true,
            writable: true,
        });
        return global$1[GLOBAL_KEY];
    }
}
var DEV = getDEV();

function maybe(thunk) {
  try { return thunk() } catch (_) {}
}

var safeGlobal = (
  maybe(function() { return globalThis }) ||
  maybe(function() { return window$1 }) ||
  maybe(function() { return self }) ||
  maybe(function() { return global }) ||
  // We don't expect the Function constructor ever to be invoked at runtime, as
  // long as at least one of globalThis, window, self, or global is defined, so
  // we are under no obligation to make it easy for static analysis tools to
  // detect syntactic usage of the Function constructor. If you think you can
  // improve your static analysis to detect this obfuscation, think again. This
  // is an arms race you cannot win, at least not in JavaScript.
  maybe(function() { return maybe.constructor("return this")() })
);

var needToRemove = false;

function install() {
  if (safeGlobal &&
      !maybe(function() { return process.env.NODE_ENV }) &&
      !maybe(function() { return process })) {
    Object.defineProperty(safeGlobal, "process", {
      value: {
        env: {
          // This default needs to be "production" instead of "development", to
          // avoid the problem https://github.com/graphql/graphql-js/pull/2894
          // will eventually solve, once merged and released.
          NODE_ENV: "production",
        },
      },
      // Let anyone else change global.process as they see fit, but hide it from
      // Object.keys(global) enumeration.
      configurable: true,
      enumerable: false,
      writable: true,
    });
    needToRemove = true;
  }
}

// Call install() at least once, when this module is imported.
install();

function remove() {
  if (needToRemove) {
    delete safeGlobal.process;
    needToRemove = false;
  }
}

function removeTemporaryGlobals() {
    return typeof Source === "function" ? remove() : remove();
}

function checkDEV() {
    __DEV__ ? invariant("boolean" === typeof DEV, DEV) : invariant("boolean" === typeof DEV, 36);
}
removeTemporaryGlobals();
checkDEV();

function shouldInclude(_a, variables) {
    var directives = _a.directives;
    if (!directives || !directives.length) {
        return true;
    }
    return getInclusionDirectives(directives).every(function (_a) {
        var directive = _a.directive, ifArgument = _a.ifArgument;
        var evaledValue = false;
        if (ifArgument.value.kind === 'Variable') {
            evaledValue = variables && variables[ifArgument.value.name.value];
            __DEV__ ? invariant(evaledValue !== void 0, "Invalid variable referenced in @".concat(directive.name.value, " directive.")) : invariant(evaledValue !== void 0, 37);
        }
        else {
            evaledValue = ifArgument.value.value;
        }
        return directive.name.value === 'skip' ? !evaledValue : evaledValue;
    });
}
function getDirectiveNames(root) {
    var names = [];
    visit(root, {
        Directive: function (node) {
            names.push(node.name.value);
        },
    });
    return names;
}
function hasDirectives(names, root) {
    return getDirectiveNames(root).some(function (name) { return names.indexOf(name) > -1; });
}
function hasClientExports(document) {
    return (document &&
        hasDirectives(['client'], document) &&
        hasDirectives(['export'], document));
}
function isInclusionDirective(_a) {
    var value = _a.name.value;
    return value === 'skip' || value === 'include';
}
function getInclusionDirectives(directives) {
    var result = [];
    if (directives && directives.length) {
        directives.forEach(function (directive) {
            if (!isInclusionDirective(directive))
                return;
            var directiveArguments = directive.arguments;
            var directiveName = directive.name.value;
            __DEV__ ? invariant(directiveArguments && directiveArguments.length === 1, "Incorrect number of arguments for the @".concat(directiveName, " directive.")) : invariant(directiveArguments && directiveArguments.length === 1, 38);
            var ifArgument = directiveArguments[0];
            __DEV__ ? invariant(ifArgument.name && ifArgument.name.value === 'if', "Invalid argument for the @".concat(directiveName, " directive.")) : invariant(ifArgument.name && ifArgument.name.value === 'if', 39);
            var ifValue = ifArgument.value;
            __DEV__ ? invariant(ifValue &&
                (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'), "Argument for the @".concat(directiveName, " directive must be a variable or a boolean value.")) : invariant(ifValue &&
                (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'), 40);
            result.push({ directive: directive, ifArgument: ifArgument });
        });
    }
    return result;
}

function getFragmentQueryDocument(document, fragmentName) {
    var actualFragmentName = fragmentName;
    var fragments = [];
    document.definitions.forEach(function (definition) {
        if (definition.kind === 'OperationDefinition') {
            throw __DEV__ ? new InvariantError("Found a ".concat(definition.operation, " operation").concat(definition.name ? " named '".concat(definition.name.value, "'") : '', ". ") +
                'No operations are allowed when using a fragment as a query. Only fragments are allowed.') : new InvariantError(41);
        }
        if (definition.kind === 'FragmentDefinition') {
            fragments.push(definition);
        }
    });
    if (typeof actualFragmentName === 'undefined') {
        __DEV__ ? invariant(fragments.length === 1, "Found ".concat(fragments.length, " fragments. `fragmentName` must be provided when there is not exactly 1 fragment.")) : invariant(fragments.length === 1, 42);
        actualFragmentName = fragments[0].name.value;
    }
    var query = __assign(__assign({}, document), { definitions: __spreadArray([
            {
                kind: 'OperationDefinition',
                operation: 'query',
                selectionSet: {
                    kind: 'SelectionSet',
                    selections: [
                        {
                            kind: 'FragmentSpread',
                            name: {
                                kind: 'Name',
                                value: actualFragmentName,
                            },
                        },
                    ],
                },
            }
        ], document.definitions, true) });
    return query;
}
function createFragmentMap(fragments) {
    if (fragments === void 0) { fragments = []; }
    var symTable = {};
    fragments.forEach(function (fragment) {
        symTable[fragment.name.value] = fragment;
    });
    return symTable;
}
function getFragmentFromSelection(selection, fragmentMap) {
    switch (selection.kind) {
        case 'InlineFragment':
            return selection;
        case 'FragmentSpread': {
            var fragment = fragmentMap && fragmentMap[selection.name.value];
            __DEV__ ? invariant(fragment, "No fragment named ".concat(selection.name.value, ".")) : invariant(fragment, 43);
            return fragment;
        }
        default:
            return null;
    }
}

function isNonNullObject(obj) {
    return obj !== null && typeof obj === 'object';
}

function makeReference(id) {
    return { __ref: String(id) };
}
function isReference(obj) {
    return Boolean(obj && typeof obj === 'object' && typeof obj.__ref === 'string');
}
function isDocumentNode(value) {
    return (isNonNullObject(value) &&
        value.kind === "Document" &&
        Array.isArray(value.definitions));
}
function isStringValue(value) {
    return value.kind === 'StringValue';
}
function isBooleanValue(value) {
    return value.kind === 'BooleanValue';
}
function isIntValue(value) {
    return value.kind === 'IntValue';
}
function isFloatValue(value) {
    return value.kind === 'FloatValue';
}
function isVariable(value) {
    return value.kind === 'Variable';
}
function isObjectValue(value) {
    return value.kind === 'ObjectValue';
}
function isListValue(value) {
    return value.kind === 'ListValue';
}
function isEnumValue(value) {
    return value.kind === 'EnumValue';
}
function isNullValue(value) {
    return value.kind === 'NullValue';
}
function valueToObjectRepresentation(argObj, name, value, variables) {
    if (isIntValue(value) || isFloatValue(value)) {
        argObj[name.value] = Number(value.value);
    }
    else if (isBooleanValue(value) || isStringValue(value)) {
        argObj[name.value] = value.value;
    }
    else if (isObjectValue(value)) {
        var nestedArgObj_1 = {};
        value.fields.map(function (obj) {
            return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
        });
        argObj[name.value] = nestedArgObj_1;
    }
    else if (isVariable(value)) {
        var variableValue = (variables || {})[value.name.value];
        argObj[name.value] = variableValue;
    }
    else if (isListValue(value)) {
        argObj[name.value] = value.values.map(function (listValue) {
            var nestedArgArrayObj = {};
            valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
            return nestedArgArrayObj[name.value];
        });
    }
    else if (isEnumValue(value)) {
        argObj[name.value] = value.value;
    }
    else if (isNullValue(value)) {
        argObj[name.value] = null;
    }
    else {
        throw __DEV__ ? new InvariantError("The inline argument \"".concat(name.value, "\" of kind \"").concat(value.kind, "\"") +
            'is not supported. Use variables instead of inline arguments to ' +
            'overcome this limitation.') : new InvariantError(52);
    }
}
function storeKeyNameFromField(field, variables) {
    var directivesObj = null;
    if (field.directives) {
        directivesObj = {};
        field.directives.forEach(function (directive) {
            directivesObj[directive.name.value] = {};
            if (directive.arguments) {
                directive.arguments.forEach(function (_a) {
                    var name = _a.name, value = _a.value;
                    return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
                });
            }
        });
    }
    var argObj = null;
    if (field.arguments && field.arguments.length) {
        argObj = {};
        field.arguments.forEach(function (_a) {
            var name = _a.name, value = _a.value;
            return valueToObjectRepresentation(argObj, name, value, variables);
        });
    }
    return getStoreKeyName(field.name.value, argObj, directivesObj);
}
var KNOWN_DIRECTIVES = [
    'connection',
    'include',
    'skip',
    'client',
    'rest',
    'export',
];
var getStoreKeyName = Object.assign(function (fieldName, args, directives) {
    if (args &&
        directives &&
        directives['connection'] &&
        directives['connection']['key']) {
        if (directives['connection']['filter'] &&
            directives['connection']['filter'].length > 0) {
            var filterKeys = directives['connection']['filter']
                ? directives['connection']['filter']
                : [];
            filterKeys.sort();
            var filteredArgs_1 = {};
            filterKeys.forEach(function (key) {
                filteredArgs_1[key] = args[key];
            });
            return "".concat(directives['connection']['key'], "(").concat(stringify$1(filteredArgs_1), ")");
        }
        else {
            return directives['connection']['key'];
        }
    }
    var completeFieldName = fieldName;
    if (args) {
        var stringifiedArgs = stringify$1(args);
        completeFieldName += "(".concat(stringifiedArgs, ")");
    }
    if (directives) {
        Object.keys(directives).forEach(function (key) {
            if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
                return;
            if (directives[key] && Object.keys(directives[key]).length) {
                completeFieldName += "@".concat(key, "(").concat(stringify$1(directives[key]), ")");
            }
            else {
                completeFieldName += "@".concat(key);
            }
        });
    }
    return completeFieldName;
}, {
    setStringify: function (s) {
        var previous = stringify$1;
        stringify$1 = s;
        return previous;
    },
});
var stringify$1 = function defaultStringify(value) {
    return JSON.stringify(value, stringifyReplacer);
};
function stringifyReplacer(_key, value) {
    if (isNonNullObject(value) && !Array.isArray(value)) {
        value = Object.keys(value).sort().reduce(function (copy, key) {
            copy[key] = value[key];
            return copy;
        }, {});
    }
    return value;
}
function argumentsObjectFromField(field, variables) {
    if (field.arguments && field.arguments.length) {
        var argObj_1 = {};
        field.arguments.forEach(function (_a) {
            var name = _a.name, value = _a.value;
            return valueToObjectRepresentation(argObj_1, name, value, variables);
        });
        return argObj_1;
    }
    return null;
}
function resultKeyNameFromField(field) {
    return field.alias ? field.alias.value : field.name.value;
}
function getTypenameFromResult(result, selectionSet, fragmentMap) {
    if (typeof result.__typename === 'string') {
        return result.__typename;
    }
    for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {
        var selection = _a[_i];
        if (isField(selection)) {
            if (selection.name.value === '__typename') {
                return result[resultKeyNameFromField(selection)];
            }
        }
        else {
            var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
            if (typeof typename === 'string') {
                return typename;
            }
        }
    }
}
function isField(selection) {
    return selection.kind === 'Field';
}
function isInlineFragment(selection) {
    return selection.kind === 'InlineFragment';
}

function checkDocument(doc) {
    __DEV__ ? invariant(doc && doc.kind === 'Document', "Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql") : invariant(doc && doc.kind === 'Document', 44);
    var operations = doc.definitions
        .filter(function (d) { return d.kind !== 'FragmentDefinition'; })
        .map(function (definition) {
        if (definition.kind !== 'OperationDefinition') {
            throw __DEV__ ? new InvariantError("Schema type definitions not allowed in queries. Found: \"".concat(definition.kind, "\"")) : new InvariantError(45);
        }
        return definition;
    });
    __DEV__ ? invariant(operations.length <= 1, "Ambiguous GraphQL document: contains ".concat(operations.length, " operations")) : invariant(operations.length <= 1, 46);
    return doc;
}
function getOperationDefinition(doc) {
    checkDocument(doc);
    return doc.definitions.filter(function (definition) { return definition.kind === 'OperationDefinition'; })[0];
}
function getOperationName(doc) {
    return (doc.definitions
        .filter(function (definition) {
        return definition.kind === 'OperationDefinition' && definition.name;
    })
        .map(function (x) { return x.name.value; })[0] || null);
}
function getFragmentDefinitions(doc) {
    return doc.definitions.filter(function (definition) { return definition.kind === 'FragmentDefinition'; });
}
function getQueryDefinition(doc) {
    var queryDef = getOperationDefinition(doc);
    __DEV__ ? invariant(queryDef && queryDef.operation === 'query', 'Must contain a query definition.') : invariant(queryDef && queryDef.operation === 'query', 47);
    return queryDef;
}
function getFragmentDefinition(doc) {
    __DEV__ ? invariant(doc.kind === 'Document', "Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql") : invariant(doc.kind === 'Document', 48);
    __DEV__ ? invariant(doc.definitions.length <= 1, 'Fragment must have exactly one definition.') : invariant(doc.definitions.length <= 1, 49);
    var fragmentDef = doc.definitions[0];
    __DEV__ ? invariant(fragmentDef.kind === 'FragmentDefinition', 'Must be a fragment definition.') : invariant(fragmentDef.kind === 'FragmentDefinition', 50);
    return fragmentDef;
}
function getMainDefinition(queryDoc) {
    checkDocument(queryDoc);
    var fragmentDefinition;
    for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {
        var definition = _a[_i];
        if (definition.kind === 'OperationDefinition') {
            var operation = definition.operation;
            if (operation === 'query' ||
                operation === 'mutation' ||
                operation === 'subscription') {
                return definition;
            }
        }
        if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {
            fragmentDefinition = definition;
        }
    }
    if (fragmentDefinition) {
        return fragmentDefinition;
    }
    throw __DEV__ ? new InvariantError('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.') : new InvariantError(51);
}
function getDefaultValues(definition) {
    var defaultValues = Object.create(null);
    var defs = definition && definition.variableDefinitions;
    if (defs && defs.length) {
        defs.forEach(function (def) {
            if (def.defaultValue) {
                valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
            }
        });
    }
    return defaultValues;
}

function filterInPlace(array, test, context) {
    var target = 0;
    array.forEach(function (elem, i) {
        if (test.call(this, elem, i, array)) {
            array[target++] = elem;
        }
    }, context);
    array.length = target;
    return array;
}

var TYPENAME_FIELD = {
    kind: 'Field',
    name: {
        kind: 'Name',
        value: '__typename',
    },
};
function isEmpty$1(op, fragments) {
    return op.selectionSet.selections.every(function (selection) {
        return selection.kind === 'FragmentSpread' &&
            isEmpty$1(fragments[selection.name.value], fragments);
    });
}
function nullIfDocIsEmpty(doc) {
    return isEmpty$1(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc)))
        ? null
        : doc;
}
function getDirectiveMatcher(directives) {
    return function directiveMatcher(directive) {
        return directives.some(function (dir) {
            return (dir.name && dir.name === directive.name.value) ||
                (dir.test && dir.test(directive));
        });
    };
}
function removeDirectivesFromDocument(directives, doc) {
    var variablesInUse = Object.create(null);
    var variablesToRemove = [];
    var fragmentSpreadsInUse = Object.create(null);
    var fragmentSpreadsToRemove = [];
    var modifiedDoc = nullIfDocIsEmpty(visit(doc, {
        Variable: {
            enter: function (node, _key, parent) {
                if (parent.kind !== 'VariableDefinition') {
                    variablesInUse[node.name.value] = true;
                }
            },
        },
        Field: {
            enter: function (node) {
                if (directives && node.directives) {
                    var shouldRemoveField = directives.some(function (directive) { return directive.remove; });
                    if (shouldRemoveField &&
                        node.directives &&
                        node.directives.some(getDirectiveMatcher(directives))) {
                        if (node.arguments) {
                            node.arguments.forEach(function (arg) {
                                if (arg.value.kind === 'Variable') {
                                    variablesToRemove.push({
                                        name: arg.value.name.value,
                                    });
                                }
                            });
                        }
                        if (node.selectionSet) {
                            getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function (frag) {
                                fragmentSpreadsToRemove.push({
                                    name: frag.name.value,
                                });
                            });
                        }
                        return null;
                    }
                }
            },
        },
        FragmentSpread: {
            enter: function (node) {
                fragmentSpreadsInUse[node.name.value] = true;
            },
        },
        Directive: {
            enter: function (node) {
                if (getDirectiveMatcher(directives)(node)) {
                    return null;
                }
            },
        },
    }));
    if (modifiedDoc &&
        filterInPlace(variablesToRemove, function (v) { return !!v.name && !variablesInUse[v.name]; }).length) {
        modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);
    }
    if (modifiedDoc &&
        filterInPlace(fragmentSpreadsToRemove, function (fs) { return !!fs.name && !fragmentSpreadsInUse[fs.name]; })
            .length) {
        modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);
    }
    return modifiedDoc;
}
var addTypenameToDocument = Object.assign(function (doc) {
    return visit(doc, {
        SelectionSet: {
            enter: function (node, _key, parent) {
                if (parent &&
                    parent.kind === 'OperationDefinition') {
                    return;
                }
                var selections = node.selections;
                if (!selections) {
                    return;
                }
                var skip = selections.some(function (selection) {
                    return (isField(selection) &&
                        (selection.name.value === '__typename' ||
                            selection.name.value.lastIndexOf('__', 0) === 0));
                });
                if (skip) {
                    return;
                }
                var field = parent;
                if (isField(field) &&
                    field.directives &&
                    field.directives.some(function (d) { return d.name.value === 'export'; })) {
                    return;
                }
                return __assign(__assign({}, node), { selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false) });
            },
        },
    });
}, {
    added: function (field) {
        return field === TYPENAME_FIELD;
    },
});
var connectionRemoveConfig = {
    test: function (directive) {
        var willRemove = directive.name.value === 'connection';
        if (willRemove) {
            if (!directive.arguments ||
                !directive.arguments.some(function (arg) { return arg.name.value === 'key'; })) {
                __DEV__ && invariant.warn('Removing an @connection directive even though it does not have a key. ' +
                    'You may want to use the key parameter to specify a store key.');
            }
        }
        return willRemove;
    },
};
function removeConnectionDirectiveFromDocument(doc) {
    return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));
}
function getArgumentMatcher(config) {
    return function argumentMatcher(argument) {
        return config.some(function (aConfig) {
            return argument.value &&
                argument.value.kind === 'Variable' &&
                argument.value.name &&
                (aConfig.name === argument.value.name.value ||
                    (aConfig.test && aConfig.test(argument)));
        });
    };
}
function removeArgumentsFromDocument(config, doc) {
    var argMatcher = getArgumentMatcher(config);
    return nullIfDocIsEmpty(visit(doc, {
        OperationDefinition: {
            enter: function (node) {
                return __assign(__assign({}, node), { variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function (varDef) {
                        return !config.some(function (arg) { return arg.name === varDef.variable.name.value; });
                    }) : [] });
            },
        },
        Field: {
            enter: function (node) {
                var shouldRemoveField = config.some(function (argConfig) { return argConfig.remove; });
                if (shouldRemoveField) {
                    var argMatchCount_1 = 0;
                    if (node.arguments) {
                        node.arguments.forEach(function (arg) {
                            if (argMatcher(arg)) {
                                argMatchCount_1 += 1;
                            }
                        });
                    }
                    if (argMatchCount_1 === 1) {
                        return null;
                    }
                }
            },
        },
        Argument: {
            enter: function (node) {
                if (argMatcher(node)) {
                    return null;
                }
            },
        },
    }));
}
function removeFragmentSpreadFromDocument(config, doc) {
    function enter(node) {
        if (config.some(function (def) { return def.name === node.name.value; })) {
            return null;
        }
    }
    return nullIfDocIsEmpty(visit(doc, {
        FragmentSpread: { enter: enter },
        FragmentDefinition: { enter: enter },
    }));
}
function getAllFragmentSpreadsFromSelectionSet(selectionSet) {
    var allFragments = [];
    selectionSet.selections.forEach(function (selection) {
        if ((isField(selection) || isInlineFragment(selection)) &&
            selection.selectionSet) {
            getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function (frag) { return allFragments.push(frag); });
        }
        else if (selection.kind === 'FragmentSpread') {
            allFragments.push(selection);
        }
    });
    return allFragments;
}
function buildQueryFromSelectionSet(document) {
    var definition = getMainDefinition(document);
    var definitionOperation = definition.operation;
    if (definitionOperation === 'query') {
        return document;
    }
    var modifiedDoc = visit(document, {
        OperationDefinition: {
            enter: function (node) {
                return __assign(__assign({}, node), { operation: 'query' });
            },
        },
    });
    return modifiedDoc;
}
function removeClientSetsFromDocument(document) {
    checkDocument(document);
    var modifiedDoc = removeDirectivesFromDocument([
        {
            test: function (directive) { return directive.name.value === 'client'; },
            remove: true,
        },
    ], document);
    if (modifiedDoc) {
        modifiedDoc = visit(modifiedDoc, {
            FragmentDefinition: {
                enter: function (node) {
                    if (node.selectionSet) {
                        var isTypenameOnly = node.selectionSet.selections.every(function (selection) {
                            return isField(selection) && selection.name.value === '__typename';
                        });
                        if (isTypenameOnly) {
                            return null;
                        }
                    }
                },
            },
        });
    }
    return modifiedDoc;
}

var hasOwnProperty$6 = Object.prototype.hasOwnProperty;
function mergeDeep$1() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    return mergeDeepArray(sources);
}
function mergeDeepArray(sources) {
    var target = sources[0] || {};
    var count = sources.length;
    if (count > 1) {
        var merger = new DeepMerger();
        for (var i = 1; i < count; ++i) {
            target = merger.merge(target, sources[i]);
        }
    }
    return target;
}
var defaultReconciler = function (target, source, property) {
    return this.merge(target[property], source[property]);
};
var DeepMerger = (function () {
    function DeepMerger(reconciler) {
        if (reconciler === void 0) { reconciler = defaultReconciler; }
        this.reconciler = reconciler;
        this.isObject = isNonNullObject;
        this.pastCopies = new Set();
    }
    DeepMerger.prototype.merge = function (target, source) {
        var _this = this;
        var context = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            context[_i - 2] = arguments[_i];
        }
        if (isNonNullObject(source) && isNonNullObject(target)) {
            Object.keys(source).forEach(function (sourceKey) {
                if (hasOwnProperty$6.call(target, sourceKey)) {
                    var targetValue = target[sourceKey];
                    if (source[sourceKey] !== targetValue) {
                        var result = _this.reconciler.apply(_this, __spreadArray([target, source, sourceKey], context, false));
                        if (result !== targetValue) {
                            target = _this.shallowCopyForMerge(target);
                            target[sourceKey] = result;
                        }
                    }
                }
                else {
                    target = _this.shallowCopyForMerge(target);
                    target[sourceKey] = source[sourceKey];
                }
            });
            return target;
        }
        return source;
    };
    DeepMerger.prototype.shallowCopyForMerge = function (value) {
        if (isNonNullObject(value)) {
            if (!this.pastCopies.has(value)) {
                if (Array.isArray(value)) {
                    value = value.slice(0);
                }
                else {
                    value = __assign({ __proto__: Object.getPrototypeOf(value) }, value);
                }
                this.pastCopies.add(value);
            }
        }
        return value;
    };
    return DeepMerger;
}());

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

// === Symbol Support ===
var hasSymbols = function () {
  return typeof Symbol === 'function';
};

var hasSymbol = function (name) {
  return hasSymbols() && Boolean(Symbol[name]);
};

var getSymbol = function (name) {
  return hasSymbol(name) ? Symbol[name] : '@@' + name;
};

if (hasSymbols() && !hasSymbol('observable')) {
  Symbol.observable = Symbol('observable');
}

var SymbolIterator = getSymbol('iterator');
var SymbolObservable = getSymbol('observable');
var SymbolSpecies = getSymbol('species'); // === Abstract Operations ===

function getMethod(obj, key) {
  var value = obj[key];
  if (value == null) return undefined;
  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');
  return value;
}

function getSpecies(obj) {
  var ctor = obj.constructor;

  if (ctor !== undefined) {
    ctor = ctor[SymbolSpecies];

    if (ctor === null) {
      ctor = undefined;
    }
  }

  return ctor !== undefined ? ctor : Observable;
}

function isObservable(x) {
  return x instanceof Observable; // SPEC: Brand check
}

function hostReportError(e) {
  if (hostReportError.log) {
    hostReportError.log(e);
  } else {
    setTimeout(function () {
      throw e;
    });
  }
}

function enqueue(fn) {
  Promise.resolve().then(function () {
    try {
      fn();
    } catch (e) {
      hostReportError(e);
    }
  });
}

function cleanupSubscription(subscription) {
  var cleanup = subscription._cleanup;
  if (cleanup === undefined) return;
  subscription._cleanup = undefined;

  if (!cleanup) {
    return;
  }

  try {
    if (typeof cleanup === 'function') {
      cleanup();
    } else {
      var unsubscribe = getMethod(cleanup, 'unsubscribe');

      if (unsubscribe) {
        unsubscribe.call(cleanup);
      }
    }
  } catch (e) {
    hostReportError(e);
  }
}

function closeSubscription(subscription) {
  subscription._observer = undefined;
  subscription._queue = undefined;
  subscription._state = 'closed';
}

function flushSubscription(subscription) {
  var queue = subscription._queue;

  if (!queue) {
    return;
  }

  subscription._queue = undefined;
  subscription._state = 'ready';

  for (var i = 0; i < queue.length; ++i) {
    notifySubscription(subscription, queue[i].type, queue[i].value);
    if (subscription._state === 'closed') break;
  }
}

function notifySubscription(subscription, type, value) {
  subscription._state = 'running';
  var observer = subscription._observer;

  try {
    var m = getMethod(observer, type);

    switch (type) {
      case 'next':
        if (m) m.call(observer, value);
        break;

      case 'error':
        closeSubscription(subscription);
        if (m) m.call(observer, value);else throw value;
        break;

      case 'complete':
        closeSubscription(subscription);
        if (m) m.call(observer);
        break;
    }
  } catch (e) {
    hostReportError(e);
  }

  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';
}

function onNotify(subscription, type, value) {
  if (subscription._state === 'closed') return;

  if (subscription._state === 'buffering') {
    subscription._queue.push({
      type: type,
      value: value
    });

    return;
  }

  if (subscription._state !== 'ready') {
    subscription._state = 'buffering';
    subscription._queue = [{
      type: type,
      value: value
    }];
    enqueue(function () {
      return flushSubscription(subscription);
    });
    return;
  }

  notifySubscription(subscription, type, value);
}

var Subscription = /*#__PURE__*/function () {
  function Subscription(observer, subscriber) {
    // ASSERT: observer is an object
    // ASSERT: subscriber is callable
    this._cleanup = undefined;
    this._observer = observer;
    this._queue = undefined;
    this._state = 'initializing';
    var subscriptionObserver = new SubscriptionObserver(this);

    try {
      this._cleanup = subscriber.call(undefined, subscriptionObserver);
    } catch (e) {
      subscriptionObserver.error(e);
    }

    if (this._state === 'initializing') this._state = 'ready';
  }

  var _proto = Subscription.prototype;

  _proto.unsubscribe = function unsubscribe() {
    if (this._state !== 'closed') {
      closeSubscription(this);
      cleanupSubscription(this);
    }
  };

  _createClass(Subscription, [{
    key: "closed",
    get: function () {
      return this._state === 'closed';
    }
  }]);

  return Subscription;
}();

var SubscriptionObserver = /*#__PURE__*/function () {
  function SubscriptionObserver(subscription) {
    this._subscription = subscription;
  }

  var _proto2 = SubscriptionObserver.prototype;

  _proto2.next = function next(value) {
    onNotify(this._subscription, 'next', value);
  };

  _proto2.error = function error(value) {
    onNotify(this._subscription, 'error', value);
  };

  _proto2.complete = function complete() {
    onNotify(this._subscription, 'complete');
  };

  _createClass(SubscriptionObserver, [{
    key: "closed",
    get: function () {
      return this._subscription._state === 'closed';
    }
  }]);

  return SubscriptionObserver;
}();

var Observable = /*#__PURE__*/function () {
  function Observable(subscriber) {
    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');
    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');
    this._subscriber = subscriber;
  }

  var _proto3 = Observable.prototype;

  _proto3.subscribe = function subscribe(observer) {
    if (typeof observer !== 'object' || observer === null) {
      observer = {
        next: observer,
        error: arguments[1],
        complete: arguments[2]
      };
    }

    return new Subscription(observer, this._subscriber);
  };

  _proto3.forEach = function forEach(fn) {
    var _this = this;

    return new Promise(function (resolve, reject) {
      if (typeof fn !== 'function') {
        reject(new TypeError(fn + ' is not a function'));
        return;
      }

      function done() {
        subscription.unsubscribe();
        resolve();
      }

      var subscription = _this.subscribe({
        next: function (value) {
          try {
            fn(value, done);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  };

  _proto3.map = function map(fn) {
    var _this2 = this;

    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
    var C = getSpecies(this);
    return new C(function (observer) {
      return _this2.subscribe({
        next: function (value) {
          try {
            value = fn(value);
          } catch (e) {
            return observer.error(e);
          }

          observer.next(value);
        },
        error: function (e) {
          observer.error(e);
        },
        complete: function () {
          observer.complete();
        }
      });
    });
  };

  _proto3.filter = function filter(fn) {
    var _this3 = this;

    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
    var C = getSpecies(this);
    return new C(function (observer) {
      return _this3.subscribe({
        next: function (value) {
          try {
            if (!fn(value)) return;
          } catch (e) {
            return observer.error(e);
          }

          observer.next(value);
        },
        error: function (e) {
          observer.error(e);
        },
        complete: function () {
          observer.complete();
        }
      });
    });
  };

  _proto3.reduce = function reduce(fn) {
    var _this4 = this;

    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
    var C = getSpecies(this);
    var hasSeed = arguments.length > 1;
    var hasValue = false;
    var seed = arguments[1];
    var acc = seed;
    return new C(function (observer) {
      return _this4.subscribe({
        next: function (value) {
          var first = !hasValue;
          hasValue = true;

          if (!first || hasSeed) {
            try {
              acc = fn(acc, value);
            } catch (e) {
              return observer.error(e);
            }
          } else {
            acc = value;
          }
        },
        error: function (e) {
          observer.error(e);
        },
        complete: function () {
          if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));
          observer.next(acc);
          observer.complete();
        }
      });
    });
  };

  _proto3.concat = function concat() {
    var _this5 = this;

    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }

    var C = getSpecies(this);
    return new C(function (observer) {
      var subscription;
      var index = 0;

      function startNext(next) {
        subscription = next.subscribe({
          next: function (v) {
            observer.next(v);
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            if (index === sources.length) {
              subscription = undefined;
              observer.complete();
            } else {
              startNext(C.from(sources[index++]));
            }
          }
        });
      }

      startNext(_this5);
      return function () {
        if (subscription) {
          subscription.unsubscribe();
          subscription = undefined;
        }
      };
    });
  };

  _proto3.flatMap = function flatMap(fn) {
    var _this6 = this;

    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
    var C = getSpecies(this);
    return new C(function (observer) {
      var subscriptions = [];

      var outer = _this6.subscribe({
        next: function (value) {
          if (fn) {
            try {
              value = fn(value);
            } catch (e) {
              return observer.error(e);
            }
          }

          var inner = C.from(value).subscribe({
            next: function (value) {
              observer.next(value);
            },
            error: function (e) {
              observer.error(e);
            },
            complete: function () {
              var i = subscriptions.indexOf(inner);
              if (i >= 0) subscriptions.splice(i, 1);
              completeIfDone();
            }
          });
          subscriptions.push(inner);
        },
        error: function (e) {
          observer.error(e);
        },
        complete: function () {
          completeIfDone();
        }
      });

      function completeIfDone() {
        if (outer.closed && subscriptions.length === 0) observer.complete();
      }

      return function () {
        subscriptions.forEach(function (s) {
          return s.unsubscribe();
        });
        outer.unsubscribe();
      };
    });
  };

  _proto3[SymbolObservable] = function () {
    return this;
  };

  Observable.from = function from(x) {
    var C = typeof this === 'function' ? this : Observable;
    if (x == null) throw new TypeError(x + ' is not an object');
    var method = getMethod(x, SymbolObservable);

    if (method) {
      var observable = method.call(x);
      if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');
      if (isObservable(observable) && observable.constructor === C) return observable;
      return new C(function (observer) {
        return observable.subscribe(observer);
      });
    }

    if (hasSymbol('iterator')) {
      method = getMethod(x, SymbolIterator);

      if (method) {
        return new C(function (observer) {
          enqueue(function () {
            if (observer.closed) return;

            for (var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done;) {
              var item = _step.value;
              observer.next(item);
              if (observer.closed) return;
            }

            observer.complete();
          });
        });
      }
    }

    if (Array.isArray(x)) {
      return new C(function (observer) {
        enqueue(function () {
          if (observer.closed) return;

          for (var i = 0; i < x.length; ++i) {
            observer.next(x[i]);
            if (observer.closed) return;
          }

          observer.complete();
        });
      });
    }

    throw new TypeError(x + ' is not observable');
  };

  Observable.of = function of() {
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }

    var C = typeof this === 'function' ? this : Observable;
    return new C(function (observer) {
      enqueue(function () {
        if (observer.closed) return;

        for (var i = 0; i < items.length; ++i) {
          observer.next(items[i]);
          if (observer.closed) return;
        }

        observer.complete();
      });
    });
  };

  _createClass(Observable, null, [{
    key: SymbolSpecies,
    get: function () {
      return this;
    }
  }]);

  return Observable;
}();

if (hasSymbols()) {
  Object.defineProperty(Observable, Symbol('extensions'), {
    value: {
      symbol: SymbolObservable,
      hostReportError: hostReportError
    },
    configurable: true
  });
}

function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {

			if (typeof Symbol.for === 'function') {
				// This just needs to be something that won't trample other user's Symbol.for use
				// It also will guide people to the source of their issues, if this is problematic.
				// META: It's a resource locator!
				result = Symbol.for('https://github.com/benlesh/symbol-observable');
			} else {
				// Symbol.for didn't exist! The best we can do at this point is a totally 
				// unique symbol. Note that the string argument here is a descriptor, not
				// an identifier. This symbol is unique.
				result = Symbol('https://github.com/benlesh/symbol-observable');
			}
			try {
				Symbol.observable = result;
			} catch (err) {
				// Do nothing. In some environments, users have frozen `Symbol` for security reasons,
				// if it is frozen assigning to it will throw. In this case, we don't care, because
				// they will need to use the returned value from the ponyfill.
			}
		}
	} else {
		result = '@@observable';
	}

	return result;
}

var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window$1 !== 'undefined') {
  root = window$1;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

symbolObservablePonyfill(root);

var prototype = Observable.prototype;
var fakeObsSymbol = '@@observable';
if (!prototype[fakeObsSymbol]) {
    prototype[fakeObsSymbol] = function () { return this; };
}

var toString$1 = Object.prototype.toString;
function cloneDeep(value) {
    return cloneDeepHelper(value);
}
function cloneDeepHelper(val, seen) {
    switch (toString$1.call(val)) {
        case "[object Array]": {
            seen = seen || new Map;
            if (seen.has(val))
                return seen.get(val);
            var copy_1 = val.slice(0);
            seen.set(val, copy_1);
            copy_1.forEach(function (child, i) {
                copy_1[i] = cloneDeepHelper(child, seen);
            });
            return copy_1;
        }
        case "[object Object]": {
            seen = seen || new Map;
            if (seen.has(val))
                return seen.get(val);
            var copy_2 = Object.create(Object.getPrototypeOf(val));
            seen.set(val, copy_2);
            Object.keys(val).forEach(function (key) {
                copy_2[key] = cloneDeepHelper(val[key], seen);
            });
            return copy_2;
        }
        default:
            return val;
    }
}

function deepFreeze(value) {
    var workSet = new Set([value]);
    workSet.forEach(function (obj) {
        if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
            Object.getOwnPropertyNames(obj).forEach(function (name) {
                if (isNonNullObject(obj[name]))
                    workSet.add(obj[name]);
            });
        }
    });
    return value;
}
function shallowFreeze(obj) {
    if (__DEV__ && !Object.isFrozen(obj)) {
        try {
            Object.freeze(obj);
        }
        catch (e) {
            if (e instanceof TypeError)
                return null;
            throw e;
        }
    }
    return obj;
}
function maybeDeepFreeze(obj) {
    if (__DEV__) {
        deepFreeze(obj);
    }
    return obj;
}

function iterateObserversSafely(observers, method, argument) {
    var observersWithMethod = [];
    observers.forEach(function (obs) { return obs[method] && observersWithMethod.push(obs); });
    observersWithMethod.forEach(function (obs) { return obs[method](argument); });
}

function asyncMap(observable, mapFn, catchFn) {
    return new Observable(function (observer) {
        var next = observer.next, error = observer.error, complete = observer.complete;
        var activeCallbackCount = 0;
        var completed = false;
        var promiseQueue = {
            then: function (callback) {
                return new Promise(function (resolve) { return resolve(callback()); });
            },
        };
        function makeCallback(examiner, delegate) {
            if (examiner) {
                return function (arg) {
                    ++activeCallbackCount;
                    var both = function () { return examiner(arg); };
                    promiseQueue = promiseQueue.then(both, both).then(function (result) {
                        --activeCallbackCount;
                        next && next.call(observer, result);
                        if (completed) {
                            handler.complete();
                        }
                    }, function (error) {
                        --activeCallbackCount;
                        throw error;
                    }).catch(function (caught) {
                        error && error.call(observer, caught);
                    });
                };
            }
            else {
                return function (arg) { return delegate && delegate.call(observer, arg); };
            }
        }
        var handler = {
            next: makeCallback(mapFn, next),
            error: makeCallback(catchFn, error),
            complete: function () {
                completed = true;
                if (!activeCallbackCount) {
                    complete && complete.call(observer);
                }
            },
        };
        var sub = observable.subscribe(handler);
        return function () { return sub.unsubscribe(); };
    });
}

var canUseWeakMap = typeof WeakMap === 'function' &&
    maybe$1(function () { return navigator.product; }) !== 'ReactNative';
var canUseWeakSet = typeof WeakSet === 'function';
var canUseSymbol = typeof Symbol === 'function' &&
    typeof Symbol.for === 'function';
var canUseDOM = typeof maybe$1(function () { return window$1.document.createElement; }) === "function";
var usingJSDOM = maybe$1(function () { return navigator.userAgent.indexOf("jsdom") >= 0; }) || false;
var canUseLayoutEffect = canUseDOM && !usingJSDOM;

function fixObservableSubclass(subclass) {
    function set(key) {
        Object.defineProperty(subclass, key, { value: Observable });
    }
    if (canUseSymbol && Symbol.species) {
        set(Symbol.species);
    }
    set("@@species");
    return subclass;
}

function isPromiseLike(value) {
    return value && typeof value.then === "function";
}
var Concast = (function (_super) {
    __extends(Concast, _super);
    function Concast(sources) {
        var _this = _super.call(this, function (observer) {
            _this.addObserver(observer);
            return function () { return _this.removeObserver(observer); };
        }) || this;
        _this.observers = new Set();
        _this.addCount = 0;
        _this.promise = new Promise(function (resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
        });
        _this.handlers = {
            next: function (result) {
                if (_this.sub !== null) {
                    _this.latest = ["next", result];
                    iterateObserversSafely(_this.observers, "next", result);
                }
            },
            error: function (error) {
                var sub = _this.sub;
                if (sub !== null) {
                    if (sub)
                        setTimeout(function () { return sub.unsubscribe(); });
                    _this.sub = null;
                    _this.latest = ["error", error];
                    _this.reject(error);
                    iterateObserversSafely(_this.observers, "error", error);
                }
            },
            complete: function () {
                var sub = _this.sub;
                if (sub !== null) {
                    var value = _this.sources.shift();
                    if (!value) {
                        if (sub)
                            setTimeout(function () { return sub.unsubscribe(); });
                        _this.sub = null;
                        if (_this.latest &&
                            _this.latest[0] === "next") {
                            _this.resolve(_this.latest[1]);
                        }
                        else {
                            _this.resolve();
                        }
                        iterateObserversSafely(_this.observers, "complete");
                    }
                    else if (isPromiseLike(value)) {
                        value.then(function (obs) { return _this.sub = obs.subscribe(_this.handlers); });
                    }
                    else {
                        _this.sub = value.subscribe(_this.handlers);
                    }
                }
            },
        };
        _this.cancel = function (reason) {
            _this.reject(reason);
            _this.sources = [];
            _this.handlers.complete();
        };
        _this.promise.catch(function (_) { });
        if (typeof sources === "function") {
            sources = [new Observable(sources)];
        }
        if (isPromiseLike(sources)) {
            sources.then(function (iterable) { return _this.start(iterable); }, _this.handlers.error);
        }
        else {
            _this.start(sources);
        }
        return _this;
    }
    Concast.prototype.start = function (sources) {
        if (this.sub !== void 0)
            return;
        this.sources = Array.from(sources);
        this.handlers.complete();
    };
    Concast.prototype.deliverLastMessage = function (observer) {
        if (this.latest) {
            var nextOrError = this.latest[0];
            var method = observer[nextOrError];
            if (method) {
                method.call(observer, this.latest[1]);
            }
            if (this.sub === null &&
                nextOrError === "next" &&
                observer.complete) {
                observer.complete();
            }
        }
    };
    Concast.prototype.addObserver = function (observer) {
        if (!this.observers.has(observer)) {
            this.deliverLastMessage(observer);
            this.observers.add(observer);
            ++this.addCount;
        }
    };
    Concast.prototype.removeObserver = function (observer, quietly) {
        if (this.observers.delete(observer) &&
            --this.addCount < 1 &&
            !quietly) {
            this.handlers.complete();
        }
    };
    Concast.prototype.cleanup = function (callback) {
        var _this = this;
        var called = false;
        var once = function () {
            if (!called) {
                called = true;
                _this.observers.delete(observer);
                callback();
            }
        };
        var observer = {
            next: once,
            error: once,
            complete: once,
        };
        var count = this.addCount;
        this.addObserver(observer);
        this.addCount = count;
    };
    return Concast;
}(Observable));
fixObservableSubclass(Concast);

function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
}

function graphQLResultHasError(result) {
    return (result.errors && result.errors.length > 0) || false;
}

function compact() {
    var objects = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
    }
    var result = Object.create(null);
    objects.forEach(function (obj) {
        if (!obj)
            return;
        Object.keys(obj).forEach(function (key) {
            var value = obj[key];
            if (value !== void 0) {
                result[key] = value;
            }
        });
    });
    return result;
}

var prefixCounts = new Map();
function makeUniqueId(prefix) {
    var count = prefixCounts.get(prefix) || 1;
    prefixCounts.set(prefix, count + 1);
    return "".concat(prefix, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
}

function stringifyForDisplay(value) {
    var undefId = makeUniqueId("stringifyForDisplay");
    return JSON.stringify(value, function (key, value) {
        return value === void 0 ? undefId : value;
    }).split(JSON.stringify(undefId)).join("<undefined>");
}

function mergeOptions(defaults, options) {
    return compact(defaults, options, options.variables && {
        variables: __assign(__assign({}, (defaults && defaults.variables)), options.variables),
    });
}

function fromError(errorValue) {
    return new Observable(function (observer) {
        observer.error(errorValue);
    });
}

var throwServerError = function (response, result, message) {
    var error = new Error(message);
    error.name = 'ServerError';
    error.response = response;
    error.statusCode = response.status;
    error.result = result;
    throw error;
};

function validateOperation(operation) {
    var OPERATION_FIELDS = [
        'query',
        'operationName',
        'variables',
        'extensions',
        'context',
    ];
    for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {
        var key = _a[_i];
        if (OPERATION_FIELDS.indexOf(key) < 0) {
            throw __DEV__ ? new InvariantError("illegal argument: ".concat(key)) : new InvariantError(24);
        }
    }
    return operation;
}

function createOperation(starting, operation) {
    var context = __assign({}, starting);
    var setContext = function (next) {
        if (typeof next === 'function') {
            context = __assign(__assign({}, context), next(context));
        }
        else {
            context = __assign(__assign({}, context), next);
        }
    };
    var getContext = function () { return (__assign({}, context)); };
    Object.defineProperty(operation, 'setContext', {
        enumerable: false,
        value: setContext,
    });
    Object.defineProperty(operation, 'getContext', {
        enumerable: false,
        value: getContext,
    });
    return operation;
}

function transformOperation(operation) {
    var transformedOperation = {
        variables: operation.variables || {},
        extensions: operation.extensions || {},
        operationName: operation.operationName,
        query: operation.query,
    };
    if (!transformedOperation.operationName) {
        transformedOperation.operationName =
            typeof transformedOperation.query !== 'string'
                ? getOperationName(transformedOperation.query) || undefined
                : '';
    }
    return transformedOperation;
}

function passthrough$1(op, forward) {
    return (forward ? forward(op) : Observable.of());
}
function toLink(handler) {
    return typeof handler === 'function' ? new ApolloLink(handler) : handler;
}
function isTerminating(link) {
    return link.request.length <= 1;
}
var LinkError = (function (_super) {
    __extends(LinkError, _super);
    function LinkError(message, link) {
        var _this = _super.call(this, message) || this;
        _this.link = link;
        return _this;
    }
    return LinkError;
}(Error));
var ApolloLink = (function () {
    function ApolloLink(request) {
        if (request)
            this.request = request;
    }
    ApolloLink.empty = function () {
        return new ApolloLink(function () { return Observable.of(); });
    };
    ApolloLink.from = function (links) {
        if (links.length === 0)
            return ApolloLink.empty();
        return links.map(toLink).reduce(function (x, y) { return x.concat(y); });
    };
    ApolloLink.split = function (test, left, right) {
        var leftLink = toLink(left);
        var rightLink = toLink(right || new ApolloLink(passthrough$1));
        if (isTerminating(leftLink) && isTerminating(rightLink)) {
            return new ApolloLink(function (operation) {
                return test(operation)
                    ? leftLink.request(operation) || Observable.of()
                    : rightLink.request(operation) || Observable.of();
            });
        }
        else {
            return new ApolloLink(function (operation, forward) {
                return test(operation)
                    ? leftLink.request(operation, forward) || Observable.of()
                    : rightLink.request(operation, forward) || Observable.of();
            });
        }
    };
    ApolloLink.execute = function (link, operation) {
        return (link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of());
    };
    ApolloLink.concat = function (first, second) {
        var firstLink = toLink(first);
        if (isTerminating(firstLink)) {
            __DEV__ && invariant.warn(new LinkError("You are calling concat on a terminating link, which will have no effect", firstLink));
            return firstLink;
        }
        var nextLink = toLink(second);
        if (isTerminating(nextLink)) {
            return new ApolloLink(function (operation) {
                return firstLink.request(operation, function (op) { return nextLink.request(op) || Observable.of(); }) || Observable.of();
            });
        }
        else {
            return new ApolloLink(function (operation, forward) {
                return (firstLink.request(operation, function (op) {
                    return nextLink.request(op, forward) || Observable.of();
                }) || Observable.of());
            });
        }
    };
    ApolloLink.prototype.split = function (test, left, right) {
        return this.concat(ApolloLink.split(test, left, right || new ApolloLink(passthrough$1)));
    };
    ApolloLink.prototype.concat = function (next) {
        return ApolloLink.concat(this, next);
    };
    ApolloLink.prototype.request = function (operation, forward) {
        throw __DEV__ ? new InvariantError('request is not implemented') : new InvariantError(19);
    };
    ApolloLink.prototype.onError = function (error, observer) {
        if (observer && observer.error) {
            observer.error(error);
            return false;
        }
        throw error;
    };
    ApolloLink.prototype.setOnError = function (fn) {
        this.onError = fn;
        return this;
    };
    return ApolloLink;
}());

var execute = ApolloLink.execute;

var version = '3.6.6';

var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
function parseAndCheckHttpResponse(operations) {
    return function (response) { return response
        .text()
        .then(function (bodyText) {
        try {
            return JSON.parse(bodyText);
        }
        catch (err) {
            var parseError = err;
            parseError.name = 'ServerParseError';
            parseError.response = response;
            parseError.statusCode = response.status;
            parseError.bodyText = bodyText;
            throw parseError;
        }
    })
        .then(function (result) {
        if (response.status >= 300) {
            throwServerError(response, result, "Response not successful: Received status code ".concat(response.status));
        }
        if (!Array.isArray(result) &&
            !hasOwnProperty$5.call(result, 'data') &&
            !hasOwnProperty$5.call(result, 'errors')) {
            throwServerError(response, result, "Server response was missing for query '".concat(Array.isArray(operations)
                ? operations.map(function (op) { return op.operationName; })
                : operations.operationName, "'."));
        }
        return result;
    }); };
}

var serializeFetchParameter = function (p, label) {
    var serialized;
    try {
        serialized = JSON.stringify(p);
    }
    catch (e) {
        var parseError = __DEV__ ? new InvariantError("Network request failed. ".concat(label, " is not serializable: ").concat(e.message)) : new InvariantError(21);
        parseError.parseError = e;
        throw parseError;
    }
    return serialized;
};

var defaultHttpOptions = {
    includeQuery: true,
    includeExtensions: false,
};
var defaultHeaders = {
    accept: '*/*',
    'content-type': 'application/json',
};
var defaultOptions = {
    method: 'POST',
};
var fallbackHttpConfig = {
    http: defaultHttpOptions,
    headers: defaultHeaders,
    options: defaultOptions,
};
var defaultPrinter = function (ast, printer) { return printer(ast); };
function selectHttpOptionsAndBodyInternal(operation, printer) {
    var configs = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        configs[_i - 2] = arguments[_i];
    }
    var options = {};
    var http = {};
    configs.forEach(function (config) {
        options = __assign(__assign(__assign({}, options), config.options), { headers: __assign(__assign({}, options.headers), headersToLowerCase(config.headers)) });
        if (config.credentials) {
            options.credentials = config.credentials;
        }
        http = __assign(__assign({}, http), config.http);
    });
    var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
    var body = { operationName: operationName, variables: variables };
    if (http.includeExtensions)
        body.extensions = extensions;
    if (http.includeQuery)
        body.query = printer(query, print);
    return {
        options: options,
        body: body,
    };
}
function headersToLowerCase(headers) {
    if (headers) {
        var normalized_1 = Object.create(null);
        Object.keys(Object(headers)).forEach(function (name) {
            normalized_1[name.toLowerCase()] = headers[name];
        });
        return normalized_1;
    }
    return headers;
}

var checkFetcher = function (fetcher) {
    if (!fetcher && typeof fetch === 'undefined') {
        throw __DEV__ ? new InvariantError("\n\"fetch\" has not been found globally and no fetcher has been configured. To fix this, install a fetch package (like https://www.npmjs.com/package/cross-fetch), instantiate the fetcher, and pass it into your HttpLink constructor. For example:\n\nimport fetch from 'cross-fetch';\nimport { ApolloClient, HttpLink } from '@apollo/client';\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: '/graphql', fetch })\n});\n    ") : new InvariantError(20);
    }
};

var createSignalIfSupported = function () {
    if (typeof AbortController === 'undefined')
        return { controller: false, signal: false };
    var controller = new AbortController();
    var signal = controller.signal;
    return { controller: controller, signal: signal };
};

var selectURI = function (operation, fallbackURI) {
    var context = operation.getContext();
    var contextURI = context.uri;
    if (contextURI) {
        return contextURI;
    }
    else if (typeof fallbackURI === 'function') {
        return fallbackURI(operation);
    }
    else {
        return fallbackURI || '/graphql';
    }
};

function rewriteURIForGET(chosenURI, body) {
    var queryParams = [];
    var addQueryParam = function (key, value) {
        queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
    };
    if ('query' in body) {
        addQueryParam('query', body.query);
    }
    if (body.operationName) {
        addQueryParam('operationName', body.operationName);
    }
    if (body.variables) {
        var serializedVariables = void 0;
        try {
            serializedVariables = serializeFetchParameter(body.variables, 'Variables map');
        }
        catch (parseError) {
            return { parseError: parseError };
        }
        addQueryParam('variables', serializedVariables);
    }
    if (body.extensions) {
        var serializedExtensions = void 0;
        try {
            serializedExtensions = serializeFetchParameter(body.extensions, 'Extensions map');
        }
        catch (parseError) {
            return { parseError: parseError };
        }
        addQueryParam('extensions', serializedExtensions);
    }
    var fragment = '', preFragment = chosenURI;
    var fragmentStart = chosenURI.indexOf('#');
    if (fragmentStart !== -1) {
        fragment = chosenURI.substr(fragmentStart);
        preFragment = chosenURI.substr(0, fragmentStart);
    }
    var queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';
    var newURI = preFragment + queryParamsPrefix + queryParams.join('&') + fragment;
    return { newURI: newURI };
}

var backupFetch = maybe$1(function () { return fetch; });
var createHttpLink = function (linkOptions) {
    if (linkOptions === void 0) { linkOptions = {}; }
    var _a = linkOptions.uri, uri = _a === void 0 ? '/graphql' : _a, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = __rest(linkOptions, ["uri", "fetch", "print", "includeExtensions", "useGETForQueries", "includeUnusedVariables"]);
    if (__DEV__) {
        checkFetcher(preferredFetch || backupFetch);
    }
    var linkConfig = {
        http: { includeExtensions: includeExtensions },
        options: requestOptions.fetchOptions,
        credentials: requestOptions.credentials,
        headers: requestOptions.headers,
    };
    return new ApolloLink(function (operation) {
        var chosenURI = selectURI(operation, uri);
        var context = operation.getContext();
        var clientAwarenessHeaders = {};
        if (context.clientAwareness) {
            var _a = context.clientAwareness, name_1 = _a.name, version = _a.version;
            if (name_1) {
                clientAwarenessHeaders['apollographql-client-name'] = name_1;
            }
            if (version) {
                clientAwarenessHeaders['apollographql-client-version'] = version;
            }
        }
        var contextHeaders = __assign(__assign({}, clientAwarenessHeaders), context.headers);
        var contextConfig = {
            http: context.http,
            options: context.fetchOptions,
            credentials: context.credentials,
            headers: contextHeaders,
        };
        var _b = selectHttpOptionsAndBodyInternal(operation, print, fallbackHttpConfig, linkConfig, contextConfig), options = _b.options, body = _b.body;
        if (body.variables && !includeUnusedVariables) {
            var unusedNames_1 = new Set(Object.keys(body.variables));
            visit(operation.query, {
                Variable: function (node, _key, parent) {
                    if (parent && parent.kind !== 'VariableDefinition') {
                        unusedNames_1.delete(node.name.value);
                    }
                },
            });
            if (unusedNames_1.size) {
                body.variables = __assign({}, body.variables);
                unusedNames_1.forEach(function (name) {
                    delete body.variables[name];
                });
            }
        }
        var controller;
        if (!options.signal) {
            var _c = createSignalIfSupported(), _controller = _c.controller, signal = _c.signal;
            controller = _controller;
            if (controller)
                options.signal = signal;
        }
        var definitionIsMutation = function (d) {
            return d.kind === 'OperationDefinition' && d.operation === 'mutation';
        };
        if (useGETForQueries &&
            !operation.query.definitions.some(definitionIsMutation)) {
            options.method = 'GET';
        }
        if (options.method === 'GET') {
            var _d = rewriteURIForGET(chosenURI, body), newURI = _d.newURI, parseError = _d.parseError;
            if (parseError) {
                return fromError(parseError);
            }
            chosenURI = newURI;
        }
        else {
            try {
                options.body = serializeFetchParameter(body, 'Payload');
            }
            catch (parseError) {
                return fromError(parseError);
            }
        }
        return new Observable(function (observer) {
            var currentFetch = preferredFetch || maybe$1(function () { return fetch; }) || backupFetch;
            currentFetch(chosenURI, options)
                .then(function (response) {
                operation.setContext({ response: response });
                return response;
            })
                .then(parseAndCheckHttpResponse(operation))
                .then(function (result) {
                observer.next(result);
                observer.complete();
                return result;
            })
                .catch(function (err) {
                if (err.name === 'AbortError')
                    return;
                if (err.result && err.result.errors && err.result.data) {
                    observer.next(err.result);
                }
                observer.error(err);
            });
            return function () {
                if (controller)
                    controller.abort();
            };
        });
    });
};

var HttpLink = (function (_super) {
    __extends(HttpLink, _super);
    function HttpLink(options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, createHttpLink(options).request) || this;
        _this.options = options;
        return _this;
    }
    return HttpLink;
}(ApolloLink));

var _a$3 = Object.prototype, toString = _a$3.toString, hasOwnProperty$4 = _a$3.hasOwnProperty;
var fnToStr = Function.prototype.toString;
var previousComparisons = new Map();
/**
 * Performs a deep equality check on two JavaScript values, tolerating cycles.
 */
function equal(a, b) {
    try {
        return check(a, b);
    }
    finally {
        previousComparisons.clear();
    }
}
function check(a, b) {
    // If the two values are strictly equal, our job is easy.
    if (a === b) {
        return true;
    }
    // Object.prototype.toString returns a representation of the runtime type of
    // the given value that is considerably more precise than typeof.
    var aTag = toString.call(a);
    var bTag = toString.call(b);
    // If the runtime types of a and b are different, they could maybe be equal
    // under some interpretation of equality, but for simplicity and performance
    // we just return false instead.
    if (aTag !== bTag) {
        return false;
    }
    switch (aTag) {
        case '[object Array]':
            // Arrays are a lot like other objects, but we can cheaply compare their
            // lengths as a short-cut before comparing their elements.
            if (a.length !== b.length)
                return false;
        // Fall through to object case...
        case '[object Object]': {
            if (previouslyCompared(a, b))
                return true;
            var aKeys = definedKeys(a);
            var bKeys = definedKeys(b);
            // If `a` and `b` have a different number of enumerable keys, they
            // must be different.
            var keyCount = aKeys.length;
            if (keyCount !== bKeys.length)
                return false;
            // Now make sure they have the same keys.
            for (var k = 0; k < keyCount; ++k) {
                if (!hasOwnProperty$4.call(b, aKeys[k])) {
                    return false;
                }
            }
            // Finally, check deep equality of all child properties.
            for (var k = 0; k < keyCount; ++k) {
                var key = aKeys[k];
                if (!check(a[key], b[key])) {
                    return false;
                }
            }
            return true;
        }
        case '[object Error]':
            return a.name === b.name && a.message === b.message;
        case '[object Number]':
            // Handle NaN, which is !== itself.
            if (a !== a)
                return b !== b;
        // Fall through to shared +a === +b case...
        case '[object Boolean]':
        case '[object Date]':
            return +a === +b;
        case '[object RegExp]':
        case '[object String]':
            return a == "" + b;
        case '[object Map]':
        case '[object Set]': {
            if (a.size !== b.size)
                return false;
            if (previouslyCompared(a, b))
                return true;
            var aIterator = a.entries();
            var isMap = aTag === '[object Map]';
            while (true) {
                var info = aIterator.next();
                if (info.done)
                    break;
                // If a instanceof Set, aValue === aKey.
                var _a = info.value, aKey = _a[0], aValue = _a[1];
                // So this works the same way for both Set and Map.
                if (!b.has(aKey)) {
                    return false;
                }
                // However, we care about deep equality of values only when dealing
                // with Map structures.
                if (isMap && !check(aValue, b.get(aKey))) {
                    return false;
                }
            }
            return true;
        }
        case '[object Uint16Array]':
        case '[object Uint8Array]': // Buffer, in Node.js.
        case '[object Uint32Array]':
        case '[object Int32Array]':
        case '[object Int8Array]':
        case '[object Int16Array]':
        case '[object ArrayBuffer]':
            // DataView doesn't need these conversions, but the equality check is
            // otherwise the same.
            a = new Uint8Array(a);
            b = new Uint8Array(b);
        // Fall through...
        case '[object DataView]': {
            var len = a.byteLength;
            if (len === b.byteLength) {
                while (len-- && a[len] === b[len]) {
                    // Keep looping as long as the bytes are equal.
                }
            }
            return len === -1;
        }
        case '[object AsyncFunction]':
        case '[object GeneratorFunction]':
        case '[object AsyncGeneratorFunction]':
        case '[object Function]': {
            var aCode = fnToStr.call(a);
            if (aCode !== fnToStr.call(b)) {
                return false;
            }
            // We consider non-native functions equal if they have the same code
            // (native functions require === because their code is censored).
            // Note that this behavior is not entirely sound, since !== function
            // objects with the same code can behave differently depending on
            // their closure scope. However, any function can behave differently
            // depending on the values of its input arguments (including this)
            // and its calling context (including its closure scope), even
            // though the function object is === to itself; and it is entirely
            // possible for functions that are not === to behave exactly the
            // same under all conceivable circumstances. Because none of these
            // factors are statically decidable in JavaScript, JS function
            // equality is not well-defined. This ambiguity allows us to
            // consider the best possible heuristic among various imperfect
            // options, and equating non-native functions that have the same
            // code has enormous practical benefits, such as when comparing
            // functions that are repeatedly passed as fresh function
            // expressions within objects that are otherwise deeply equal. Since
            // any function created from the same syntactic expression (in the
            // same code location) will always stringify to the same code
            // according to fnToStr.call, we can reasonably expect these
            // repeatedly passed function expressions to have the same code, and
            // thus behave "the same" (with all the caveats mentioned above),
            // even though the runtime function objects are !== to one another.
            return !endsWith(aCode, nativeCodeSuffix);
        }
    }
    // Otherwise the values are not equal.
    return false;
}
function definedKeys(obj) {
    // Remember that the second argument to Array.prototype.filter will be
    // used as `this` within the callback function.
    return Object.keys(obj).filter(isDefinedKey, obj);
}
function isDefinedKey(key) {
    return this[key] !== void 0;
}
var nativeCodeSuffix = "{ [native code] }";
function endsWith(full, suffix) {
    var fromIndex = full.length - suffix.length;
    return fromIndex >= 0 &&
        full.indexOf(suffix, fromIndex) === fromIndex;
}
function previouslyCompared(a, b) {
    // Though cyclic references can make an object graph appear infinite from the
    // perspective of a depth-first traversal, the graph still contains a finite
    // number of distinct object references. We use the previousComparisons cache
    // to avoid comparing the same pair of object references more than once, which
    // guarantees termination (even if we end up comparing every object in one
    // graph to every object in the other graph, which is extremely unlikely),
    // while still allowing weird isomorphic structures (like rings with different
    // lengths) a chance to pass the equality test.
    var bSet = previousComparisons.get(a);
    if (bSet) {
        // Return true here because we can be sure false will be returned somewhere
        // else if the objects are not equivalent.
        if (bSet.has(b))
            return true;
    }
    else {
        previousComparisons.set(a, bSet = new Set);
    }
    bSet.add(b);
    return false;
}

// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds
// object keys weakly, yet can also hold non-object keys, unlike the
// native `WeakMap`.
// If no makeData function is supplied, the looked-up data will be an empty,
// null-prototype Object.
var defaultMakeData = function () { return Object.create(null); };
// Useful for processing arguments objects as well as arrays.
var _a$2 = Array.prototype, forEach$2 = _a$2.forEach, slice = _a$2.slice;
var Trie = /** @class */ (function () {
    function Trie(weakness, makeData) {
        if (weakness === void 0) { weakness = true; }
        if (makeData === void 0) { makeData = defaultMakeData; }
        this.weakness = weakness;
        this.makeData = makeData;
    }
    Trie.prototype.lookup = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i] = arguments[_i];
        }
        return this.lookupArray(array);
    };
    Trie.prototype.lookupArray = function (array) {
        var node = this;
        forEach$2.call(array, function (key) { return node = node.getChildTrie(key); });
        return node.data || (node.data = this.makeData(slice.call(array)));
    };
    Trie.prototype.getChildTrie = function (key) {
        var map = this.weakness && isObjRef(key)
            ? this.weak || (this.weak = new WeakMap())
            : this.strong || (this.strong = new Map());
        var child = map.get(key);
        if (!child)
            map.set(key, child = new Trie(this.weakness, this.makeData));
        return child;
    };
    return Trie;
}());
function isObjRef(value) {
    switch (typeof value) {
        case "object":
            if (value === null)
                break;
        // Fall through to return true...
        case "function":
            return true;
    }
    return false;
}

// This currentContext variable will only be used if the makeSlotClass
// function is called, which happens only if this is the first copy of the
// @wry/context package to be imported.
var currentContext = null;
// This unique internal object is used to denote the absence of a value
// for a given Slot, and is never exposed to outside code.
var MISSING_VALUE = {};
var idCounter = 1;
// Although we can't do anything about the cost of duplicated code from
// accidentally bundling multiple copies of the @wry/context package, we can
// avoid creating the Slot class more than once using makeSlotClass.
var makeSlotClass = function () { return /** @class */ (function () {
    function Slot() {
        // If you have a Slot object, you can find out its slot.id, but you cannot
        // guess the slot.id of a Slot you don't have access to, thanks to the
        // randomized suffix.
        this.id = [
            "slot",
            idCounter++,
            Date.now(),
            Math.random().toString(36).slice(2),
        ].join(":");
    }
    Slot.prototype.hasValue = function () {
        for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {
            // We use the Slot object iself as a key to its value, which means the
            // value cannot be obtained without a reference to the Slot object.
            if (this.id in context_1.slots) {
                var value = context_1.slots[this.id];
                if (value === MISSING_VALUE)
                    break;
                if (context_1 !== currentContext) {
                    // Cache the value in currentContext.slots so the next lookup will
                    // be faster. This caching is safe because the tree of contexts and
                    // the values of the slots are logically immutable.
                    currentContext.slots[this.id] = value;
                }
                return true;
            }
        }
        if (currentContext) {
            // If a value was not found for this Slot, it's never going to be found
            // no matter how many times we look it up, so we might as well cache
            // the absence of the value, too.
            currentContext.slots[this.id] = MISSING_VALUE;
        }
        return false;
    };
    Slot.prototype.getValue = function () {
        if (this.hasValue()) {
            return currentContext.slots[this.id];
        }
    };
    Slot.prototype.withValue = function (value, callback, 
    // Given the prevalence of arrow functions, specifying arguments is likely
    // to be much more common than specifying `this`, hence this ordering:
    args, thisArg) {
        var _a;
        var slots = (_a = {
                __proto__: null
            },
            _a[this.id] = value,
            _a);
        var parent = currentContext;
        currentContext = { parent: parent, slots: slots };
        try {
            // Function.prototype.apply allows the arguments array argument to be
            // omitted or undefined, so args! is fine here.
            return callback.apply(thisArg, args);
        }
        finally {
            currentContext = parent;
        }
    };
    // Capture the current context and wrap a callback function so that it
    // reestablishes the captured context when called.
    Slot.bind = function (callback) {
        var context = currentContext;
        return function () {
            var saved = currentContext;
            try {
                currentContext = context;
                return callback.apply(this, arguments);
            }
            finally {
                currentContext = saved;
            }
        };
    };
    // Immediately run a callback function without any captured context.
    Slot.noContext = function (callback, 
    // Given the prevalence of arrow functions, specifying arguments is likely
    // to be much more common than specifying `this`, hence this ordering:
    args, thisArg) {
        if (currentContext) {
            var saved = currentContext;
            try {
                currentContext = null;
                // Function.prototype.apply allows the arguments array argument to be
                // omitted or undefined, so args! is fine here.
                return callback.apply(thisArg, args);
            }
            finally {
                currentContext = saved;
            }
        }
        else {
            return callback.apply(thisArg, args);
        }
    };
    return Slot;
}()); };
// We store a single global implementation of the Slot class as a permanent
// non-enumerable symbol property of the Array constructor. This obfuscation
// does nothing to prevent access to the Slot class, but at least it ensures
// the implementation (i.e. currentContext) cannot be tampered with, and all
// copies of the @wry/context package (hopefully just one) will share the
// same Slot implementation. Since the first copy of the @wry/context package
// to be imported wins, this technique imposes a very high cost for any
// future breaking changes to the Slot class.
var globalKey = "@wry/context:Slot";
var host = Array;
var Slot = host[globalKey] || function () {
    var Slot = makeSlotClass();
    try {
        Object.defineProperty(host, globalKey, {
            value: host[globalKey] = Slot,
            enumerable: false,
            writable: false,
            configurable: false,
        });
    }
    finally {
        return Slot;
    }
}();

Slot.bind; Slot.noContext;

function defaultDispose() { }
var Cache = /** @class */ (function () {
    function Cache(max, dispose) {
        if (max === void 0) { max = Infinity; }
        if (dispose === void 0) { dispose = defaultDispose; }
        this.max = max;
        this.dispose = dispose;
        this.map = new Map();
        this.newest = null;
        this.oldest = null;
    }
    Cache.prototype.has = function (key) {
        return this.map.has(key);
    };
    Cache.prototype.get = function (key) {
        var node = this.getNode(key);
        return node && node.value;
    };
    Cache.prototype.getNode = function (key) {
        var node = this.map.get(key);
        if (node && node !== this.newest) {
            var older = node.older, newer = node.newer;
            if (newer) {
                newer.older = older;
            }
            if (older) {
                older.newer = newer;
            }
            node.older = this.newest;
            node.older.newer = node;
            node.newer = null;
            this.newest = node;
            if (node === this.oldest) {
                this.oldest = newer;
            }
        }
        return node;
    };
    Cache.prototype.set = function (key, value) {
        var node = this.getNode(key);
        if (node) {
            return node.value = value;
        }
        node = {
            key: key,
            value: value,
            newer: null,
            older: this.newest
        };
        if (this.newest) {
            this.newest.newer = node;
        }
        this.newest = node;
        this.oldest = this.oldest || node;
        this.map.set(key, node);
        return node.value;
    };
    Cache.prototype.clean = function () {
        while (this.oldest && this.map.size > this.max) {
            this.delete(this.oldest.key);
        }
    };
    Cache.prototype.delete = function (key) {
        var node = this.map.get(key);
        if (node) {
            if (node === this.newest) {
                this.newest = node.older;
            }
            if (node === this.oldest) {
                this.oldest = node.newer;
            }
            if (node.newer) {
                node.newer.older = node.older;
            }
            if (node.older) {
                node.older.newer = node.newer;
            }
            this.map.delete(key);
            this.dispose(node.value, key);
            return true;
        }
        return false;
    };
    return Cache;
}());

var parentEntrySlot = new Slot();

var _a$1;
var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var 
// This Array.from polyfill is restricted to working with Set<any> for now,
// but we can improve the polyfill and add other input types, as needed. Note
// that this fallback implementation will only be used if the host environment
// does not support a native Array.from function. In most modern JS runtimes,
// the toArray function exported here will be === Array.from.
toArray = (_a$1 = Array.from, _a$1 === void 0 ? function (collection) {
    var array = [];
    collection.forEach(function (item) { return array.push(item); });
    return array;
} : _a$1);
function maybeUnsubscribe(entryOrDep) {
    var unsubscribe = entryOrDep.unsubscribe;
    if (typeof unsubscribe === "function") {
        entryOrDep.unsubscribe = void 0;
        unsubscribe();
    }
}

var emptySetPool = [];
var POOL_TARGET_SIZE = 100;
// Since this package might be used browsers, we should avoid using the
// Node built-in assert module.
function assert(condition, optionalMessage) {
    if (!condition) {
        throw new Error(optionalMessage || "assertion failure");
    }
}
function valueIs(a, b) {
    var len = a.length;
    return (
    // Unknown values are not equal to each other.
    len > 0 &&
        // Both values must be ordinary (or both exceptional) to be equal.
        len === b.length &&
        // The underlying value or exception must be the same.
        a[len - 1] === b[len - 1]);
}
function valueGet(value) {
    switch (value.length) {
        case 0: throw new Error("unknown value");
        case 1: return value[0];
        case 2: throw value[1];
    }
}
function valueCopy(value) {
    return value.slice(0);
}
var Entry = /** @class */ (function () {
    function Entry(fn) {
        this.fn = fn;
        this.parents = new Set();
        this.childValues = new Map();
        // When this Entry has children that are dirty, this property becomes
        // a Set containing other Entry objects, borrowed from emptySetPool.
        // When the set becomes empty, it gets recycled back to emptySetPool.
        this.dirtyChildren = null;
        this.dirty = true;
        this.recomputing = false;
        this.value = [];
        this.deps = null;
        ++Entry.count;
    }
    Entry.prototype.peek = function () {
        if (this.value.length === 1 && !mightBeDirty(this)) {
            rememberParent(this);
            return this.value[0];
        }
    };
    // This is the most important method of the Entry API, because it
    // determines whether the cached this.value can be returned immediately,
    // or must be recomputed. The overall performance of the caching system
    // depends on the truth of the following observations: (1) this.dirty is
    // usually false, (2) this.dirtyChildren is usually null/empty, and thus
    // (3) valueGet(this.value) is usually returned without recomputation.
    Entry.prototype.recompute = function (args) {
        assert(!this.recomputing, "already recomputing");
        rememberParent(this);
        return mightBeDirty(this)
            ? reallyRecompute(this, args)
            : valueGet(this.value);
    };
    Entry.prototype.setDirty = function () {
        if (this.dirty)
            return;
        this.dirty = true;
        this.value.length = 0;
        reportDirty(this);
        // We can go ahead and unsubscribe here, since any further dirty
        // notifications we receive will be redundant, and unsubscribing may
        // free up some resources, e.g. file watchers.
        maybeUnsubscribe(this);
    };
    Entry.prototype.dispose = function () {
        var _this = this;
        this.setDirty();
        // Sever any dependency relationships with our own children, so those
        // children don't retain this parent Entry in their child.parents sets,
        // thereby preventing it from being fully garbage collected.
        forgetChildren(this);
        // Because this entry has been kicked out of the cache (in index.js),
        // we've lost the ability to find out if/when this entry becomes dirty,
        // whether that happens through a subscription, because of a direct call
        // to entry.setDirty(), or because one of its children becomes dirty.
        // Because of this loss of future information, we have to assume the
        // worst (that this entry might have become dirty very soon), so we must
        // immediately mark this entry's parents as dirty. Normally we could
        // just call entry.setDirty() rather than calling parent.setDirty() for
        // each parent, but that would leave this entry in parent.childValues
        // and parent.dirtyChildren, which would prevent the child from being
        // truly forgotten.
        eachParent(this, function (parent, child) {
            parent.setDirty();
            forgetChild(parent, _this);
        });
    };
    Entry.prototype.forget = function () {
        // The code that creates Entry objects in index.ts will replace this method
        // with one that actually removes the Entry from the cache, which will also
        // trigger the entry.dispose method.
        this.dispose();
    };
    Entry.prototype.dependOn = function (dep) {
        dep.add(this);
        if (!this.deps) {
            this.deps = emptySetPool.pop() || new Set();
        }
        this.deps.add(dep);
    };
    Entry.prototype.forgetDeps = function () {
        var _this = this;
        if (this.deps) {
            toArray(this.deps).forEach(function (dep) { return dep.delete(_this); });
            this.deps.clear();
            emptySetPool.push(this.deps);
            this.deps = null;
        }
    };
    Entry.count = 0;
    return Entry;
}());
function rememberParent(child) {
    var parent = parentEntrySlot.getValue();
    if (parent) {
        child.parents.add(parent);
        if (!parent.childValues.has(child)) {
            parent.childValues.set(child, []);
        }
        if (mightBeDirty(child)) {
            reportDirtyChild(parent, child);
        }
        else {
            reportCleanChild(parent, child);
        }
        return parent;
    }
}
function reallyRecompute(entry, args) {
    forgetChildren(entry);
    // Set entry as the parent entry while calling recomputeNewValue(entry).
    parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);
    if (maybeSubscribe(entry, args)) {
        // If we successfully recomputed entry.value and did not fail to
        // (re)subscribe, then this Entry is no longer explicitly dirty.
        setClean(entry);
    }
    return valueGet(entry.value);
}
function recomputeNewValue(entry, args) {
    entry.recomputing = true;
    // Set entry.value as unknown.
    entry.value.length = 0;
    try {
        // If entry.fn succeeds, entry.value will become a normal Value.
        entry.value[0] = entry.fn.apply(null, args);
    }
    catch (e) {
        // If entry.fn throws, entry.value will become exceptional.
        entry.value[1] = e;
    }
    // Either way, this line is always reached.
    entry.recomputing = false;
}
function mightBeDirty(entry) {
    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
}
function setClean(entry) {
    entry.dirty = false;
    if (mightBeDirty(entry)) {
        // This Entry may still have dirty children, in which case we can't
        // let our parents know we're clean just yet.
        return;
    }
    reportClean(entry);
}
function reportDirty(child) {
    eachParent(child, reportDirtyChild);
}
function reportClean(child) {
    eachParent(child, reportCleanChild);
}
function eachParent(child, callback) {
    var parentCount = child.parents.size;
    if (parentCount) {
        var parents = toArray(child.parents);
        for (var i = 0; i < parentCount; ++i) {
            callback(parents[i], child);
        }
    }
}
// Let a parent Entry know that one of its children may be dirty.
function reportDirtyChild(parent, child) {
    // Must have called rememberParent(child) before calling
    // reportDirtyChild(parent, child).
    assert(parent.childValues.has(child));
    assert(mightBeDirty(child));
    var parentWasClean = !mightBeDirty(parent);
    if (!parent.dirtyChildren) {
        parent.dirtyChildren = emptySetPool.pop() || new Set;
    }
    else if (parent.dirtyChildren.has(child)) {
        // If we already know this child is dirty, then we must have already
        // informed our own parents that we are dirty, so we can terminate
        // the recursion early.
        return;
    }
    parent.dirtyChildren.add(child);
    // If parent was clean before, it just became (possibly) dirty (according to
    // mightBeDirty), since we just added child to parent.dirtyChildren.
    if (parentWasClean) {
        reportDirty(parent);
    }
}
// Let a parent Entry know that one of its children is no longer dirty.
function reportCleanChild(parent, child) {
    // Must have called rememberChild(child) before calling
    // reportCleanChild(parent, child).
    assert(parent.childValues.has(child));
    assert(!mightBeDirty(child));
    var childValue = parent.childValues.get(child);
    if (childValue.length === 0) {
        parent.childValues.set(child, valueCopy(child.value));
    }
    else if (!valueIs(childValue, child.value)) {
        parent.setDirty();
    }
    removeDirtyChild(parent, child);
    if (mightBeDirty(parent)) {
        return;
    }
    reportClean(parent);
}
function removeDirtyChild(parent, child) {
    var dc = parent.dirtyChildren;
    if (dc) {
        dc.delete(child);
        if (dc.size === 0) {
            if (emptySetPool.length < POOL_TARGET_SIZE) {
                emptySetPool.push(dc);
            }
            parent.dirtyChildren = null;
        }
    }
}
// Removes all children from this entry and returns an array of the
// removed children.
function forgetChildren(parent) {
    if (parent.childValues.size > 0) {
        parent.childValues.forEach(function (_value, child) {
            forgetChild(parent, child);
        });
    }
    // Remove this parent Entry from any sets to which it was added by the
    // addToSet method.
    parent.forgetDeps();
    // After we forget all our children, this.dirtyChildren must be empty
    // and therefore must have been reset to null.
    assert(parent.dirtyChildren === null);
}
function forgetChild(parent, child) {
    child.parents.delete(parent);
    parent.childValues.delete(child);
    removeDirtyChild(parent, child);
}
function maybeSubscribe(entry, args) {
    if (typeof entry.subscribe === "function") {
        try {
            maybeUnsubscribe(entry); // Prevent double subscriptions.
            entry.unsubscribe = entry.subscribe.apply(null, args);
        }
        catch (e) {
            // If this Entry has a subscribe function and it threw an exception
            // (or an unsubscribe function it previously returned now throws),
            // return false to indicate that we were not able to subscribe (or
            // unsubscribe), and this Entry should remain dirty.
            entry.setDirty();
            return false;
        }
    }
    // Returning true indicates either that there was no entry.subscribe
    // function or that it succeeded.
    return true;
}

var EntryMethods = {
    setDirty: true,
    dispose: true,
    forget: true,
};
function dep(options) {
    var depsByKey = new Map();
    var subscribe = options && options.subscribe;
    function depend(key) {
        var parent = parentEntrySlot.getValue();
        if (parent) {
            var dep_1 = depsByKey.get(key);
            if (!dep_1) {
                depsByKey.set(key, dep_1 = new Set);
            }
            parent.dependOn(dep_1);
            if (typeof subscribe === "function") {
                maybeUnsubscribe(dep_1);
                dep_1.unsubscribe = subscribe(key);
            }
        }
    }
    depend.dirty = function dirty(key, entryMethodName) {
        var dep = depsByKey.get(key);
        if (dep) {
            var m_1 = (entryMethodName &&
                hasOwnProperty$3.call(EntryMethods, entryMethodName)) ? entryMethodName : "setDirty";
            // We have to use toArray(dep).forEach instead of dep.forEach, because
            // modifying a Set while iterating over it can cause elements in the Set
            // to be removed from the Set before they've been iterated over.
            toArray(dep).forEach(function (entry) { return entry[m_1](); });
            depsByKey.delete(key);
            maybeUnsubscribe(dep);
        }
    };
    return depend;
}

function makeDefaultMakeCacheKeyFunction() {
    var keyTrie = new Trie(typeof WeakMap === "function");
    return function () {
        return keyTrie.lookupArray(arguments);
    };
}
// The defaultMakeCacheKey function is remarkably powerful, because it gives
// a unique object for any shallow-identical list of arguments. If you need
// to implement a custom makeCacheKey function, you may find it helpful to
// delegate the final work to defaultMakeCacheKey, which is why we export it
// here. However, you may want to avoid defaultMakeCacheKey if your runtime
// does not support WeakMap, or you have the ability to return a string key.
// In those cases, just write your own custom makeCacheKey functions.
makeDefaultMakeCacheKeyFunction();
var caches = new Set();
function wrap$1(originalFunction, options) {
    if (options === void 0) { options = Object.create(null); }
    var cache = new Cache(options.max || Math.pow(2, 16), function (entry) { return entry.dispose(); });
    var keyArgs = options.keyArgs;
    var makeCacheKey = options.makeCacheKey ||
        makeDefaultMakeCacheKeyFunction();
    var optimistic = function () {
        var key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);
        if (key === void 0) {
            return originalFunction.apply(null, arguments);
        }
        var entry = cache.get(key);
        if (!entry) {
            cache.set(key, entry = new Entry(originalFunction));
            entry.subscribe = options.subscribe;
            // Give the Entry the ability to trigger cache.delete(key), even though
            // the Entry itself does not know about key or cache.
            entry.forget = function () { return cache.delete(key); };
        }
        var value = entry.recompute(Array.prototype.slice.call(arguments));
        // Move this entry to the front of the least-recently used queue,
        // since we just finished computing its value.
        cache.set(key, entry);
        caches.add(cache);
        // Clean up any excess entries in the cache, but only if there is no
        // active parent entry, meaning we're not in the middle of a larger
        // computation that might be flummoxed by the cleaning.
        if (!parentEntrySlot.hasValue()) {
            caches.forEach(function (cache) { return cache.clean(); });
            caches.clear();
        }
        return value;
    };
    Object.defineProperty(optimistic, "size", {
        get: function () {
            return cache["map"].size;
        },
        configurable: false,
        enumerable: false,
    });
    function dirtyKey(key) {
        var entry = cache.get(key);
        if (entry) {
            entry.setDirty();
        }
    }
    optimistic.dirtyKey = dirtyKey;
    optimistic.dirty = function dirty() {
        dirtyKey(makeCacheKey.apply(null, arguments));
    };
    function peekKey(key) {
        var entry = cache.get(key);
        if (entry) {
            return entry.peek();
        }
    }
    optimistic.peekKey = peekKey;
    optimistic.peek = function peek() {
        return peekKey(makeCacheKey.apply(null, arguments));
    };
    function forgetKey(key) {
        return cache.delete(key);
    }
    optimistic.forgetKey = forgetKey;
    optimistic.forget = function forget() {
        return forgetKey(makeCacheKey.apply(null, arguments));
    };
    optimistic.makeCacheKey = makeCacheKey;
    optimistic.getKey = keyArgs ? function getKey() {
        return makeCacheKey.apply(null, keyArgs.apply(null, arguments));
    } : makeCacheKey;
    return Object.freeze(optimistic);
}

var ApolloCache = (function () {
    function ApolloCache() {
        this.getFragmentDoc = wrap$1(getFragmentQueryDocument);
    }
    ApolloCache.prototype.batch = function (options) {
        var _this = this;
        var optimisticId = typeof options.optimistic === "string" ? options.optimistic :
            options.optimistic === false ? null : void 0;
        var updateResult;
        this.performTransaction(function () { return updateResult = options.update(_this); }, optimisticId);
        return updateResult;
    };
    ApolloCache.prototype.recordOptimisticTransaction = function (transaction, optimisticId) {
        this.performTransaction(transaction, optimisticId);
    };
    ApolloCache.prototype.transformDocument = function (document) {
        return document;
    };
    ApolloCache.prototype.identify = function (object) {
        return;
    };
    ApolloCache.prototype.gc = function () {
        return [];
    };
    ApolloCache.prototype.modify = function (options) {
        return false;
    };
    ApolloCache.prototype.transformForLink = function (document) {
        return document;
    };
    ApolloCache.prototype.readQuery = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = !!options.optimistic; }
        return this.read(__assign(__assign({}, options), { rootId: options.id || 'ROOT_QUERY', optimistic: optimistic }));
    };
    ApolloCache.prototype.readFragment = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = !!options.optimistic; }
        return this.read(__assign(__assign({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic: optimistic }));
    };
    ApolloCache.prototype.writeQuery = function (_a) {
        var id = _a.id, data = _a.data, options = __rest(_a, ["id", "data"]);
        return this.write(Object.assign(options, {
            dataId: id || 'ROOT_QUERY',
            result: data,
        }));
    };
    ApolloCache.prototype.writeFragment = function (_a) {
        var id = _a.id, data = _a.data, fragment = _a.fragment, fragmentName = _a.fragmentName, options = __rest(_a, ["id", "data", "fragment", "fragmentName"]);
        return this.write(Object.assign(options, {
            query: this.getFragmentDoc(fragment, fragmentName),
            dataId: id,
            result: data,
        }));
    };
    ApolloCache.prototype.updateQuery = function (options, update) {
        return this.batch({
            update: function (cache) {
                var value = cache.readQuery(options);
                var data = update(value);
                if (data === void 0 || data === null)
                    return value;
                cache.writeQuery(__assign(__assign({}, options), { data: data }));
                return data;
            },
        });
    };
    ApolloCache.prototype.updateFragment = function (options, update) {
        return this.batch({
            update: function (cache) {
                var value = cache.readFragment(options);
                var data = update(value);
                if (data === void 0 || data === null)
                    return value;
                cache.writeFragment(__assign(__assign({}, options), { data: data }));
                return data;
            },
        });
    };
    return ApolloCache;
}());

var MissingFieldError = (function () {
    function MissingFieldError(message, path, query, variables) {
        this.message = message;
        this.path = path;
        this.query = query;
        this.variables = variables;
    }
    return MissingFieldError;
}());

var hasOwn = Object.prototype.hasOwnProperty;
function defaultDataIdFromObject(_a, context) {
    var __typename = _a.__typename, id = _a.id, _id = _a._id;
    if (typeof __typename === "string") {
        if (context) {
            context.keyObject =
                id !== void 0 ? { id: id } :
                    _id !== void 0 ? { _id: _id } :
                        void 0;
        }
        if (id === void 0)
            id = _id;
        if (id !== void 0) {
            return "".concat(__typename, ":").concat((typeof id === "number" ||
                typeof id === "string") ? id : JSON.stringify(id));
        }
    }
}
var defaultConfig = {
    dataIdFromObject: defaultDataIdFromObject,
    addTypename: true,
    resultCaching: true,
    canonizeResults: false,
};
function normalizeConfig(config) {
    return compact(defaultConfig, config);
}
function shouldCanonizeResults(config) {
    var value = config.canonizeResults;
    return value === void 0 ? defaultConfig.canonizeResults : value;
}
function getTypenameFromStoreObject(store, objectOrReference) {
    return isReference(objectOrReference)
        ? store.get(objectOrReference.__ref, "__typename")
        : objectOrReference && objectOrReference.__typename;
}
var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
function fieldNameFromStoreName(storeFieldName) {
    var match = storeFieldName.match(TypeOrFieldNameRegExp);
    return match ? match[0] : storeFieldName;
}
function selectionSetMatchesResult(selectionSet, result, variables) {
    if (isNonNullObject(result)) {
        return isArray$1(result)
            ? result.every(function (item) { return selectionSetMatchesResult(selectionSet, item, variables); })
            : selectionSet.selections.every(function (field) {
                if (isField(field) && shouldInclude(field, variables)) {
                    var key = resultKeyNameFromField(field);
                    return hasOwn.call(result, key) &&
                        (!field.selectionSet ||
                            selectionSetMatchesResult(field.selectionSet, result[key], variables));
                }
                return true;
            });
    }
    return false;
}
function storeValueIsStoreObject(value) {
    return isNonNullObject(value) &&
        !isReference(value) &&
        !isArray$1(value);
}
function makeProcessedFieldsMerger() {
    return new DeepMerger;
}
var isArray$1 = function (a) { return Array.isArray(a); };

var DELETE = Object.create(null);
var delModifier = function () { return DELETE; };
var INVALIDATE = Object.create(null);
var EntityStore = (function () {
    function EntityStore(policies, group) {
        var _this = this;
        this.policies = policies;
        this.group = group;
        this.data = Object.create(null);
        this.rootIds = Object.create(null);
        this.refs = Object.create(null);
        this.getFieldValue = function (objectOrReference, storeFieldName) { return maybeDeepFreeze(isReference(objectOrReference)
            ? _this.get(objectOrReference.__ref, storeFieldName)
            : objectOrReference && objectOrReference[storeFieldName]); };
        this.canRead = function (objOrRef) {
            return isReference(objOrRef)
                ? _this.has(objOrRef.__ref)
                : typeof objOrRef === "object";
        };
        this.toReference = function (objOrIdOrRef, mergeIntoStore) {
            if (typeof objOrIdOrRef === "string") {
                return makeReference(objOrIdOrRef);
            }
            if (isReference(objOrIdOrRef)) {
                return objOrIdOrRef;
            }
            var id = _this.policies.identify(objOrIdOrRef)[0];
            if (id) {
                var ref = makeReference(id);
                if (mergeIntoStore) {
                    _this.merge(id, objOrIdOrRef);
                }
                return ref;
            }
        };
    }
    EntityStore.prototype.toObject = function () {
        return __assign({}, this.data);
    };
    EntityStore.prototype.has = function (dataId) {
        return this.lookup(dataId, true) !== void 0;
    };
    EntityStore.prototype.get = function (dataId, fieldName) {
        this.group.depend(dataId, fieldName);
        if (hasOwn.call(this.data, dataId)) {
            var storeObject = this.data[dataId];
            if (storeObject && hasOwn.call(storeObject, fieldName)) {
                return storeObject[fieldName];
            }
        }
        if (fieldName === "__typename" &&
            hasOwn.call(this.policies.rootTypenamesById, dataId)) {
            return this.policies.rootTypenamesById[dataId];
        }
        if (this instanceof Layer) {
            return this.parent.get(dataId, fieldName);
        }
    };
    EntityStore.prototype.lookup = function (dataId, dependOnExistence) {
        if (dependOnExistence)
            this.group.depend(dataId, "__exists");
        if (hasOwn.call(this.data, dataId)) {
            return this.data[dataId];
        }
        if (this instanceof Layer) {
            return this.parent.lookup(dataId, dependOnExistence);
        }
        if (this.policies.rootTypenamesById[dataId]) {
            return Object.create(null);
        }
    };
    EntityStore.prototype.merge = function (older, newer) {
        var _this = this;
        var dataId;
        if (isReference(older))
            older = older.__ref;
        if (isReference(newer))
            newer = newer.__ref;
        var existing = typeof older === "string"
            ? this.lookup(dataId = older)
            : older;
        var incoming = typeof newer === "string"
            ? this.lookup(dataId = newer)
            : newer;
        if (!incoming)
            return;
        __DEV__ ? invariant(typeof dataId === "string", "store.merge expects a string ID") : invariant(typeof dataId === "string", 1);
        var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);
        this.data[dataId] = merged;
        if (merged !== existing) {
            delete this.refs[dataId];
            if (this.group.caching) {
                var fieldsToDirty_1 = Object.create(null);
                if (!existing)
                    fieldsToDirty_1.__exists = 1;
                Object.keys(incoming).forEach(function (storeFieldName) {
                    if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
                        fieldsToDirty_1[storeFieldName] = 1;
                        var fieldName = fieldNameFromStoreName(storeFieldName);
                        if (fieldName !== storeFieldName &&
                            !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
                            fieldsToDirty_1[fieldName] = 1;
                        }
                        if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
                            delete merged[storeFieldName];
                        }
                    }
                });
                if (fieldsToDirty_1.__typename &&
                    !(existing && existing.__typename) &&
                    this.policies.rootTypenamesById[dataId] === merged.__typename) {
                    delete fieldsToDirty_1.__typename;
                }
                Object.keys(fieldsToDirty_1).forEach(function (fieldName) { return _this.group.dirty(dataId, fieldName); });
            }
        }
    };
    EntityStore.prototype.modify = function (dataId, fields) {
        var _this = this;
        var storeObject = this.lookup(dataId);
        if (storeObject) {
            var changedFields_1 = Object.create(null);
            var needToMerge_1 = false;
            var allDeleted_1 = true;
            var sharedDetails_1 = {
                DELETE: DELETE,
                INVALIDATE: INVALIDATE,
                isReference: isReference,
                toReference: this.toReference,
                canRead: this.canRead,
                readField: function (fieldNameOrOptions, from) { return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
                    fieldName: fieldNameOrOptions,
                    from: from || makeReference(dataId),
                } : fieldNameOrOptions, { store: _this }); },
            };
            Object.keys(storeObject).forEach(function (storeFieldName) {
                var fieldName = fieldNameFromStoreName(storeFieldName);
                var fieldValue = storeObject[storeFieldName];
                if (fieldValue === void 0)
                    return;
                var modify = typeof fields === "function"
                    ? fields
                    : fields[storeFieldName] || fields[fieldName];
                if (modify) {
                    var newValue = modify === delModifier ? DELETE :
                        modify(maybeDeepFreeze(fieldValue), __assign(__assign({}, sharedDetails_1), { fieldName: fieldName, storeFieldName: storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
                    if (newValue === INVALIDATE) {
                        _this.group.dirty(dataId, storeFieldName);
                    }
                    else {
                        if (newValue === DELETE)
                            newValue = void 0;
                        if (newValue !== fieldValue) {
                            changedFields_1[storeFieldName] = newValue;
                            needToMerge_1 = true;
                            fieldValue = newValue;
                        }
                    }
                }
                if (fieldValue !== void 0) {
                    allDeleted_1 = false;
                }
            });
            if (needToMerge_1) {
                this.merge(dataId, changedFields_1);
                if (allDeleted_1) {
                    if (this instanceof Layer) {
                        this.data[dataId] = void 0;
                    }
                    else {
                        delete this.data[dataId];
                    }
                    this.group.dirty(dataId, "__exists");
                }
                return true;
            }
        }
        return false;
    };
    EntityStore.prototype.delete = function (dataId, fieldName, args) {
        var _a;
        var storeObject = this.lookup(dataId);
        if (storeObject) {
            var typename = this.getFieldValue(storeObject, "__typename");
            var storeFieldName = fieldName && args
                ? this.policies.getStoreFieldName({ typename: typename, fieldName: fieldName, args: args })
                : fieldName;
            return this.modify(dataId, storeFieldName ? (_a = {},
                _a[storeFieldName] = delModifier,
                _a) : delModifier);
        }
        return false;
    };
    EntityStore.prototype.evict = function (options, limit) {
        var evicted = false;
        if (options.id) {
            if (hasOwn.call(this.data, options.id)) {
                evicted = this.delete(options.id, options.fieldName, options.args);
            }
            if (this instanceof Layer && this !== limit) {
                evicted = this.parent.evict(options, limit) || evicted;
            }
            if (options.fieldName || evicted) {
                this.group.dirty(options.id, options.fieldName || "__exists");
            }
        }
        return evicted;
    };
    EntityStore.prototype.clear = function () {
        this.replace(null);
    };
    EntityStore.prototype.extract = function () {
        var _this = this;
        var obj = this.toObject();
        var extraRootIds = [];
        this.getRootIdSet().forEach(function (id) {
            if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {
                extraRootIds.push(id);
            }
        });
        if (extraRootIds.length) {
            obj.__META = { extraRootIds: extraRootIds.sort() };
        }
        return obj;
    };
    EntityStore.prototype.replace = function (newData) {
        var _this = this;
        Object.keys(this.data).forEach(function (dataId) {
            if (!(newData && hasOwn.call(newData, dataId))) {
                _this.delete(dataId);
            }
        });
        if (newData) {
            var __META = newData.__META, rest_1 = __rest(newData, ["__META"]);
            Object.keys(rest_1).forEach(function (dataId) {
                _this.merge(dataId, rest_1[dataId]);
            });
            if (__META) {
                __META.extraRootIds.forEach(this.retain, this);
            }
        }
    };
    EntityStore.prototype.retain = function (rootId) {
        return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
    };
    EntityStore.prototype.release = function (rootId) {
        if (this.rootIds[rootId] > 0) {
            var count = --this.rootIds[rootId];
            if (!count)
                delete this.rootIds[rootId];
            return count;
        }
        return 0;
    };
    EntityStore.prototype.getRootIdSet = function (ids) {
        if (ids === void 0) { ids = new Set(); }
        Object.keys(this.rootIds).forEach(ids.add, ids);
        if (this instanceof Layer) {
            this.parent.getRootIdSet(ids);
        }
        else {
            Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
        }
        return ids;
    };
    EntityStore.prototype.gc = function () {
        var _this = this;
        var ids = this.getRootIdSet();
        var snapshot = this.toObject();
        ids.forEach(function (id) {
            if (hasOwn.call(snapshot, id)) {
                Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);
                delete snapshot[id];
            }
        });
        var idsToRemove = Object.keys(snapshot);
        if (idsToRemove.length) {
            var root_1 = this;
            while (root_1 instanceof Layer)
                root_1 = root_1.parent;
            idsToRemove.forEach(function (id) { return root_1.delete(id); });
        }
        return idsToRemove;
    };
    EntityStore.prototype.findChildRefIds = function (dataId) {
        if (!hasOwn.call(this.refs, dataId)) {
            var found_1 = this.refs[dataId] = Object.create(null);
            var root = this.data[dataId];
            if (!root)
                return found_1;
            var workSet_1 = new Set([root]);
            workSet_1.forEach(function (obj) {
                if (isReference(obj)) {
                    found_1[obj.__ref] = true;
                }
                if (isNonNullObject(obj)) {
                    Object.keys(obj).forEach(function (key) {
                        var child = obj[key];
                        if (isNonNullObject(child)) {
                            workSet_1.add(child);
                        }
                    });
                }
            });
        }
        return this.refs[dataId];
    };
    EntityStore.prototype.makeCacheKey = function () {
        return this.group.keyMaker.lookupArray(arguments);
    };
    return EntityStore;
}());
var CacheGroup = (function () {
    function CacheGroup(caching, parent) {
        if (parent === void 0) { parent = null; }
        this.caching = caching;
        this.parent = parent;
        this.d = null;
        this.resetCaching();
    }
    CacheGroup.prototype.resetCaching = function () {
        this.d = this.caching ? dep() : null;
        this.keyMaker = new Trie(canUseWeakMap);
    };
    CacheGroup.prototype.depend = function (dataId, storeFieldName) {
        if (this.d) {
            this.d(makeDepKey(dataId, storeFieldName));
            var fieldName = fieldNameFromStoreName(storeFieldName);
            if (fieldName !== storeFieldName) {
                this.d(makeDepKey(dataId, fieldName));
            }
            if (this.parent) {
                this.parent.depend(dataId, storeFieldName);
            }
        }
    };
    CacheGroup.prototype.dirty = function (dataId, storeFieldName) {
        if (this.d) {
            this.d.dirty(makeDepKey(dataId, storeFieldName), storeFieldName === "__exists" ? "forget" : "setDirty");
        }
    };
    return CacheGroup;
}());
function makeDepKey(dataId, storeFieldName) {
    return storeFieldName + '#' + dataId;
}
function maybeDependOnExistenceOfEntity(store, entityId) {
    if (supportsResultCaching(store)) {
        store.group.depend(entityId, "__exists");
    }
}
(function (EntityStore) {
    var Root = (function (_super) {
        __extends(Root, _super);
        function Root(_a) {
            var policies = _a.policies, _b = _a.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a.seed;
            var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
            _this.stump = new Stump(_this);
            _this.storageTrie = new Trie(canUseWeakMap);
            if (seed)
                _this.replace(seed);
            return _this;
        }
        Root.prototype.addLayer = function (layerId, replay) {
            return this.stump.addLayer(layerId, replay);
        };
        Root.prototype.removeLayer = function () {
            return this;
        };
        Root.prototype.getStorage = function () {
            return this.storageTrie.lookupArray(arguments);
        };
        return Root;
    }(EntityStore));
    EntityStore.Root = Root;
})(EntityStore || (EntityStore = {}));
var Layer = (function (_super) {
    __extends(Layer, _super);
    function Layer(id, parent, replay, group) {
        var _this = _super.call(this, parent.policies, group) || this;
        _this.id = id;
        _this.parent = parent;
        _this.replay = replay;
        _this.group = group;
        replay(_this);
        return _this;
    }
    Layer.prototype.addLayer = function (layerId, replay) {
        return new Layer(layerId, this, replay, this.group);
    };
    Layer.prototype.removeLayer = function (layerId) {
        var _this = this;
        var parent = this.parent.removeLayer(layerId);
        if (layerId === this.id) {
            if (this.group.caching) {
                Object.keys(this.data).forEach(function (dataId) {
                    var ownStoreObject = _this.data[dataId];
                    var parentStoreObject = parent["lookup"](dataId);
                    if (!parentStoreObject) {
                        _this.delete(dataId);
                    }
                    else if (!ownStoreObject) {
                        _this.group.dirty(dataId, "__exists");
                        Object.keys(parentStoreObject).forEach(function (storeFieldName) {
                            _this.group.dirty(dataId, storeFieldName);
                        });
                    }
                    else if (ownStoreObject !== parentStoreObject) {
                        Object.keys(ownStoreObject).forEach(function (storeFieldName) {
                            if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                                _this.group.dirty(dataId, storeFieldName);
                            }
                        });
                    }
                });
            }
            return parent;
        }
        if (parent === this.parent)
            return this;
        return parent.addLayer(this.id, this.replay);
    };
    Layer.prototype.toObject = function () {
        return __assign(__assign({}, this.parent.toObject()), this.data);
    };
    Layer.prototype.findChildRefIds = function (dataId) {
        var fromParent = this.parent.findChildRefIds(dataId);
        return hasOwn.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
    };
    Layer.prototype.getStorage = function () {
        var p = this.parent;
        while (p.parent)
            p = p.parent;
        return p.getStorage.apply(p, arguments);
    };
    return Layer;
}(EntityStore));
var Stump = (function (_super) {
    __extends(Stump, _super);
    function Stump(root) {
        return _super.call(this, "EntityStore.Stump", root, function () { }, new CacheGroup(root.group.caching, root.group)) || this;
    }
    Stump.prototype.removeLayer = function () {
        return this;
    };
    Stump.prototype.merge = function () {
        return this.parent.merge.apply(this.parent, arguments);
    };
    return Stump;
}(Layer));
function storeObjectReconciler(existingObject, incomingObject, property) {
    var existingValue = existingObject[property];
    var incomingValue = incomingObject[property];
    return equal(existingValue, incomingValue) ? existingValue : incomingValue;
}
function supportsResultCaching(store) {
    return !!(store instanceof EntityStore && store.group.caching);
}

function shallowCopy(value) {
    if (isNonNullObject(value)) {
        return isArray$1(value)
            ? value.slice(0)
            : __assign({ __proto__: Object.getPrototypeOf(value) }, value);
    }
    return value;
}
var ObjectCanon = (function () {
    function ObjectCanon() {
        this.known = new (canUseWeakSet ? WeakSet : Set)();
        this.pool = new Trie(canUseWeakMap);
        this.passes = new WeakMap();
        this.keysByJSON = new Map();
        this.empty = this.admit({});
    }
    ObjectCanon.prototype.isKnown = function (value) {
        return isNonNullObject(value) && this.known.has(value);
    };
    ObjectCanon.prototype.pass = function (value) {
        if (isNonNullObject(value)) {
            var copy = shallowCopy(value);
            this.passes.set(copy, value);
            return copy;
        }
        return value;
    };
    ObjectCanon.prototype.admit = function (value) {
        var _this = this;
        if (isNonNullObject(value)) {
            var original = this.passes.get(value);
            if (original)
                return original;
            var proto = Object.getPrototypeOf(value);
            switch (proto) {
                case Array.prototype: {
                    if (this.known.has(value))
                        return value;
                    var array = value.map(this.admit, this);
                    var node = this.pool.lookupArray(array);
                    if (!node.array) {
                        this.known.add(node.array = array);
                        if (__DEV__) {
                            Object.freeze(array);
                        }
                    }
                    return node.array;
                }
                case null:
                case Object.prototype: {
                    if (this.known.has(value))
                        return value;
                    var proto_1 = Object.getPrototypeOf(value);
                    var array_1 = [proto_1];
                    var keys = this.sortedKeys(value);
                    array_1.push(keys.json);
                    var firstValueIndex_1 = array_1.length;
                    keys.sorted.forEach(function (key) {
                        array_1.push(_this.admit(value[key]));
                    });
                    var node = this.pool.lookupArray(array_1);
                    if (!node.object) {
                        var obj_1 = node.object = Object.create(proto_1);
                        this.known.add(obj_1);
                        keys.sorted.forEach(function (key, i) {
                            obj_1[key] = array_1[firstValueIndex_1 + i];
                        });
                        if (__DEV__) {
                            Object.freeze(obj_1);
                        }
                    }
                    return node.object;
                }
            }
        }
        return value;
    };
    ObjectCanon.prototype.sortedKeys = function (obj) {
        var keys = Object.keys(obj);
        var node = this.pool.lookupArray(keys);
        if (!node.keys) {
            keys.sort();
            var json = JSON.stringify(keys);
            if (!(node.keys = this.keysByJSON.get(json))) {
                this.keysByJSON.set(json, node.keys = { sorted: keys, json: json });
            }
        }
        return node.keys;
    };
    return ObjectCanon;
}());
var canonicalStringify = Object.assign(function (value) {
    if (isNonNullObject(value)) {
        if (stringifyCanon === void 0) {
            resetCanonicalStringify();
        }
        var canonical = stringifyCanon.admit(value);
        var json = stringifyCache.get(canonical);
        if (json === void 0) {
            stringifyCache.set(canonical, json = JSON.stringify(canonical));
        }
        return json;
    }
    return JSON.stringify(value);
}, {
    reset: resetCanonicalStringify,
});
var stringifyCanon;
var stringifyCache;
function resetCanonicalStringify() {
    stringifyCanon = new ObjectCanon;
    stringifyCache = new (canUseWeakMap ? WeakMap : Map)();
}

function execSelectionSetKeyArgs(options) {
    return [
        options.selectionSet,
        options.objectOrReference,
        options.context,
        options.context.canonizeResults,
    ];
}
var StoreReader = (function () {
    function StoreReader(config) {
        var _this = this;
        this.knownResults = new (canUseWeakMap ? WeakMap : Map)();
        this.config = compact(config, {
            addTypename: config.addTypename !== false,
            canonizeResults: shouldCanonizeResults(config),
        });
        this.canon = config.canon || new ObjectCanon;
        this.executeSelectionSet = wrap$1(function (options) {
            var _a;
            var canonizeResults = options.context.canonizeResults;
            var peekArgs = execSelectionSetKeyArgs(options);
            peekArgs[3] = !canonizeResults;
            var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);
            if (other) {
                if (canonizeResults) {
                    return __assign(__assign({}, other), { result: _this.canon.admit(other.result) });
                }
                return other;
            }
            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
            return _this.execSelectionSetImpl(options);
        }, {
            max: this.config.resultCacheMaxSize,
            keyArgs: execSelectionSetKeyArgs,
            makeCacheKey: function (selectionSet, parent, context, canonizeResults) {
                if (supportsResultCaching(context.store)) {
                    return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);
                }
            }
        });
        this.executeSubSelectedArray = wrap$1(function (options) {
            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
            return _this.execSubSelectedArrayImpl(options);
        }, {
            max: this.config.resultCacheMaxSize,
            makeCacheKey: function (_a) {
                var field = _a.field, array = _a.array, context = _a.context;
                if (supportsResultCaching(context.store)) {
                    return context.store.makeCacheKey(field, array, context.varString);
                }
            }
        });
    }
    StoreReader.prototype.resetCanon = function () {
        this.canon = new ObjectCanon;
    };
    StoreReader.prototype.diffQueryAgainstStore = function (_a) {
        var store = _a.store, query = _a.query, _b = _a.rootId, rootId = _b === void 0 ? 'ROOT_QUERY' : _b, variables = _a.variables, _c = _a.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
        var policies = this.config.cache.policies;
        variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);
        var rootRef = makeReference(rootId);
        var execResult = this.executeSelectionSet({
            selectionSet: getMainDefinition(query).selectionSet,
            objectOrReference: rootRef,
            enclosingRef: rootRef,
            context: {
                store: store,
                query: query,
                policies: policies,
                variables: variables,
                varString: canonicalStringify(variables),
                canonizeResults: canonizeResults,
                fragmentMap: createFragmentMap(getFragmentDefinitions(query)),
            },
        });
        var missing;
        if (execResult.missing) {
            missing = [new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)];
            if (!returnPartialData) {
                throw missing[0];
            }
        }
        return {
            result: execResult.result,
            complete: !missing,
            missing: missing,
        };
    };
    StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {
        if (supportsResultCaching(context.store) &&
            this.knownResults.get(result) === selectionSet) {
            var latest = this.executeSelectionSet.peek(selectionSet, parent, context, this.canon.isKnown(result));
            if (latest && result === latest.result) {
                return true;
            }
        }
        return false;
    };
    StoreReader.prototype.execSelectionSetImpl = function (_a) {
        var _this = this;
        var selectionSet = _a.selectionSet, objectOrReference = _a.objectOrReference, enclosingRef = _a.enclosingRef, context = _a.context;
        if (isReference(objectOrReference) &&
            !context.policies.rootTypenamesById[objectOrReference.__ref] &&
            !context.store.has(objectOrReference.__ref)) {
            return {
                result: this.canon.empty,
                missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object"),
            };
        }
        var variables = context.variables, policies = context.policies, store = context.store;
        var typename = store.getFieldValue(objectOrReference, "__typename");
        var objectsToMerge = [];
        var missing;
        var missingMerger = new DeepMerger();
        if (this.config.addTypename &&
            typeof typename === "string" &&
            !policies.rootIdsByTypename[typename]) {
            objectsToMerge.push({ __typename: typename });
        }
        function handleMissing(result, resultName) {
            var _a;
            if (result.missing) {
                missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = result.missing, _a));
            }
            return result.result;
        }
        var workSet = new Set(selectionSet.selections);
        workSet.forEach(function (selection) {
            var _a, _b;
            if (!shouldInclude(selection, variables))
                return;
            if (isField(selection)) {
                var fieldValue = policies.readField({
                    fieldName: selection.name.value,
                    field: selection,
                    variables: context.variables,
                    from: objectOrReference,
                }, context);
                var resultName = resultKeyNameFromField(selection);
                if (fieldValue === void 0) {
                    if (!addTypenameToDocument.added(selection)) {
                        missing = missingMerger.merge(missing, (_a = {},
                            _a[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(isReference(objectOrReference)
                                ? objectOrReference.__ref + " object"
                                : "object " + JSON.stringify(objectOrReference, null, 2)),
                            _a));
                    }
                }
                else if (isArray$1(fieldValue)) {
                    fieldValue = handleMissing(_this.executeSubSelectedArray({
                        field: selection,
                        array: fieldValue,
                        enclosingRef: enclosingRef,
                        context: context,
                    }), resultName);
                }
                else if (!selection.selectionSet) {
                    if (context.canonizeResults) {
                        fieldValue = _this.canon.pass(fieldValue);
                    }
                }
                else if (fieldValue != null) {
                    fieldValue = handleMissing(_this.executeSelectionSet({
                        selectionSet: selection.selectionSet,
                        objectOrReference: fieldValue,
                        enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,
                        context: context,
                    }), resultName);
                }
                if (fieldValue !== void 0) {
                    objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));
                }
            }
            else {
                var fragment = getFragmentFromSelection(selection, context.fragmentMap);
                if (fragment && policies.fragmentMatches(fragment, typename)) {
                    fragment.selectionSet.selections.forEach(workSet.add, workSet);
                }
            }
        });
        var result = mergeDeepArray(objectsToMerge);
        var finalResult = { result: result, missing: missing };
        var frozen = context.canonizeResults
            ? this.canon.admit(finalResult)
            : maybeDeepFreeze(finalResult);
        if (frozen.result) {
            this.knownResults.set(frozen.result, selectionSet);
        }
        return frozen;
    };
    StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {
        var _this = this;
        var field = _a.field, array = _a.array, enclosingRef = _a.enclosingRef, context = _a.context;
        var missing;
        var missingMerger = new DeepMerger();
        function handleMissing(childResult, i) {
            var _a;
            if (childResult.missing) {
                missing = missingMerger.merge(missing, (_a = {}, _a[i] = childResult.missing, _a));
            }
            return childResult.result;
        }
        if (field.selectionSet) {
            array = array.filter(context.store.canRead);
        }
        array = array.map(function (item, i) {
            if (item === null) {
                return null;
            }
            if (isArray$1(item)) {
                return handleMissing(_this.executeSubSelectedArray({
                    field: field,
                    array: item,
                    enclosingRef: enclosingRef,
                    context: context,
                }), i);
            }
            if (field.selectionSet) {
                return handleMissing(_this.executeSelectionSet({
                    selectionSet: field.selectionSet,
                    objectOrReference: item,
                    enclosingRef: isReference(item) ? item : enclosingRef,
                    context: context,
                }), i);
            }
            if (__DEV__) {
                assertSelectionSetForIdValue(context.store, field, item);
            }
            return item;
        });
        return {
            result: context.canonizeResults ? this.canon.admit(array) : array,
            missing: missing,
        };
    };
    return StoreReader;
}());
function firstMissing(tree) {
    try {
        JSON.stringify(tree, function (_, value) {
            if (typeof value === "string")
                throw value;
            return value;
        });
    }
    catch (result) {
        return result;
    }
}
function assertSelectionSetForIdValue(store, field, fieldValue) {
    if (!field.selectionSet) {
        var workSet_1 = new Set([fieldValue]);
        workSet_1.forEach(function (value) {
            if (isNonNullObject(value)) {
                __DEV__ ? invariant(!isReference(value), "Missing selection set for object of type ".concat(getTypenameFromStoreObject(store, value), " returned for query field ").concat(field.name.value)) : invariant(!isReference(value), 5);
                Object.values(value).forEach(workSet_1.add, workSet_1);
            }
        });
    }
}

var cacheSlot = new Slot();
var cacheInfoMap = new WeakMap();
function getCacheInfo(cache) {
    var info = cacheInfoMap.get(cache);
    if (!info) {
        cacheInfoMap.set(cache, info = {
            vars: new Set,
            dep: dep(),
        });
    }
    return info;
}
function forgetCache(cache) {
    getCacheInfo(cache).vars.forEach(function (rv) { return rv.forgetCache(cache); });
}
function recallCache(cache) {
    getCacheInfo(cache).vars.forEach(function (rv) { return rv.attachCache(cache); });
}
function makeVar(value) {
    var caches = new Set();
    var listeners = new Set();
    var rv = function (newValue) {
        if (arguments.length > 0) {
            if (value !== newValue) {
                value = newValue;
                caches.forEach(function (cache) {
                    getCacheInfo(cache).dep.dirty(rv);
                    broadcast(cache);
                });
                var oldListeners = Array.from(listeners);
                listeners.clear();
                oldListeners.forEach(function (listener) { return listener(value); });
            }
        }
        else {
            var cache = cacheSlot.getValue();
            if (cache) {
                attach(cache);
                getCacheInfo(cache).dep(rv);
            }
        }
        return value;
    };
    rv.onNextChange = function (listener) {
        listeners.add(listener);
        return function () {
            listeners.delete(listener);
        };
    };
    var attach = rv.attachCache = function (cache) {
        caches.add(cache);
        getCacheInfo(cache).vars.add(rv);
        return rv;
    };
    rv.forgetCache = function (cache) { return caches.delete(cache); };
    return rv;
}
function broadcast(cache) {
    if (cache.broadcastWatches) {
        cache.broadcastWatches();
    }
}

var specifierInfoCache = Object.create(null);
function lookupSpecifierInfo(spec) {
    var cacheKey = JSON.stringify(spec);
    return specifierInfoCache[cacheKey] ||
        (specifierInfoCache[cacheKey] = Object.create(null));
}
function keyFieldsFnFromSpecifier(specifier) {
    var info = lookupSpecifierInfo(specifier);
    return info.keyFieldsFn || (info.keyFieldsFn = function (object, context) {
        var extract = function (from, key) { return context.readField(key, from); };
        var keyObject = context.keyObject = collectSpecifierPaths(specifier, function (schemaKeyPath) {
            var extracted = extractKeyPath(context.storeObject, schemaKeyPath, extract);
            if (extracted === void 0 &&
                object !== context.storeObject &&
                hasOwn.call(object, schemaKeyPath[0])) {
                extracted = extractKeyPath(object, schemaKeyPath, extractKey);
            }
            __DEV__ ? invariant(extracted !== void 0, "Missing field '".concat(schemaKeyPath.join('.'), "' while extracting keyFields from ").concat(JSON.stringify(object))) : invariant(extracted !== void 0, 2);
            return extracted;
        });
        return "".concat(context.typename, ":").concat(JSON.stringify(keyObject));
    });
}
function keyArgsFnFromSpecifier(specifier) {
    var info = lookupSpecifierInfo(specifier);
    return info.keyArgsFn || (info.keyArgsFn = function (args, _a) {
        var field = _a.field, variables = _a.variables, fieldName = _a.fieldName;
        var collected = collectSpecifierPaths(specifier, function (keyPath) {
            var firstKey = keyPath[0];
            var firstChar = firstKey.charAt(0);
            if (firstChar === "@") {
                if (field && isNonEmptyArray(field.directives)) {
                    var directiveName_1 = firstKey.slice(1);
                    var d = field.directives.find(function (d) { return d.name.value === directiveName_1; });
                    var directiveArgs = d && argumentsObjectFromField(d, variables);
                    return directiveArgs && extractKeyPath(directiveArgs, keyPath.slice(1));
                }
                return;
            }
            if (firstChar === "$") {
                var variableName = firstKey.slice(1);
                if (variables && hasOwn.call(variables, variableName)) {
                    var varKeyPath = keyPath.slice(0);
                    varKeyPath[0] = variableName;
                    return extractKeyPath(variables, varKeyPath);
                }
                return;
            }
            if (args) {
                return extractKeyPath(args, keyPath);
            }
        });
        var suffix = JSON.stringify(collected);
        if (args || suffix !== "{}") {
            fieldName += ":" + suffix;
        }
        return fieldName;
    });
}
function collectSpecifierPaths(specifier, extractor) {
    var merger = new DeepMerger;
    return getSpecifierPaths(specifier).reduce(function (collected, path) {
        var _a;
        var toMerge = extractor(path);
        if (toMerge !== void 0) {
            for (var i = path.length - 1; i >= 0; --i) {
                toMerge = (_a = {}, _a[path[i]] = toMerge, _a);
            }
            collected = merger.merge(collected, toMerge);
        }
        return collected;
    }, Object.create(null));
}
function getSpecifierPaths(spec) {
    var info = lookupSpecifierInfo(spec);
    if (!info.paths) {
        var paths_1 = info.paths = [];
        var currentPath_1 = [];
        spec.forEach(function (s, i) {
            if (isArray$1(s)) {
                getSpecifierPaths(s).forEach(function (p) { return paths_1.push(currentPath_1.concat(p)); });
                currentPath_1.length = 0;
            }
            else {
                currentPath_1.push(s);
                if (!isArray$1(spec[i + 1])) {
                    paths_1.push(currentPath_1.slice(0));
                    currentPath_1.length = 0;
                }
            }
        });
    }
    return info.paths;
}
function extractKey(object, key) {
    return object[key];
}
function extractKeyPath(object, path, extract) {
    extract = extract || extractKey;
    return normalize$2(path.reduce(function reducer(obj, key) {
        return isArray$1(obj)
            ? obj.map(function (child) { return reducer(child, key); })
            : obj && extract(obj, key);
    }, object));
}
function normalize$2(value) {
    if (isNonNullObject(value)) {
        if (isArray$1(value)) {
            return value.map(normalize$2);
        }
        return collectSpecifierPaths(Object.keys(value).sort(), function (path) { return extractKeyPath(value, path); });
    }
    return value;
}

getStoreKeyName.setStringify(canonicalStringify);
function argsFromFieldSpecifier(spec) {
    return spec.args !== void 0 ? spec.args :
        spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;
}
var nullKeyFieldsFn = function () { return void 0; };
var simpleKeyArgsFn = function (_args, context) { return context.fieldName; };
var mergeTrueFn = function (existing, incoming, _a) {
    var mergeObjects = _a.mergeObjects;
    return mergeObjects(existing, incoming);
};
var mergeFalseFn = function (_, incoming) { return incoming; };
var Policies = (function () {
    function Policies(config) {
        this.config = config;
        this.typePolicies = Object.create(null);
        this.toBeAdded = Object.create(null);
        this.supertypeMap = new Map();
        this.fuzzySubtypes = new Map();
        this.rootIdsByTypename = Object.create(null);
        this.rootTypenamesById = Object.create(null);
        this.usingPossibleTypes = false;
        this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);
        this.cache = this.config.cache;
        this.setRootTypename("Query");
        this.setRootTypename("Mutation");
        this.setRootTypename("Subscription");
        if (config.possibleTypes) {
            this.addPossibleTypes(config.possibleTypes);
        }
        if (config.typePolicies) {
            this.addTypePolicies(config.typePolicies);
        }
    }
    Policies.prototype.identify = function (object, partialContext) {
        var _a;
        var policies = this;
        var typename = partialContext && (partialContext.typename ||
            ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename)) || object.__typename;
        if (typename === this.rootTypenamesById.ROOT_QUERY) {
            return ["ROOT_QUERY"];
        }
        var storeObject = partialContext && partialContext.storeObject || object;
        var context = __assign(__assign({}, partialContext), { typename: typename, storeObject: storeObject, readField: partialContext && partialContext.readField || function () {
                var options = normalizeReadFieldOptions(arguments, storeObject);
                return policies.readField(options, {
                    store: policies.cache["data"],
                    variables: options.variables,
                });
            } });
        var id;
        var policy = typename && this.getTypePolicy(typename);
        var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
        while (keyFn) {
            var specifierOrId = keyFn(object, context);
            if (isArray$1(specifierOrId)) {
                keyFn = keyFieldsFnFromSpecifier(specifierOrId);
            }
            else {
                id = specifierOrId;
                break;
            }
        }
        id = id ? String(id) : void 0;
        return context.keyObject ? [id, context.keyObject] : [id];
    };
    Policies.prototype.addTypePolicies = function (typePolicies) {
        var _this = this;
        Object.keys(typePolicies).forEach(function (typename) {
            var _a = typePolicies[typename], queryType = _a.queryType, mutationType = _a.mutationType, subscriptionType = _a.subscriptionType, incoming = __rest(_a, ["queryType", "mutationType", "subscriptionType"]);
            if (queryType)
                _this.setRootTypename("Query", typename);
            if (mutationType)
                _this.setRootTypename("Mutation", typename);
            if (subscriptionType)
                _this.setRootTypename("Subscription", typename);
            if (hasOwn.call(_this.toBeAdded, typename)) {
                _this.toBeAdded[typename].push(incoming);
            }
            else {
                _this.toBeAdded[typename] = [incoming];
            }
        });
    };
    Policies.prototype.updateTypePolicy = function (typename, incoming) {
        var _this = this;
        var existing = this.getTypePolicy(typename);
        var keyFields = incoming.keyFields, fields = incoming.fields;
        function setMerge(existing, merge) {
            existing.merge =
                typeof merge === "function" ? merge :
                    merge === true ? mergeTrueFn :
                        merge === false ? mergeFalseFn :
                            existing.merge;
        }
        setMerge(existing, incoming.merge);
        existing.keyFn =
            keyFields === false ? nullKeyFieldsFn :
                isArray$1(keyFields) ? keyFieldsFnFromSpecifier(keyFields) :
                    typeof keyFields === "function" ? keyFields :
                        existing.keyFn;
        if (fields) {
            Object.keys(fields).forEach(function (fieldName) {
                var existing = _this.getFieldPolicy(typename, fieldName, true);
                var incoming = fields[fieldName];
                if (typeof incoming === "function") {
                    existing.read = incoming;
                }
                else {
                    var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;
                    existing.keyFn =
                        keyArgs === false ? simpleKeyArgsFn :
                            isArray$1(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) :
                                typeof keyArgs === "function" ? keyArgs :
                                    existing.keyFn;
                    if (typeof read === "function") {
                        existing.read = read;
                    }
                    setMerge(existing, merge);
                }
                if (existing.read && existing.merge) {
                    existing.keyFn = existing.keyFn || simpleKeyArgsFn;
                }
            });
        }
    };
    Policies.prototype.setRootTypename = function (which, typename) {
        if (typename === void 0) { typename = which; }
        var rootId = "ROOT_" + which.toUpperCase();
        var old = this.rootTypenamesById[rootId];
        if (typename !== old) {
            __DEV__ ? invariant(!old || old === which, "Cannot change root ".concat(which, " __typename more than once")) : invariant(!old || old === which, 3);
            if (old)
                delete this.rootIdsByTypename[old];
            this.rootIdsByTypename[typename] = rootId;
            this.rootTypenamesById[rootId] = typename;
        }
    };
    Policies.prototype.addPossibleTypes = function (possibleTypes) {
        var _this = this;
        this.usingPossibleTypes = true;
        Object.keys(possibleTypes).forEach(function (supertype) {
            _this.getSupertypeSet(supertype, true);
            possibleTypes[supertype].forEach(function (subtype) {
                _this.getSupertypeSet(subtype, true).add(supertype);
                var match = subtype.match(TypeOrFieldNameRegExp);
                if (!match || match[0] !== subtype) {
                    _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
                }
            });
        });
    };
    Policies.prototype.getTypePolicy = function (typename) {
        var _this = this;
        if (!hasOwn.call(this.typePolicies, typename)) {
            var policy_1 = this.typePolicies[typename] = Object.create(null);
            policy_1.fields = Object.create(null);
            var supertypes = this.supertypeMap.get(typename);
            if (supertypes && supertypes.size) {
                supertypes.forEach(function (supertype) {
                    var _a = _this.getTypePolicy(supertype), fields = _a.fields, rest = __rest(_a, ["fields"]);
                    Object.assign(policy_1, rest);
                    Object.assign(policy_1.fields, fields);
                });
            }
        }
        var inbox = this.toBeAdded[typename];
        if (inbox && inbox.length) {
            inbox.splice(0).forEach(function (policy) {
                _this.updateTypePolicy(typename, policy);
            });
        }
        return this.typePolicies[typename];
    };
    Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {
        if (typename) {
            var fieldPolicies = this.getTypePolicy(typename).fields;
            return fieldPolicies[fieldName] || (createIfMissing && (fieldPolicies[fieldName] = Object.create(null)));
        }
    };
    Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {
        var supertypeSet = this.supertypeMap.get(subtype);
        if (!supertypeSet && createIfMissing) {
            this.supertypeMap.set(subtype, supertypeSet = new Set());
        }
        return supertypeSet;
    };
    Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {
        var _this = this;
        if (!fragment.typeCondition)
            return true;
        if (!typename)
            return false;
        var supertype = fragment.typeCondition.name.value;
        if (typename === supertype)
            return true;
        if (this.usingPossibleTypes &&
            this.supertypeMap.has(supertype)) {
            var typenameSupertypeSet = this.getSupertypeSet(typename, true);
            var workQueue_1 = [typenameSupertypeSet];
            var maybeEnqueue_1 = function (subtype) {
                var supertypeSet = _this.getSupertypeSet(subtype, false);
                if (supertypeSet &&
                    supertypeSet.size &&
                    workQueue_1.indexOf(supertypeSet) < 0) {
                    workQueue_1.push(supertypeSet);
                }
            };
            var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);
            var checkingFuzzySubtypes = false;
            for (var i = 0; i < workQueue_1.length; ++i) {
                var supertypeSet = workQueue_1[i];
                if (supertypeSet.has(supertype)) {
                    if (!typenameSupertypeSet.has(supertype)) {
                        if (checkingFuzzySubtypes) {
                            __DEV__ && invariant.warn("Inferring subtype ".concat(typename, " of supertype ").concat(supertype));
                        }
                        typenameSupertypeSet.add(supertype);
                    }
                    return true;
                }
                supertypeSet.forEach(maybeEnqueue_1);
                if (needToCheckFuzzySubtypes &&
                    i === workQueue_1.length - 1 &&
                    selectionSetMatchesResult(fragment.selectionSet, result, variables)) {
                    needToCheckFuzzySubtypes = false;
                    checkingFuzzySubtypes = true;
                    this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {
                        var match = typename.match(regExp);
                        if (match && match[0] === typename) {
                            maybeEnqueue_1(fuzzyString);
                        }
                    });
                }
            }
        }
        return false;
    };
    Policies.prototype.hasKeyArgs = function (typename, fieldName) {
        var policy = this.getFieldPolicy(typename, fieldName, false);
        return !!(policy && policy.keyFn);
    };
    Policies.prototype.getStoreFieldName = function (fieldSpec) {
        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
        var policy = this.getFieldPolicy(typename, fieldName, false);
        var storeFieldName;
        var keyFn = policy && policy.keyFn;
        if (keyFn && typename) {
            var context = {
                typename: typename,
                fieldName: fieldName,
                field: fieldSpec.field || null,
                variables: fieldSpec.variables,
            };
            var args = argsFromFieldSpecifier(fieldSpec);
            while (keyFn) {
                var specifierOrString = keyFn(args, context);
                if (isArray$1(specifierOrString)) {
                    keyFn = keyArgsFnFromSpecifier(specifierOrString);
                }
                else {
                    storeFieldName = specifierOrString || fieldName;
                    break;
                }
            }
        }
        if (storeFieldName === void 0) {
            storeFieldName = fieldSpec.field
                ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)
                : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
        }
        if (storeFieldName === false) {
            return fieldName;
        }
        return fieldName === fieldNameFromStoreName(storeFieldName)
            ? storeFieldName
            : fieldName + ":" + storeFieldName;
    };
    Policies.prototype.readField = function (options, context) {
        var objectOrReference = options.from;
        if (!objectOrReference)
            return;
        var nameOrField = options.field || options.fieldName;
        if (!nameOrField)
            return;
        if (options.typename === void 0) {
            var typename = context.store.getFieldValue(objectOrReference, "__typename");
            if (typename)
                options.typename = typename;
        }
        var storeFieldName = this.getStoreFieldName(options);
        var fieldName = fieldNameFromStoreName(storeFieldName);
        var existing = context.store.getFieldValue(objectOrReference, storeFieldName);
        var policy = this.getFieldPolicy(options.typename, fieldName, false);
        var read = policy && policy.read;
        if (read) {
            var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference)
                ? objectOrReference.__ref
                : objectOrReference, storeFieldName));
            return cacheSlot.withValue(this.cache, read, [existing, readOptions]);
        }
        return existing;
    };
    Policies.prototype.getReadFunction = function (typename, fieldName) {
        var policy = this.getFieldPolicy(typename, fieldName, false);
        return policy && policy.read;
    };
    Policies.prototype.getMergeFunction = function (parentTypename, fieldName, childTypename) {
        var policy = this.getFieldPolicy(parentTypename, fieldName, false);
        var merge = policy && policy.merge;
        if (!merge && childTypename) {
            policy = this.getTypePolicy(childTypename);
            merge = policy && policy.merge;
        }
        return merge;
    };
    Policies.prototype.runMergeFunction = function (existing, incoming, _a, context, storage) {
        var field = _a.field, typename = _a.typename, merge = _a.merge;
        if (merge === mergeTrueFn) {
            return makeMergeObjectsFunction(context.store)(existing, incoming);
        }
        if (merge === mergeFalseFn) {
            return incoming;
        }
        if (context.overwrite) {
            existing = void 0;
        }
        return merge(existing, incoming, makeFieldFunctionOptions(this, void 0, { typename: typename, fieldName: field.name.value, field: field, variables: context.variables }, context, storage || Object.create(null)));
    };
    return Policies;
}());
function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {
    var storeFieldName = policies.getStoreFieldName(fieldSpec);
    var fieldName = fieldNameFromStoreName(storeFieldName);
    var variables = fieldSpec.variables || context.variables;
    var _a = context.store, toReference = _a.toReference, canRead = _a.canRead;
    return {
        args: argsFromFieldSpecifier(fieldSpec),
        field: fieldSpec.field || null,
        fieldName: fieldName,
        storeFieldName: storeFieldName,
        variables: variables,
        isReference: isReference,
        toReference: toReference,
        storage: storage,
        cache: policies.cache,
        canRead: canRead,
        readField: function () {
            return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, context), context);
        },
        mergeObjects: makeMergeObjectsFunction(context.store),
    };
}
function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {
    var fieldNameOrOptions = readFieldArgs[0], from = readFieldArgs[1], argc = readFieldArgs.length;
    var options;
    if (typeof fieldNameOrOptions === "string") {
        options = {
            fieldName: fieldNameOrOptions,
            from: argc > 1 ? from : objectOrReference,
        };
    }
    else {
        options = __assign({}, fieldNameOrOptions);
        if (!hasOwn.call(options, "from")) {
            options.from = objectOrReference;
        }
    }
    if (__DEV__ && options.from === void 0) {
        __DEV__ && invariant.warn("Undefined 'from' passed to readField with arguments ".concat(stringifyForDisplay(Array.from(readFieldArgs))));
    }
    if (void 0 === options.variables) {
        options.variables = variables;
    }
    return options;
}
function makeMergeObjectsFunction(store) {
    return function mergeObjects(existing, incoming) {
        if (isArray$1(existing) || isArray$1(incoming)) {
            throw __DEV__ ? new InvariantError("Cannot automatically merge arrays") : new InvariantError(4);
        }
        if (isNonNullObject(existing) &&
            isNonNullObject(incoming)) {
            var eType = store.getFieldValue(existing, "__typename");
            var iType = store.getFieldValue(incoming, "__typename");
            var typesDiffer = eType && iType && eType !== iType;
            if (typesDiffer) {
                return incoming;
            }
            if (isReference(existing) &&
                storeValueIsStoreObject(incoming)) {
                store.merge(existing.__ref, incoming);
                return existing;
            }
            if (storeValueIsStoreObject(existing) &&
                isReference(incoming)) {
                store.merge(existing, incoming.__ref);
                return incoming;
            }
            if (storeValueIsStoreObject(existing) &&
                storeValueIsStoreObject(incoming)) {
                return __assign(__assign({}, existing), incoming);
            }
        }
        return incoming;
    };
}

function getContextFlavor(context, clientOnly, deferred) {
    var key = "".concat(clientOnly).concat(deferred);
    var flavored = context.flavors.get(key);
    if (!flavored) {
        context.flavors.set(key, flavored = (context.clientOnly === clientOnly &&
            context.deferred === deferred) ? context : __assign(__assign({}, context), { clientOnly: clientOnly, deferred: deferred }));
    }
    return flavored;
}
var StoreWriter = (function () {
    function StoreWriter(cache, reader) {
        this.cache = cache;
        this.reader = reader;
    }
    StoreWriter.prototype.writeToStore = function (store, _a) {
        var _this = this;
        var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;
        var operationDefinition = getOperationDefinition(query);
        var merger = makeProcessedFieldsMerger();
        variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);
        var context = {
            store: store,
            written: Object.create(null),
            merge: function (existing, incoming) {
                return merger.merge(existing, incoming);
            },
            variables: variables,
            varString: canonicalStringify(variables),
            fragmentMap: createFragmentMap(getFragmentDefinitions(query)),
            overwrite: !!overwrite,
            incomingById: new Map,
            clientOnly: false,
            deferred: false,
            flavors: new Map,
        };
        var ref = this.processSelectionSet({
            result: result || Object.create(null),
            dataId: dataId,
            selectionSet: operationDefinition.selectionSet,
            mergeTree: { map: new Map },
            context: context,
        });
        if (!isReference(ref)) {
            throw __DEV__ ? new InvariantError("Could not identify object ".concat(JSON.stringify(result))) : new InvariantError(6);
        }
        context.incomingById.forEach(function (_a, dataId) {
            var storeObject = _a.storeObject, mergeTree = _a.mergeTree, fieldNodeSet = _a.fieldNodeSet;
            var entityRef = makeReference(dataId);
            if (mergeTree && mergeTree.map.size) {
                var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);
                if (isReference(applied)) {
                    return;
                }
                storeObject = applied;
            }
            if (__DEV__ && !context.overwrite) {
                var fieldsWithSelectionSets_1 = Object.create(null);
                fieldNodeSet.forEach(function (field) {
                    if (field.selectionSet) {
                        fieldsWithSelectionSets_1[field.name.value] = true;
                    }
                });
                var hasSelectionSet_1 = function (storeFieldName) {
                    return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;
                };
                var hasMergeFunction_1 = function (storeFieldName) {
                    var childTree = mergeTree && mergeTree.map.get(storeFieldName);
                    return Boolean(childTree && childTree.info && childTree.info.merge);
                };
                Object.keys(storeObject).forEach(function (storeFieldName) {
                    if (hasSelectionSet_1(storeFieldName) &&
                        !hasMergeFunction_1(storeFieldName)) {
                        warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);
                    }
                });
            }
            store.merge(dataId, storeObject);
        });
        store.retain(ref.__ref);
        return ref;
    };
    StoreWriter.prototype.processSelectionSet = function (_a) {
        var _this = this;
        var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, mergeTree = _a.mergeTree;
        var policies = this.cache.policies;
        var incoming = Object.create(null);
        var typename = (dataId && policies.rootTypenamesById[dataId]) ||
            getTypenameFromResult(result, selectionSet, context.fragmentMap) ||
            (dataId && context.store.get(dataId, "__typename"));
        if ("string" === typeof typename) {
            incoming.__typename = typename;
        }
        var readField = function () {
            var options = normalizeReadFieldOptions(arguments, incoming, context.variables);
            if (isReference(options.from)) {
                var info = context.incomingById.get(options.from.__ref);
                if (info) {
                    var result_1 = policies.readField(__assign(__assign({}, options), { from: info.storeObject }), context);
                    if (result_1 !== void 0) {
                        return result_1;
                    }
                }
            }
            return policies.readField(options, context);
        };
        var fieldNodeSet = new Set();
        this.flattenFields(selectionSet, result, context, typename).forEach(function (context, field) {
            var _a;
            var resultFieldKey = resultKeyNameFromField(field);
            var value = result[resultFieldKey];
            fieldNodeSet.add(field);
            if (value !== void 0) {
                var storeFieldName = policies.getStoreFieldName({
                    typename: typename,
                    fieldName: field.name.value,
                    field: field,
                    variables: context.variables,
                });
                var childTree = getChildMergeTree(mergeTree, storeFieldName);
                var incomingValue = _this.processFieldValue(value, field, field.selectionSet
                    ? getContextFlavor(context, false, false)
                    : context, childTree);
                var childTypename = void 0;
                if (field.selectionSet &&
                    (isReference(incomingValue) ||
                        storeValueIsStoreObject(incomingValue))) {
                    childTypename = readField("__typename", incomingValue);
                }
                var merge = policies.getMergeFunction(typename, field.name.value, childTypename);
                if (merge) {
                    childTree.info = {
                        field: field,
                        typename: typename,
                        merge: merge,
                    };
                }
                else {
                    maybeRecycleChildMergeTree(mergeTree, storeFieldName);
                }
                incoming = context.merge(incoming, (_a = {},
                    _a[storeFieldName] = incomingValue,
                    _a));
            }
            else if (__DEV__ &&
                !context.clientOnly &&
                !context.deferred &&
                !addTypenameToDocument.added(field) &&
                !policies.getReadFunction(typename, field.name.value)) {
                __DEV__ && invariant.error("Missing field '".concat(resultKeyNameFromField(field), "' while writing result ").concat(JSON.stringify(result, null, 2)).substring(0, 1000));
            }
        });
        try {
            var _b = policies.identify(result, {
                typename: typename,
                selectionSet: selectionSet,
                fragmentMap: context.fragmentMap,
                storeObject: incoming,
                readField: readField,
            }), id = _b[0], keyObject = _b[1];
            dataId = dataId || id;
            if (keyObject) {
                incoming = context.merge(incoming, keyObject);
            }
        }
        catch (e) {
            if (!dataId)
                throw e;
        }
        if ("string" === typeof dataId) {
            var dataRef = makeReference(dataId);
            var sets = context.written[dataId] || (context.written[dataId] = []);
            if (sets.indexOf(selectionSet) >= 0)
                return dataRef;
            sets.push(selectionSet);
            if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {
                return dataRef;
            }
            var previous_1 = context.incomingById.get(dataId);
            if (previous_1) {
                previous_1.storeObject = context.merge(previous_1.storeObject, incoming);
                previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);
                fieldNodeSet.forEach(function (field) { return previous_1.fieldNodeSet.add(field); });
            }
            else {
                context.incomingById.set(dataId, {
                    storeObject: incoming,
                    mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
                    fieldNodeSet: fieldNodeSet,
                });
            }
            return dataRef;
        }
        return incoming;
    };
    StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {
        var _this = this;
        if (!field.selectionSet || value === null) {
            return __DEV__ ? cloneDeep(value) : value;
        }
        if (isArray$1(value)) {
            return value.map(function (item, i) {
                var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));
                maybeRecycleChildMergeTree(mergeTree, i);
                return value;
            });
        }
        return this.processSelectionSet({
            result: value,
            selectionSet: field.selectionSet,
            context: context,
            mergeTree: mergeTree,
        });
    };
    StoreWriter.prototype.flattenFields = function (selectionSet, result, context, typename) {
        if (typename === void 0) { typename = getTypenameFromResult(result, selectionSet, context.fragmentMap); }
        var fieldMap = new Map();
        var policies = this.cache.policies;
        var limitingTrie = new Trie(false);
        (function flatten(selectionSet, inheritedContext) {
            var visitedNode = limitingTrie.lookup(selectionSet, inheritedContext.clientOnly, inheritedContext.deferred);
            if (visitedNode.visited)
                return;
            visitedNode.visited = true;
            selectionSet.selections.forEach(function (selection) {
                if (!shouldInclude(selection, context.variables))
                    return;
                var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
                if (!(clientOnly && deferred) &&
                    isNonEmptyArray(selection.directives)) {
                    selection.directives.forEach(function (dir) {
                        var name = dir.name.value;
                        if (name === "client")
                            clientOnly = true;
                        if (name === "defer") {
                            var args = argumentsObjectFromField(dir, context.variables);
                            if (!args || args.if !== false) {
                                deferred = true;
                            }
                        }
                    });
                }
                if (isField(selection)) {
                    var existing = fieldMap.get(selection);
                    if (existing) {
                        clientOnly = clientOnly && existing.clientOnly;
                        deferred = deferred && existing.deferred;
                    }
                    fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));
                }
                else {
                    var fragment = getFragmentFromSelection(selection, context.fragmentMap);
                    if (fragment &&
                        policies.fragmentMatches(fragment, typename, result, context.variables)) {
                        flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));
                    }
                }
            });
        })(selectionSet, context);
        return fieldMap;
    };
    StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {
        var _a;
        var _this = this;
        if (mergeTree.map.size && !isReference(incoming)) {
            var e_1 = (!isArray$1(incoming) &&
                (isReference(existing) || storeValueIsStoreObject(existing))) ? existing : void 0;
            var i_1 = incoming;
            if (e_1 && !getStorageArgs) {
                getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];
            }
            var changedFields_1;
            var getValue_1 = function (from, name) {
                return isArray$1(from)
                    ? (typeof name === "number" ? from[name] : void 0)
                    : context.store.getFieldValue(from, String(name));
            };
            mergeTree.map.forEach(function (childTree, storeFieldName) {
                var eVal = getValue_1(e_1, storeFieldName);
                var iVal = getValue_1(i_1, storeFieldName);
                if (void 0 === iVal)
                    return;
                if (getStorageArgs) {
                    getStorageArgs.push(storeFieldName);
                }
                var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);
                if (aVal !== iVal) {
                    changedFields_1 = changedFields_1 || new Map;
                    changedFields_1.set(storeFieldName, aVal);
                }
                if (getStorageArgs) {
                    invariant(getStorageArgs.pop() === storeFieldName);
                }
            });
            if (changedFields_1) {
                incoming = (isArray$1(i_1) ? i_1.slice(0) : __assign({}, i_1));
                changedFields_1.forEach(function (value, name) {
                    incoming[name] = value;
                });
            }
        }
        if (mergeTree.info) {
            return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));
        }
        return incoming;
    };
    return StoreWriter;
}());
var emptyMergeTreePool = [];
function getChildMergeTree(_a, name) {
    var map = _a.map;
    if (!map.has(name)) {
        map.set(name, emptyMergeTreePool.pop() || { map: new Map });
    }
    return map.get(name);
}
function mergeMergeTrees(left, right) {
    if (left === right || !right || mergeTreeIsEmpty(right))
        return left;
    if (!left || mergeTreeIsEmpty(left))
        return right;
    var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;
    var needToMergeMaps = left.map.size && right.map.size;
    var map = needToMergeMaps ? new Map :
        left.map.size ? left.map : right.map;
    var merged = { info: info, map: map };
    if (needToMergeMaps) {
        var remainingRightKeys_1 = new Set(right.map.keys());
        left.map.forEach(function (leftTree, key) {
            merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));
            remainingRightKeys_1.delete(key);
        });
        remainingRightKeys_1.forEach(function (key) {
            merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));
        });
    }
    return merged;
}
function mergeTreeIsEmpty(tree) {
    return !tree || !(tree.info || tree.map.size);
}
function maybeRecycleChildMergeTree(_a, name) {
    var map = _a.map;
    var childTree = map.get(name);
    if (childTree && mergeTreeIsEmpty(childTree)) {
        emptyMergeTreePool.push(childTree);
        map.delete(name);
    }
}
var warnings = new Set();
function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
    var getChild = function (objOrRef) {
        var child = store.getFieldValue(objOrRef, storeFieldName);
        return typeof child === "object" && child;
    };
    var existing = getChild(existingRef);
    if (!existing)
        return;
    var incoming = getChild(incomingObj);
    if (!incoming)
        return;
    if (isReference(existing))
        return;
    if (equal(existing, incoming))
        return;
    if (Object.keys(existing).every(function (key) { return store.getFieldValue(incoming, key) !== void 0; })) {
        return;
    }
    var parentType = store.getFieldValue(existingRef, "__typename") ||
        store.getFieldValue(incomingObj, "__typename");
    var fieldName = fieldNameFromStoreName(storeFieldName);
    var typeDotName = "".concat(parentType, ".").concat(fieldName);
    if (warnings.has(typeDotName))
        return;
    warnings.add(typeDotName);
    var childTypenames = [];
    if (!isArray$1(existing) &&
        !isArray$1(incoming)) {
        [existing, incoming].forEach(function (child) {
            var typename = store.getFieldValue(child, "__typename");
            if (typeof typename === "string" &&
                !childTypenames.includes(typename)) {
                childTypenames.push(typename);
            }
        });
    }
    __DEV__ && invariant.warn("Cache data may be lost when replacing the ".concat(fieldName, " field of a ").concat(parentType, " object.\n\nTo address this problem (which is not a bug in Apollo Client), ").concat(childTypenames.length
        ? "either ensure all objects of type " +
            childTypenames.join(" and ") + " have an ID or a custom merge function, or "
        : "", "define a custom merge function for the ").concat(typeDotName, " field, so InMemoryCache can safely merge these objects:\n\n  existing: ").concat(JSON.stringify(existing).slice(0, 1000), "\n  incoming: ").concat(JSON.stringify(incoming).slice(0, 1000), "\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n"));
}

var InMemoryCache = (function (_super) {
    __extends(InMemoryCache, _super);
    function InMemoryCache(config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this) || this;
        _this.watches = new Set();
        _this.typenameDocumentCache = new Map();
        _this.makeVar = makeVar;
        _this.txCount = 0;
        _this.config = normalizeConfig(config);
        _this.addTypename = !!_this.config.addTypename;
        _this.policies = new Policies({
            cache: _this,
            dataIdFromObject: _this.config.dataIdFromObject,
            possibleTypes: _this.config.possibleTypes,
            typePolicies: _this.config.typePolicies,
        });
        _this.init();
        return _this;
    }
    InMemoryCache.prototype.init = function () {
        var rootStore = this.data = new EntityStore.Root({
            policies: this.policies,
            resultCaching: this.config.resultCaching,
        });
        this.optimisticData = rootStore.stump;
        this.resetResultCache();
    };
    InMemoryCache.prototype.resetResultCache = function (resetResultIdentities) {
        var _this = this;
        var previousReader = this.storeReader;
        this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({
            cache: this,
            addTypename: this.addTypename,
            resultCacheMaxSize: this.config.resultCacheMaxSize,
            canonizeResults: shouldCanonizeResults(this.config),
            canon: resetResultIdentities
                ? void 0
                : previousReader && previousReader.canon,
        }));
        this.maybeBroadcastWatch = wrap$1(function (c, options) {
            return _this.broadcastWatch(c, options);
        }, {
            max: this.config.resultCacheMaxSize,
            makeCacheKey: function (c) {
                var store = c.optimistic ? _this.optimisticData : _this.data;
                if (supportsResultCaching(store)) {
                    var optimistic = c.optimistic, rootId = c.rootId, variables = c.variables;
                    return store.makeCacheKey(c.query, c.callback, canonicalStringify({ optimistic: optimistic, rootId: rootId, variables: variables }));
                }
            }
        });
        new Set([
            this.data.group,
            this.optimisticData.group,
        ]).forEach(function (group) { return group.resetCaching(); });
    };
    InMemoryCache.prototype.restore = function (data) {
        this.init();
        if (data)
            this.data.replace(data);
        return this;
    };
    InMemoryCache.prototype.extract = function (optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        return (optimistic ? this.optimisticData : this.data).extract();
    };
    InMemoryCache.prototype.read = function (options) {
        var _a = options.returnPartialData, returnPartialData = _a === void 0 ? false : _a;
        try {
            return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData: returnPartialData })).result || null;
        }
        catch (e) {
            if (e instanceof MissingFieldError) {
                return null;
            }
            throw e;
        }
    };
    InMemoryCache.prototype.write = function (options) {
        try {
            ++this.txCount;
            return this.storeWriter.writeToStore(this.data, options);
        }
        finally {
            if (!--this.txCount && options.broadcast !== false) {
                this.broadcastWatches();
            }
        }
    };
    InMemoryCache.prototype.modify = function (options) {
        if (hasOwn.call(options, "id") && !options.id) {
            return false;
        }
        var store = options.optimistic
            ? this.optimisticData
            : this.data;
        try {
            ++this.txCount;
            return store.modify(options.id || "ROOT_QUERY", options.fields);
        }
        finally {
            if (!--this.txCount && options.broadcast !== false) {
                this.broadcastWatches();
            }
        }
    };
    InMemoryCache.prototype.diff = function (options) {
        return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || "ROOT_QUERY", config: this.config }));
    };
    InMemoryCache.prototype.watch = function (watch) {
        var _this = this;
        if (!this.watches.size) {
            recallCache(this);
        }
        this.watches.add(watch);
        if (watch.immediate) {
            this.maybeBroadcastWatch(watch);
        }
        return function () {
            if (_this.watches.delete(watch) && !_this.watches.size) {
                forgetCache(_this);
            }
            _this.maybeBroadcastWatch.forget(watch);
        };
    };
    InMemoryCache.prototype.gc = function (options) {
        canonicalStringify.reset();
        var ids = this.optimisticData.gc();
        if (options && !this.txCount) {
            if (options.resetResultCache) {
                this.resetResultCache(options.resetResultIdentities);
            }
            else if (options.resetResultIdentities) {
                this.storeReader.resetCanon();
            }
        }
        return ids;
    };
    InMemoryCache.prototype.retain = function (rootId, optimistic) {
        return (optimistic ? this.optimisticData : this.data).retain(rootId);
    };
    InMemoryCache.prototype.release = function (rootId, optimistic) {
        return (optimistic ? this.optimisticData : this.data).release(rootId);
    };
    InMemoryCache.prototype.identify = function (object) {
        if (isReference(object))
            return object.__ref;
        try {
            return this.policies.identify(object)[0];
        }
        catch (e) {
            __DEV__ && invariant.warn(e);
        }
    };
    InMemoryCache.prototype.evict = function (options) {
        if (!options.id) {
            if (hasOwn.call(options, "id")) {
                return false;
            }
            options = __assign(__assign({}, options), { id: "ROOT_QUERY" });
        }
        try {
            ++this.txCount;
            return this.optimisticData.evict(options, this.data);
        }
        finally {
            if (!--this.txCount && options.broadcast !== false) {
                this.broadcastWatches();
            }
        }
    };
    InMemoryCache.prototype.reset = function (options) {
        var _this = this;
        this.init();
        canonicalStringify.reset();
        if (options && options.discardWatches) {
            this.watches.forEach(function (watch) { return _this.maybeBroadcastWatch.forget(watch); });
            this.watches.clear();
            forgetCache(this);
        }
        else {
            this.broadcastWatches();
        }
        return Promise.resolve();
    };
    InMemoryCache.prototype.removeOptimistic = function (idToRemove) {
        var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
        if (newOptimisticData !== this.optimisticData) {
            this.optimisticData = newOptimisticData;
            this.broadcastWatches();
        }
    };
    InMemoryCache.prototype.batch = function (options) {
        var _this = this;
        var update = options.update, _a = options.optimistic, optimistic = _a === void 0 ? true : _a, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;
        var updateResult;
        var perform = function (layer) {
            var _a = _this, data = _a.data, optimisticData = _a.optimisticData;
            ++_this.txCount;
            if (layer) {
                _this.data = _this.optimisticData = layer;
            }
            try {
                return updateResult = update(_this);
            }
            finally {
                --_this.txCount;
                _this.data = data;
                _this.optimisticData = optimisticData;
            }
        };
        var alreadyDirty = new Set();
        if (onWatchUpdated && !this.txCount) {
            this.broadcastWatches(__assign(__assign({}, options), { onWatchUpdated: function (watch) {
                    alreadyDirty.add(watch);
                    return false;
                } }));
        }
        if (typeof optimistic === 'string') {
            this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
        }
        else if (optimistic === false) {
            perform(this.data);
        }
        else {
            perform();
        }
        if (typeof removeOptimistic === "string") {
            this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
        }
        if (onWatchUpdated && alreadyDirty.size) {
            this.broadcastWatches(__assign(__assign({}, options), { onWatchUpdated: function (watch, diff) {
                    var result = onWatchUpdated.call(this, watch, diff);
                    if (result !== false) {
                        alreadyDirty.delete(watch);
                    }
                    return result;
                } }));
            if (alreadyDirty.size) {
                alreadyDirty.forEach(function (watch) { return _this.maybeBroadcastWatch.dirty(watch); });
            }
        }
        else {
            this.broadcastWatches(options);
        }
        return updateResult;
    };
    InMemoryCache.prototype.performTransaction = function (update, optimisticId) {
        return this.batch({
            update: update,
            optimistic: optimisticId || (optimisticId !== null),
        });
    };
    InMemoryCache.prototype.transformDocument = function (document) {
        if (this.addTypename) {
            var result = this.typenameDocumentCache.get(document);
            if (!result) {
                result = addTypenameToDocument(document);
                this.typenameDocumentCache.set(document, result);
                this.typenameDocumentCache.set(result, result);
            }
            return result;
        }
        return document;
    };
    InMemoryCache.prototype.broadcastWatches = function (options) {
        var _this = this;
        if (!this.txCount) {
            this.watches.forEach(function (c) { return _this.maybeBroadcastWatch(c, options); });
        }
    };
    InMemoryCache.prototype.broadcastWatch = function (c, options) {
        var lastDiff = c.lastDiff;
        var diff = this.diff(c);
        if (options) {
            if (c.optimistic &&
                typeof options.optimistic === "string") {
                diff.fromOptimisticTransaction = true;
            }
            if (options.onWatchUpdated &&
                options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {
                return;
            }
        }
        if (!lastDiff || !equal(lastDiff.result, diff.result)) {
            c.callback(c.lastDiff = diff, lastDiff);
        }
    };
    return InMemoryCache;
}(ApolloCache));

function isApolloError(err) {
    return err.hasOwnProperty('graphQLErrors');
}
var generateErrorMessage = function (err) {
    var message = '';
    if (isNonEmptyArray(err.graphQLErrors) || isNonEmptyArray(err.clientErrors)) {
        var errors = (err.graphQLErrors || [])
            .concat(err.clientErrors || []);
        errors.forEach(function (error) {
            var errorMessage = error
                ? error.message
                : 'Error message not found.';
            message += "".concat(errorMessage, "\n");
        });
    }
    if (err.networkError) {
        message += "".concat(err.networkError.message, "\n");
    }
    message = message.replace(/\n$/, '');
    return message;
};
var ApolloError = (function (_super) {
    __extends(ApolloError, _super);
    function ApolloError(_a) {
        var graphQLErrors = _a.graphQLErrors, clientErrors = _a.clientErrors, networkError = _a.networkError, errorMessage = _a.errorMessage, extraInfo = _a.extraInfo;
        var _this = _super.call(this, errorMessage) || this;
        _this.graphQLErrors = graphQLErrors || [];
        _this.clientErrors = clientErrors || [];
        _this.networkError = networkError || null;
        _this.message = errorMessage || generateErrorMessage(_this);
        _this.extraInfo = extraInfo;
        _this.__proto__ = ApolloError.prototype;
        return _this;
    }
    return ApolloError;
}(Error));

var NetworkStatus;
(function (NetworkStatus) {
    NetworkStatus[NetworkStatus["loading"] = 1] = "loading";
    NetworkStatus[NetworkStatus["setVariables"] = 2] = "setVariables";
    NetworkStatus[NetworkStatus["fetchMore"] = 3] = "fetchMore";
    NetworkStatus[NetworkStatus["refetch"] = 4] = "refetch";
    NetworkStatus[NetworkStatus["poll"] = 6] = "poll";
    NetworkStatus[NetworkStatus["ready"] = 7] = "ready";
    NetworkStatus[NetworkStatus["error"] = 8] = "error";
})(NetworkStatus || (NetworkStatus = {}));
function isNetworkRequestInFlight(networkStatus) {
    return networkStatus ? networkStatus < 7 : false;
}

var assign$1 = Object.assign, hasOwnProperty$2 = Object.hasOwnProperty;
var ObservableQuery = (function (_super) {
    __extends(ObservableQuery, _super);
    function ObservableQuery(_a) {
        var queryManager = _a.queryManager, queryInfo = _a.queryInfo, options = _a.options;
        var _this = _super.call(this, function (observer) {
            try {
                var subObserver = observer._subscription._observer;
                if (subObserver && !subObserver.error) {
                    subObserver.error = defaultSubscriptionObserverErrorCallback;
                }
            }
            catch (_a) { }
            var first = !_this.observers.size;
            _this.observers.add(observer);
            var last = _this.last;
            if (last && last.error) {
                observer.error && observer.error(last.error);
            }
            else if (last && last.result) {
                observer.next && observer.next(last.result);
            }
            if (first) {
                _this.reobserve().catch(function () { });
            }
            return function () {
                if (_this.observers.delete(observer) && !_this.observers.size) {
                    _this.tearDownQuery();
                }
            };
        }) || this;
        _this.observers = new Set();
        _this.subscriptions = new Set();
        _this.queryInfo = queryInfo;
        _this.queryManager = queryManager;
        _this.isTornDown = false;
        var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
        var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? (fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy) : _f;
        _this.options = __assign(__assign({}, options), { initialFetchPolicy: initialFetchPolicy, fetchPolicy: fetchPolicy });
        _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
        var opDef = getOperationDefinition(_this.query);
        _this.queryName = opDef && opDef.name && opDef.name.value;
        return _this;
    }
    Object.defineProperty(ObservableQuery.prototype, "query", {
        get: function () {
            return this.queryManager.transform(this.options.query).document;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ObservableQuery.prototype, "variables", {
        get: function () {
            return this.options.variables;
        },
        enumerable: false,
        configurable: true
    });
    ObservableQuery.prototype.result = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var observer = {
                next: function (result) {
                    resolve(result);
                    _this.observers.delete(observer);
                    if (!_this.observers.size) {
                        _this.queryManager.removeQuery(_this.queryId);
                    }
                    setTimeout(function () {
                        subscription.unsubscribe();
                    }, 0);
                },
                error: reject,
            };
            var subscription = _this.subscribe(observer);
        });
    };
    ObservableQuery.prototype.getCurrentResult = function (saveAsLastResult) {
        if (saveAsLastResult === void 0) { saveAsLastResult = true; }
        var lastResult = this.getLastResult(true);
        var networkStatus = this.queryInfo.networkStatus ||
            (lastResult && lastResult.networkStatus) ||
            NetworkStatus.ready;
        var result = __assign(__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus: networkStatus });
        var _a = this.options.fetchPolicy, fetchPolicy = _a === void 0 ? "cache-first" : _a;
        if (fetchPolicy === 'network-only' ||
            fetchPolicy === 'no-cache' ||
            fetchPolicy === 'standby' ||
            this.queryManager.transform(this.options.query).hasForcedResolvers) ;
        else {
            var diff = this.queryInfo.getDiff();
            if (diff.complete || this.options.returnPartialData) {
                result.data = diff.result;
            }
            if (equal(result.data, {})) {
                result.data = void 0;
            }
            if (diff.complete) {
                delete result.partial;
                if (diff.complete &&
                    result.networkStatus === NetworkStatus.loading &&
                    (fetchPolicy === 'cache-first' ||
                        fetchPolicy === 'cache-only')) {
                    result.networkStatus = NetworkStatus.ready;
                    result.loading = false;
                }
            }
            else {
                result.partial = true;
            }
            if (__DEV__ &&
                !diff.complete &&
                !this.options.partialRefetch &&
                !result.loading &&
                !result.data &&
                !result.error) {
                logMissingFieldErrors(diff.missing);
            }
        }
        if (saveAsLastResult) {
            this.updateLastResult(result);
        }
        return result;
    };
    ObservableQuery.prototype.isDifferentFromLastResult = function (newResult) {
        return !this.last || !equal(this.last.result, newResult);
    };
    ObservableQuery.prototype.getLast = function (key, variablesMustMatch) {
        var last = this.last;
        if (last &&
            last[key] &&
            (!variablesMustMatch || equal(last.variables, this.variables))) {
            return last[key];
        }
    };
    ObservableQuery.prototype.getLastResult = function (variablesMustMatch) {
        return this.getLast("result", variablesMustMatch);
    };
    ObservableQuery.prototype.getLastError = function (variablesMustMatch) {
        return this.getLast("error", variablesMustMatch);
    };
    ObservableQuery.prototype.resetLastResults = function () {
        delete this.last;
        this.isTornDown = false;
    };
    ObservableQuery.prototype.resetQueryStoreErrors = function () {
        this.queryManager.resetErrors(this.queryId);
    };
    ObservableQuery.prototype.refetch = function (variables) {
        var _a;
        var reobserveOptions = {
            pollInterval: 0,
        };
        var fetchPolicy = this.options.fetchPolicy;
        if (fetchPolicy === 'cache-and-network') {
            reobserveOptions.fetchPolicy = fetchPolicy;
        }
        else if (fetchPolicy === 'no-cache') {
            reobserveOptions.fetchPolicy = 'no-cache';
        }
        else {
            reobserveOptions.fetchPolicy = 'network-only';
        }
        if (__DEV__ && variables && hasOwnProperty$2.call(variables, "variables")) {
            var queryDef = getQueryDefinition(this.query);
            var vars = queryDef.variableDefinitions;
            if (!vars || !vars.some(function (v) { return v.variable.name.value === "variables"; })) {
                __DEV__ && invariant.warn("Called refetch(".concat(JSON.stringify(variables), ") for query ").concat(((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || JSON.stringify(queryDef), ", which does not declare a $variables variable.\nDid you mean to call refetch(variables) instead of refetch({ variables })?"));
            }
        }
        if (variables && !equal(this.options.variables, variables)) {
            reobserveOptions.variables = this.options.variables = __assign(__assign({}, this.options.variables), variables);
        }
        this.queryInfo.resetLastWrite();
        return this.reobserve(reobserveOptions, NetworkStatus.refetch);
    };
    ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {
        var _this = this;
        var combinedOptions = __assign(__assign({}, (fetchMoreOptions.query ? fetchMoreOptions : __assign(__assign(__assign(__assign({}, this.options), { query: this.query }), fetchMoreOptions), { variables: __assign(__assign({}, this.options.variables), fetchMoreOptions.variables) }))), { fetchPolicy: "no-cache" });
        var qid = this.queryManager.generateQueryId();
        var queryInfo = this.queryInfo;
        var originalNetworkStatus = queryInfo.networkStatus;
        queryInfo.networkStatus = NetworkStatus.fetchMore;
        if (combinedOptions.notifyOnNetworkStatusChange) {
            this.observe();
        }
        var updatedQuerySet = new Set();
        return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function (fetchMoreResult) {
            _this.queryManager.removeQuery(qid);
            if (queryInfo.networkStatus === NetworkStatus.fetchMore) {
                queryInfo.networkStatus = originalNetworkStatus;
            }
            _this.queryManager.cache.batch({
                update: function (cache) {
                    var updateQuery = fetchMoreOptions.updateQuery;
                    if (updateQuery) {
                        cache.updateQuery({
                            query: _this.query,
                            variables: _this.variables,
                            returnPartialData: true,
                            optimistic: false,
                        }, function (previous) { return updateQuery(previous, {
                            fetchMoreResult: fetchMoreResult.data,
                            variables: combinedOptions.variables,
                        }); });
                    }
                    else {
                        cache.writeQuery({
                            query: combinedOptions.query,
                            variables: combinedOptions.variables,
                            data: fetchMoreResult.data,
                        });
                    }
                },
                onWatchUpdated: function (watch) {
                    updatedQuerySet.add(watch.query);
                },
            });
            return fetchMoreResult;
        }).finally(function () {
            if (!updatedQuerySet.has(_this.query)) {
                reobserveCacheFirst(_this);
            }
        });
    };
    ObservableQuery.prototype.subscribeToMore = function (options) {
        var _this = this;
        var subscription = this.queryManager
            .startGraphQLSubscription({
            query: options.document,
            variables: options.variables,
            context: options.context,
        })
            .subscribe({
            next: function (subscriptionData) {
                var updateQuery = options.updateQuery;
                if (updateQuery) {
                    _this.updateQuery(function (previous, _a) {
                        var variables = _a.variables;
                        return updateQuery(previous, {
                            subscriptionData: subscriptionData,
                            variables: variables,
                        });
                    });
                }
            },
            error: function (err) {
                if (options.onError) {
                    options.onError(err);
                    return;
                }
                __DEV__ && invariant.error('Unhandled GraphQL subscription error', err);
            },
        });
        this.subscriptions.add(subscription);
        return function () {
            if (_this.subscriptions.delete(subscription)) {
                subscription.unsubscribe();
            }
        };
    };
    ObservableQuery.prototype.setOptions = function (newOptions) {
        return this.reobserve(newOptions);
    };
    ObservableQuery.prototype.setVariables = function (variables) {
        if (equal(this.variables, variables)) {
            return this.observers.size
                ? this.result()
                : Promise.resolve();
        }
        this.options.variables = variables;
        if (!this.observers.size) {
            return Promise.resolve();
        }
        return this.reobserve({
            fetchPolicy: this.options.initialFetchPolicy,
            variables: variables,
        }, NetworkStatus.setVariables);
    };
    ObservableQuery.prototype.updateQuery = function (mapFn) {
        var queryManager = this.queryManager;
        var result = queryManager.cache.diff({
            query: this.options.query,
            variables: this.variables,
            returnPartialData: true,
            optimistic: false,
        }).result;
        var newResult = mapFn(result, {
            variables: this.variables,
        });
        if (newResult) {
            queryManager.cache.writeQuery({
                query: this.options.query,
                data: newResult,
                variables: this.variables,
            });
            queryManager.broadcastQueries();
        }
    };
    ObservableQuery.prototype.startPolling = function (pollInterval) {
        this.options.pollInterval = pollInterval;
        this.updatePolling();
    };
    ObservableQuery.prototype.stopPolling = function () {
        this.options.pollInterval = 0;
        this.updatePolling();
    };
    ObservableQuery.prototype.applyNextFetchPolicy = function (reason, options) {
        if (options.nextFetchPolicy) {
            var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? "cache-first" : _a, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;
            if (typeof options.nextFetchPolicy === "function") {
                options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {
                    reason: reason,
                    options: options,
                    observable: this,
                    initialFetchPolicy: initialFetchPolicy,
                });
            }
            else if (reason === "variables-changed") {
                options.fetchPolicy = initialFetchPolicy;
            }
            else {
                options.fetchPolicy = options.nextFetchPolicy;
            }
        }
        return options.fetchPolicy;
    };
    ObservableQuery.prototype.fetch = function (options, newNetworkStatus) {
        this.queryManager.setObservableQuery(this);
        return this.queryManager.fetchQueryObservable(this.queryId, options, newNetworkStatus);
    };
    ObservableQuery.prototype.updatePolling = function () {
        var _this = this;
        if (this.queryManager.ssrMode) {
            return;
        }
        var _a = this, pollingInfo = _a.pollingInfo, pollInterval = _a.options.pollInterval;
        if (!pollInterval) {
            if (pollingInfo) {
                clearTimeout(pollingInfo.timeout);
                delete this.pollingInfo;
            }
            return;
        }
        if (pollingInfo &&
            pollingInfo.interval === pollInterval) {
            return;
        }
        __DEV__ ? invariant(pollInterval, 'Attempted to start a polling query without a polling interval.') : invariant(pollInterval, 10);
        var info = pollingInfo || (this.pollingInfo = {});
        info.interval = pollInterval;
        var maybeFetch = function () {
            if (_this.pollingInfo) {
                if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus)) {
                    _this.reobserve({
                        fetchPolicy: "network-only",
                    }, NetworkStatus.poll).then(poll, poll);
                }
                else {
                    poll();
                }
            }
        };
        var poll = function () {
            var info = _this.pollingInfo;
            if (info) {
                clearTimeout(info.timeout);
                info.timeout = setTimeout(maybeFetch, info.interval);
            }
        };
        poll();
    };
    ObservableQuery.prototype.updateLastResult = function (newResult, variables) {
        if (variables === void 0) { variables = this.variables; }
        this.last = __assign(__assign({}, this.last), { result: this.queryManager.assumeImmutableResults
                ? newResult
                : cloneDeep(newResult), variables: variables });
        if (!isNonEmptyArray(newResult.errors)) {
            delete this.last.error;
        }
        return this.last;
    };
    ObservableQuery.prototype.reobserve = function (newOptions, newNetworkStatus) {
        var _this = this;
        this.isTornDown = false;
        var useDisposableConcast = newNetworkStatus === NetworkStatus.refetch ||
            newNetworkStatus === NetworkStatus.fetchMore ||
            newNetworkStatus === NetworkStatus.poll;
        var oldVariables = this.options.variables;
        var oldFetchPolicy = this.options.fetchPolicy;
        var mergedOptions = compact(this.options, newOptions || {});
        var options = useDisposableConcast
            ? mergedOptions
            : assign$1(this.options, mergedOptions);
        if (!useDisposableConcast) {
            this.updatePolling();
            if (newOptions &&
                newOptions.variables &&
                !equal(newOptions.variables, oldVariables) &&
                (!newOptions.fetchPolicy || newOptions.fetchPolicy === oldFetchPolicy)) {
                this.applyNextFetchPolicy("variables-changed", options);
                if (newNetworkStatus === void 0) {
                    newNetworkStatus = NetworkStatus.setVariables;
                }
            }
        }
        var variables = options.variables && __assign({}, options.variables);
        var concast = this.fetch(options, newNetworkStatus);
        var observer = {
            next: function (result) {
                _this.reportResult(result, variables);
            },
            error: function (error) {
                _this.reportError(error, variables);
            },
        };
        if (!useDisposableConcast) {
            if (this.concast && this.observer) {
                this.concast.removeObserver(this.observer, true);
            }
            this.concast = concast;
            this.observer = observer;
        }
        concast.addObserver(observer);
        return concast.promise;
    };
    ObservableQuery.prototype.observe = function () {
        this.reportResult(this.getCurrentResult(false), this.variables);
    };
    ObservableQuery.prototype.reportResult = function (result, variables) {
        var lastError = this.getLastError();
        if (lastError || this.isDifferentFromLastResult(result)) {
            if (lastError || !result.partial || this.options.returnPartialData) {
                this.updateLastResult(result, variables);
            }
            iterateObserversSafely(this.observers, 'next', result);
        }
    };
    ObservableQuery.prototype.reportError = function (error, variables) {
        var errorResult = __assign(__assign({}, this.getLastResult()), { error: error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });
        this.updateLastResult(errorResult, variables);
        iterateObserversSafely(this.observers, 'error', this.last.error = error);
    };
    ObservableQuery.prototype.hasObservers = function () {
        return this.observers.size > 0;
    };
    ObservableQuery.prototype.tearDownQuery = function () {
        if (this.isTornDown)
            return;
        if (this.concast && this.observer) {
            this.concast.removeObserver(this.observer);
            delete this.concast;
            delete this.observer;
        }
        this.stopPolling();
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        this.subscriptions.clear();
        this.queryManager.stopQuery(this.queryId);
        this.observers.clear();
        this.isTornDown = true;
    };
    return ObservableQuery;
}(Observable));
fixObservableSubclass(ObservableQuery);
function reobserveCacheFirst(obsQuery) {
    var _a = obsQuery.options, fetchPolicy = _a.fetchPolicy, nextFetchPolicy = _a.nextFetchPolicy;
    if (fetchPolicy === "cache-and-network" ||
        fetchPolicy === "network-only") {
        return obsQuery.reobserve({
            fetchPolicy: "cache-first",
            nextFetchPolicy: function () {
                this.nextFetchPolicy = nextFetchPolicy;
                if (typeof nextFetchPolicy === "function") {
                    return nextFetchPolicy.apply(this, arguments);
                }
                return fetchPolicy;
            },
        });
    }
    return obsQuery.reobserve();
}
function defaultSubscriptionObserverErrorCallback(error) {
    __DEV__ && invariant.error('Unhandled error', error.message, error.stack);
}
function logMissingFieldErrors(missing) {
    if (__DEV__ && missing) {
        __DEV__ && invariant.debug("Missing cache result fields: ".concat(JSON.stringify(missing)), missing);
    }
}

var LocalState = (function () {
    function LocalState(_a) {
        var cache = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;
        this.cache = cache;
        if (client) {
            this.client = client;
        }
        if (resolvers) {
            this.addResolvers(resolvers);
        }
        if (fragmentMatcher) {
            this.setFragmentMatcher(fragmentMatcher);
        }
    }
    LocalState.prototype.addResolvers = function (resolvers) {
        var _this = this;
        this.resolvers = this.resolvers || {};
        if (Array.isArray(resolvers)) {
            resolvers.forEach(function (resolverGroup) {
                _this.resolvers = mergeDeep$1(_this.resolvers, resolverGroup);
            });
        }
        else {
            this.resolvers = mergeDeep$1(this.resolvers, resolvers);
        }
    };
    LocalState.prototype.setResolvers = function (resolvers) {
        this.resolvers = {};
        this.addResolvers(resolvers);
    };
    LocalState.prototype.getResolvers = function () {
        return this.resolvers || {};
    };
    LocalState.prototype.runResolvers = function (_a) {
        var document = _a.document, remoteResult = _a.remoteResult, context = _a.context, variables = _a.variables, _b = _a.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_c) {
                if (document) {
                    return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) { return (__assign(__assign({}, remoteResult), { data: localResult.result })); })];
                }
                return [2, remoteResult];
            });
        });
    };
    LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {
        this.fragmentMatcher = fragmentMatcher;
    };
    LocalState.prototype.getFragmentMatcher = function () {
        return this.fragmentMatcher;
    };
    LocalState.prototype.clientQuery = function (document) {
        if (hasDirectives(['client'], document)) {
            if (this.resolvers) {
                return document;
            }
        }
        return null;
    };
    LocalState.prototype.serverQuery = function (document) {
        return removeClientSetsFromDocument(document);
    };
    LocalState.prototype.prepareContext = function (context) {
        var cache = this.cache;
        return __assign(__assign({}, context), { cache: cache, getCacheKey: function (obj) {
                return cache.identify(obj);
            } });
    };
    LocalState.prototype.addExportedVariables = function (document, variables, context) {
        if (variables === void 0) { variables = {}; }
        if (context === void 0) { context = {}; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (document) {
                    return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) { return (__assign(__assign({}, variables), data.exportedVariables)); })];
                }
                return [2, __assign({}, variables)];
            });
        });
    };
    LocalState.prototype.shouldForceResolvers = function (document) {
        var forceResolvers = false;
        visit(document, {
            Directive: {
                enter: function (node) {
                    if (node.name.value === 'client' && node.arguments) {
                        forceResolvers = node.arguments.some(function (arg) {
                            return arg.name.value === 'always' &&
                                arg.value.kind === 'BooleanValue' &&
                                arg.value.value === true;
                        });
                        if (forceResolvers) {
                            return BREAK;
                        }
                    }
                },
            },
        });
        return forceResolvers;
    };
    LocalState.prototype.buildRootValueFromCache = function (document, variables) {
        return this.cache.diff({
            query: buildQueryFromSelectionSet(document),
            variables: variables,
            returnPartialData: true,
            optimistic: false,
        }).result;
    };
    LocalState.prototype.resolveDocument = function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
        if (context === void 0) { context = {}; }
        if (variables === void 0) { variables = {}; }
        if (fragmentMatcher === void 0) { fragmentMatcher = function () { return true; }; }
        if (onlyRunForcedResolvers === void 0) { onlyRunForcedResolvers = false; }
        return __awaiter(this, void 0, void 0, function () {
            var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a, cache, client, execContext;
            return __generator(this, function (_b) {
                mainDefinition = getMainDefinition(document);
                fragments = getFragmentDefinitions(document);
                fragmentMap = createFragmentMap(fragments);
                definitionOperation = mainDefinition
                    .operation;
                defaultOperationType = definitionOperation
                    ? definitionOperation.charAt(0).toUpperCase() +
                        definitionOperation.slice(1)
                    : 'Query';
                _a = this, cache = _a.cache, client = _a.client;
                execContext = {
                    fragmentMap: fragmentMap,
                    context: __assign(__assign({}, context), { cache: cache, client: client }),
                    variables: variables,
                    fragmentMatcher: fragmentMatcher,
                    defaultOperationType: defaultOperationType,
                    exportedVariables: {},
                    onlyRunForcedResolvers: onlyRunForcedResolvers,
                };
                return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function (result) { return ({
                        result: result,
                        exportedVariables: execContext.exportedVariables,
                    }); })];
            });
        });
    };
    LocalState.prototype.resolveSelectionSet = function (selectionSet, rootValue, execContext) {
        return __awaiter(this, void 0, void 0, function () {
            var fragmentMap, context, variables, resultsToMerge, execute;
            var _this = this;
            return __generator(this, function (_a) {
                fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
                resultsToMerge = [rootValue];
                execute = function (selection) { return __awaiter(_this, void 0, void 0, function () {
                    var fragment, typeCondition;
                    return __generator(this, function (_a) {
                        if (!shouldInclude(selection, variables)) {
                            return [2];
                        }
                        if (isField(selection)) {
                            return [2, this.resolveField(selection, rootValue, execContext).then(function (fieldResult) {
                                    var _a;
                                    if (typeof fieldResult !== 'undefined') {
                                        resultsToMerge.push((_a = {},
                                            _a[resultKeyNameFromField(selection)] = fieldResult,
                                            _a));
                                    }
                                })];
                        }
                        if (isInlineFragment(selection)) {
                            fragment = selection;
                        }
                        else {
                            fragment = fragmentMap[selection.name.value];
                            __DEV__ ? invariant(fragment, "No fragment named ".concat(selection.name.value)) : invariant(fragment, 9);
                        }
                        if (fragment && fragment.typeCondition) {
                            typeCondition = fragment.typeCondition.name.value;
                            if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                                return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function (fragmentResult) {
                                        resultsToMerge.push(fragmentResult);
                                    })];
                            }
                        }
                        return [2];
                    });
                }); };
                return [2, Promise.all(selectionSet.selections.map(execute)).then(function () {
                        return mergeDeepArray(resultsToMerge);
                    })];
            });
        });
    };
    LocalState.prototype.resolveField = function (field, rootValue, execContext) {
        return __awaiter(this, void 0, void 0, function () {
            var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
            var _this = this;
            return __generator(this, function (_a) {
                variables = execContext.variables;
                fieldName = field.name.value;
                aliasedFieldName = resultKeyNameFromField(field);
                aliasUsed = fieldName !== aliasedFieldName;
                defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
                resultPromise = Promise.resolve(defaultResult);
                if (!execContext.onlyRunForcedResolvers ||
                    this.shouldForceResolvers(field)) {
                    resolverType = rootValue.__typename || execContext.defaultOperationType;
                    resolverMap = this.resolvers && this.resolvers[resolverType];
                    if (resolverMap) {
                        resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
                        if (resolve) {
                            resultPromise = Promise.resolve(cacheSlot.withValue(this.cache, resolve, [
                                rootValue,
                                argumentsObjectFromField(field, variables),
                                execContext.context,
                                { field: field, fragmentMap: execContext.fragmentMap },
                            ]));
                        }
                    }
                }
                return [2, resultPromise.then(function (result) {
                        if (result === void 0) { result = defaultResult; }
                        if (field.directives) {
                            field.directives.forEach(function (directive) {
                                if (directive.name.value === 'export' && directive.arguments) {
                                    directive.arguments.forEach(function (arg) {
                                        if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {
                                            execContext.exportedVariables[arg.value.value] = result;
                                        }
                                    });
                                }
                            });
                        }
                        if (!field.selectionSet) {
                            return result;
                        }
                        if (result == null) {
                            return result;
                        }
                        if (Array.isArray(result)) {
                            return _this.resolveSubSelectedArray(field, result, execContext);
                        }
                        if (field.selectionSet) {
                            return _this.resolveSelectionSet(field.selectionSet, result, execContext);
                        }
                    })];
            });
        });
    };
    LocalState.prototype.resolveSubSelectedArray = function (field, result, execContext) {
        var _this = this;
        return Promise.all(result.map(function (item) {
            if (item === null) {
                return null;
            }
            if (Array.isArray(item)) {
                return _this.resolveSubSelectedArray(field, item, execContext);
            }
            if (field.selectionSet) {
                return _this.resolveSelectionSet(field.selectionSet, item, execContext);
            }
        }));
    };
    return LocalState;
}());

var destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();
function wrapDestructiveCacheMethod(cache, methodName) {
    var original = cache[methodName];
    if (typeof original === "function") {
        cache[methodName] = function () {
            destructiveMethodCounts.set(cache, (destructiveMethodCounts.get(cache) + 1) % 1e15);
            return original.apply(this, arguments);
        };
    }
}
function cancelNotifyTimeout(info) {
    if (info["notifyTimeout"]) {
        clearTimeout(info["notifyTimeout"]);
        info["notifyTimeout"] = void 0;
    }
}
var QueryInfo = (function () {
    function QueryInfo(queryManager, queryId) {
        if (queryId === void 0) { queryId = queryManager.generateQueryId(); }
        this.queryId = queryId;
        this.listeners = new Set();
        this.document = null;
        this.lastRequestId = 1;
        this.subscriptions = new Set();
        this.stopped = false;
        this.dirty = false;
        this.observableQuery = null;
        var cache = this.cache = queryManager.cache;
        if (!destructiveMethodCounts.has(cache)) {
            destructiveMethodCounts.set(cache, 0);
            wrapDestructiveCacheMethod(cache, "evict");
            wrapDestructiveCacheMethod(cache, "modify");
            wrapDestructiveCacheMethod(cache, "reset");
        }
    }
    QueryInfo.prototype.init = function (query) {
        var networkStatus = query.networkStatus || NetworkStatus.loading;
        if (this.variables &&
            this.networkStatus !== NetworkStatus.loading &&
            !equal(this.variables, query.variables)) {
            networkStatus = NetworkStatus.setVariables;
        }
        if (!equal(query.variables, this.variables)) {
            this.lastDiff = void 0;
        }
        Object.assign(this, {
            document: query.document,
            variables: query.variables,
            networkError: null,
            graphQLErrors: this.graphQLErrors || [],
            networkStatus: networkStatus,
        });
        if (query.observableQuery) {
            this.setObservableQuery(query.observableQuery);
        }
        if (query.lastRequestId) {
            this.lastRequestId = query.lastRequestId;
        }
        return this;
    };
    QueryInfo.prototype.reset = function () {
        cancelNotifyTimeout(this);
        this.lastDiff = void 0;
        this.dirty = false;
    };
    QueryInfo.prototype.getDiff = function (variables) {
        if (variables === void 0) { variables = this.variables; }
        var options = this.getDiffOptions(variables);
        if (this.lastDiff && equal(options, this.lastDiff.options)) {
            return this.lastDiff.diff;
        }
        this.updateWatch(this.variables = variables);
        var oq = this.observableQuery;
        if (oq && oq.options.fetchPolicy === "no-cache") {
            return { complete: false };
        }
        var diff = this.cache.diff(options);
        this.updateLastDiff(diff, options);
        return diff;
    };
    QueryInfo.prototype.updateLastDiff = function (diff, options) {
        this.lastDiff = diff ? {
            diff: diff,
            options: options || this.getDiffOptions(),
        } : void 0;
    };
    QueryInfo.prototype.getDiffOptions = function (variables) {
        var _a;
        if (variables === void 0) { variables = this.variables; }
        return {
            query: this.document,
            variables: variables,
            returnPartialData: true,
            optimistic: true,
            canonizeResults: (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.options.canonizeResults,
        };
    };
    QueryInfo.prototype.setDiff = function (diff) {
        var _this = this;
        var oldDiff = this.lastDiff && this.lastDiff.diff;
        this.updateLastDiff(diff);
        if (!this.dirty &&
            !equal(oldDiff && oldDiff.result, diff && diff.result)) {
            this.dirty = true;
            if (!this.notifyTimeout) {
                this.notifyTimeout = setTimeout(function () { return _this.notify(); }, 0);
            }
        }
    };
    QueryInfo.prototype.setObservableQuery = function (oq) {
        var _this = this;
        if (oq === this.observableQuery)
            return;
        if (this.oqListener) {
            this.listeners.delete(this.oqListener);
        }
        this.observableQuery = oq;
        if (oq) {
            oq["queryInfo"] = this;
            this.listeners.add(this.oqListener = function () {
                var diff = _this.getDiff();
                if (diff.fromOptimisticTransaction) {
                    oq["observe"]();
                }
                else {
                    reobserveCacheFirst(oq);
                }
            });
        }
        else {
            delete this.oqListener;
        }
    };
    QueryInfo.prototype.notify = function () {
        var _this = this;
        cancelNotifyTimeout(this);
        if (this.shouldNotify()) {
            this.listeners.forEach(function (listener) { return listener(_this); });
        }
        this.dirty = false;
    };
    QueryInfo.prototype.shouldNotify = function () {
        if (!this.dirty || !this.listeners.size) {
            return false;
        }
        if (isNetworkRequestInFlight(this.networkStatus) &&
            this.observableQuery) {
            var fetchPolicy = this.observableQuery.options.fetchPolicy;
            if (fetchPolicy !== "cache-only" &&
                fetchPolicy !== "cache-and-network") {
                return false;
            }
        }
        return true;
    };
    QueryInfo.prototype.stop = function () {
        if (!this.stopped) {
            this.stopped = true;
            this.reset();
            this.cancel();
            this.cancel = QueryInfo.prototype.cancel;
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            var oq = this.observableQuery;
            if (oq)
                oq.stopPolling();
        }
    };
    QueryInfo.prototype.cancel = function () { };
    QueryInfo.prototype.updateWatch = function (variables) {
        var _this = this;
        if (variables === void 0) { variables = this.variables; }
        var oq = this.observableQuery;
        if (oq && oq.options.fetchPolicy === "no-cache") {
            return;
        }
        var watchOptions = __assign(__assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function (diff) { return _this.setDiff(diff); } });
        if (!this.lastWatch ||
            !equal(watchOptions, this.lastWatch)) {
            this.cancel();
            this.cancel = this.cache.watch(this.lastWatch = watchOptions);
        }
    };
    QueryInfo.prototype.resetLastWrite = function () {
        this.lastWrite = void 0;
    };
    QueryInfo.prototype.shouldWrite = function (result, variables) {
        var lastWrite = this.lastWrite;
        return !(lastWrite &&
            lastWrite.dmCount === destructiveMethodCounts.get(this.cache) &&
            equal(variables, lastWrite.variables) &&
            equal(result.data, lastWrite.result.data));
    };
    QueryInfo.prototype.markResult = function (result, options, cacheWriteBehavior) {
        var _this = this;
        this.graphQLErrors = isNonEmptyArray(result.errors) ? result.errors : [];
        this.reset();
        if (options.fetchPolicy === 'no-cache') {
            this.updateLastDiff({ result: result.data, complete: true }, this.getDiffOptions(options.variables));
        }
        else if (cacheWriteBehavior !== 0) {
            if (shouldWriteResult(result, options.errorPolicy)) {
                this.cache.performTransaction(function (cache) {
                    if (_this.shouldWrite(result, options.variables)) {
                        cache.writeQuery({
                            query: _this.document,
                            data: result.data,
                            variables: options.variables,
                            overwrite: cacheWriteBehavior === 1,
                        });
                        _this.lastWrite = {
                            result: result,
                            variables: options.variables,
                            dmCount: destructiveMethodCounts.get(_this.cache),
                        };
                    }
                    else {
                        if (_this.lastDiff &&
                            _this.lastDiff.diff.complete) {
                            result.data = _this.lastDiff.diff.result;
                            return;
                        }
                    }
                    var diffOptions = _this.getDiffOptions(options.variables);
                    var diff = cache.diff(diffOptions);
                    if (!_this.stopped) {
                        _this.updateWatch(options.variables);
                    }
                    _this.updateLastDiff(diff, diffOptions);
                    if (diff.complete) {
                        result.data = diff.result;
                    }
                });
            }
            else {
                this.lastWrite = void 0;
            }
        }
    };
    QueryInfo.prototype.markReady = function () {
        this.networkError = null;
        return this.networkStatus = NetworkStatus.ready;
    };
    QueryInfo.prototype.markError = function (error) {
        this.networkStatus = NetworkStatus.error;
        this.lastWrite = void 0;
        this.reset();
        if (error.graphQLErrors) {
            this.graphQLErrors = error.graphQLErrors;
        }
        if (error.networkError) {
            this.networkError = error.networkError;
        }
        return error;
    };
    return QueryInfo;
}());
function shouldWriteResult(result, errorPolicy) {
    if (errorPolicy === void 0) { errorPolicy = "none"; }
    var ignoreErrors = errorPolicy === "ignore" ||
        errorPolicy === "all";
    var writeWithErrors = !graphQLResultHasError(result);
    if (!writeWithErrors && ignoreErrors && result.data) {
        writeWithErrors = true;
    }
    return writeWithErrors;
}

var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var QueryManager = (function () {
    function QueryManager(_a) {
        var cache = _a.cache, link = _a.link, defaultOptions = _a.defaultOptions, _b = _a.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, onBroadcast = _a.onBroadcast, _c = _a.ssrMode, ssrMode = _c === void 0 ? false : _c, _d = _a.clientAwareness, clientAwareness = _d === void 0 ? {} : _d, localState = _a.localState, assumeImmutableResults = _a.assumeImmutableResults;
        this.clientAwareness = {};
        this.queries = new Map();
        this.fetchCancelFns = new Map();
        this.transformCache = new (canUseWeakMap ? WeakMap : Map)();
        this.queryIdCounter = 1;
        this.requestIdCounter = 1;
        this.mutationIdCounter = 1;
        this.inFlightLinkObservables = new Map();
        this.cache = cache;
        this.link = link;
        this.defaultOptions = defaultOptions || Object.create(null);
        this.queryDeduplication = queryDeduplication;
        this.clientAwareness = clientAwareness;
        this.localState = localState || new LocalState({ cache: cache });
        this.ssrMode = ssrMode;
        this.assumeImmutableResults = !!assumeImmutableResults;
        if ((this.onBroadcast = onBroadcast)) {
            this.mutationStore = Object.create(null);
        }
    }
    QueryManager.prototype.stop = function () {
        var _this = this;
        this.queries.forEach(function (_info, queryId) {
            _this.stopQueryNoBroadcast(queryId);
        });
        this.cancelPendingFetches(__DEV__ ? new InvariantError('QueryManager stopped while query was in flight') : new InvariantError(11));
    };
    QueryManager.prototype.cancelPendingFetches = function (error) {
        this.fetchCancelFns.forEach(function (cancel) { return cancel(error); });
        this.fetchCancelFns.clear();
    };
    QueryManager.prototype.mutate = function (_a) {
        var _b, _c;
        var mutation = _a.mutation, variables = _a.variables, optimisticResponse = _a.optimisticResponse, updateQueries = _a.updateQueries, _d = _a.refetchQueries, refetchQueries = _d === void 0 ? [] : _d, _e = _a.awaitRefetchQueries, awaitRefetchQueries = _e === void 0 ? false : _e, updateWithProxyFn = _a.update, onQueryUpdated = _a.onQueryUpdated, _f = _a.fetchPolicy, fetchPolicy = _f === void 0 ? ((_b = this.defaultOptions.mutate) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || "network-only" : _f, _g = _a.errorPolicy, errorPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.errorPolicy) || "none" : _g, keepRootFields = _a.keepRootFields, context = _a.context;
        return __awaiter(this, void 0, void 0, function () {
            var mutationId, mutationStoreValue, self;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        __DEV__ ? invariant(mutation, 'mutation option is required. You must specify your GraphQL document in the mutation option.') : invariant(mutation, 12);
                        __DEV__ ? invariant(fetchPolicy === 'network-only' ||
                            fetchPolicy === 'no-cache', "Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.") : invariant(fetchPolicy === 'network-only' ||
                            fetchPolicy === 'no-cache', 13);
                        mutationId = this.generateMutationId();
                        mutation = this.transform(mutation).document;
                        variables = this.getVariables(mutation, variables);
                        if (!this.transform(mutation).hasClientExports) return [3, 2];
                        return [4, this.localState.addExportedVariables(mutation, variables, context)];
                    case 1:
                        variables = (_h.sent());
                        _h.label = 2;
                    case 2:
                        mutationStoreValue = this.mutationStore &&
                            (this.mutationStore[mutationId] = {
                                mutation: mutation,
                                variables: variables,
                                loading: true,
                                error: null,
                            });
                        if (optimisticResponse) {
                            this.markMutationOptimistic(optimisticResponse, {
                                mutationId: mutationId,
                                document: mutation,
                                variables: variables,
                                fetchPolicy: fetchPolicy,
                                errorPolicy: errorPolicy,
                                context: context,
                                updateQueries: updateQueries,
                                update: updateWithProxyFn,
                                keepRootFields: keepRootFields,
                            });
                        }
                        this.broadcastQueries();
                        self = this;
                        return [2, new Promise(function (resolve, reject) {
                                return asyncMap(self.getObservableFromLink(mutation, __assign(__assign({}, context), { optimisticResponse: optimisticResponse }), variables, false), function (result) {
                                    if (graphQLResultHasError(result) && errorPolicy === 'none') {
                                        throw new ApolloError({
                                            graphQLErrors: result.errors,
                                        });
                                    }
                                    if (mutationStoreValue) {
                                        mutationStoreValue.loading = false;
                                        mutationStoreValue.error = null;
                                    }
                                    var storeResult = __assign({}, result);
                                    if (typeof refetchQueries === "function") {
                                        refetchQueries = refetchQueries(storeResult);
                                    }
                                    if (errorPolicy === 'ignore' &&
                                        graphQLResultHasError(storeResult)) {
                                        delete storeResult.errors;
                                    }
                                    return self.markMutationResult({
                                        mutationId: mutationId,
                                        result: storeResult,
                                        document: mutation,
                                        variables: variables,
                                        fetchPolicy: fetchPolicy,
                                        errorPolicy: errorPolicy,
                                        context: context,
                                        update: updateWithProxyFn,
                                        updateQueries: updateQueries,
                                        awaitRefetchQueries: awaitRefetchQueries,
                                        refetchQueries: refetchQueries,
                                        removeOptimistic: optimisticResponse ? mutationId : void 0,
                                        onQueryUpdated: onQueryUpdated,
                                        keepRootFields: keepRootFields,
                                    });
                                }).subscribe({
                                    next: function (storeResult) {
                                        self.broadcastQueries();
                                        resolve(storeResult);
                                    },
                                    error: function (err) {
                                        if (mutationStoreValue) {
                                            mutationStoreValue.loading = false;
                                            mutationStoreValue.error = err;
                                        }
                                        if (optimisticResponse) {
                                            self.cache.removeOptimistic(mutationId);
                                        }
                                        self.broadcastQueries();
                                        reject(err instanceof ApolloError ? err : new ApolloError({
                                            networkError: err,
                                        }));
                                    },
                                });
                            })];
                }
            });
        });
    };
    QueryManager.prototype.markMutationResult = function (mutation, cache) {
        var _this = this;
        if (cache === void 0) { cache = this.cache; }
        var result = mutation.result;
        var cacheWrites = [];
        var skipCache = mutation.fetchPolicy === "no-cache";
        if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {
            cacheWrites.push({
                result: result.data,
                dataId: 'ROOT_MUTATION',
                query: mutation.document,
                variables: mutation.variables,
            });
            var updateQueries_1 = mutation.updateQueries;
            if (updateQueries_1) {
                this.queries.forEach(function (_a, queryId) {
                    var observableQuery = _a.observableQuery;
                    var queryName = observableQuery && observableQuery.queryName;
                    if (!queryName || !hasOwnProperty$1.call(updateQueries_1, queryName)) {
                        return;
                    }
                    var updater = updateQueries_1[queryName];
                    var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;
                    var _c = cache.diff({
                        query: document,
                        variables: variables,
                        returnPartialData: true,
                        optimistic: false,
                    }), currentQueryResult = _c.result, complete = _c.complete;
                    if (complete && currentQueryResult) {
                        var nextQueryResult = updater(currentQueryResult, {
                            mutationResult: result,
                            queryName: document && getOperationName(document) || void 0,
                            queryVariables: variables,
                        });
                        if (nextQueryResult) {
                            cacheWrites.push({
                                result: nextQueryResult,
                                dataId: 'ROOT_QUERY',
                                query: document,
                                variables: variables,
                            });
                        }
                    }
                });
            }
        }
        if (cacheWrites.length > 0 ||
            mutation.refetchQueries ||
            mutation.update ||
            mutation.onQueryUpdated ||
            mutation.removeOptimistic) {
            var results_1 = [];
            this.refetchQueries({
                updateCache: function (cache) {
                    if (!skipCache) {
                        cacheWrites.forEach(function (write) { return cache.write(write); });
                    }
                    var update = mutation.update;
                    if (update) {
                        if (!skipCache) {
                            var diff = cache.diff({
                                id: "ROOT_MUTATION",
                                query: _this.transform(mutation.document).asQuery,
                                variables: mutation.variables,
                                optimistic: false,
                                returnPartialData: true,
                            });
                            if (diff.complete) {
                                result = __assign(__assign({}, result), { data: diff.result });
                            }
                        }
                        update(cache, result, {
                            context: mutation.context,
                            variables: mutation.variables,
                        });
                    }
                    if (!skipCache && !mutation.keepRootFields) {
                        cache.modify({
                            id: 'ROOT_MUTATION',
                            fields: function (value, _a) {
                                var fieldName = _a.fieldName, DELETE = _a.DELETE;
                                return fieldName === "__typename" ? value : DELETE;
                            },
                        });
                    }
                },
                include: mutation.refetchQueries,
                optimistic: false,
                removeOptimistic: mutation.removeOptimistic,
                onQueryUpdated: mutation.onQueryUpdated || null,
            }).forEach(function (result) { return results_1.push(result); });
            if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
                return Promise.all(results_1).then(function () { return result; });
            }
        }
        return Promise.resolve(result);
    };
    QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {
        var _this = this;
        var data = typeof optimisticResponse === "function"
            ? optimisticResponse(mutation.variables)
            : optimisticResponse;
        return this.cache.recordOptimisticTransaction(function (cache) {
            try {
                _this.markMutationResult(__assign(__assign({}, mutation), { result: { data: data } }), cache);
            }
            catch (error) {
                __DEV__ && invariant.error(error);
            }
        }, mutation.mutationId);
    };
    QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {
        return this.fetchQueryObservable(queryId, options, networkStatus).promise;
    };
    QueryManager.prototype.getQueryStore = function () {
        var store = Object.create(null);
        this.queries.forEach(function (info, queryId) {
            store[queryId] = {
                variables: info.variables,
                networkStatus: info.networkStatus,
                networkError: info.networkError,
                graphQLErrors: info.graphQLErrors,
            };
        });
        return store;
    };
    QueryManager.prototype.resetErrors = function (queryId) {
        var queryInfo = this.queries.get(queryId);
        if (queryInfo) {
            queryInfo.networkError = undefined;
            queryInfo.graphQLErrors = [];
        }
    };
    QueryManager.prototype.transform = function (document) {
        var transformCache = this.transformCache;
        if (!transformCache.has(document)) {
            var transformed = this.cache.transformDocument(document);
            var forLink = removeConnectionDirectiveFromDocument(this.cache.transformForLink(transformed));
            var clientQuery = this.localState.clientQuery(transformed);
            var serverQuery = forLink && this.localState.serverQuery(forLink);
            var cacheEntry_1 = {
                document: transformed,
                hasClientExports: hasClientExports(transformed),
                hasForcedResolvers: this.localState.shouldForceResolvers(transformed),
                clientQuery: clientQuery,
                serverQuery: serverQuery,
                defaultVars: getDefaultValues(getOperationDefinition(transformed)),
                asQuery: __assign(__assign({}, transformed), { definitions: transformed.definitions.map(function (def) {
                        if (def.kind === "OperationDefinition" &&
                            def.operation !== "query") {
                            return __assign(__assign({}, def), { operation: "query" });
                        }
                        return def;
                    }) })
            };
            var add = function (doc) {
                if (doc && !transformCache.has(doc)) {
                    transformCache.set(doc, cacheEntry_1);
                }
            };
            add(document);
            add(transformed);
            add(clientQuery);
            add(serverQuery);
        }
        return transformCache.get(document);
    };
    QueryManager.prototype.getVariables = function (document, variables) {
        return __assign(__assign({}, this.transform(document).defaultVars), variables);
    };
    QueryManager.prototype.watchQuery = function (options) {
        options = __assign(__assign({}, options), { variables: this.getVariables(options.query, options.variables) });
        if (typeof options.notifyOnNetworkStatusChange === 'undefined') {
            options.notifyOnNetworkStatusChange = false;
        }
        var queryInfo = new QueryInfo(this);
        var observable = new ObservableQuery({
            queryManager: this,
            queryInfo: queryInfo,
            options: options,
        });
        this.queries.set(observable.queryId, queryInfo);
        queryInfo.init({
            document: observable.query,
            observableQuery: observable,
            variables: observable.variables,
        });
        return observable;
    };
    QueryManager.prototype.query = function (options, queryId) {
        var _this = this;
        if (queryId === void 0) { queryId = this.generateQueryId(); }
        __DEV__ ? invariant(options.query, 'query option is required. You must specify your GraphQL document ' +
            'in the query option.') : invariant(options.query, 14);
        __DEV__ ? invariant(options.query.kind === 'Document', 'You must wrap the query string in a "gql" tag.') : invariant(options.query.kind === 'Document', 15);
        __DEV__ ? invariant(!options.returnPartialData, 'returnPartialData option only supported on watchQuery.') : invariant(!options.returnPartialData, 16);
        __DEV__ ? invariant(!options.pollInterval, 'pollInterval option only supported on watchQuery.') : invariant(!options.pollInterval, 17);
        return this.fetchQuery(queryId, options).finally(function () { return _this.stopQuery(queryId); });
    };
    QueryManager.prototype.generateQueryId = function () {
        return String(this.queryIdCounter++);
    };
    QueryManager.prototype.generateRequestId = function () {
        return this.requestIdCounter++;
    };
    QueryManager.prototype.generateMutationId = function () {
        return String(this.mutationIdCounter++);
    };
    QueryManager.prototype.stopQueryInStore = function (queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.broadcastQueries();
    };
    QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {
        var queryInfo = this.queries.get(queryId);
        if (queryInfo)
            queryInfo.stop();
    };
    QueryManager.prototype.clearStore = function (options) {
        if (options === void 0) { options = {
            discardWatches: true,
        }; }
        this.cancelPendingFetches(__DEV__ ? new InvariantError('Store reset while query was in flight (not completed in link chain)') : new InvariantError(18));
        this.queries.forEach(function (queryInfo) {
            if (queryInfo.observableQuery) {
                queryInfo.networkStatus = NetworkStatus.loading;
            }
            else {
                queryInfo.stop();
            }
        });
        if (this.mutationStore) {
            this.mutationStore = Object.create(null);
        }
        return this.cache.reset(options);
    };
    QueryManager.prototype.getObservableQueries = function (include) {
        var _this = this;
        if (include === void 0) { include = "active"; }
        var queries = new Map();
        var queryNamesAndDocs = new Map();
        var legacyQueryOptions = new Set();
        if (Array.isArray(include)) {
            include.forEach(function (desc) {
                if (typeof desc === "string") {
                    queryNamesAndDocs.set(desc, false);
                }
                else if (isDocumentNode(desc)) {
                    queryNamesAndDocs.set(_this.transform(desc).document, false);
                }
                else if (isNonNullObject(desc) && desc.query) {
                    legacyQueryOptions.add(desc);
                }
            });
        }
        this.queries.forEach(function (_a, queryId) {
            var oq = _a.observableQuery, document = _a.document;
            if (oq) {
                if (include === "all") {
                    queries.set(queryId, oq);
                    return;
                }
                var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
                if (fetchPolicy === "standby" ||
                    (include === "active" && !oq.hasObservers())) {
                    return;
                }
                if (include === "active" ||
                    (queryName && queryNamesAndDocs.has(queryName)) ||
                    (document && queryNamesAndDocs.has(document))) {
                    queries.set(queryId, oq);
                    if (queryName)
                        queryNamesAndDocs.set(queryName, true);
                    if (document)
                        queryNamesAndDocs.set(document, true);
                }
            }
        });
        if (legacyQueryOptions.size) {
            legacyQueryOptions.forEach(function (options) {
                var queryId = makeUniqueId("legacyOneTimeQuery");
                var queryInfo = _this.getQuery(queryId).init({
                    document: options.query,
                    variables: options.variables,
                });
                var oq = new ObservableQuery({
                    queryManager: _this,
                    queryInfo: queryInfo,
                    options: __assign(__assign({}, options), { fetchPolicy: "network-only" }),
                });
                invariant(oq.queryId === queryId);
                queryInfo.setObservableQuery(oq);
                queries.set(queryId, oq);
            });
        }
        if (__DEV__ && queryNamesAndDocs.size) {
            queryNamesAndDocs.forEach(function (included, nameOrDoc) {
                if (!included) {
                    __DEV__ && invariant.warn("Unknown query ".concat(typeof nameOrDoc === "string" ? "named " : "").concat(JSON.stringify(nameOrDoc, null, 2), " requested in refetchQueries options.include array"));
                }
            });
        }
        return queries;
    };
    QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {
        var _this = this;
        if (includeStandby === void 0) { includeStandby = false; }
        var observableQueryPromises = [];
        this.getObservableQueries(includeStandby ? "all" : "active").forEach(function (observableQuery, queryId) {
            var fetchPolicy = observableQuery.options.fetchPolicy;
            observableQuery.resetLastResults();
            if (includeStandby ||
                (fetchPolicy !== "standby" &&
                    fetchPolicy !== "cache-only")) {
                observableQueryPromises.push(observableQuery.refetch());
            }
            _this.getQuery(queryId).setDiff(null);
        });
        this.broadcastQueries();
        return Promise.all(observableQueryPromises);
    };
    QueryManager.prototype.setObservableQuery = function (observableQuery) {
        this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
    };
    QueryManager.prototype.startGraphQLSubscription = function (_a) {
        var _this = this;
        var query = _a.query, fetchPolicy = _a.fetchPolicy, errorPolicy = _a.errorPolicy, variables = _a.variables, _b = _a.context, context = _b === void 0 ? {} : _b;
        query = this.transform(query).document;
        variables = this.getVariables(query, variables);
        var makeObservable = function (variables) {
            return _this.getObservableFromLink(query, context, variables).map(function (result) {
                if (fetchPolicy !== 'no-cache') {
                    if (shouldWriteResult(result, errorPolicy)) {
                        _this.cache.write({
                            query: query,
                            result: result.data,
                            dataId: 'ROOT_SUBSCRIPTION',
                            variables: variables,
                        });
                    }
                    _this.broadcastQueries();
                }
                if (graphQLResultHasError(result)) {
                    throw new ApolloError({
                        graphQLErrors: result.errors,
                    });
                }
                return result;
            });
        };
        if (this.transform(query).hasClientExports) {
            var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);
            return new Observable(function (observer) {
                var sub = null;
                observablePromise_1.then(function (observable) { return sub = observable.subscribe(observer); }, observer.error);
                return function () { return sub && sub.unsubscribe(); };
            });
        }
        return makeObservable(variables);
    };
    QueryManager.prototype.stopQuery = function (queryId) {
        this.stopQueryNoBroadcast(queryId);
        this.broadcastQueries();
    };
    QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.removeQuery(queryId);
    };
    QueryManager.prototype.removeQuery = function (queryId) {
        this.fetchCancelFns.delete(queryId);
        if (this.queries.has(queryId)) {
            this.getQuery(queryId).stop();
            this.queries.delete(queryId);
        }
    };
    QueryManager.prototype.broadcastQueries = function () {
        if (this.onBroadcast)
            this.onBroadcast();
        this.queries.forEach(function (info) { return info.notify(); });
    };
    QueryManager.prototype.getLocalState = function () {
        return this.localState;
    };
    QueryManager.prototype.getObservableFromLink = function (query, context, variables, deduplication) {
        var _this = this;
        var _a;
        if (deduplication === void 0) { deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication; }
        var observable;
        var serverQuery = this.transform(query).serverQuery;
        if (serverQuery) {
            var _b = this, inFlightLinkObservables_1 = _b.inFlightLinkObservables, link = _b.link;
            var operation = {
                query: serverQuery,
                variables: variables,
                operationName: getOperationName(serverQuery) || void 0,
                context: this.prepareContext(__assign(__assign({}, context), { forceFetch: !deduplication })),
            };
            context = operation.context;
            if (deduplication) {
                var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || new Map();
                inFlightLinkObservables_1.set(serverQuery, byVariables_1);
                var varJson_1 = canonicalStringify(variables);
                observable = byVariables_1.get(varJson_1);
                if (!observable) {
                    var concast = new Concast([
                        execute(link, operation)
                    ]);
                    byVariables_1.set(varJson_1, observable = concast);
                    concast.cleanup(function () {
                        if (byVariables_1.delete(varJson_1) &&
                            byVariables_1.size < 1) {
                            inFlightLinkObservables_1.delete(serverQuery);
                        }
                    });
                }
            }
            else {
                observable = new Concast([
                    execute(link, operation)
                ]);
            }
        }
        else {
            observable = new Concast([
                Observable.of({ data: {} })
            ]);
            context = this.prepareContext(context);
        }
        var clientQuery = this.transform(query).clientQuery;
        if (clientQuery) {
            observable = asyncMap(observable, function (result) {
                return _this.localState.runResolvers({
                    document: clientQuery,
                    remoteResult: result,
                    context: context,
                    variables: variables,
                });
            });
        }
        return observable;
    };
    QueryManager.prototype.getResultsFromLink = function (queryInfo, cacheWriteBehavior, options) {
        var requestId = queryInfo.lastRequestId = this.generateRequestId();
        return asyncMap(this.getObservableFromLink(queryInfo.document, options.context, options.variables), function (result) {
            var hasErrors = isNonEmptyArray(result.errors);
            if (requestId >= queryInfo.lastRequestId) {
                if (hasErrors && options.errorPolicy === "none") {
                    throw queryInfo.markError(new ApolloError({
                        graphQLErrors: result.errors,
                    }));
                }
                queryInfo.markResult(result, options, cacheWriteBehavior);
                queryInfo.markReady();
            }
            var aqr = {
                data: result.data,
                loading: false,
                networkStatus: NetworkStatus.ready,
            };
            if (hasErrors && options.errorPolicy !== "ignore") {
                aqr.errors = result.errors;
                aqr.networkStatus = NetworkStatus.error;
            }
            return aqr;
        }, function (networkError) {
            var error = isApolloError(networkError)
                ? networkError
                : new ApolloError({ networkError: networkError });
            if (requestId >= queryInfo.lastRequestId) {
                queryInfo.markError(error);
            }
            throw error;
        });
    };
    QueryManager.prototype.fetchQueryObservable = function (queryId, options, networkStatus) {
        var _this = this;
        if (networkStatus === void 0) { networkStatus = NetworkStatus.loading; }
        var query = this.transform(options.query).document;
        var variables = this.getVariables(query, options.variables);
        var queryInfo = this.getQuery(queryId);
        var defaults = this.defaultOptions.watchQuery;
        var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? defaults && defaults.fetchPolicy || "cache-first" : _a, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || "none" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;
        var normalized = Object.assign({}, options, {
            query: query,
            variables: variables,
            fetchPolicy: fetchPolicy,
            errorPolicy: errorPolicy,
            returnPartialData: returnPartialData,
            notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,
            context: context,
        });
        var fromVariables = function (variables) {
            normalized.variables = variables;
            return _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
        };
        this.fetchCancelFns.set(queryId, function (reason) {
            setTimeout(function () { return concast.cancel(reason); });
        });
        var concast = new Concast(this.transform(normalized.query).hasClientExports
            ? this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables)
            : fromVariables(normalized.variables));
        concast.cleanup(function () {
            _this.fetchCancelFns.delete(queryId);
            if (queryInfo.observableQuery) {
                queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options);
            }
        });
        return concast;
    };
    QueryManager.prototype.refetchQueries = function (_a) {
        var _this = this;
        var updateCache = _a.updateCache, include = _a.include, _b = _a.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a.onQueryUpdated;
        var includedQueriesById = new Map();
        if (include) {
            this.getObservableQueries(include).forEach(function (oq, queryId) {
                includedQueriesById.set(queryId, {
                    oq: oq,
                    lastDiff: _this.getQuery(queryId).getDiff(),
                });
            });
        }
        var results = new Map;
        if (updateCache) {
            this.cache.batch({
                update: updateCache,
                optimistic: optimistic && removeOptimistic || false,
                removeOptimistic: removeOptimistic,
                onWatchUpdated: function (watch, diff, lastDiff) {
                    var oq = watch.watcher instanceof QueryInfo &&
                        watch.watcher.observableQuery;
                    if (oq) {
                        if (onQueryUpdated) {
                            includedQueriesById.delete(oq.queryId);
                            var result = onQueryUpdated(oq, diff, lastDiff);
                            if (result === true) {
                                result = oq.refetch();
                            }
                            if (result !== false) {
                                results.set(oq, result);
                            }
                            return result;
                        }
                        if (onQueryUpdated !== null) {
                            includedQueriesById.set(oq.queryId, { oq: oq, lastDiff: lastDiff, diff: diff });
                        }
                    }
                },
            });
        }
        if (includedQueriesById.size) {
            includedQueriesById.forEach(function (_a, queryId) {
                var oq = _a.oq, lastDiff = _a.lastDiff, diff = _a.diff;
                var result;
                if (onQueryUpdated) {
                    if (!diff) {
                        var info = oq["queryInfo"];
                        info.reset();
                        diff = info.getDiff();
                    }
                    result = onQueryUpdated(oq, diff, lastDiff);
                }
                if (!onQueryUpdated || result === true) {
                    result = oq.refetch();
                }
                if (result !== false) {
                    results.set(oq, result);
                }
                if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
                    _this.stopQueryNoBroadcast(queryId);
                }
            });
        }
        if (removeOptimistic) {
            this.cache.removeOptimistic(removeOptimistic);
        }
        return results;
    };
    QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, _a, networkStatus) {
        var _this = this;
        var query = _a.query, variables = _a.variables, fetchPolicy = _a.fetchPolicy, refetchWritePolicy = _a.refetchWritePolicy, errorPolicy = _a.errorPolicy, returnPartialData = _a.returnPartialData, context = _a.context, notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;
        var oldNetworkStatus = queryInfo.networkStatus;
        queryInfo.init({
            document: this.transform(query).document,
            variables: variables,
            networkStatus: networkStatus,
        });
        var readCache = function () { return queryInfo.getDiff(variables); };
        var resultsFromCache = function (diff, networkStatus) {
            if (networkStatus === void 0) { networkStatus = queryInfo.networkStatus || NetworkStatus.loading; }
            var data = diff.result;
            if (__DEV__ &&
                !returnPartialData &&
                !equal(data, {})) {
                logMissingFieldErrors(diff.missing);
            }
            var fromData = function (data) { return Observable.of(__assign({ data: data, loading: isNetworkRequestInFlight(networkStatus), networkStatus: networkStatus }, (diff.complete ? null : { partial: true }))); };
            if (data && _this.transform(query).hasForcedResolvers) {
                return _this.localState.runResolvers({
                    document: query,
                    remoteResult: { data: data },
                    context: context,
                    variables: variables,
                    onlyRunForcedResolvers: true,
                }).then(function (resolved) { return fromData(resolved.data || void 0); });
            }
            return fromData(data);
        };
        var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 :
            (networkStatus === NetworkStatus.refetch &&
                refetchWritePolicy !== "merge") ? 1
                : 2;
        var resultsFromLink = function () { return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
            variables: variables,
            context: context,
            fetchPolicy: fetchPolicy,
            errorPolicy: errorPolicy,
        }); };
        var shouldNotify = notifyOnNetworkStatusChange &&
            typeof oldNetworkStatus === "number" &&
            oldNetworkStatus !== networkStatus &&
            isNetworkRequestInFlight(networkStatus);
        switch (fetchPolicy) {
            default:
            case "cache-first": {
                var diff = readCache();
                if (diff.complete) {
                    return [
                        resultsFromCache(diff, queryInfo.markReady()),
                    ];
                }
                if (returnPartialData || shouldNotify) {
                    return [
                        resultsFromCache(diff),
                        resultsFromLink(),
                    ];
                }
                return [
                    resultsFromLink(),
                ];
            }
            case "cache-and-network": {
                var diff = readCache();
                if (diff.complete || returnPartialData || shouldNotify) {
                    return [
                        resultsFromCache(diff),
                        resultsFromLink(),
                    ];
                }
                return [
                    resultsFromLink(),
                ];
            }
            case "cache-only":
                return [
                    resultsFromCache(readCache(), queryInfo.markReady()),
                ];
            case "network-only":
                if (shouldNotify) {
                    return [
                        resultsFromCache(readCache()),
                        resultsFromLink(),
                    ];
                }
                return [resultsFromLink()];
            case "no-cache":
                if (shouldNotify) {
                    return [
                        resultsFromCache(queryInfo.getDiff()),
                        resultsFromLink(),
                    ];
                }
                return [resultsFromLink()];
            case "standby":
                return [];
        }
    };
    QueryManager.prototype.getQuery = function (queryId) {
        if (queryId && !this.queries.has(queryId)) {
            this.queries.set(queryId, new QueryInfo(this, queryId));
        }
        return this.queries.get(queryId);
    };
    QueryManager.prototype.prepareContext = function (context) {
        if (context === void 0) { context = {}; }
        var newContext = this.localState.prepareContext(context);
        return __assign(__assign({}, newContext), { clientAwareness: this.clientAwareness });
    };
    return QueryManager;
}());

var hasSuggestedDevtools = false;
var ApolloClient = (function () {
    function ApolloClient(options) {
        var _this = this;
        this.resetStoreCallbacks = [];
        this.clearStoreCallbacks = [];
        var uri = options.uri, credentials = options.credentials, headers = options.headers, cache = options.cache, _a = options.ssrMode, ssrMode = _a === void 0 ? false : _a, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, _c = options.connectToDevTools, connectToDevTools = _c === void 0 ? typeof window$1 === 'object' &&
            !window$1.__APOLLO_CLIENT__ &&
            __DEV__ : _c, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions = options.defaultOptions, _e = options.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? false : _e, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;
        var link = options.link;
        if (!link) {
            link = uri
                ? new HttpLink({ uri: uri, credentials: credentials, headers: headers })
                : ApolloLink.empty();
        }
        if (!cache) {
            throw __DEV__ ? new InvariantError("To initialize Apollo Client, you must specify a 'cache' property " +
                "in the options object. \n" +
                "For more information, please visit: https://go.apollo.dev/c/docs") : new InvariantError(7);
        }
        this.link = link;
        this.cache = cache;
        this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
        this.queryDeduplication = queryDeduplication;
        this.defaultOptions = defaultOptions || Object.create(null);
        this.typeDefs = typeDefs;
        if (ssrForceFetchDelay) {
            setTimeout(function () { return (_this.disableNetworkFetches = false); }, ssrForceFetchDelay);
        }
        this.watchQuery = this.watchQuery.bind(this);
        this.query = this.query.bind(this);
        this.mutate = this.mutate.bind(this);
        this.resetStore = this.resetStore.bind(this);
        this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
        if (connectToDevTools && typeof window$1 === 'object') {
            window$1.__APOLLO_CLIENT__ = this;
        }
        if (!hasSuggestedDevtools && __DEV__) {
            hasSuggestedDevtools = true;
            if (typeof window$1 !== 'undefined' &&
                window$1.document &&
                window$1.top === window$1.self &&
                !window$1.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
                var nav = window$1.navigator;
                var ua = nav && nav.userAgent;
                var url = void 0;
                if (typeof ua === "string") {
                    if (ua.indexOf("Chrome/") > -1) {
                        url = "https://chrome.google.com/webstore/detail/" +
                            "apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
                    }
                    else if (ua.indexOf("Firefox/") > -1) {
                        url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
                    }
                }
                if (url) {
                    __DEV__ && invariant.log("Download the Apollo DevTools for a better development " +
                        "experience: " + url);
                }
            }
        }
        this.version = version;
        this.localState = new LocalState({
            cache: cache,
            client: this,
            resolvers: resolvers,
            fragmentMatcher: fragmentMatcher,
        });
        this.queryManager = new QueryManager({
            cache: this.cache,
            link: this.link,
            defaultOptions: this.defaultOptions,
            queryDeduplication: queryDeduplication,
            ssrMode: ssrMode,
            clientAwareness: {
                name: clientAwarenessName,
                version: clientAwarenessVersion,
            },
            localState: this.localState,
            assumeImmutableResults: assumeImmutableResults,
            onBroadcast: connectToDevTools ? function () {
                if (_this.devToolsHookCb) {
                    _this.devToolsHookCb({
                        action: {},
                        state: {
                            queries: _this.queryManager.getQueryStore(),
                            mutations: _this.queryManager.mutationStore || {},
                        },
                        dataWithOptimisticResults: _this.cache.extract(true),
                    });
                }
            } : void 0,
        });
    }
    ApolloClient.prototype.stop = function () {
        this.queryManager.stop();
    };
    ApolloClient.prototype.watchQuery = function (options) {
        if (this.defaultOptions.watchQuery) {
            options = mergeOptions(this.defaultOptions.watchQuery, options);
        }
        if (this.disableNetworkFetches &&
            (options.fetchPolicy === 'network-only' ||
                options.fetchPolicy === 'cache-and-network')) {
            options = __assign(__assign({}, options), { fetchPolicy: 'cache-first' });
        }
        return this.queryManager.watchQuery(options);
    };
    ApolloClient.prototype.query = function (options) {
        if (this.defaultOptions.query) {
            options = mergeOptions(this.defaultOptions.query, options);
        }
        __DEV__ ? invariant(options.fetchPolicy !== 'cache-and-network', 'The cache-and-network fetchPolicy does not work with client.query, because ' +
            'client.query can only return a single result. Please use client.watchQuery ' +
            'to receive multiple results from the cache and the network, or consider ' +
            'using a different fetchPolicy, such as cache-first or network-only.') : invariant(options.fetchPolicy !== 'cache-and-network', 8);
        if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {
            options = __assign(__assign({}, options), { fetchPolicy: 'cache-first' });
        }
        return this.queryManager.query(options);
    };
    ApolloClient.prototype.mutate = function (options) {
        if (this.defaultOptions.mutate) {
            options = mergeOptions(this.defaultOptions.mutate, options);
        }
        return this.queryManager.mutate(options);
    };
    ApolloClient.prototype.subscribe = function (options) {
        return this.queryManager.startGraphQLSubscription(options);
    };
    ApolloClient.prototype.readQuery = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        return this.cache.readQuery(options, optimistic);
    };
    ApolloClient.prototype.readFragment = function (options, optimistic) {
        if (optimistic === void 0) { optimistic = false; }
        return this.cache.readFragment(options, optimistic);
    };
    ApolloClient.prototype.writeQuery = function (options) {
        this.cache.writeQuery(options);
        this.queryManager.broadcastQueries();
    };
    ApolloClient.prototype.writeFragment = function (options) {
        this.cache.writeFragment(options);
        this.queryManager.broadcastQueries();
    };
    ApolloClient.prototype.__actionHookForDevTools = function (cb) {
        this.devToolsHookCb = cb;
    };
    ApolloClient.prototype.__requestRaw = function (payload) {
        return execute(this.link, payload);
    };
    ApolloClient.prototype.resetStore = function () {
        var _this = this;
        return Promise.resolve()
            .then(function () { return _this.queryManager.clearStore({
            discardWatches: false,
        }); })
            .then(function () { return Promise.all(_this.resetStoreCallbacks.map(function (fn) { return fn(); })); })
            .then(function () { return _this.reFetchObservableQueries(); });
    };
    ApolloClient.prototype.clearStore = function () {
        var _this = this;
        return Promise.resolve()
            .then(function () { return _this.queryManager.clearStore({
            discardWatches: true,
        }); })
            .then(function () { return Promise.all(_this.clearStoreCallbacks.map(function (fn) { return fn(); })); });
    };
    ApolloClient.prototype.onResetStore = function (cb) {
        var _this = this;
        this.resetStoreCallbacks.push(cb);
        return function () {
            _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) { return c !== cb; });
        };
    };
    ApolloClient.prototype.onClearStore = function (cb) {
        var _this = this;
        this.clearStoreCallbacks.push(cb);
        return function () {
            _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) { return c !== cb; });
        };
    };
    ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {
        return this.queryManager.reFetchObservableQueries(includeStandby);
    };
    ApolloClient.prototype.refetchQueries = function (options) {
        var map = this.queryManager.refetchQueries(options);
        var queries = [];
        var results = [];
        map.forEach(function (result, obsQuery) {
            queries.push(obsQuery);
            results.push(result);
        });
        var result = Promise.all(results);
        result.queries = queries;
        result.results = results;
        result.catch(function (error) {
            __DEV__ && invariant.debug("In client.refetchQueries, Promise.all promise rejected with error ".concat(error));
        });
        return result;
    };
    ApolloClient.prototype.getObservableQueries = function (include) {
        if (include === void 0) { include = "active"; }
        return this.queryManager.getObservableQueries(include);
    };
    ApolloClient.prototype.extract = function (optimistic) {
        return this.cache.extract(optimistic);
    };
    ApolloClient.prototype.restore = function (serializedState) {
        return this.cache.restore(serializedState);
    };
    ApolloClient.prototype.addResolvers = function (resolvers) {
        this.localState.addResolvers(resolvers);
    };
    ApolloClient.prototype.setResolvers = function (resolvers) {
        this.localState.setResolvers(resolvers);
    };
    ApolloClient.prototype.getResolvers = function () {
        return this.localState.getResolvers();
    };
    ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {
        this.localState.setFragmentMatcher(fragmentMatcher);
    };
    ApolloClient.prototype.setLink = function (newLink) {
        this.link = this.queryManager.link = newLink;
    };
    return ApolloClient;
}());

var docCache = new Map();
var fragmentSourceMap = new Map();
var printFragmentWarnings = true;
var experimentalFragmentVariables = false;
function normalize$1(string) {
    return string.replace(/[\s,]+/g, ' ').trim();
}
function cacheKeyFromLoc(loc) {
    return normalize$1(loc.source.body.substring(loc.start, loc.end));
}
function processFragments(ast) {
    var seenKeys = new Set();
    var definitions = [];
    ast.definitions.forEach(function (fragmentDefinition) {
        if (fragmentDefinition.kind === 'FragmentDefinition') {
            var fragmentName = fragmentDefinition.name.value;
            var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
            var sourceKeySet = fragmentSourceMap.get(fragmentName);
            if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
                if (printFragmentWarnings) {
                    console.warn("Warning: fragment with name " + fragmentName + " already exists.\n"
                        + "graphql-tag enforces all fragment names across your application to be unique; read more about\n"
                        + "this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
                }
            }
            else if (!sourceKeySet) {
                fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);
            }
            sourceKeySet.add(sourceKey);
            if (!seenKeys.has(sourceKey)) {
                seenKeys.add(sourceKey);
                definitions.push(fragmentDefinition);
            }
        }
        else {
            definitions.push(fragmentDefinition);
        }
    });
    return __assign(__assign({}, ast), { definitions: definitions });
}
function stripLoc(doc) {
    var workSet = new Set(doc.definitions);
    workSet.forEach(function (node) {
        if (node.loc)
            delete node.loc;
        Object.keys(node).forEach(function (key) {
            var value = node[key];
            if (value && typeof value === 'object') {
                workSet.add(value);
            }
        });
    });
    var loc = doc.loc;
    if (loc) {
        delete loc.startToken;
        delete loc.endToken;
    }
    return doc;
}
function parseDocument(source) {
    var cacheKey = normalize$1(source);
    if (!docCache.has(cacheKey)) {
        var parsed = parse(source, {
            experimentalFragmentVariables: experimentalFragmentVariables,
            allowLegacyFragmentVariables: experimentalFragmentVariables
        });
        if (!parsed || parsed.kind !== 'Document') {
            throw new Error('Not a valid GraphQL document.');
        }
        docCache.set(cacheKey, stripLoc(processFragments(parsed)));
    }
    return docCache.get(cacheKey);
}
function gql(literals) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    if (typeof literals === 'string') {
        literals = [literals];
    }
    var result = literals[0];
    args.forEach(function (arg, i) {
        if (arg && arg.kind === 'Document') {
            result += arg.loc.source.body;
        }
        else {
            result += arg;
        }
        result += literals[i + 1];
    });
    return parseDocument(result);
}
function resetCaches() {
    docCache.clear();
    fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
    printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
    experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
    experimentalFragmentVariables = false;
}
var extras = {
    gql: gql,
    resetCaches: resetCaches,
    disableFragmentWarnings: disableFragmentWarnings,
    enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,
    disableExperimentalFragmentVariables: disableExperimentalFragmentVariables
};
(function (gql_1) {
    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
})(gql || (gql = {}));
gql["default"] = gql;

var contextKey = canUseSymbol
    ? Symbol.for('__APOLLO_CONTEXT__')
    : '__APOLLO_CONTEXT__';
function getApolloContext() {
    var context = React.createContext[contextKey];
    if (!context) {
        Object.defineProperty(React.createContext, contextKey, {
            value: context = React.createContext({}),
            enumerable: false,
            writable: false,
            configurable: true,
        });
        context.displayName = 'ApolloContext';
    }
    return context;
}

function useApolloClient(override) {
    var context = useContext(getApolloContext());
    var client = override || context.client;
    __DEV__ ? invariant(!!client, 'Could not find "client" in the context or passed in as an option. ' +
        'Wrap the root component in an <ApolloProvider>, or pass an ApolloClient ' +
        'instance in via options.') : invariant(!!client, 29);
    return client;
}

var didWarnUncachedGetSnapshot = false;
var uSESKey = "useSyncExternalStore";
var realHook = React[uSESKey];
var useSyncExternalStore = realHook || (function (subscribe, getSnapshot, getServerSnapshot) {
    var value = getSnapshot();
    if (__DEV__ &&
        !didWarnUncachedGetSnapshot &&
        value !== getSnapshot()) {
        didWarnUncachedGetSnapshot = true;
        __DEV__ && invariant.error('The result of getSnapshot should be cached to avoid an infinite loop');
    }
    var _a = React.useState({ inst: { value: value, getSnapshot: getSnapshot } }), inst = _a[0].inst, forceUpdate = _a[1];
    if (canUseLayoutEffect) {
        React.useLayoutEffect(function () {
            Object.assign(inst, { value: value, getSnapshot: getSnapshot });
            if (checkIfSnapshotChanged(inst)) {
                forceUpdate({ inst: inst });
            }
        }, [subscribe, value, getSnapshot]);
    }
    else {
        Object.assign(inst, { value: value, getSnapshot: getSnapshot });
    }
    React.useEffect(function () {
        if (checkIfSnapshotChanged(inst)) {
            forceUpdate({ inst: inst });
        }
        return subscribe(function handleStoreChange() {
            if (checkIfSnapshotChanged(inst)) {
                forceUpdate({ inst: inst });
            }
        });
    }, [subscribe]);
    return value;
});
function checkIfSnapshotChanged(_a) {
    var value = _a.value, getSnapshot = _a.getSnapshot;
    try {
        return value !== getSnapshot();
    }
    catch (_b) {
        return true;
    }
}

var DocumentType;
(function (DocumentType) {
    DocumentType[DocumentType["Query"] = 0] = "Query";
    DocumentType[DocumentType["Mutation"] = 1] = "Mutation";
    DocumentType[DocumentType["Subscription"] = 2] = "Subscription";
})(DocumentType || (DocumentType = {}));
var cache$4 = new Map();
function operationName(type) {
    var name;
    switch (type) {
        case DocumentType.Query:
            name = 'Query';
            break;
        case DocumentType.Mutation:
            name = 'Mutation';
            break;
        case DocumentType.Subscription:
            name = 'Subscription';
            break;
    }
    return name;
}
function parser(document) {
    var cached = cache$4.get(document);
    if (cached)
        return cached;
    var variables, type, name;
    __DEV__ ? invariant(!!document && !!document.kind, "Argument of ".concat(document, " passed to parser was not a valid GraphQL ") +
        "DocumentNode. You may need to use 'graphql-tag' or another method " +
        "to convert your operation into a document") : invariant(!!document && !!document.kind, 30);
    var fragments = [];
    var queries = [];
    var mutations = [];
    var subscriptions = [];
    for (var _i = 0, _a = document.definitions; _i < _a.length; _i++) {
        var x = _a[_i];
        if (x.kind === 'FragmentDefinition') {
            fragments.push(x);
            continue;
        }
        if (x.kind === 'OperationDefinition') {
            switch (x.operation) {
                case 'query':
                    queries.push(x);
                    break;
                case 'mutation':
                    mutations.push(x);
                    break;
                case 'subscription':
                    subscriptions.push(x);
                    break;
            }
        }
    }
    __DEV__ ? invariant(!fragments.length ||
        (queries.length || mutations.length || subscriptions.length), "Passing only a fragment to 'graphql' is not yet supported. " +
        "You must include a query, subscription or mutation as well") : invariant(!fragments.length ||
        (queries.length || mutations.length || subscriptions.length), 31);
    __DEV__ ? invariant(queries.length + mutations.length + subscriptions.length <= 1, "react-apollo only supports a query, subscription, or a mutation per HOC. " +
        "".concat(document, " had ").concat(queries.length, " queries, ").concat(subscriptions.length, " ") +
        "subscriptions and ".concat(mutations.length, " mutations. ") +
        "You can use 'compose' to join multiple operation types to a component") : invariant(queries.length + mutations.length + subscriptions.length <= 1, 32);
    type = queries.length ? DocumentType.Query : DocumentType.Mutation;
    if (!queries.length && !mutations.length)
        type = DocumentType.Subscription;
    var definitions = queries.length
        ? queries
        : mutations.length
            ? mutations
            : subscriptions;
    __DEV__ ? invariant(definitions.length === 1, "react-apollo only supports one definition per HOC. ".concat(document, " had ") +
        "".concat(definitions.length, " definitions. ") +
        "You can use 'compose' to join multiple operation types to a component") : invariant(definitions.length === 1, 33);
    var definition = definitions[0];
    variables = definition.variableDefinitions || [];
    if (definition.name && definition.name.kind === 'Name') {
        name = definition.name.value;
    }
    else {
        name = 'data';
    }
    var payload = { name: name, type: type, variables: variables };
    cache$4.set(document, payload);
    return payload;
}
function verifyDocumentType(document, type) {
    var operation = parser(document);
    var requiredOperationName = operationName(type);
    var usedOperationName = operationName(operation.type);
    __DEV__ ? invariant(operation.type === type, "Running a ".concat(requiredOperationName, " requires a graphql ") +
        "".concat(requiredOperationName, ", but a ").concat(usedOperationName, " was used instead.")) : invariant(operation.type === type, 34);
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
function useQuery(query, options) {
    if (options === void 0) { options = Object.create(null); }
    return useInternalState(useApolloClient(options.client), query).useQuery(options);
}
function useInternalState(client, query) {
    var stateRef = useRef();
    if (!stateRef.current ||
        client !== stateRef.current.client ||
        query !== stateRef.current.query) {
        stateRef.current = new InternalState(client, query, stateRef.current);
    }
    var state = stateRef.current;
    var _a = useState(0); _a[0]; var setTick = _a[1];
    state.forceUpdate = function () {
        setTick(function (tick) { return tick + 1; });
    };
    return state;
}
var InternalState = (function () {
    function InternalState(client, query, previous) {
        this.client = client;
        this.query = query;
        this.asyncResolveFns = new Set();
        this.optionsToIgnoreOnce = new (canUseWeakSet ? WeakSet : Set)();
        this.ssrDisabledResult = maybeDeepFreeze({
            loading: true,
            data: void 0,
            error: void 0,
            networkStatus: NetworkStatus.loading,
        });
        this.skipStandbyResult = maybeDeepFreeze({
            loading: false,
            data: void 0,
            error: void 0,
            networkStatus: NetworkStatus.ready,
        });
        this.toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)();
        verifyDocumentType(query, DocumentType.Query);
        var previousResult = previous && previous.result;
        var previousData = previousResult && previousResult.data;
        if (previousData) {
            this.previousData = previousData;
        }
    }
    InternalState.prototype.forceUpdate = function () {
        __DEV__ && invariant.warn("Calling default no-op implementation of InternalState#forceUpdate");
    };
    InternalState.prototype.asyncUpdate = function () {
        var _this = this;
        return new Promise(function (resolve) {
            _this.asyncResolveFns.add(resolve);
            _this.optionsToIgnoreOnce.add(_this.watchQueryOptions);
            _this.forceUpdate();
        });
    };
    InternalState.prototype.useQuery = function (options) {
        var _this = this;
        this.renderPromises = useContext(getApolloContext()).renderPromises;
        this.useOptions(options);
        var obsQuery = this.useObservableQuery();
        var result = useSyncExternalStore(useCallback(function () {
            if (_this.renderPromises) {
                return function () { };
            }
            var onNext = function () {
                var previousResult = _this.result;
                var result = obsQuery.getCurrentResult();
                if (previousResult &&
                    previousResult.loading === result.loading &&
                    previousResult.networkStatus === result.networkStatus &&
                    equal(previousResult.data, result.data)) {
                    return;
                }
                _this.setResult(result);
            };
            var onError = function (error) {
                var last = obsQuery["last"];
                subscription.unsubscribe();
                try {
                    obsQuery.resetLastResults();
                    subscription = obsQuery.subscribe(onNext, onError);
                }
                finally {
                    obsQuery["last"] = last;
                }
                if (!hasOwnProperty.call(error, 'graphQLErrors')) {
                    throw error;
                }
                var previousResult = _this.result;
                if (!previousResult ||
                    (previousResult && previousResult.loading) ||
                    !equal(error, previousResult.error)) {
                    _this.setResult({
                        data: (previousResult && previousResult.data),
                        error: error,
                        loading: false,
                        networkStatus: NetworkStatus.error,
                    });
                }
            };
            var subscription = obsQuery.subscribe(onNext, onError);
            return function () { return subscription.unsubscribe(); };
        }, [
            obsQuery,
            this.renderPromises,
            this.client.disableNetworkFetches,
        ]), function () { return _this.getCurrentResult(); }, function () { return _this.getCurrentResult(); });
        this.unsafeHandlePartialRefetch(result);
        var queryResult = this.toQueryResult(result);
        if (!queryResult.loading && this.asyncResolveFns.size) {
            this.asyncResolveFns.forEach(function (resolve) { return resolve(queryResult); });
            this.asyncResolveFns.clear();
        }
        return queryResult;
    };
    InternalState.prototype.useOptions = function (options) {
        var _a;
        var watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);
        var currentWatchQueryOptions = this.watchQueryOptions;
        if (this.optionsToIgnoreOnce.has(currentWatchQueryOptions) ||
            !equal(watchQueryOptions, currentWatchQueryOptions)) {
            this.watchQueryOptions = watchQueryOptions;
            if (currentWatchQueryOptions && this.observable) {
                this.optionsToIgnoreOnce.delete(currentWatchQueryOptions);
                this.observable.reobserve(this.getObsQueryOptions());
                this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;
                this.result = void 0;
            }
        }
        this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;
        this.onError = options.onError || InternalState.prototype.onError;
        if ((this.renderPromises || this.client.disableNetworkFetches) &&
            this.queryHookOptions.ssr === false &&
            !this.queryHookOptions.skip) {
            this.result = this.ssrDisabledResult;
        }
        else if (this.queryHookOptions.skip ||
            this.watchQueryOptions.fetchPolicy === 'standby') {
            this.result = this.skipStandbyResult;
        }
        else if (this.result === this.ssrDisabledResult ||
            this.result === this.skipStandbyResult) {
            this.result = void 0;
        }
    };
    InternalState.prototype.getObsQueryOptions = function () {
        var toMerge = [];
        var globalDefaults = this.client.defaultOptions.watchQuery;
        if (globalDefaults)
            toMerge.push(globalDefaults);
        if (this.queryHookOptions.defaultOptions) {
            toMerge.push(this.queryHookOptions.defaultOptions);
        }
        toMerge.push(compact(this.observable && this.observable.options, this.watchQueryOptions));
        return toMerge.reduce(mergeOptions);
    };
    InternalState.prototype.createWatchQueryOptions = function (_a) {
        var _b;
        if (_a === void 0) { _a = {}; }
        var skip = _a.skip; _a.ssr; _a.onCompleted; _a.onError; _a.displayName; _a.defaultOptions; var otherOptions = __rest(_a, ["skip", "ssr", "onCompleted", "onError", "displayName", "defaultOptions"]);
        var watchQueryOptions = Object.assign(otherOptions, { query: this.query });
        if (this.renderPromises &&
            (watchQueryOptions.fetchPolicy === 'network-only' ||
                watchQueryOptions.fetchPolicy === 'cache-and-network')) {
            watchQueryOptions.fetchPolicy = 'cache-first';
        }
        if (!watchQueryOptions.variables) {
            watchQueryOptions.variables = {};
        }
        if (skip) {
            var _c = watchQueryOptions.fetchPolicy, fetchPolicy = _c === void 0 ? this.getDefaultFetchPolicy() : _c, _d = watchQueryOptions.initialFetchPolicy, initialFetchPolicy = _d === void 0 ? fetchPolicy : _d;
            Object.assign(watchQueryOptions, {
                initialFetchPolicy: initialFetchPolicy,
                fetchPolicy: 'standby',
            });
        }
        else if (!watchQueryOptions.fetchPolicy) {
            watchQueryOptions.fetchPolicy =
                ((_b = this.observable) === null || _b === void 0 ? void 0 : _b.options.initialFetchPolicy) ||
                    this.getDefaultFetchPolicy();
        }
        return watchQueryOptions;
    };
    InternalState.prototype.getDefaultFetchPolicy = function () {
        var _a, _b;
        return (((_a = this.queryHookOptions.defaultOptions) === null || _a === void 0 ? void 0 : _a.fetchPolicy) ||
            ((_b = this.client.defaultOptions.watchQuery) === null || _b === void 0 ? void 0 : _b.fetchPolicy) ||
            "cache-first");
    };
    InternalState.prototype.onCompleted = function (data) { };
    InternalState.prototype.onError = function (error) { };
    InternalState.prototype.useObservableQuery = function () {
        var obsQuery = this.observable =
            this.renderPromises
                && this.renderPromises.getSSRObservable(this.watchQueryOptions)
                || this.observable
                || this.client.watchQuery(this.getObsQueryOptions());
        this.obsQueryFields = useMemo(function () { return ({
            refetch: obsQuery.refetch.bind(obsQuery),
            reobserve: obsQuery.reobserve.bind(obsQuery),
            fetchMore: obsQuery.fetchMore.bind(obsQuery),
            updateQuery: obsQuery.updateQuery.bind(obsQuery),
            startPolling: obsQuery.startPolling.bind(obsQuery),
            stopPolling: obsQuery.stopPolling.bind(obsQuery),
            subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),
        }); }, [obsQuery]);
        var ssrAllowed = !(this.queryHookOptions.ssr === false ||
            this.queryHookOptions.skip);
        if (this.renderPromises && ssrAllowed) {
            this.renderPromises.registerSSRObservable(obsQuery);
            if (obsQuery.getCurrentResult().loading) {
                this.renderPromises.addObservableQueryPromise(obsQuery);
            }
        }
        return obsQuery;
    };
    InternalState.prototype.setResult = function (nextResult) {
        var previousResult = this.result;
        if (previousResult && previousResult.data) {
            this.previousData = previousResult.data;
        }
        this.result = nextResult;
        this.forceUpdate();
        this.handleErrorOrCompleted(nextResult);
    };
    InternalState.prototype.handleErrorOrCompleted = function (result) {
        if (!result.loading) {
            if (result.error) {
                this.onError(result.error);
            }
            else if (result.data) {
                this.onCompleted(result.data);
            }
        }
    };
    InternalState.prototype.getCurrentResult = function () {
        if (!this.result) {
            this.handleErrorOrCompleted(this.result = this.observable.getCurrentResult());
        }
        return this.result;
    };
    InternalState.prototype.toQueryResult = function (result) {
        var queryResult = this.toQueryResultCache.get(result);
        if (queryResult)
            return queryResult;
        var data = result.data; result.partial; var resultWithoutPartial = __rest(result, ["data", "partial"]);
        this.toQueryResultCache.set(result, queryResult = __assign(__assign(__assign({ data: data }, resultWithoutPartial), this.obsQueryFields), { client: this.client, observable: this.observable, variables: this.observable.variables, called: true, previousData: this.previousData }));
        if (!queryResult.error && isNonEmptyArray(result.errors)) {
            queryResult.error = new ApolloError({ graphQLErrors: result.errors });
        }
        return queryResult;
    };
    InternalState.prototype.unsafeHandlePartialRefetch = function (result) {
        if (result.partial &&
            this.queryHookOptions.partialRefetch &&
            !result.loading &&
            (!result.data || Object.keys(result.data).length === 0) &&
            this.observable.options.fetchPolicy !== 'cache-only') {
            Object.assign(result, {
                loading: true,
                networkStatus: NetworkStatus.refetch,
            });
            this.observable.refetch();
        }
    };
    return InternalState;
}());

var EAGER_METHODS = [
    'refetch',
    'reobserve',
    'fetchMore',
    'updateQuery',
    'startPolling',
    'subscribeToMore',
];
function useLazyQuery(query, options) {
    var internalState = useInternalState(useApolloClient(options && options.client), query);
    var execOptionsRef = useRef();
    var merged = execOptionsRef.current
        ? mergeOptions(options, execOptionsRef.current)
        : options;
    var useQueryResult = internalState.useQuery(__assign(__assign({}, merged), { skip: !execOptionsRef.current }));
    var initialFetchPolicy = useQueryResult.observable.options.initialFetchPolicy ||
        internalState.getDefaultFetchPolicy();
    var result = Object.assign(useQueryResult, {
        called: !!execOptionsRef.current,
    });
    var eagerMethods = useMemo(function () {
        var eagerMethods = {};
        var _loop_1 = function (key) {
            var method = result[key];
            eagerMethods[key] = function () {
                if (!execOptionsRef.current) {
                    execOptionsRef.current = Object.create(null);
                    internalState.forceUpdate();
                }
                return method.apply(this, arguments);
            };
        };
        for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {
            var key = EAGER_METHODS_1[_i];
            _loop_1(key);
        }
        return eagerMethods;
    }, []);
    Object.assign(result, eagerMethods);
    var execute = useCallback(function (executeOptions) {
        execOptionsRef.current = executeOptions ? __assign(__assign({}, executeOptions), { fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy }) : {
            fetchPolicy: initialFetchPolicy,
        };
        var promise = internalState
            .asyncUpdate()
            .then(function (queryResult) { return Object.assign(queryResult, eagerMethods); });
        promise.catch(function () { });
        return promise;
    }, []);
    return [execute, result];
}

function useMutation(mutation, options) {
    var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);
    verifyDocumentType(mutation, DocumentType.Mutation);
    var _a = useState({
        called: false,
        loading: false,
        client: client,
    }), result = _a[0], setResult = _a[1];
    var ref = useRef({
        result: result,
        mutationId: 0,
        isMounted: true,
        client: client,
        mutation: mutation,
        options: options,
    });
    {
        Object.assign(ref.current, { client: client, options: options, mutation: mutation });
    }
    var execute = useCallback(function (executeOptions) {
        if (executeOptions === void 0) { executeOptions = {}; }
        var _a = ref.current, client = _a.client, options = _a.options, mutation = _a.mutation;
        var baseOptions = __assign(__assign({}, options), { mutation: mutation });
        if (!ref.current.result.loading && !baseOptions.ignoreResults) {
            setResult(ref.current.result = {
                loading: true,
                error: void 0,
                data: void 0,
                called: true,
                client: client,
            });
        }
        var mutationId = ++ref.current.mutationId;
        var clientOptions = mergeOptions(baseOptions, executeOptions);
        return client.mutate(clientOptions).then(function (response) {
            var _a, _b, _c;
            var data = response.data, errors = response.errors;
            var error = errors && errors.length > 0
                ? new ApolloError({ graphQLErrors: errors })
                : void 0;
            if (mutationId === ref.current.mutationId &&
                !clientOptions.ignoreResults) {
                var result_1 = {
                    called: true,
                    loading: false,
                    data: data,
                    error: error,
                    client: client,
                };
                if (ref.current.isMounted && !equal(ref.current.result, result_1)) {
                    setResult(ref.current.result = result_1);
                }
            }
            (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onCompleted) === null || _b === void 0 ? void 0 : _b.call(_a, response.data);
            (_c = executeOptions.onCompleted) === null || _c === void 0 ? void 0 : _c.call(executeOptions, response.data);
            return response;
        }).catch(function (error) {
            var _a, _b, _c, _d;
            if (mutationId === ref.current.mutationId &&
                ref.current.isMounted) {
                var result_2 = {
                    loading: false,
                    error: error,
                    data: void 0,
                    called: true,
                    client: client,
                };
                if (!equal(ref.current.result, result_2)) {
                    setResult(ref.current.result = result_2);
                }
            }
            if (((_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onError) || clientOptions.onError) {
                (_c = (_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.onError) === null || _c === void 0 ? void 0 : _c.call(_b, error);
                (_d = executeOptions.onError) === null || _d === void 0 ? void 0 : _d.call(executeOptions, error);
                return { data: void 0, errors: error };
            }
            throw error;
        });
    }, []);
    var reset = useCallback(function () {
        setResult({ called: false, loading: false, client: client });
    }, []);
    useEffect(function () {
        ref.current.isMounted = true;
        return function () {
            ref.current.isMounted = false;
        };
    }, []);
    return [execute, __assign({ reset: reset }, result)];
}

var AddCart = function (payload) { return ({
    type: 'ADDCART',
    payload: payload
}); };
var DeleteCart = function (payload) { return ({
    type: 'DELETECART',
    payload: payload
}); };
var DeleteAllItemCart = function (payload) { return ({
    type: 'DELETEALLITEMCART',
    payload: payload
}); };

function setContext$1(setter) {
    return new ApolloLink(function (operation, forward) {
        var request = __rest(operation, []);
        return new Observable(function (observer) {
            var handle;
            var closed = false;
            Promise.resolve(request)
                .then(function (req) { return setter(req, operation.getContext()); })
                .then(operation.setContext)
                .then(function () {
                if (closed)
                    return;
                handle = forward(operation).subscribe({
                    next: observer.next.bind(observer),
                    error: observer.error.bind(observer),
                    complete: observer.complete.bind(observer),
                });
            })
                .catch(observer.error.bind(observer));
            return function () {
                closed = true;
                if (handle)
                    handle.unsubscribe();
            };
        });
    });
}

function onError(errorHandler) {
    return new ApolloLink(function (operation, forward) {
        return new Observable(function (observer) {
            var sub;
            var retriedSub;
            var retriedResult;
            try {
                sub = forward(operation).subscribe({
                    next: function (result) {
                        if (result.errors) {
                            retriedResult = errorHandler({
                                graphQLErrors: result.errors,
                                response: result,
                                operation: operation,
                                forward: forward,
                            });
                            if (retriedResult) {
                                retriedSub = retriedResult.subscribe({
                                    next: observer.next.bind(observer),
                                    error: observer.error.bind(observer),
                                    complete: observer.complete.bind(observer),
                                });
                                return;
                            }
                        }
                        observer.next(result);
                    },
                    error: function (networkError) {
                        retriedResult = errorHandler({
                            operation: operation,
                            networkError: networkError,
                            graphQLErrors: networkError &&
                                networkError.result &&
                                networkError.result.errors,
                            forward: forward,
                        });
                        if (retriedResult) {
                            retriedSub = retriedResult.subscribe({
                                next: observer.next.bind(observer),
                                error: observer.error.bind(observer),
                                complete: observer.complete.bind(observer),
                            });
                            return;
                        }
                        observer.error(networkError);
                    },
                    complete: function () {
                        if (!retriedResult) {
                            observer.complete.bind(observer)();
                        }
                    },
                });
            }
            catch (e) {
                errorHandler({ networkError: e, operation: operation, forward: forward });
                observer.error(e);
            }
            return function () {
                if (sub)
                    sub.unsubscribe();
                if (retriedSub)
                    sub.unsubscribe();
            };
        });
    });
}
((function (_super) {
    __extends(ErrorLink, _super);
    function ErrorLink(errorHandler) {
        var _this = _super.call(this) || this;
        _this.link = onError(errorHandler);
        return _this;
    }
    ErrorLink.prototype.request = function (operation, forward) {
        return this.link.request(operation, forward);
    };
    return ErrorLink;
})(ApolloLink));

var _a, _b;
var CONFIG = {
    GRAPHQL_URL: process.env.GRAPHQL_SERVER_URL ||
        'https://gateway.staging.ixuapis.com/graphql/',
    GRAPHQL_CHAT_URL: 'https://chat-cs-service.staging.ixulabs.com/graphql',
    GRAPHQL_URL_WS: 'wss://chat-cs-service.staging.ixulabs.com/graphql',
    GRAPHQL_VIDEO_URL: ' https://rooms-service.staging.ixulabs.com/graphql',
    GRAPHQL_VIDEO_WSS_URL: 'wss://videocall.ixulabs.com',
    SITE: (_a = process.env.SITE) !== null && _a !== void 0 ? _a : '.sites.develop.ixulabs.com',
    APP_ENV: (_b = process.env.APP_ENV) !== null && _b !== void 0 ? _b : 'develop',
};

var cache$3 = new InMemoryCache();
var httpLink = createHttpLink({
    uri: "".concat(CONFIG.GRAPHQL_URL),
});
var authLink = setContext$1(function (_, _a) {
    var _b;
    var headers = _a.headers;
    return ({
        headers: __assign(__assign({}, headers), { authorization: "Bearer ".concat((_b = cookie.get("bearer")) !== null && _b !== void 0 ? _b : 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1laWRlbnRpZmllciI6ImQxNWM4MmFmLWI1ZTQtNGQ3YS1iN2FkLWJmMDgxMTk2MzJiNCIsImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd3MvMjAwOC8wNi9pZGVudGl0eS9jbGFpbXMvcm9sZSI6Il9fb3duZXJfXyIsImV4cCI6MTY4NTcyNTEzMiwiaXNzIjoibG9jYWxob3N0OjgwMDAiLCJhdWQiOiJBUEkifQ.bU9C6gBadJVRNwVRXIK2yi7I5WcKyRuKC6goEyl4szk') }),
    });
});
var errorLink = onError(function (_a) {
    var graphQLErrors = _a.graphQLErrors, networkError = _a.networkError;
    if (graphQLErrors &&
        !graphQLErrors.filter(function (error) { return error.message === "INVALID_TOKEN"; }))
        graphQLErrors.forEach(function (_a) {
            var message = _a.message, locations = _a.locations, path = _a.path;
            return console.warn("[GraphQL error]: Message: ".concat(message, ", Location: ").concat(locations, ", Path: ").concat(path));
        });
    if (networkError)
        console.warn("[Network error]: ".concat(networkError));
});
var link = errorLink.concat(authLink.concat(httpLink));
var client = new ApolloClient({
    link: link,
    ssrMode: true,
    cache: cache$3,
    connectToDevTools: true,
    queryDeduplication: true,
});

var numberWithCommas = function (x, opt) {
    if (opt === void 0) { opt = {}; }
    var error = opt.error, prefix = opt.prefix, suffix = opt.suffix;
    if (!x)
        return error !== null && error !== void 0 ? error : null;
    var convertNumber = Number(x);
    if (!convertNumber)
        return error !== null && error !== void 0 ? error : null;
    return "".concat(prefix !== null && prefix !== void 0 ? prefix : '').concat(convertNumber === null || convertNumber === void 0 ? void 0 : convertNumber.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ",")).concat(suffix !== null && suffix !== void 0 ? suffix : '');
};

var AtomSeparatorStyled = styled$1(motion.hr)(templateObject_1$1k || (templateObject_1$1k = __makeTemplateObject(["\n  width: ", ";\n  height: ", ";\n  border: none;\n  margin: ", ";\n  background: ", ";\n\n  ", ";\n"], ["\n  width: ", ";\n  height: ", ";\n  border: none;\n  margin: ", ";\n  background: ", ";\n\n  ", ";\n"])), function (_a) {
    var width = _a.width;
    return width || "100%";
}, function (_a) {
    var height = _a.height;
    return height || "2px";
}, function (_a) {
    var margin = _a.margin;
    return margin || "30px 0px;";
}, function (_a) {
    var color = _a.color;
    return color || "white";
}, function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
var templateObject_1$1k;

var Separator = function (props) { return (jsx(AtomSeparatorStyled, __assign({}, props))); };

var AtomImageStyled = styled$1(motion.div)(templateObject_1$1j || (templateObject_1$1j = __makeTemplateObject(["\n  width: ", ";\n  max-width: ", ";\n  height: ", ";\n  max-height: ", ";\n  margin: ", ";\n  position: ", ";\n  left: ", ";\n  top: ", ";\n  right: ", ";\n  bottom: ", ";\n  img {\n    object-fit: ", ";\n    object-position: ", ";\n  }\n  z-index: ", ";\n\n  ", ";\n"], ["\n  width: ", ";\n  max-width: ", ";\n  height: ", ";\n  max-height: ", ";\n  margin: ", ";\n  position: ", ";\n  left: ", ";\n  top: ", ";\n  right: ", ";\n  bottom: ", ";\n  img {\n    object-fit: ", ";\n    object-position: ", ";\n  }\n  z-index: ", ";\n\n  ", ";\n"])), function (_a) {
    var width = _a.width;
    return width || "100%";
}, function (_a) {
    var maxWidth = _a.maxWidth;
    return maxWidth || "initial";
}, function (_a) {
    var height = _a.height;
    return height || "100%";
}, function (_a) {
    var maxHeight = _a.maxHeight;
    return maxHeight || "initial";
}, function (_a) {
    var margin = _a.margin;
    return margin || "0";
}, function (_a) {
    var position = _a.position;
    return position || "initial";
}, function (_a) {
    var left = _a.left;
    return left || "initial";
}, function (_a) {
    var top = _a.top;
    return top || "initial";
}, function (_a) {
    var right = _a.right;
    return right || "initial";
}, function (_a) {
    var bottom = _a.bottom;
    return bottom || "initial";
}, function (_a) {
    var objectFit = _a.objectFit;
    return objectFit || "cover";
}, function (_a) {
    var objectPosition = _a.objectPosition;
    return objectPosition || "center center";
}, function (_a) {
    var zIndex = _a.zIndex;
    return zIndex || "initial";
}, function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
var AtomImageWrapperStyled = styled$1.div(templateObject_2$Y || (templateObject_2$Y = __makeTemplateObject(["\n  width: 100%;\n  height: 100%;\n  position: relative;\n"], ["\n  width: 100%;\n  height: 100%;\n  position: relative;\n"])));
var AtomImageImgStyled = styled$1.img(templateObject_3$O || (templateObject_3$O = __makeTemplateObject(["\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n"], ["\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n"])));
var templateObject_1$1j, templateObject_2$Y, templateObject_3$O;

var Image$2 = function (props) {
    var src = props.src, alt = props.alt, isNextImage = props.isNextImage;
    return (jsx(AtomImageStyled, __assign({}, __assign(__assign({}, props), { src: undefined }), { children: isNextImage ? (jsx(AtomImageWrapperStyled, { children: jsx(NextImage, { src: src, alt: "".concat(alt, "image"), layout: "fill", placeholder: "blur", blurDataURL: src }) })) : (jsx(AtomImageImgStyled, { src: src, alt: alt })) })));
};

var IconContainer = styled$1(motion.div)(templateObject_1$1i || (templateObject_1$1i = __makeTemplateObject(["\n  display: flex;\n  width: max-content;\n  height: max-content;\n  svg {\n    width: ", ";\n    height: ", ";\n    path {\n      fill: ", "!important;\n    }\n    polygon {\n      fill: ", "!important;\n    }\n    circle {\n      fill: ", "!important;\n    }\n  }\n\n  ", ";\n"], ["\n  display: flex;\n  width: max-content;\n  height: max-content;\n  svg {\n    width: ", ";\n    height: ", ";\n    path {\n      fill: ", "!important;\n    }\n    polygon {\n      fill: ", "!important;\n    }\n    circle {\n      fill: ", "!important;\n    }\n  }\n\n  ", ";\n"])), function (_a) {
    var width = _a.width;
    return width || "34px";
}, function (_a) {
    var height = _a.height;
    return height || "34px";
}, function (_a) {
    var color = _a.color;
    return color || "#000";
}, function (_a) {
    var color = _a.color;
    return color || "#000";
}, function (_a) {
    var color = _a.color;
    return color || "#000";
}, function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
var PlaceholderIcon = styled$1(motion.div)(templateObject_2$X || (templateObject_2$X = __makeTemplateObject(["\n  width: ", ";\n  height: ", ";\n"], ["\n  width: ", ";\n  height: ", ";\n"])), function (_a) {
    var width = _a.width;
    return width || "34px";
}, function (_a) {
    var height = _a.height;
    return height || "34px";
});
var templateObject_1$1i, templateObject_2$X;

var DefaultIcon = "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/PFS-0001/outline/house-beat.svg";
var Icon$1 = function (props) {
    var icon = props.icon;
    var _a = __read(useState(""), 2), getIcon = _a[0], setGetIcon = _a[1];
    useEffect(function () {
        var fetchIcon = function () {
            return fetch(icon || DefaultIcon)
                .then(function (response) { return response.text(); })
                .then(function (res) { return res && setGetIcon(res); });
        };
        fetchIcon();
        return function () {
            setGetIcon(null);
        };
    }, [icon]);
    return getIcon ? (jsx(IconContainer, __assign({}, props, { dangerouslySetInnerHTML: {
            __html: getIcon,
        } }))) : (jsx(PlaceholderIcon, {}));
};

var GETPRODUCTBYID = gql(templateObject_1$1h || (templateObject_1$1h = __makeTemplateObject(["\n  query productById($id: UUID!) {\n    productById(id: $id) {\n      projectId\n      memberId\n      title\n      photo\n      slug\n      sku\n      price\n      offerPrice\n      stock\n      active\n      seoProduct\n      shippingType\n      shippingPrice\n      description\n      publishDate\n      shopType\n      views\n      status\n      seoProduct\n      categories {\n        name\n        id\n        parentId\n        subCategories {\n          name\n          parentId\n          id\n        }\n      }\n      images {\n        id\n        title\n        original\n      }\n      id\n      createdAt\n      updatedAt\n    }\n  }\n"], ["\n  query productById($id: UUID!) {\n    productById(id: $id) {\n      projectId\n      memberId\n      title\n      photo\n      slug\n      sku\n      price\n      offerPrice\n      stock\n      active\n      seoProduct\n      shippingType\n      shippingPrice\n      description\n      publishDate\n      shopType\n      views\n      status\n      seoProduct\n      categories {\n        name\n        id\n        parentId\n        subCategories {\n          name\n          parentId\n          id\n        }\n      }\n      images {\n        id\n        title\n        original\n      }\n      id\n      createdAt\n      updatedAt\n    }\n  }\n"])));
var templateObject_1$1h;

var SkletonStyles = css$1(templateObject_1$1g || (templateObject_1$1g = __makeTemplateObject(["\n  @keyframes skeleton {\n    0% {\n      background-position: 200% 0%;\n    }\n    50% {\n      background-position: 100% 50%;\n    }\n    100% {\n      background-position: 0% 0%;\n    }\n  }\n  img {\n    display: none;\n  }\n  p,\n  span {\n    text-indent: 100%;\n    white-space: nowrap;\n    overflow: hidden;\n  }\n  background: linear-gradient(90deg, #ffffff 0%, #ebebeb 50%, #ffffff 100%);\n  background-size: 200% 200%;\n  animation: skeleton 1.8s ease-out infinite;\n"], ["\n  @keyframes skeleton {\n    0% {\n      background-position: 200% 0%;\n    }\n    50% {\n      background-position: 100% 50%;\n    }\n    100% {\n      background-position: 0% 0%;\n    }\n  }\n  img {\n    display: none;\n  }\n  p,\n  span {\n    text-indent: 100%;\n    white-space: nowrap;\n    overflow: hidden;\n  }\n  background: linear-gradient(90deg, #ffffff 0%, #ebebeb 50%, #ffffff 100%);\n  background-size: 200% 200%;\n  animation: skeleton 1.8s ease-out infinite;\n"])));
var templateObject_1$1g;

var Animation$d = {
    whileHover: {
        scale: 1.09,
        transition: { duration: 0.3 },
    },
    whileTap: { scale: 0.98, opacity: 0.8 },
};
var AnimationWrapper = {
    transition: {
        default: { duration: 0.3 },
    },
    initial: { opacity: 0 },
    animate: { opacity: 1 },
    exit: { opacity: 0 },
};
var Wrapper$1 = motion.div;
var AtomCartShop = function (props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    var path = props.path;
    var router = useRouter();
    var customize = useSelector(function (state) { return state.customize; });
    var cart = useSelector(function (state) { return state.cartShop; });
    var _l = __read(useState(false), 2), show = _l[0], setShow = _l[1];
    var ref = useRef(null);
    var _m = __read(useState([]), 2), cartsItems = _m[0], setCartsItems = _m[1];
    useEffect(function () {
        var getData = function () { return __awaiter(void 0, void 0, void 0, function () {
            var getcarts;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.all(cart === null || cart === void 0 ? void 0 : cart.map(function (item) { return __awaiter(void 0, void 0, void 0, function () {
                            var _a;
                            var _b;
                            return __generator(this, function (_c) {
                                switch (_c.label) {
                                    case 0:
                                        _a = [__assign({}, item)];
                                        _b = {};
                                        return [4 /*yield*/, client
                                                .query({
                                                query: GETPRODUCTBYID,
                                                variables: {
                                                    id: item.id,
                                                },
                                            })
                                                .then(function (res) { return res.data.productById; })
                                                .catch(function (err) { return err; })];
                                    case 1: return [2 /*return*/, (__assign.apply(void 0, _a.concat([(_b.data = _c.sent(), _b)])))];
                                }
                            });
                        }); }))];
                    case 1:
                        getcarts = _a.sent();
                        setCartsItems(getcarts);
                        return [2 /*return*/];
                }
            });
        }); };
        if (Array.isArray(cart)) {
            getData();
        }
    }, [cart]);
    useEffect(function () {
        var handleClickOutside = function (event) {
            if (ref.current && !ref.current.contains(event.target)) {
                setShow(false);
            }
        };
        document.addEventListener("mousedown", handleClickOutside);
        return function () {
            document.removeEventListener("mousedown", handleClickOutside);
        };
    }, [ref]);
    return (jsxs(Fragment$1, { children: [jsxs(AtomButton, __assign({}, Animation$d, { onClick: function () { return setShow(!show); }, customCSS: css$1(templateObject_1$1f || (templateObject_1$1f = __makeTemplateObject(["\n          background-color: transparent;\n          padding: 10px;\n          border-radius: 50%;\n          position: relative;\n          border: 1px solid ", ";\n          :hover {\n            background-color: ", ";\n            div {\n              svg {\n                path {\n                  fill: #ffffff !important;\n                }\n              }\n            }\n          }\n          transition: background-color 0.3s ease-in-out;\n        "], ["\n          background-color: transparent;\n          padding: 10px;\n          border-radius: 50%;\n          position: relative;\n          border: 1px solid ", ";\n          :hover {\n            background-color: ", ";\n            div {\n              svg {\n                path {\n                  fill: #ffffff !important;\n                }\n              }\n            }\n          }\n          transition: background-color 0.3s ease-in-out;\n        "])), (_b = (_a = customize === null || customize === void 0 ? void 0 : customize.colors) === null || _a === void 0 ? void 0 : _a.primary) !== null && _b !== void 0 ? _b : '#fe6a6a', (_d = (_c = customize === null || customize === void 0 ? void 0 : customize.colors) === null || _c === void 0 ? void 0 : _c.primary) !== null && _d !== void 0 ? _d : '#fe6a6a') }, { children: [jsx(Icon$1, { height: "20px", width: "20px", color: (_f = (_e = customize === null || customize === void 0 ? void 0 : customize.colors) === null || _e === void 0 ? void 0 : _e.primary) !== null && _f !== void 0 ? _f : '#fe6a6a', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/icons/svgs/add-item-in-cart.svg" }), cartsItems.length > 0 && (jsx(Text$2, __assign({ customCSS: css$1(templateObject_2$W || (templateObject_2$W = __makeTemplateObject(["\n              top: -8px;\n              right: -12px;\n              position: absolute;\n              padding: 5px;\n              font-size: 10px;\n              border-radius: 50%;\n              display: flex;\n              flex-direction: column;\n              justify-content: center;\n              align-items: center;\n              width: 25px;\n              height: 25px;\n              color: #ffffff;\n              font-weight: bold;\n              background-color: ", ";\n            "], ["\n              top: -8px;\n              right: -12px;\n              position: absolute;\n              padding: 5px;\n              font-size: 10px;\n              border-radius: 50%;\n              display: flex;\n              flex-direction: column;\n              justify-content: center;\n              align-items: center;\n              width: 25px;\n              height: 25px;\n              color: #ffffff;\n              font-weight: bold;\n              background-color: ", ";\n            "])), (_h = (_g = customize === null || customize === void 0 ? void 0 : customize.colors) === null || _g === void 0 ? void 0 : _g.primary) !== null && _h !== void 0 ? _h : '#fe6a6a') }, { children: cartsItems.reduce(function (acc, item) { return acc + item.quantity; }, 0) })))] })), jsx(AnimatePresence, { children: show && (jsx(Wrapper$1, __assign({}, AnimationWrapper, { css: css$1(templateObject_3$N || (templateObject_3$N = __makeTemplateObject(["\n              display: flex;\n              position: fixed;\n              top: 0;\n              left: 0;\n              width: 100vw;\n              height: 100vh;\n              background-color: #111111b0;\n              flex-direction: row;\n              justify-content: flex-end;\n            "], ["\n              display: flex;\n              position: fixed;\n              top: 0;\n              left: 0;\n              width: 100vw;\n              height: 100vh;\n              background-color: #111111b0;\n              flex-direction: row;\n              justify-content: flex-end;\n            "]))) }, { children: jsxs(Wrapper$2, __assign({ refObject: ref, customCSS: css$1(templateObject_4$B || (templateObject_4$B = __makeTemplateObject(["\n                flex-direction: column;\n                justify-content: flex-start;\n                align-items: space-between;\n                height: 100%;\n                width: 450px;\n                padding: 40px 60px;\n                background-color: #ffffff;\n                box-shadow: 0px 0px 10px rgb(0 0 0 / 10%);\n                gap: 15px;\n              "], ["\n                flex-direction: column;\n                justify-content: flex-start;\n                align-items: space-between;\n                height: 100%;\n                width: 450px;\n                padding: 40px 60px;\n                background-color: #ffffff;\n                box-shadow: 0px 0px 10px rgb(0 0 0 / 10%);\n                gap: 15px;\n              "]))) }, { children: [jsx(Text$2, __assign({ fontSize: "22px", fontWeight: 700 }, { children: "CARRITO" })), jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_5$q || (templateObject_5$q = __makeTemplateObject(["\n                  gap: 15px;\n                  height: 100%;\n                  overflow-y: auto;\n                  align-items: flex-start;\n                  justify-content: flex-start;\n                "], ["\n                  gap: 15px;\n                  height: 100%;\n                  overflow-y: auto;\n                  align-items: flex-start;\n                  justify-content: flex-start;\n                "]))) }, { children: cart === null || cart === void 0 ? void 0 : cart.map(function (item) { return (jsx(CardCart, __assign({}, item), item.id)); }) })), jsx(Separator, { customCSS: css$1(templateObject_6$k || (templateObject_6$k = __makeTemplateObject(["\n                  background-color: #e4e4e4;\n                  margin: 0px;\n                "], ["\n                  background-color: #e4e4e4;\n                  margin: 0px;\n                "]))) }), jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_7$g || (templateObject_7$g = __makeTemplateObject(["\n                  gap: 15px;\n                  height: max-content;\n                  flex-direction: row;\n                "], ["\n                  gap: 15px;\n                  height: max-content;\n                  flex-direction: row;\n                "]))) }, { children: [jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_8$a || (templateObject_8$a = __makeTemplateObject(["\n                    align-items: flex-end;\n                    gap: 10px;\n                  "], ["\n                    align-items: flex-end;\n                    gap: 10px;\n                  "]))) }, { children: [jsx(Text$2, { children: "Subtotal (IVA Incluido)" }), jsx(Text$2, { children: "Envio" }), jsx(Text$2, __assign({ customCSS: css$1(templateObject_9$8 || (templateObject_9$8 = __makeTemplateObject(["\n                      font-size: 16px;\n                      font-weight: 700;\n                    "], ["\n                      font-size: 16px;\n                      font-weight: 700;\n                    "]))) }, { children: "Total" }))] })), jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_10$7 || (templateObject_10$7 = __makeTemplateObject(["\n                    align-items: flex-end;\n                    gap: 10px;\n                  "], ["\n                    align-items: flex-end;\n                    gap: 10px;\n                  "]))) }, { children: [jsx(Text$2, { children: "$".concat(numberWithCommas(cartsItems === null || cartsItems === void 0 ? void 0 : cartsItems.reduce(function (acc, item) { var _a; return acc + ((_a = item === null || item === void 0 ? void 0 : item.data) === null || _a === void 0 ? void 0 : _a.price) * item.quantity; }, 0)), " MXN") }), jsx(Text$2, { children: "Por definir" }), jsx(Text$2, __assign({ customCSS: css$1(templateObject_11$7 || (templateObject_11$7 = __makeTemplateObject(["\n                      font-size: 16px;\n                      font-weight: 700;\n                    "], ["\n                      font-size: 16px;\n                      font-weight: 700;\n                    "]))) }, { children: "$".concat(numberWithCommas(cartsItems === null || cartsItems === void 0 ? void 0 : cartsItems.reduce(function (acc, item) { var _a; return acc + ((_a = item === null || item === void 0 ? void 0 : item.data) === null || _a === void 0 ? void 0 : _a.price) * item.quantity; }, 0)), " MXN") }))] }))] })), jsx(AtomButton, __assign({ width: "100%", padding: "10px 0px", onClick: function () {
                                    setShow(false);
                                    router.push(path !== null && path !== void 0 ? path : "/feed/shop/checkout");
                                }, backgroundColor: (_k = (_j = customize === null || customize === void 0 ? void 0 : customize.colors) === null || _j === void 0 ? void 0 : _j.primary) !== null && _k !== void 0 ? _k : '#fe6a6a' }, { children: "PROCEDER CON EL PAGO" }))] })) }))) })] }));
};
var CardCart = function (props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    var id = props.id, quantity = props.quantity;
    var dispatch = useDispatch();
    var customize = useSelector(function (state) { return state.customize; });
    var _q = useQuery(GETPRODUCTBYID, {
        variables: {
            id: id,
        },
    }), data = _q.data, loading = _q.loading;
    return (jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_12$6 || (templateObject_12$6 = __makeTemplateObject(["\n        width: 100%;\n        display: flex;\n        flex-direction: row;\n        justify-content: flex-start;\n        align-items: flex-start;\n        padding: 10px;\n        gap: 20px;\n        border-radius: 4px;\n        background-color: #ffffff;\n        border: 1px solid #ebebeb;\n        box-shadow: 0px 0px 8px #dbdbdb78;\n        ", "\n      "], ["\n        width: 100%;\n        display: flex;\n        flex-direction: row;\n        justify-content: flex-start;\n        align-items: flex-start;\n        padding: 10px;\n        gap: 20px;\n        border-radius: 4px;\n        background-color: #ffffff;\n        border: 1px solid #ebebeb;\n        box-shadow: 0px 0px 8px #dbdbdb78;\n        ", "\n      "])), loading && SkletonStyles) }, { children: [jsx(Image$2, { src: (_a = data === null || data === void 0 ? void 0 : data.productById) === null || _a === void 0 ? void 0 : _a.photo, alt: "product", customCSS: css$1(templateObject_13$4 || (templateObject_13$4 = __makeTemplateObject(["\n          height: 100px;\n          width: 100px;\n          ", "\n        "], ["\n          height: 100px;\n          width: 100px;\n          ", "\n        "])), loading && SkletonStyles) }), jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_14$4 || (templateObject_14$4 = __makeTemplateObject(["\n          width: calc(100% - 100px);\n          gap: 5px;\n        "], ["\n          width: calc(100% - 100px);\n          gap: 5px;\n        "]))) }, { children: [jsx(Text$2, __assign({ customCSS: css$1(templateObject_15$4 || (templateObject_15$4 = __makeTemplateObject(["\n            font-size: 14px;\n            font-weight: 600;\n            display: -webkit-box;\n            -webkit-line-clamp: 1;\n            -webkit-box-orient: vertical;\n            overflow: hidden;\n            text-overflow: ellipsis;\n            ", "\n          "], ["\n            font-size: 14px;\n            font-weight: 600;\n            display: -webkit-box;\n            -webkit-line-clamp: 1;\n            -webkit-box-orient: vertical;\n            overflow: hidden;\n            text-overflow: ellipsis;\n            ", "\n          "])), loading && SkletonStyles) }, { children: (_b = data === null || data === void 0 ? void 0 : data.productById) === null || _b === void 0 ? void 0 : _b.title })), jsx(Text$2, { customCSS: css$1(templateObject_16$4 || (templateObject_16$4 = __makeTemplateObject(["\n            ", "\n            height: 20px;\n            font-size: 12px;\n            display: -webkit-box;\n            -webkit-line-clamp: 2;\n            -webkit-box-orient: vertical;\n            overflow: hidden;\n            text-overflow: ellipsis;\n          "], ["\n            ", "\n            height: 20px;\n            font-size: 12px;\n            display: -webkit-box;\n            -webkit-line-clamp: 2;\n            -webkit-box-orient: vertical;\n            overflow: hidden;\n            text-overflow: ellipsis;\n          "])), loading && SkletonStyles), dangerouslySetInnerHTML: {
                            __html: (_c = data === null || data === void 0 ? void 0 : data.productById) === null || _c === void 0 ? void 0 : _c.description,
                        } }), jsx(Text$2, __assign({ customCSS: css$1(templateObject_17$4 || (templateObject_17$4 = __makeTemplateObject(["\n            font-weight: 600;\n            ", "\n          "], ["\n            font-weight: 600;\n            ", "\n          "])), loading && SkletonStyles) }, { children: "$ ".concat(numberWithCommas(((_d = data === null || data === void 0 ? void 0 : data.productById) === null || _d === void 0 ? void 0 : _d.price) * quantity)) })), jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_18$3 || (templateObject_18$3 = __makeTemplateObject(["\n            flex-direction: row;\n            justify-content: flex-start;\n            gap: 5px;\n          "], ["\n            flex-direction: row;\n            justify-content: flex-start;\n            gap: 5px;\n          "]))) }, { children: [jsx(AtomButton, __assign({ onClick: function () { return dispatch(DeleteCart(id)); }, disabled: quantity === 1, customCSS: css$1(templateObject_19$3 || (templateObject_19$3 = __makeTemplateObject(["\n              display: flex;\n              flex-direction: row;\n              justify-content: center;\n              align-items: center;\n              width: 24px;\n              height: 24px;\n              padding: 0;\n              font-size: 10px;\n              background-color: ", ";\n            "], ["\n              display: flex;\n              flex-direction: row;\n              justify-content: center;\n              align-items: center;\n              width: 24px;\n              height: 24px;\n              padding: 0;\n              font-size: 10px;\n              background-color: ", ";\n            "])), (_f = (_e = customize === null || customize === void 0 ? void 0 : customize.colors) === null || _e === void 0 ? void 0 : _e.primary) !== null && _f !== void 0 ? _f : '#fe6a6a') }, { children: "-" })), jsx(AtomButton, __assign({ customCSS: css$1(templateObject_20$3 || (templateObject_20$3 = __makeTemplateObject(["\n              display: flex;\n              flex-direction: row;\n              justify-content: center;\n              align-items: center;\n              width: 24px;\n              height: 24px;\n              padding: 0;\n              font-size: 8px;\n              background-color: transparent;\n              border: 1px solid ", ";\n              color: ", ";\n            "], ["\n              display: flex;\n              flex-direction: row;\n              justify-content: center;\n              align-items: center;\n              width: 24px;\n              height: 24px;\n              padding: 0;\n              font-size: 8px;\n              background-color: transparent;\n              border: 1px solid ", ";\n              color: ", ";\n            "])), (_h = (_g = customize === null || customize === void 0 ? void 0 : customize.colors) === null || _g === void 0 ? void 0 : _g.primary) !== null && _h !== void 0 ? _h : '#fe6a6a', (_k = (_j = customize === null || customize === void 0 ? void 0 : customize.colors) === null || _j === void 0 ? void 0 : _j.primary) !== null && _k !== void 0 ? _k : '#fe6a6a') }, { children: quantity })), jsx(AtomButton, __assign({ onClick: function () { return dispatch(AddCart(id)); }, customCSS: css$1(templateObject_21$2 || (templateObject_21$2 = __makeTemplateObject(["\n              display: flex;\n              flex-direction: row;\n              justify-content: center;\n              align-items: center;\n              width: 24px;\n              height: 24px;\n              padding: 0;\n              font-size: 10px;\n              background-color: ", ";\n            "], ["\n              display: flex;\n              flex-direction: row;\n              justify-content: center;\n              align-items: center;\n              width: 24px;\n              height: 24px;\n              padding: 0;\n              font-size: 10px;\n              background-color: ", ";\n            "])), (_m = (_l = customize === null || customize === void 0 ? void 0 : customize.colors) === null || _l === void 0 ? void 0 : _l.primary) !== null && _m !== void 0 ? _m : '#fe6a6a') }, { children: "+" })), jsx(AtomButton, __assign({ onClick: function () { return dispatch(DeleteAllItemCart(id)); }, customCSS: css$1(templateObject_22$2 || (templateObject_22$2 = __makeTemplateObject(["\n              display: flex;\n              flex-direction: row;\n              justify-content: center;\n              align-items: center;\n              width: 24px;\n              height: 24px;\n              padding: 0;\n              font-size: 10px;\n              background-color: ", ";\n            "], ["\n              display: flex;\n              flex-direction: row;\n              justify-content: center;\n              align-items: center;\n              width: 24px;\n              height: 24px;\n              padding: 0;\n              font-size: 10px;\n              background-color: ", ";\n            "])), (_p = (_o = customize === null || customize === void 0 ? void 0 : customize.colors) === null || _o === void 0 ? void 0 : _o.primary) !== null && _p !== void 0 ? _p : '#fe6a6a') }, { children: jsx(Icon$1, { color: "white", height: "15px", width: "15px", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/JRO-0001/icons/Component%20199%20%E2%80%93%202.svg" }) }))] }))] }))] })));
};
var templateObject_1$1f, templateObject_2$W, templateObject_3$N, templateObject_4$B, templateObject_5$q, templateObject_6$k, templateObject_7$g, templateObject_8$a, templateObject_9$8, templateObject_10$7, templateObject_11$7, templateObject_12$6, templateObject_13$4, templateObject_14$4, templateObject_15$4, templateObject_16$4, templateObject_17$4, templateObject_18$3, templateObject_19$3, templateObject_20$3, templateObject_21$2, templateObject_22$2;

var color = {
    primary: '#ff4f66',
    darckBlue: '#023059',
    darkGray: '#4a4a49',
    lightGray: '#d8d8d8',
    background: '#fafbfc',
    white: '#fff',
    black: '#000000',
};

var ContactComponent = function (props) {
    var _a, _b;
    var image = props.image, name = props.name, messageSend = props.messageSend, onClick = props.onClick, colorPrimary = props.colorPrimary, componentProps = props.componentProps;
    return (jsxs(AtomButton, __assign({ customCSS: css$1(templateObject_1$1e || (templateObject_1$1e = __makeTemplateObject(["\n        outline: none;\n        border: none;\n        cursor: pointer;\n        width: 100%;\n        height: 100px;\n        background-color: ", ";\n        border-radius: 10px;\n        display: flex;\n        align-items: center;\n        margin-bottom: 10px;\n        padding: 20px;\n        &:hover {\n          filter: drop-shadow(5px 5px 5px ", ");\n        }\n      "], ["\n        outline: none;\n        border: none;\n        cursor: pointer;\n        width: 100%;\n        height: 100px;\n        background-color: ", ";\n        border-radius: 10px;\n        display: flex;\n        align-items: center;\n        margin-bottom: 10px;\n        padding: 20px;\n        &:hover {\n          filter: drop-shadow(5px 5px 5px ", ");\n        }\n      "])), color.background, colorPrimary || "gray"), onClick: onClick }, componentProps === null || componentProps === void 0 ? void 0 : componentProps.wrapperProps, { children: [jsx(Image$2, __assign({ src: image ||
                    'https://storage.googleapis.com/cdn-bucket-ixulabs-platform/MDCAO-0001/images/userDefault.avif', alt: "user avatar", customCSS: css$1(templateObject_2$V || (templateObject_2$V = __makeTemplateObject(["\n          width: 50px;\n          height: 50px;\n          object-fit: cover;\n          border-radius: 50%;\n          margin-right: 10px;\n        "], ["\n          width: 50px;\n          height: 50px;\n          object-fit: cover;\n          border-radius: 50%;\n          margin-right: 10px;\n        "]))) }, componentProps === null || componentProps === void 0 ? void 0 : componentProps.imageProps)), jsxs(Wrapper$2, __assign({ width: "auto", alignItems: "flex-start", customCSS: css$1(templateObject_3$M || (templateObject_3$M = __makeTemplateObject(["\n          h3 {\n            color: ", ";\n            button :hover & {\n              color: ", ";\n            }\n          }\n        "], ["\n          h3 {\n            color: ", ";\n            button :hover & {\n              color: ", ";\n            }\n          }\n        "])), color.darkGray, color.primary) }, (_a = componentProps === null || componentProps === void 0 ? void 0 : componentProps.containerMessageProps) === null || _a === void 0 ? void 0 : _a.wrapperProps, { children: [jsx(Text$2, __assign({ as: "h3" }, (_b = componentProps === null || componentProps === void 0 ? void 0 : componentProps.containerMessageProps) === null || _b === void 0 ? void 0 : _b.nameProps, { children: name })), jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_4$A || (templateObject_4$A = __makeTemplateObject(["\n            flex-direction: row;\n            justify-content: flex-start;\n            align-items: center;\n            p {\n              color: ", ";\n              font-size: 14px;\n            }\n          "], ["\n            flex-direction: row;\n            justify-content: flex-start;\n            align-items: center;\n            p {\n              color: ", ";\n              font-size: 14px;\n            }\n          "])), colorPrimary || 'gray') }, { children: [jsx(Icon$1, { width: "30px", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/icons/chat-icon.svg" }), jsx(Text$2, __assign({ as: "p" }, { children: messageSend || 'Enviar mensaje' }))] }))] }))] })));
};
var templateObject_1$1e, templateObject_2$V, templateObject_3$M, templateObject_4$A;

var AtomContainerStyled = function (props) { return css$1(templateObject_1$1d || (templateObject_1$1d = __makeTemplateObject(["\n  display: flex;\n  width: 100%;\n  min-height: ", ";\n  height: ", ";\n  flex-wrap: ", ";\n  flex-direction: ", ";\n  justify-content: ", ";\n  align-items: ", ";\n  padding: ", ";\n  margin: ", ";\n  position: ", ";\n  ", ";\n  background-color: ", ";\n  background-image: ", ";\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: ", ";\n\n  ", ";\n"], ["\n  display: flex;\n  width: 100%;\n  min-height: ", ";\n  height: ", ";\n  flex-wrap: ", ";\n  flex-direction: ", ";\n  justify-content: ", ";\n  align-items: ", ";\n  padding: ", ";\n  margin: ", ";\n  position: ", ";\n  ", ";\n  background-color: ", ";\n  background-image: ", ";\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: ", ";\n\n  ", ";\n"])), (props === null || props === void 0 ? void 0 : props.minHeight) || "max-content", (props === null || props === void 0 ? void 0 : props.height) || "max-content", (props === null || props === void 0 ? void 0 : props.flexWrap) || "wrap", (props === null || props === void 0 ? void 0 : props.flexDirection) || "column", (props === null || props === void 0 ? void 0 : props.justifyContent) || "center", (props === null || props === void 0 ? void 0 : props.alignItems) || "center", (props === null || props === void 0 ? void 0 : props.padding) || "initial", (props === null || props === void 0 ? void 0 : props.margin) || "initial", (props === null || props === void 0 ? void 0 : props.position) || "initial", (props === null || props === void 0 ? void 0 : props.shadow) && "box-shadow: 0px 10px 20px #00000029", (props === null || props === void 0 ? void 0 : props.backgroundColor) || "white", props === null || props === void 0 ? void 0 : props.backgroundImage, (props === null || props === void 0 ? void 0 : props.backgroundSize) || "cover", props === null || props === void 0 ? void 0 : props.customCSS); };
var AtomContainerDefaultStyled = styled$1(motion.main)(templateObject_2$U || (templateObject_2$U = __makeTemplateObject(["\n  ", ";\n"], ["\n  ", ";\n"])), function (props) { return AtomContainerStyled(props); });
var AtomContainerNavStyled = styled$1(motion.nav)(templateObject_3$L || (templateObject_3$L = __makeTemplateObject(["\n  ", ";\n"], ["\n  ", ";\n"])), function (props) { return AtomContainerStyled(props); });
var AtomContainerFooterStyled = styled$1(motion.footer)(templateObject_4$z || (templateObject_4$z = __makeTemplateObject(["\n  ", ";\n"], ["\n  ", ";\n"])), function (props) { return AtomContainerStyled(props); });
var templateObject_1$1d, templateObject_2$U, templateObject_3$L, templateObject_4$z;

var Container = function (props) {
    var children = props.children, as = props.as;
    switch (as) {
        case 'nav':
            return (jsx(AtomContainerNavStyled, __assign({}, props, { children: children })));
        case 'footer':
            return (jsx(AtomContainerFooterStyled, __assign({}, props, { children: children })));
        default:
            return (jsx(AtomContainerDefaultStyled, __assign({}, props, { children: children })));
    }
};

var Animation$c = {
    whileHover: { scale: 1.02, transition: { duration: 0.3 } },
    whileTap: { scale: 0.95, opacity: 0.8 },
};
var LinkForewardRef = forwardRef(function (props, ref) {
    var children = props.children;
    return (jsx(TextStyledA, __assign({}, Animation$c, { fontWeight: "bold", cursor: "pointer" }, props, { ref: ref }, { children: children })));
});
LinkForewardRef.displayName = 'LinkForewardRef';
var Link$1 = function (props) {
    var children = props.children, link = props.link;
    return link ? (jsx(NextLink, __assign({ href: link, passHref: true }, { children: jsx(LinkForewardRef, __assign({}, props, { children: children })) }))) : (jsx(TextStyledA, __assign({}, Animation$c, { fontWeight: "bold", cursor: "pointer", target: "_blank" }, props, { children: children })));
};

var RecursiveDropdown = function (props, recursive, hover, setHover, stylesWrapper, stylesText, stylesLink) {
    var _a = __read(useState(0), 2), actual = _a[0], setActual = _a[1];
    return (jsx(Wrapper$2, __assign({ position: "absolute", shadow: true, backgroundColor: "#fff", width: "max-content", justifyContent: "flex-start", alignItems: "center", borderRadius: "5px", padding: "5px 0", customCSS: css$1(templateObject_3$K || (templateObject_3$K = __makeTemplateObject(["\n        * {\n          align-items: center !important;\n          justify-content: space-around !important;\n          align-text: center;\n        }\n        ", "\n        transform: translateX(-50%);\n        a {\n          width: 100%;\n          padding: 5px 10px;\n          font-width: bold;\n        }\n        li {\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          width: max-content;\n          padding: 0px 4px;\n        }\n        min-width: 130px;\n      "], ["\n        * {\n          align-items: center !important;\n          justify-content: space-around !important;\n          align-text: center;\n        }\n        ", "\n        transform: translateX(-50%);\n        a {\n          width: 100%;\n          padding: 5px 10px;\n          font-width: bold;\n        }\n        li {\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          width: max-content;\n          padding: 0px 4px;\n        }\n        min-width: 130px;\n      "])), recursive
            ? css$1(templateObject_1$1c || (templateObject_1$1c = __makeTemplateObject(["\n              top: 0;\n              left: 140%;\n            "], ["\n              top: 0;\n              left: 140%;\n            "]))) : css$1(templateObject_2$T || (templateObject_2$T = __makeTemplateObject(["\n              top: 18px;\n              left: 50%;\n            "], ["\n              top: 18px;\n              left: 50%;\n            "])))) }, stylesWrapper, { children: props === null || props === void 0 ? void 0 : props.map(function (link, index) { return (jsx(Fragment$1, { children: link.type === 'dropdown' ? (jsxs(Link$1, __assign({ margin: "0px", onHoverEnd: function () { return setHover(false); }, onHoverStart: function () {
                    setHover(true);
                    setActual(index);
                }, customCSS: css$1(templateObject_4$y || (templateObject_4$y = __makeTemplateObject(["\n                width: 100%;\n                padding: 5px 10px;\n              "], ["\n                width: 100%;\n                padding: 5px 10px;\n              "]))) }, { children: [jsxs(Text$2, __assign({ fontSize: "12px", as: "a" }, link, { color: "#7F7F7F", padding: "5px 10px", align: "center", fontWeight: 600, customCSS: css$1(templateObject_5$p || (templateObject_5$p = __makeTemplateObject(["\n                  display: flex;\n                  flex-direction: row;\n                  align-items: center;\n                  border-radius: 2px;\n                  text-align: center;\n                  width: max-content;\n                  flex-grow: 1;\n                  align-items: center;\n                  justify-content: center;\n                  align-text: center;\n                  padding: 5px 10px;\n                  :hover {\n                    width: 100%;\n                    background-color: #dadada;\n                  }\n                  transition: background-color 0.3s ease;\n                "], ["\n                  display: flex;\n                  flex-direction: row;\n                  align-items: center;\n                  border-radius: 2px;\n                  text-align: center;\n                  width: max-content;\n                  flex-grow: 1;\n                  align-items: center;\n                  justify-content: center;\n                  align-text: center;\n                  padding: 5px 10px;\n                  :hover {\n                    width: 100%;\n                    background-color: #dadada;\n                  }\n                  transition: background-color 0.3s ease;\n                "]))) }, stylesText, { children: [link.label, jsx(Icon$1, { customCSS: css$1(templateObject_6$j || (templateObject_6$j = __makeTemplateObject(["\n                    margin: 0px 0px 0px 10px;\n                    transform: rotate(-90deg);\n                  "], ["\n                    margin: 0px 0px 0px 10px;\n                    transform: rotate(-90deg);\n                  "]))), height: "10px", width: "10px", color: "#7F7F7F", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-commons/frontend-library/icons/arrow-down-3101.svg" })] })), link.subFields && hover && index === actual && (jsx(RecursiveDropdownHook, { data: link.subFields, recursive: true }))] }), "".concat(index + 1))) : (jsx(Link$1, __assign({ fontSize: "12px", as: "a" }, link, { color: "#7F7F7F", padding: "5px 10px", margin: "4px 0px", fontWeight: 600, customCSS: css$1(templateObject_7$f || (templateObject_7$f = __makeTemplateObject(["\n                display: flex;\n                flex-direction: row;\n                align-items: center;\n                border-radius: 2px;\n                text-align: center;\n                width: 100%;\n                padding: 5px 10px;\n                :hover {\n                  width: 100%;\n                  background-color: #dadada;\n                }\n                transition: background-color 0.3s ease;\n              "], ["\n                display: flex;\n                flex-direction: row;\n                align-items: center;\n                border-radius: 2px;\n                text-align: center;\n                width: 100%;\n                padding: 5px 10px;\n                :hover {\n                  width: 100%;\n                  background-color: #dadada;\n                }\n                transition: background-color 0.3s ease;\n              "]))) }, stylesLink, { children: link.label }))) })); }) })));
};
var RecursiveDropdownHook = function (_a) {
    var data = _a.data, _b = _a.recursive, recursive = _b === void 0 ? false : _b, stylesWrapper = _a.stylesWrapper, stylesText = _a.stylesText, stylesLink = _a.stylesLink;
    var _c = __read(useState(false), 2), hover = _c[0], setHover = _c[1];
    return (jsx(Fragment$1, { children: RecursiveDropdown(data, recursive, hover, setHover, stylesWrapper, stylesText, stylesLink) }));
};
var templateObject_1$1c, templateObject_2$T, templateObject_3$K, templateObject_4$y, templateObject_5$p, templateObject_6$j, templateObject_7$f;

styled$1(motion.ul)(templateObject_1$1b || (templateObject_1$1b = __makeTemplateObject(["\n  display: flex;\n  position: absolute;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 100%;\n  width: max-content;\n  background-color: white;\n  align-items: center;\n  justify-content: flex-start;\n  flex-direction: column;\n  border-radius: 4px;\n  box-shadow: 0px 10px 20px #00000029;\n  padding: 5px;\n"], ["\n  display: flex;\n  position: absolute;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 100%;\n  width: max-content;\n  background-color: white;\n  align-items: center;\n  justify-content: flex-start;\n  flex-direction: column;\n  border-radius: 4px;\n  box-shadow: 0px 10px 20px #00000029;\n  padding: 5px;\n"])));
var LinkStyled$3 = styled$1(motion.li)(templateObject_2$S || (templateObject_2$S = __makeTemplateObject(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: row;\n  cursor: pointer;\n  position: relative;\n  width: 100%;\n  padding: 0px 40px;\n  justify-content: space-between;\n  :hover {\n    width: 100%;\n    background-color: #a01d7f;\n    a {\n      color: white;\n    }\n  }\n\n  ", ";\n"], ["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: row;\n  cursor: pointer;\n  position: relative;\n  width: 100%;\n  padding: 0px 40px;\n  justify-content: space-between;\n  :hover {\n    width: 100%;\n    background-color: #a01d7f;\n    a {\n      color: white;\n    }\n  }\n\n  ", ";\n"])), function (_a) {
    var customcss = _a.customcss;
    return customcss;
});
styled$1(motion.ul)(templateObject_3$J || (templateObject_3$J = __makeTemplateObject(["\n  display: flex;\n  width: max-content;\n  align-items: center;\n  justify-content: flex-start;\n  flex-direction: column;\n  border-radius: 4px;\n  cursor: pointer;\n  :hover {\n    width: 100%;\n    background-color: #dadada;\n  }\n  transition: background-color 0.3s ease;\n"], ["\n  display: flex;\n  width: max-content;\n  align-items: center;\n  justify-content: flex-start;\n  flex-direction: column;\n  border-radius: 4px;\n  cursor: pointer;\n  :hover {\n    width: 100%;\n    background-color: #dadada;\n  }\n  transition: background-color 0.3s ease;\n"])));
styled$1(motion.li)(templateObject_4$x || (templateObject_4$x = __makeTemplateObject(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: row;\n  cursor: pointer;\n  width: 100%;\n  position: absolute;\n  top: 0;\n  left: 70%;\n  font-size: 12px;\n  color: #7f7f7f;\n  box-shadow: 0px 10px 20px #00000029;\n  z-index: 1;\n"], ["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: row;\n  cursor: pointer;\n  width: 100%;\n  position: absolute;\n  top: 0;\n  left: 70%;\n  font-size: 12px;\n  color: #7f7f7f;\n  box-shadow: 0px 10px 20px #00000029;\n  z-index: 1;\n"])));
var templateObject_1$1b, templateObject_2$S, templateObject_3$J, templateObject_4$x;

var AtomDropdownSidebarAdmin = function (props) {
    var links = props.links, _a = props.level, level = _a === void 0 ? 0 : _a, componentsProps = props.componentsProps;
    var _b = __read(useState(false), 2), showSubLinks = _b[0], setShowSubLinks = _b[1];
    return (jsx(Fragment$1, { children: links === null || links === void 0 ? void 0 : links.map(function (subField) { return (jsxs(Fragment$2, { children: [jsxs(LinkStyled$3, __assign({ onClick: function () {
                        return subField.type === 'dropdown' && setShowSubLinks(!showSubLinks);
                    } }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.linkProps, { children: [jsx(Link$1, __assign({ as: "a" }, subField, { color: "#7F7F7F", fontWeight: 600, padding: "15px ".concat(level * 10, "px") }, { children: subField.label })), subField.type === 'dropdown' && (jsx(Icon$1, { height: "14px", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-commons/frontend-library/icons/arrow-down-3101.svg", color: "#1F1F1F" }))] })), showSubLinks && (jsx(AtomDropdownSidebarAdmin, { links: subField.subFields, level: level + 1 }))] }, subField.id)); }) }));
};

styled$1(motion.ul)(templateObject_1$1a || (templateObject_1$1a = __makeTemplateObject(["\n  display: flex;\n  position: absolute;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 100%;\n  width: max-content;\n  background-color: white;\n  align-items: center;\n  justify-content: flex-start;\n  flex-direction: column;\n  border-radius: 4px;\n  box-shadow: 0px 10px 20px #00000029;\n  padding: 5px;\n"], ["\n  display: flex;\n  position: absolute;\n  left: 50%;\n  transform: translateX(-50%);\n  top: 100%;\n  width: max-content;\n  background-color: white;\n  align-items: center;\n  justify-content: flex-start;\n  flex-direction: column;\n  border-radius: 4px;\n  box-shadow: 0px 10px 20px #00000029;\n  padding: 5px;\n"])));
var LinkStyled$2 = styled$1(motion.li)(templateObject_2$R || (templateObject_2$R = __makeTemplateObject(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: row;\n  cursor: pointer;\n  position: relative;\n  width: 100%;\n  padding: 0px 40px;\n  justify-content: space-between;\n  :hover {\n    width: 100%;\n    background-color: #a01d7f;\n    a {\n      color: white;\n    }\n  }\n\n  ", ";\n"], ["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: row;\n  cursor: pointer;\n  position: relative;\n  width: 100%;\n  padding: 0px 40px;\n  justify-content: space-between;\n  :hover {\n    width: 100%;\n    background-color: #a01d7f;\n    a {\n      color: white;\n    }\n  }\n\n  ", ";\n"])), function (_a) {
    var customcss = _a.customcss;
    return customcss;
});
styled$1(motion.ul)(templateObject_3$I || (templateObject_3$I = __makeTemplateObject(["\n  display: flex;\n  width: max-content;\n  align-items: center;\n  justify-content: flex-start;\n  flex-direction: column;\n  border-radius: 4px;\n  cursor: pointer;\n  :hover {\n    width: 100%;\n    background-color: #dadada;\n  }\n  transition: background-color 0.3s ease;\n"], ["\n  display: flex;\n  width: max-content;\n  align-items: center;\n  justify-content: flex-start;\n  flex-direction: column;\n  border-radius: 4px;\n  cursor: pointer;\n  :hover {\n    width: 100%;\n    background-color: #dadada;\n  }\n  transition: background-color 0.3s ease;\n"])));
styled$1(motion.li)(templateObject_4$w || (templateObject_4$w = __makeTemplateObject(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: row;\n  cursor: pointer;\n  width: 100%;\n  position: absolute;\n  top: 0;\n  left: 70%;\n  font-size: 12px;\n  color: #7f7f7f;\n  box-shadow: 0px 10px 20px #00000029;\n  z-index: 1;\n"], ["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: row;\n  cursor: pointer;\n  width: 100%;\n  position: absolute;\n  top: 0;\n  left: 70%;\n  font-size: 12px;\n  color: #7f7f7f;\n  box-shadow: 0px 10px 20px #00000029;\n  z-index: 1;\n"])));
var templateObject_1$1a, templateObject_2$R, templateObject_3$I, templateObject_4$w;

var AtomDropdownSidebarDefault = function (props) {
    var links = props.links, _a = props.level, level = _a === void 0 ? 0 : _a, componentsProps = props.componentsProps;
    var _b = __read(useState(false), 2), showSubLinks = _b[0], setShowSubLinks = _b[1];
    return (jsx(Fragment$1, { children: links === null || links === void 0 ? void 0 : links.map(function (subField) { return (jsxs(Fragment$2, { children: [jsxs(LinkStyled$2, __assign({ onClick: function () {
                        return subField.type === 'dropdown' && setShowSubLinks(!showSubLinks);
                    } }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.linkProps, { children: [jsx(Link$1, __assign({ as: "a" }, subField, { color: "#7F7F7F", fontWeight: 600, padding: "15px ".concat(level * 10, "px") }, { children: subField.label })), subField.type === 'dropdown' && (jsx(Icon$1, { height: "14px", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-commons/frontend-library/icons/arrow-down-3101.svg", color: "#1F1F1F" }))] })), showSubLinks && (jsx(AtomDropdownSidebarDefault, { links: subField.subFields, level: level + 1 }))] }, subField.id)); }) }));
};

var ContainerLinkStyled$1 = styled$1(motion.ul)(templateObject_2$Q || (templateObject_2$Q = __makeTemplateObject(["\n  display: flex;\n  align-items: center;\n  justify-content: flex-start;\n  flex-direction: row;\n  ", "\n"], ["\n  display: flex;\n  align-items: center;\n  justify-content: flex-start;\n  flex-direction: row;\n  ", "\n"])), css$1(templateObject_1$19 || (templateObject_1$19 = __makeTemplateObject(["\n    @media only screen and (max-width: 1200px) {\n      display: none;\n    }\n  "], ["\n    @media only screen and (max-width: 1200px) {\n      display: none;\n    }\n  "]))));
var LinkStyled$1 = styled$1(motion.li)(templateObject_3$H || (templateObject_3$H = __makeTemplateObject(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: max-content;\n  flex-direction: row;\n  margin: ", ";\n  cursor: pointer;\n  position: relative;\n\n  ", ";\n"], ["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: max-content;\n  flex-direction: row;\n  margin: ", ";\n  cursor: pointer;\n  position: relative;\n\n  ", ";\n"])), function (props) { return props.margin || '0px 25px 0px 0px'; }, function (_a) {
    var customcss = _a.customcss;
    return customcss;
});
styled$1(motion.ul)(templateObject_4$v || (templateObject_4$v = __makeTemplateObject(["\n  display: flex;\n  position: relative;\n  align-items: center;\n  justify-content: flex-start;\n  flex-direction: column;\n"], ["\n  display: flex;\n  position: relative;\n  align-items: center;\n  justify-content: flex-start;\n  flex-direction: column;\n"])));
var templateObject_1$19, templateObject_2$Q, templateObject_3$H, templateObject_4$v;

var AtomDropdownSidebarLinks = function (props) {
    var links = props.links, _a = props.linksQuanty, linksQuanty = _a === void 0 ? 4 : _a;
    var _b = __read(useState(false), 2), treeSubFileds = _b[0], setTreeSubFileds = _b[1];
    var _c = __read(useState(false), 2), showMoreLinks = _c[0], setShowMoreLikns = _c[1];
    return (jsx(ContainerLinkStyled$1, __assign({ onHoverEnd: function () { return setTreeSubFileds(false); } }, { children: links.length > linksQuanty - 1 ? (jsxs(Fragment$1, { children: [links
                    .filter(function (_, index) { return index < linksQuanty; })
                    .map(function (link) {
                    return (link === null || link === void 0 ? void 0 : link.type) === 'dropdown' ? (jsxs(LinkStyled$1, __assign({ onHoverStart: function () { return setTreeSubFileds(true); } }, { children: [jsxs(Text$2, __assign({ fontSize: "12px", as: "span" }, link, { color: "#6c6c6c", fontWeight: 600, cursor: "pointer", customCSS: css$1(templateObject_1$18 || (templateObject_1$18 = __makeTemplateObject(["\n                      display: flex;\n                      align-items: center;\n                      justify-content: center;\n                    "], ["\n                      display: flex;\n                      align-items: center;\n                      justify-content: center;\n                    "]))) }, { children: [link.label, jsx(Icon$1, { height: "10px", width: "10px", color: "#6c6c6c", customCSS: css$1(templateObject_2$P || (templateObject_2$P = __makeTemplateObject(["\n                        margin: 0px 0px 0px 10px;\n                      "], ["\n                        margin: 0px 0px 0px 10px;\n                      "]))), icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-commons/frontend-library/icons/arrow-down-3101.svg" })] })), treeSubFileds && jsx(RecursiveDropdownHook, { data: link === null || link === void 0 ? void 0 : link.subFields })] }), link.id)) : (jsx(LinkStyled$1, { children: jsx(Link$1, __assign({ fontSize: "12px", as: "a" }, link, { color: "#6c6c6c", fontWeight: 600 }, { children: link.label })) }, link.id));
                }), links.filter(function (_, index) { return index > linksQuanty - 1; }).length > 0 && (jsxs(Wrapper$2, __assign({ as: "li", position: "relative", flexDirection: "row", width: "max-content", height: "max-content", onHoverEnd: function () { return setShowMoreLikns(false); }, onHoverStart: function () { return setShowMoreLikns(true); } }, { children: [jsxs(AtomButton, __assign({ borderRadius: "100%", width: "18px", height: "18px", padding: "0", customCSS: css$1(templateObject_3$G || (templateObject_3$G = __makeTemplateObject(["\n                  display: flex;\n                  background-color: transparent;\n                  align-items: center;\n                  justify-content: center;\n                  fill: #fff;\n                  stroke: #fff;\n                  :hover {\n                    background-color: #dadada;\n                  }\n\n                  transition: background-color 0.3s ease;\n                "], ["\n                  display: flex;\n                  background-color: transparent;\n                  align-items: center;\n                  justify-content: center;\n                  fill: #fff;\n                  stroke: #fff;\n                  :hover {\n                    background-color: #dadada;\n                  }\n\n                  transition: background-color 0.3s ease;\n                "]))) }, { children: [jsx(Icon$1, { width: "11px", height: "11px", color: "#1d1d1b", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/PFS-0001/outline/three-dots-svgrepo-com.svg" }), jsx(Text$2, __assign({ customCSS: css$1(templateObject_4$u || (templateObject_4$u = __makeTemplateObject(["\n                    width: 0px;\n                    height: 0px;\n                    opacity: 0;\n                  "], ["\n                    width: 0px;\n                    height: 0px;\n                    opacity: 0;\n                  "]))) }, { children: "MENU" }))] })), showMoreLinks && (jsx(RecursiveDropdownHook, { data: links.filter(function (_, index) { return index > linksQuanty - 1; }) }))] })))] })) : (jsx(Fragment$1, { children: links.map(function (link) { return (jsx(LinkStyled$1, { children: jsx(Link$1, __assign({ fontSize: "12px", as: "a" }, link, { color: "#7F7F7F", fontWeight: 600 }, { children: link.label })) }, link.id)); }) })) })));
};
var templateObject_1$18, templateObject_2$P, templateObject_3$G, templateObject_4$u;

styled$1(motion.div)(templateObject_1$17 || (templateObject_1$17 = __makeTemplateObject(["\n  width: 100%;\n  display: flex;\n  flex-direction: row;\n"], ["\n  width: 100%;\n  display: flex;\n  flex-direction: row;\n"])));
var InputTBodyStyled = styled$1.tbody(templateObject_2$O || (templateObject_2$O = __makeTemplateObject(["\n  padding: 10px;\n  width: 100%;\n  gap: 10px;\n  display: flex;\n  flex-direction: column;\n  td {\n    font-family: 'Montserrat', sans-serif;\n    color: #565656;\n    font-size: 14px;\n    display: flex;\n    flex-direction: column;\n    /* padding: 15px 30px; */\n    width: 100%;\n    text-align: left;\n  }\n  tr {\n    width: 100%;\n    background-color: #fefefe;\n    transition: all 0.3s ease-in-out;\n    border-bottom: 1px solid #eeeeee;\n    z-index: 2;\n  }\n  tr:hover {\n    background-color: #fafafa;\n  }\n"], ["\n  padding: 10px;\n  width: 100%;\n  gap: 10px;\n  display: flex;\n  flex-direction: column;\n  td {\n    font-family: 'Montserrat', sans-serif;\n    color: #565656;\n    font-size: 14px;\n    display: flex;\n    flex-direction: column;\n    /* padding: 15px 30px; */\n    width: 100%;\n    text-align: left;\n  }\n  tr {\n    width: 100%;\n    background-color: #fefefe;\n    transition: all 0.3s ease-in-out;\n    border-bottom: 1px solid #eeeeee;\n    z-index: 2;\n  }\n  tr:hover {\n    background-color: #fafafa;\n  }\n"])));
styled$1(motion.div)(templateObject_4$t || (templateObject_4$t = __makeTemplateObject(["\n  display: flex;\n  align-items: ", ";\n  justify-content: ", ";\n  font-family: ", ";\n  font-size: ", ";\n  font-weight: ", ";\n  margin: ", ";\n  padding: ", ";\n  ", "\n  color: ", ";\n  ::placeholder {\n    color: ", ";\n  }\n  background-color: ", ";\n  height: ", ";\n  width: ", ";\n  max-width: ", ";\n  border-radius: ", ";\n  border: ", ";\n"], ["\n  display: flex;\n  align-items: ", ";\n  justify-content: ", ";\n  font-family: ", ";\n  font-size: ", ";\n  font-weight: ", ";\n  margin: ", ";\n  padding: ", ";\n  ", "\n  color: ", ";\n  ::placeholder {\n    color: ", ";\n  }\n  background-color: ", ";\n  height: ", ";\n  width: ", ";\n  max-width: ", ";\n  border-radius: ", ";\n  border: ", ";\n"])), function (_a) {
    var alignItems = _a.alignItems;
    return alignItems !== null && alignItems !== void 0 ? alignItems : 'flex-start';
}, function (_a) {
    var justifyContent = _a.justifyContent;
    return justifyContent !== null && justifyContent !== void 0 ? justifyContent : 'flex-start';
}, function (_a) {
    var fontFamily = _a.fontFamily;
    return fontFamily || "'Montserrat', sans-serif";
}, function (_a) {
    var fontSize = _a.fontSize;
    return fontSize || "12px";
}, function (_a) {
    var fontWeight = _a.fontWeight;
    return fontWeight || "600";
}, function (_a) {
    var margin = _a.margin;
    return margin || "0px 0px 0px 0px";
}, function (_a) {
    var padding = _a.padding;
    return padding || "0px 0px 0px 0px";
}, function (_a) {
    var autoFocus = _a.autoFocus;
    return autoFocus && css$1(templateObject_3$F || (templateObject_3$F = __makeTemplateObject(["\n      box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);\n      border-color: #0f1e2f;\n    "], ["\n      box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);\n      border-color: #0f1e2f;\n    "])));
}, function (_a) {
    var color = _a.color;
    return color || "#1a1a1a";
}, function (_a) {
    var placeholderColor = _a.placeholderColor;
    return placeholderColor || "#202124";
}, function (_a) {
    var backgroundColor = _a.backgroundColor;
    return backgroundColor || "#ffffff";
}, function (_a) {
    var height = _a.height;
    return height || "auto";
}, function (_a) {
    var width = _a.width;
    return width || "100%";
}, function (_a) {
    var maxWidth = _a.maxWidth;
    return maxWidth || "100%";
}, function (_a) {
    var borderRadius = _a.borderRadius;
    return borderRadius || "4px";
}, function (_a) {
    var border = _a.border;
    return border || "1px solid #f2f2f2";
});
var InputSelectPaginationLabelStyled = styled$1(motion.label)(templateObject_5$o || (templateObject_5$o = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  cursor: pointer !important;\n  font-family: ", ";\n  margin: ", ";\n  color: ", ";\n  width: ", ";\n  height: ", ";\n  font-size: ", ";\n  text-align: ", ";\n  font-weight: ", ";\n  position: relative;\n  ", ";\n"], ["\n  display: flex;\n  flex-direction: column;\n  cursor: pointer !important;\n  font-family: ", ";\n  margin: ", ";\n  color: ", ";\n  width: ", ";\n  height: ", ";\n  font-size: ", ";\n  text-align: ", ";\n  font-weight: ", ";\n  position: relative;\n  ", ";\n"])), function (_a) {
    var labelFontFamily = _a.labelFontFamily;
    return labelFontFamily || "'Montserrat', sans-serif";
}, function (_a) {
    var labelMargin = _a.labelMargin;
    return labelMargin || "0px 0px 0px 0px";
}, function (_a) {
    var labelColor = _a.labelColor;
    return labelColor || "black";
}, function (_a) {
    var labelWidth = _a.labelWidth;
    return labelWidth || "100%";
}, function (_a) {
    var labelHeight = _a.labelHeight;
    return labelHeight || "max-content";
}, function (_a) {
    var labelFontSize = _a.labelFontSize;
    return labelFontSize || "16px";
}, function (_a) {
    var labelTextAlign = _a.labelTextAlign;
    return labelTextAlign || "left";
}, function (_a) {
    var labelFontWeight = _a.labelFontWeight;
    return labelFontWeight || "500";
}, function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
// export const GlobalContainerStyled = styled.label<AtomInputTypes>`
//   display: flex;
//   flex-direction: column;
//   justify-content: center;
//   font-size: ${({ fontsize }) => fontsize || `12px`};
//   width: ${({ width }) => width || `max-content`};
// `;
// export const InputLabelStyled = styled.label<AtomInputTypes>`
//   font-family: ${({ font }) => font || `'Montserrat', sans-serif`};
//   display: flex;
//   flex-direction: column;
//   width: ${({ width }) => width || `250px`};
//   height: max-content;
//   color: ${({ colorLabel }) => colorLabel || `#47585d`};
//   font-size: ${({ fontsize }) => fontsize || `12px`};
//   font-weight: 600;
// `;
// export const ContainerRadioStyled = styled.div<AtomInputTypes>`
//   font-family: ${({ font }) => font || `'Montserrat', sans-serif`};
//   display: flex;
//   flex-direction: column;
//   width: ${({ width }) => width || `250px`};
//   height: max-content;
//   color: ${({ colorLabel }) => colorLabel || `#47585d`};
//   font-size: ${({ fontsize }) => fontsize || `12px`};
//   font-weight: 600;
//   fieldset {
//     margin-top: 10px;
//     border: none;
//     display: flex;
//     width: 100%;
//     flex-wrap: wrap;
//     justify-content: space-between;
//     label {
//       width: max-content;
//     }
//   }
// `;
// export const DragDropStyled = styled.div<AtomInputTypes>`
//   border-radius: 10px;
//   background-color: #f6f7fb;
//   margin: 5px 0px 20px 0px;
//   height: ${({ height }) => height || `150px`};
//   display: flex;
//   justify-content: center;
//   align-items: center;
//   color: #a5a7ad;
// `;
// export const RadioLabelStyled = styled.label<AtomInputTypes>`
//   font-family: ${({ font }) => font || `'Montserrat', sans-serif`};
//   display: flex;
//   align-items: center;
//   justify-content: center;
//   height: max-content;
//   width: ${({ width }) => width || `250px`};
//   color: ${({ colorLabel }) => colorLabel || `#47585d`};
//   font-size: ${({ fontsize }) => fontsize || `12px`};
//   font-weight: 500;
// `;
// export const RadioInputStyled = styled.input<AtomInputTypes>`
//   margin-right: 10px;
//   display: flex;
// `;
// export const CheckboxLabelStyled = styled.label<AtomInputTypes>`
//   font-family: ${({ font }) => font || `'Montserrat', sans-serif`};
//   margin: ${({ margin }) => margin || `10px 0px 0px 30px`};
//   display: flex;
//   align-items: center;
//   width: ${({ width }) => width || `max-content`};
//   justify-content: center;
//   height: max-content;
//   font-size: ${({ fontsize }) => fontsize || `12px`};
//   font-weight: 600;
//   color: ${({ colorLabel }) => colorLabel || `#47585d`};
//   button {
//     margin-left: 5px;
//     border: none;
//     background-color: transparent;
//     color: #2b6ab5;
//     font-size: 14px;
//     font-weight: 600;
//     text-decoration: underline;
//   }
// `;
// export const SelectLabelStyled = styled.label<AtomInputTypes>`
//   font-family: ${({ font }) => font || `'Montserrat', sans-serif`};
//   display: flex;
//   flex-direction: column;
//   width: ${({ width }) => width || `250px`};
//   align-items: flex-start;
//   justify-content: center;
//   height: max-content;
//   font-size: ${({ fontsize }) => fontsize || `12px`};
//   font-weight: 600;
//   color: ${({ colorLabel }) => colorLabel || `#47585d`};
//   margin: ${({ marginLabel }) => marginLabel || `0px 0px`};
// `;
// export const SelectInputStyled = styled.select<AtomInputTypes>`
//   font-family: ${({ font }) => font || `'Montserrat', sans-serif`};
//   margin: ${({ margin }) => margin || `10px 0px 20px 0px`};
//   padding: 0px 10px;
//   display: flex;
//   width: 100%;
//   height: ${({ height }) => height || `35px`};
//   font-size: ${({ fontsize }) => fontsize || `12px`};
//   font-weight: 500;
//   border-radius: ${({ borderRadius }) => borderRadius || `10px`};
//   border: ${({ border }) => border || `2px solid #c8d2dd;`};
//   color: ${({ optionColor }) => optionColor || `#244a77`};
//   option {
//     margin: 5px 0px;
//     font-size: ${({ fontsize }) => fontsize || `12px`};
//     font-weight: 600;
//     color: ${({ optionColor }) => optionColor || `#75758b`};
//     border: ${({ border }) => border || `2px solid #c8d2dd;`};
//   }
//   ${({ disabled }) =>
//     disabled &&
//     css`
//       background-color: #fafafa;
//     `}
// `;
// export const CheckboxInputStyled = styled.input<AtomInputTypes>`
//   margin-right: 10px;
//   display: flex;
//   border: solid 1px #244a77;
// `;
// export const SelectBigLabelStyled = styled.label<AtomInputTypes>`
//   display: flex;
//   flex-direction: column;
//   width: ${({ width }) => width || `250px`};
//   align-items: flex-start;
//   justify-content: center;
//   height: max-content;
//   font-weight: 600;
//   position: relative;
//   color: ${({ colorLabel }) => colorLabel || `#47585d`};
// `;
// export const TextAreaInputStyled = styled.textarea<AtomInputTypes>`
//   font-family: ${({ font }) => font || `'Montserrat', sans-serif`};
//   margin: 10px 0px 20px 0px;
//   padding: 0px 10px;
//   display: flex;
//   width: 100%;
//   height: ${({ height }) => height || `150px`};
//   border-radius: 10px;
//   border: 2px solid #c8d2dd;
//   font-size: ${({ fontsize }) => fontsize || `12px`};
//   border-radius: ${({ borderRadius }) => borderRadius || `10px`};
//   border: ${({ border }) => border || `2px solid #c8d2dd;`};
//   font-weight: 500;
//   padding-top: 10px;
//   color: #0f1e2f;
//   font-family: "Montserrat", sans-serif;
//   font-weight: bold;
//   resize: none;
// `;
// export const SelectBigInputStyled = styled.select<AtomInputTypes>`
//   font-family: ${({ font }) => font || `'Montserrat', sans-serif`};
//   margin: 10px 0px 20px 0px;
//   padding: 0px 10px;
//   display: flex;
//   width: 100%;
//   height: 30px;
//   border-radius: 10px;
//   border: 2px solid #c8d2dd;
//   font-size: ${({ fontsize }) => fontsize || `12px`};
//   font-weight: 500;
//   color: #244a77;
//   div {
//     background-color: red;
//     display: flex;
//     height: 400px;
//     position: absolute;
//   }
//   option {
//     margin: 5px 0px;
//     font-size: ${({ fontsize }) => fontsize || `12px`};
//     font-weight: 600;
//     color: #75758b;
//     border: 2px solid #c8d2dd;
//   }
// `;
// export const FileInputStyled = styled.label<AtomInputTypes>`
//   font-family: ${({ font }) => font || `'Montserrat', sans-serif`};
//   margin: 10px 0px 20px 0px;
//   padding: 0px 10px;
//   display: flex;
//   width: 100%;
//   position: relative;
//   height: ${({ height }) => height || `170px`};
//   border-radius: 10px;
//   background-color: #f6f7fb;
//   border-radius: 4px;
//   font-size: ${({ fontsize }) => fontsize || `12px`};
//   font-weight: 500;
//   color: #a5a7ad;
//   cursor: pointer;
//   display: flex;
//   justify-content: center;
//   align-items: center;
//   ${({ dropActive }) =>
//     dropActive &&
//     css`
//       border: 2px solid #c8d2dd;
//       background-color: #193452;
//       color: white;
//     `}
//   span {
//     display: flex;
//     align-items: center;
//     justify-content: center;
//     img {
//       width: 20px;
//       margin-right: 10px;
//     }
//   }
//   input {
//     opacity: 0;
//     position: absolute;
//     z-index: -1;
//   }
//   .preview {
//     border-radius: 4px;
//     position: absolute;
//     width: 100%;
//     height: 100%;
//     object-fit: cover;
//   }
// `;
/// ///////////////////////////////////////////////////////////////////////////////////////////
var InputTextLabelStyled = styled$1(motion.label)(templateObject_6$i || (templateObject_6$i = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  font-family: ", ";\n  margin: ", ";\n  color: ", ";\n  width: ", ";\n  height: ", ";\n  font-size: ", ";\n  text-align: ", ";\n  font-weight: ", ";\n  position: relative;\n\n  ", ";\n"], ["\n  display: flex;\n  flex-direction: column;\n  font-family: ", ";\n  margin: ", ";\n  color: ", ";\n  width: ", ";\n  height: ", ";\n  font-size: ", ";\n  text-align: ", ";\n  font-weight: ", ";\n  position: relative;\n\n  ", ";\n"])), function (_a) {
    var labelFontFamily = _a.labelFontFamily;
    return labelFontFamily || "'Montserrat', sans-serif";
}, function (_a) {
    var labelMargin = _a.labelMargin;
    return labelMargin || "0px 0px 0px 0px";
}, function (_a) {
    var labelColor = _a.labelColor;
    return labelColor || "black";
}, function (_a) {
    var labelWidth = _a.labelWidth;
    return labelWidth || "max-content";
}, function (_a) {
    var labelHeight = _a.labelHeight;
    return labelHeight || "max-content";
}, function (_a) {
    var labelFontSize = _a.labelFontSize;
    return labelFontSize || "16px";
}, function (_a) {
    var labelTextAlign = _a.labelTextAlign;
    return labelTextAlign || "left";
}, function (_a) {
    var labelFontWeight = _a.labelFontWeight;
    return labelFontWeight || "500";
}, function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
var InputCheckboxLabelStyled = styled$1(motion.label)(templateObject_7$e || (templateObject_7$e = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  font-family: ", ";\n  margin: ", ";\n  color: ", ";\n  width: ", ";\n  height: ", ";\n  font-size: ", ";\n  text-align: ", ";\n  font-weight: ", ";\n  position: relative;\n\n  ", ";\n"], ["\n  display: flex;\n  flex-direction: column;\n  font-family: ", ";\n  margin: ", ";\n  color: ", ";\n  width: ", ";\n  height: ", ";\n  font-size: ", ";\n  text-align: ", ";\n  font-weight: ", ";\n  position: relative;\n\n  ", ";\n"])), function (_a) {
    var labelFontFamily = _a.labelFontFamily;
    return labelFontFamily || "'Montserrat', sans-serif";
}, function (_a) {
    var labelMargin = _a.labelMargin;
    return labelMargin || "0px 0px 0px 0px";
}, function (_a) {
    var labelColor = _a.labelColor;
    return labelColor || "black";
}, function (_a) {
    var labelWidth = _a.labelWidth;
    return labelWidth || "max-content";
}, function (_a) {
    var labelHeight = _a.labelHeight;
    return labelHeight || "max-content";
}, function (_a) {
    var labelFontSize = _a.labelFontSize;
    return labelFontSize || "16px";
}, function (_a) {
    var labelTextAlign = _a.labelTextAlign;
    return labelTextAlign || "left";
}, function (_a) {
    var labelFontWeight = _a.labelFontWeight;
    return labelFontWeight || "500";
}, function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
var InputTextSpanStyled = styled$1.span(templateObject_8$9 || (templateObject_8$9 = __makeTemplateObject(["\n  margin: ", ";\n"], ["\n  margin: ", ";\n"])), function (_a) {
    var spanMargin = _a.spanMargin;
    return spanMargin || "10px 0px 0px 0px";
});
var InputTextStyled = styled$1(motion.input)(templateObject_10$6 || (templateObject_10$6 = __makeTemplateObject(["\n  font-family: ", ";\n  font-size: ", ";\n  font-weight: ", ";\n  margin: ", ";\n  padding: ", ";\n  ", "\n  color: ", ";\n  ::placeholder {\n    color: ", ";\n  }\n  background-color: ", ";\n  height: ", ";\n  width: ", ";\n  max-width: ", ";\n  border-radius: ", ";\n  border: ", ";\n"], ["\n  font-family: ", ";\n  font-size: ", ";\n  font-weight: ", ";\n  margin: ", ";\n  padding: ", ";\n  ", "\n  color: ", ";\n  ::placeholder {\n    color: ", ";\n  }\n  background-color: ", ";\n  height: ", ";\n  width: ", ";\n  max-width: ", ";\n  border-radius: ", ";\n  border: ", ";\n"])), function (_a) {
    var fontFamily = _a.fontFamily;
    return fontFamily || "'Montserrat', sans-serif";
}, function (_a) {
    var fontSize = _a.fontSize;
    return fontSize || "12px";
}, function (_a) {
    var fontWeight = _a.fontWeight;
    return fontWeight || "600";
}, function (_a) {
    var margin = _a.margin;
    return margin || "0px 0px 0px 0px";
}, function (_a) {
    var padding = _a.padding;
    return padding || "0px 0px 0px 15px";
}, function (_a) {
    var autoFocus = _a.autoFocus;
    return autoFocus && css$1(templateObject_9$7 || (templateObject_9$7 = __makeTemplateObject(["\n      box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);\n      border-color: #0f1e2f;\n    "], ["\n      box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);\n      border-color: #0f1e2f;\n    "])));
}, function (_a) {
    var color = _a.color;
    return color || "#1a1a1a";
}, function (_a) {
    var placeholderColor = _a.placeholderColor;
    return placeholderColor || "#202124";
}, function (_a) {
    var backgroundColor = _a.backgroundColor;
    return backgroundColor || "#ffffff";
}, function (_a) {
    var height = _a.height;
    return height || "35px";
}, function (_a) {
    var width = _a.width;
    return width || "100%";
}, function (_a) {
    var maxWidth = _a.maxWidth;
    return maxWidth || "100%";
}, function (_a) {
    var borderRadius = _a.borderRadius;
    return borderRadius || "4px";
}, function (_a) {
    var border = _a.border;
    return border || "1px solid #f2f2f2";
});
var InputCheckboxStyled = styled$1(motion.input)(templateObject_11$6 || (templateObject_11$6 = __makeTemplateObject(["\n  margin-right: 10px;\n  display: flex;\n  border: solid 1px #244a77;\n  :checked {\n    accent-color: ", ";\n  }\n"], ["\n  margin-right: 10px;\n  display: flex;\n  border: solid 1px #244a77;\n  :checked {\n    accent-color: ", ";\n  }\n"])), function (_a) {
    var accentColor = _a.accentColor;
    return accentColor || "#005cc8";
});
var InputRadioButtonStyled = styled$1(motion.input)(templateObject_12$5 || (templateObject_12$5 = __makeTemplateObject(["\n  margin-right: 10px;\n  display: flex;\n  border: solid 1px #244a77;\n"], ["\n  margin-right: 10px;\n  display: flex;\n  border: solid 1px #244a77;\n"])));
var LabelRadioButtonStyled = styled$1(motion.label)(templateObject_13$3 || (templateObject_13$3 = __makeTemplateObject(["\n  display: flex;\n  align-items: center;\n  justify-content: flex-start;\n"], ["\n  display: flex;\n  align-items: center;\n  justify-content: flex-start;\n"])));
var InputCheckboxToggleStyled = styled$1(motion.input)(templateObject_14$3 || (templateObject_14$3 = __makeTemplateObject(["\n  margin-right: 10px;\n  display: flex;\n  border: solid 1px #244a77;\n"], ["\n  margin-right: 10px;\n  display: flex;\n  border: solid 1px #244a77;\n"])));
var InputErrorStyled$1 = styled$1.span(templateObject_15$3 || (templateObject_15$3 = __makeTemplateObject(["\n  font-family: ", ";\n  font-size: ", ";\n  font-weight: ", ";\n  color: ", ";\n  height: ", ";\n  margin: ", ";\n  padding: ", ";\n"], ["\n  font-family: ", ";\n  font-size: ", ";\n  font-weight: ", ";\n  color: ", ";\n  height: ", ";\n  margin: ", ";\n  padding: ", ";\n"])), function (_a) {
    var errorFontFamily = _a.errorFontFamily;
    return errorFontFamily || "'Montserrat', sans-serif";
}, function (_a) {
    var errorFontSize = _a.errorFontSize;
    return errorFontSize || "10px";
}, function (_a) {
    var errorFontWeight = _a.errorFontWeight;
    return errorFontWeight || "700";
}, function (_a) {
    var errorColor = _a.errorColor;
    return errorColor || "#ff295f";
}, function (_a) {
    var errorHeight = _a.errorHeight;
    return errorHeight || "20px";
}, function (_a) {
    var errorMargin = _a.errorMargin;
    return errorMargin || "0px 0px 0px 0px";
}, function (_a) {
    var errorPadding = _a.errorPadding;
    return errorPadding || "5px 0px 0px 0px";
});
var FileInputStyled = styled$1(motion.label)(templateObject_17$3 || (templateObject_17$3 = __makeTemplateObject(["\n  display: flex;\n  width: ", ";\n  height: ", ";\n  position: relative;\n\n  border-radius: ", ";\n  background-color: #f6f7fb;\n  font-size: ", ";\n  font-weight: 500;\n  color: #a5a7ad;\n  cursor: pointer;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  ", "\n  input {\n    opacity: 0;\n    position: absolute;\n    z-index: 1;\n  }\n"], ["\n  display: flex;\n  width: ", ";\n  height: ", ";\n  position: relative;\n\n  border-radius: ", ";\n  background-color: #f6f7fb;\n  font-size: ", ";\n  font-weight: 500;\n  color: #a5a7ad;\n  cursor: pointer;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  ", "\n  input {\n    opacity: 0;\n    position: absolute;\n    z-index: 1;\n  }\n"])), function (_a) {
    var width = _a.width;
    return width || "250px";
}, function (_a) {
    var height = _a.height;
    return height || "40px";
}, function (_a) {
    var borderRadius = _a.borderRadius;
    return borderRadius || "4px";
}, function (_a) {
    var fontSize = _a.fontSize;
    return fontSize || "12px";
}, function (_a) {
    var dropActive = _a.dropActive;
    return dropActive && css$1(templateObject_16$3 || (templateObject_16$3 = __makeTemplateObject(["\n      border: 2px solid white;\n      background-color: #dadada;\n      color: white;\n    "], ["\n      border: 2px solid white;\n      background-color: #dadada;\n      color: white;\n    "])));
});
var FileInputMultipleStyled = styled$1(motion.label)(templateObject_19$2 || (templateObject_19$2 = __makeTemplateObject(["\n  display: flex;\n  width: ", ";\n  height: ", ";\n  position: relative;\n\n  border-radius: ", ";\n  background-color: #f6f7fb;\n  font-size: ", ";\n  font-weight: 500;\n  color: #a5a7ad;\n  cursor: pointer;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  ", "\n  input {\n    opacity: 0;\n    position: absolute;\n    z-index: 1;\n  }\n"], ["\n  display: flex;\n  width: ", ";\n  height: ", ";\n  position: relative;\n\n  border-radius: ", ";\n  background-color: #f6f7fb;\n  font-size: ", ";\n  font-weight: 500;\n  color: #a5a7ad;\n  cursor: pointer;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  ", "\n  input {\n    opacity: 0;\n    position: absolute;\n    z-index: 1;\n  }\n"])), function (_a) {
    var width = _a.width;
    return width || "250px";
}, function (_a) {
    var height = _a.height;
    return height || "250px";
}, function (_a) {
    var borderRadius = _a.borderRadius;
    return borderRadius || "4px";
}, function (_a) {
    var fontSize = _a.fontSize;
    return fontSize || "12px";
}, function (_a) {
    var dropActive = _a.dropActive;
    return dropActive && css$1(templateObject_18$2 || (templateObject_18$2 = __makeTemplateObject(["\n      border: 2px solid white;\n      background-color: #dadada;\n      color: white;\n    "], ["\n      border: 2px solid white;\n      background-color: #dadada;\n      color: white;\n    "])));
});
var InputSelectStyled = styled$1(motion.select)(templateObject_20$2 || (templateObject_20$2 = __makeTemplateObject(["\n  margin: ", ";\n  padding: 0px 10px;\n  display: flex;\n  width: 100%;\n  height: ", ";\n  font-size: ", ";\n  font-weight: 500;\n  border-radius: ", ";\n  border: ", ";\n  color: ", ";\n  option {\n    margin: 5px 0px;\n    font-size: ", ";\n    font-weight: 600;\n    color: ", ";\n    border: ", ";\n  }\n  ", ";\n"], ["\n  margin: ", ";\n  padding: 0px 10px;\n  display: flex;\n  width: 100%;\n  height: ", ";\n  font-size: ", ";\n  font-weight: 500;\n  border-radius: ", ";\n  border: ", ";\n  color: ", ";\n  option {\n    margin: 5px 0px;\n    font-size: ", ";\n    font-weight: 600;\n    color: ", ";\n    border: ", ";\n  }\n  ", ";\n"])), function (_a) {
    var margin = _a.margin;
    return margin || "0px 0px 0px 0px";
}, function (_a) {
    var height = _a.height;
    return height || "35px";
}, function (_a) {
    var fontSize = _a.fontSize;
    return fontSize || "12px";
}, function (_a) {
    var borderRadius = _a.borderRadius;
    return borderRadius || "4px";
}, function (_a) {
    var border = _a.border;
    return border || "2px solid #c8d2dd;";
}, function (_a) {
    var optionColor = _a.optionColor;
    return optionColor || "#75758b";
}, function (_a) {
    var fontSize = _a.fontSize;
    return fontSize || "12px";
}, function (_a) {
    var optionColor = _a.optionColor;
    return optionColor || "#75758b";
}, function (_a) {
    var border = _a.border;
    return border || "2px solid #c8d2dd;";
}, function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
var InputOptionStyled = styled$1(motion.option)(templateObject_21$1 || (templateObject_21$1 = __makeTemplateObject([""], [""])));
var InputRangeLabelStyled = styled$1(motion.label)(templateObject_22$1 || (templateObject_22$1 = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  font-family: ", ";\n  margin: ", ";\n  color: ", ";\n  width: ", ";\n  height: ", ";\n  font-size: ", ";\n  text-align: ", ";\n  font-weight: ", ";\n  position: relative;\n\n  ", ";\n"], ["\n  display: flex;\n  flex-direction: column;\n  font-family: ", ";\n  margin: ", ";\n  color: ", ";\n  width: ", ";\n  height: ", ";\n  font-size: ", ";\n  text-align: ", ";\n  font-weight: ", ";\n  position: relative;\n\n  ", ";\n"])), function (_a) {
    var labelFontFamily = _a.labelFontFamily;
    return labelFontFamily || "'Montserrat', sans-serif";
}, function (_a) {
    var labelMargin = _a.labelMargin;
    return labelMargin || "0px 0px 0px 0px";
}, function (_a) {
    var labelColor = _a.labelColor;
    return labelColor || "black";
}, function (_a) {
    var labelWidth = _a.labelWidth;
    return labelWidth || "100%";
}, function (_a) {
    var labelHeight = _a.labelHeight;
    return labelHeight || "max-content";
}, function (_a) {
    var labelFontSize = _a.labelFontSize;
    return labelFontSize || "16px";
}, function (_a) {
    var labelTextAlign = _a.labelTextAlign;
    return labelTextAlign || "left";
}, function (_a) {
    var labelFontWeight = _a.labelFontWeight;
    return labelFontWeight || "500";
}, function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
var InputRangeStyled = styled$1(motion.input)(templateObject_23$1 || (templateObject_23$1 = __makeTemplateObject(["\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n  width: 100%;\n  outline: none;\n  position: absolute;\n  margin: auto;\n  top: 50%;\n  background-color: transparent;\n  pointer-events: none;\n\n  ::-webkit-slider-runnable-track {\n    -webkit-appearance: none;\n    height: 5px;\n  }\n  ::-moz-range-track {\n    -moz-appearance: none;\n    height: 5px;\n  }\n  ::-ms-track {\n    appearance: none;\n    height: 5px;\n  }\n  ::-webkit-slider-thumb {\n    -webkit-appearance: none;\n    height: 15px;\n    width: 15px;\n    background-color: ", ";\n    border: ", ";\n    cursor: pointer;\n    margin-top: -9px;\n    pointer-events: auto;\n    border-radius: 50%;\n  }\n  ::-moz-range-thumb {\n    -webkit-appearance: none;\n    height: 15px;\n    width: 15px;\n    cursor: pointer;\n    border-radius: 50%;\n    background-color: ", ";\n    border: ", ";\n    pointer-events: auto;\n  }\n  ::-ms-thumb {\n    appearance: none;\n    height: 15px;\n    width: 15px;\n    cursor: pointer;\n    border-radius: 50%;\n    background-color: ", ";\n    border: ", ";\n    pointer-events: auto;\n  }\n  :active::-webkit-slider-thumb {\n    background-color: ", ";\n    border: ", ";\n  }\n"], ["\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n  width: 100%;\n  outline: none;\n  position: absolute;\n  margin: auto;\n  top: 50%;\n  background-color: transparent;\n  pointer-events: none;\n\n  ::-webkit-slider-runnable-track {\n    -webkit-appearance: none;\n    height: 5px;\n  }\n  ::-moz-range-track {\n    -moz-appearance: none;\n    height: 5px;\n  }\n  ::-ms-track {\n    appearance: none;\n    height: 5px;\n  }\n  ::-webkit-slider-thumb {\n    -webkit-appearance: none;\n    height: 15px;\n    width: 15px;\n    background-color: ", ";\n    border: ", ";\n    cursor: pointer;\n    margin-top: -9px;\n    pointer-events: auto;\n    border-radius: 50%;\n  }\n  ::-moz-range-thumb {\n    -webkit-appearance: none;\n    height: 15px;\n    width: 15px;\n    cursor: pointer;\n    border-radius: 50%;\n    background-color: ", ";\n    border: ", ";\n    pointer-events: auto;\n  }\n  ::-ms-thumb {\n    appearance: none;\n    height: 15px;\n    width: 15px;\n    cursor: pointer;\n    border-radius: 50%;\n    background-color: ", ";\n    border: ", ";\n    pointer-events: auto;\n  }\n  :active::-webkit-slider-thumb {\n    background-color: ", ";\n    border: ", ";\n  }\n"])), function (_a) {
    var thumbColor = _a.thumbColor;
    return thumbColor || "#ffffff";
}, function (_a) {
    var thumbBorder = _a.thumbBorder;
    return thumbBorder || "2px solid #3264fe";
}, function (_a) {
    var thumbColor = _a.thumbColor;
    return thumbColor || "#ffffff";
}, function (_a) {
    var thumbBorder = _a.thumbBorder;
    return thumbBorder || "2px solid #3264fe";
}, function (_a) {
    var thumbColor = _a.thumbColor;
    return thumbColor || "#ffffff";
}, function (_a) {
    var thumbBorder = _a.thumbBorder;
    return thumbBorder || "2px solid #3264fe";
}, function (_a) {
    var thumbColor = _a.thumbColor;
    return thumbColor || "#ffffff";
}, function (_a) {
    var thumbBorder = _a.thumbBorder;
    return thumbBorder || "3px solid #3264fe";
});
var SliderTrackStyled = styled$1(motion.div)(templateObject_24$1 || (templateObject_24$1 = __makeTemplateObject(["\n  width: 100%;\n  height: 5px;\n  position: relative;\n  margin: auto;\n  top: 0;\n  bottom: 0;\n  border-radius: 200px;\n  background: ", ";\n"], ["\n  width: 100%;\n  height: 5px;\n  position: relative;\n  margin: auto;\n  top: 0;\n  bottom: 0;\n  border-radius: 200px;\n  background: ", ";\n"])), function (_a) {
    var minTrack = _a.minTrack, maxTrack = _a.maxTrack, trackColor = _a.trackColor, trackBackground = _a.trackBackground;
    var isNegative = minTrack - maxTrack < 0;
    return isNegative
        ? "linear-gradient(to right, ".concat(trackBackground || "#dadae5", " ").concat(minTrack, "% , ").concat(trackColor || "#4271ff", " ").concat(minTrack, "% , ").concat(trackColor || "#4271ff", " ").concat(maxTrack, "%, ").concat(trackBackground || "#dadae5", " ").concat(maxTrack, "%)")
        : "linear-gradient(to right, ".concat(trackBackground || "#dadae5", " ").concat(maxTrack, "% , ").concat(trackColor || "#4271ff", " ").concat(maxTrack, "% , ").concat(trackColor || "#4271ff", " ").concat(minTrack, "%, ").concat(trackBackground || "#dadae5", " ").concat(minTrack, "%)");
});
var InputTextBoxStyled = styled$1(motion.textarea)(templateObject_26 || (templateObject_26 = __makeTemplateObject(["\n  font-family: ", ";\n  font-size: ", ";\n  font-weight: ", ";\n  margin: ", ";\n  padding: ", ";\n  color: ", ";\n  ::placeholder {\n    color: ", ";\n  }\n  ", "\n  background-color: ", ";\n  height: ", ";\n  width: ", ";\n  max-width: ", ";\n  border-radius: ", ";\n  border: ", ";\n"], ["\n  font-family: ", ";\n  font-size: ", ";\n  font-weight: ", ";\n  margin: ", ";\n  padding: ", ";\n  color: ", ";\n  ::placeholder {\n    color: ", ";\n  }\n  ", "\n  background-color: ", ";\n  height: ", ";\n  width: ", ";\n  max-width: ", ";\n  border-radius: ", ";\n  border: ", ";\n"])), function (_a) {
    var fontFamily = _a.fontFamily;
    return fontFamily || "'Montserrat', sans-serif";
}, function (_a) {
    var fontSize = _a.fontSize;
    return fontSize || "12px";
}, function (_a) {
    var fontWeight = _a.fontWeight;
    return fontWeight || "500";
}, function (_a) {
    var margin = _a.margin;
    return margin || "0px 0px 0px 0px";
}, function (_a) {
    var padding = _a.padding;
    return padding || "0px 0px 0px 15px";
}, function (_a) {
    var color = _a.color;
    return color || "black";
}, function (_a) {
    var placeholderColor = _a.placeholderColor;
    return placeholderColor || "#1a1a1a";
}, function (_a) {
    var autoFocus = _a.autoFocus;
    return autoFocus && css$1(templateObject_25$1 || (templateObject_25$1 = __makeTemplateObject(["\n      box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);\n      border-color: #0f1e2f;\n    "], ["\n      box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);\n      border-color: #0f1e2f;\n    "])));
}, function (_a) {
    var backgroundColor = _a.backgroundColor;
    return backgroundColor || "#ffffff";
}, function (_a) {
    var height = _a.height;
    return height || "200px";
}, function (_a) {
    var width = _a.width;
    return width || "100%";
}, function (_a) {
    var maxWidth = _a.maxWidth;
    return maxWidth || "100%";
}, function (_a) {
    var borderRadius = _a.borderRadius;
    return borderRadius || "4px";
}, function (_a) {
    var border = _a.border;
    return border || "1px solid #c8d2dd";
});
var VideoPlayerStyledContainer = styled$1(motion.div)(templateObject_27 || (templateObject_27 = __makeTemplateObject(["\n  overflow: hidden;\n  max-height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n"], ["\n  overflow: hidden;\n  max-height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n"])));
var VideoPlayerStyled = styled$1(motion.video)(templateObject_28 || (templateObject_28 = __makeTemplateObject(["\n  width: ", ";\n"], ["\n  width: ", ";\n"])), function (_a) {
    var width = _a.width;
    return width || "100%";
});
var templateObject_1$17, templateObject_2$O, templateObject_3$F, templateObject_4$t, templateObject_5$o, templateObject_6$i, templateObject_7$e, templateObject_8$9, templateObject_9$7, templateObject_10$6, templateObject_11$6, templateObject_12$5, templateObject_13$3, templateObject_14$3, templateObject_15$3, templateObject_16$3, templateObject_17$3, templateObject_18$2, templateObject_19$2, templateObject_20$2, templateObject_21$1, templateObject_22$1, templateObject_23$1, templateObject_24$1, templateObject_25$1, templateObject_26, templateObject_27, templateObject_28;

var AtomInputTextError = function (props) {
    var formik = props.formik, id = props.id, error = props.error;
    return formik ? (((lodash.get(formik === null || formik === void 0 ? void 0 : formik.values, id) !== "" ||
        lodash.get(formik === null || formik === void 0 ? void 0 : formik.touched, id)) &&
        lodash.get(formik === null || formik === void 0 ? void 0 : formik.errors, id)) ||
        error ? (jsxs(InputErrorStyled$1, __assign({}, props, { children: [lodash.get(formik === null || formik === void 0 ? void 0 : formik.errors, id), " ", error !== null && error !== void 0 ? error : ''] }))) : null) : (jsx(Fragment$1, {}));
};

var Animation$b = {
    whileTap: { scale: 0.98, opacity: 0.8 },
};
var InputCheckbox$1 = function (props) {
    var value = props.value, onChange = props.onChange, onBlur = props.onBlur, formik = props.formik, id = props.id, children = props.children;
    var labelWidth = props.labelWidth, labelColor = props.labelColor, labelFontFamily = props.labelFontFamily, labelFontSize = props.labelFontSize, labelFontWeight = props.labelFontWeight, labelMargin = props.labelMargin, labelPadding = props.labelPadding, spanMargin = props.spanMargin, customCSS = props.customCSS, label = props.label, checked = props.checked;
    return (jsxs(InputTextLabelStyled, __assign({ labelWidth: labelWidth, labelColor: labelColor, labelFontFamily: labelFontFamily, labelFontSize: labelFontSize, labelFontWeight: labelFontWeight, labelMargin: labelMargin, labelPadding: labelPadding, spanMargin: spanMargin, customCSS: customCSS }, { children: [jsxs("div", __assign({ style: {
                    display: "flex",
                    flexDirection: "row",
                    width: '100%',
                    alignItems: 'center',
                } }, { children: [label && jsx("span", { children: label }), jsx(InputCheckboxStyled, __assign({ type: "checkbox" }, Animation$b, { id: label, name: id, disabled: props.disabled, value: formik && id ? formik === null || formik === void 0 ? void 0 : formik.values[id] : value, onChange: function (e) {
                            formik === null || formik === void 0 ? void 0 : formik.handleChange(e);
                            onChange === null || onChange === void 0 ? void 0 : onChange(e);
                        }, onBlur: function (e) {
                            formik === null || formik === void 0 ? void 0 : formik.handleBlur(e);
                            onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
                        }, checked: formik && id
                            ? (formik === null || formik === void 0 ? void 0 : formik.values[id]) === true
                            : checked || value === "on", accentColor: props.accentColor })), children] })), jsx(AtomInputTextError, __assign({}, props))] })));
};

var Animation$a = {
    whileHover: { scale: 1.02, transition: { duration: 0.3 } },
    whileTap: { scale: 0.98, opacity: 0.8 },
};
var InputDragDrop = function (props) {
    var id = props.id, children = props.children, formik = props.formik, wrapperCustomCSS = props.wrapperCustomCSS, imagePreview = props.imagePreview, placeholderDragDrop = props.placeholderDragDrop, onChangeDrop = props.onChangeDrop, video = props.video;
    var _a = __read(useState(""), 2), preview = _a[0], setPreview = _a[1];
    var _b = __read(useState(false), 2), dropActive = _b[0], setDropActive = _b[1];
    useEffect(function () {
        setPreview(imagePreview);
    }, [imagePreview]);
    useEffect(function () {
        var _a;
        if ((_a = formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)]) === null || _a === void 0 ? void 0 : _a.name) {
            var url = URL === null || URL === void 0 ? void 0 : URL.createObjectURL(formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)]);
            setPreview(url);
            setDropActive(false);
        }
        else {
            setPreview(imagePreview !== null && imagePreview !== void 0 ? imagePreview : "");
            setDropActive(false);
        }
    }, [formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)]]);
    var Drop = function (e) {
        e.preventDefault();
        e.stopPropagation();
        var files = e.dataTransfer.files;
        if (files.length !== 0) {
            var url = URL === null || URL === void 0 ? void 0 : URL.createObjectURL(files[0]);
            setPreview(url);
            setDropActive(false);
            formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, files[0]);
            onChangeDrop === null || onChangeDrop === void 0 ? void 0 : onChangeDrop(files[0]);
        }
        else {
            setPreview("");
            setDropActive(false);
            formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, "");
        }
    };
    var DropInput = function (e) {
        e.preventDefault();
        e.stopPropagation();
        var files = e.currentTarget.files;
        if (files) {
            if (files.length !== 0) {
                var url = URL === null || URL === void 0 ? void 0 : URL.createObjectURL(files[0]);
                setPreview(url);
                setDropActive(false);
                formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, files[0]);
                onChangeDrop === null || onChangeDrop === void 0 ? void 0 : onChangeDrop(files[0]);
            }
            else {
                setPreview("");
                setDropActive(false);
                formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, "");
            }
        }
    };
    var handleDrag = function (e) {
        e.preventDefault();
        e.stopPropagation();
    };
    var labelWidth = props.labelWidth, labelColor = props.labelColor, labelFontFamily = props.labelFontFamily, labelFontSize = props.labelFontSize, labelFontWeight = props.labelFontWeight, labelMargin = props.labelMargin, labelPadding = props.labelPadding, spanMargin = props.spanMargin, customCSS = props.customCSS, label = props.label, borderRadius = props.borderRadius;
    return (jsxs(InputTextLabelStyled, __assign({ labelWidth: labelWidth, labelColor: labelColor, labelFontFamily: labelFontFamily, labelFontSize: labelFontSize, labelFontWeight: labelFontWeight, labelMargin: labelMargin, labelPadding: labelPadding, customCSS: customCSS }, { children: [label && (jsx(InputTextSpanStyled, __assign({ spanMargin: spanMargin }, { children: label }))), jsxs(FileInputStyled, __assign({ dropActive: dropActive, htmlFor: id, onDrop: Drop, onDragOver: function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    setDropActive(true);
                }, onDragEnter: function (event) { return handleDrag(event); }, onDragLeave: function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    setDropActive(false);
                } }, props, Animation$a, { children: [preview === "" && (jsx(Wrapper$2, __assign({ flexDirection: "row", customCSS: wrapperCustomCSS }, { children: placeholderDragDrop ? (placeholderDragDrop(dropActive)) : (jsx(Fragment$1, { children: !dropActive ? (jsxs(Fragment$1, { children: [jsx(Image$2, { alt: "Drag and drop", height: "15px", width: "15px", margin: "0px 10px 0px 0px", src: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/PFS-0001/upload.svg" }), "ARRASTRA Y SUELTA"] })) : (jsx(Fragment$1, { children: "SUELTA" })) })) }))), video ? (jsx(Fragment$1, { children: preview !== "" && (jsx(VideoPlayerStyledContainer, { children: jsx(VideoPlayerStyled, { muted: true, autoPlay: true, loop: true, src: preview }) })) })) : (jsx(Fragment$1, { children: preview !== "" && (jsx(Image$2, { alt: "Drag and drop Preview", src: preview, customCSS: css$1(templateObject_1$16 || (templateObject_1$16 = __makeTemplateObject(["\n                  border-radius: ", ";\n                  position: absolute;\n                  width: 100%;\n                  height: 100%;\n                  object-fit: cover;\n                "], ["\n                  border-radius: ", ";\n                  position: absolute;\n                  width: 100%;\n                  height: 100%;\n                  object-fit: cover;\n                "])), borderRadius || '4px') })) })), jsx("input", { type: "file", id: id, onChange: DropInput, style: { width: '100%', height: '100%' } })] })), children, jsx(AtomInputTextError, __assign({}, props))] })));
};
var templateObject_1$16;

var Animation$9 = {
    whileHover: { scale: 1.02, transition: { duration: 0.3 } },
    whileTap: { scale: 0.98, opacity: 0.8 },
};
var InputDragDropFile = function (props) {
    var id = props.id, children = props.children, formik = props.formik, wrapperCustomCSS = props.wrapperCustomCSS, imagePreview = props.imagePreview, placeholderDragDrop = props.placeholderDragDrop, onChangeDrop = props.onChangeDrop;
    var _a = __read(useState(""), 2), preview = _a[0], setPreview = _a[1];
    var _b = __read(useState(false), 2), dropActive = _b[0], setDropActive = _b[1];
    useEffect(function () {
        setPreview(imagePreview);
    }, [imagePreview]);
    useEffect(function () {
        var _a, _b;
        if ((_a = formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)]) === null || _a === void 0 ? void 0 : _a.name) {
            // const url = URL?.createObjectURL(formik?.values[`${id}`]);
            setPreview((_b = formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)]) === null || _b === void 0 ? void 0 : _b.name);
            setDropActive(false);
        }
        else {
            setPreview(imagePreview !== null && imagePreview !== void 0 ? imagePreview : "");
            setDropActive(false);
        }
    }, [formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)]]);
    var Drop = function (e) {
        e.preventDefault();
        e.stopPropagation();
        var files = e.dataTransfer.files;
        if (files.length !== 0) {
            // const url = URL?.createObjectURL(files[0]);
            setPreview(files[0].name);
            setDropActive(false);
            formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, files[0]);
            onChangeDrop === null || onChangeDrop === void 0 ? void 0 : onChangeDrop(files[0]);
        }
        else {
            setPreview("");
            setDropActive(false);
            formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, "");
        }
    };
    var DropInput = function (e) {
        e.preventDefault();
        e.stopPropagation();
        var files = e.currentTarget.files;
        if (files) {
            if (files.length !== 0) {
                // const url = URL?.createObjectURL(files[0]);
                // setPreview(url);
                setDropActive(false);
                formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, files[0]);
                onChangeDrop === null || onChangeDrop === void 0 ? void 0 : onChangeDrop(files[0]);
                setPreview(files[0].name);
            }
            else {
                setPreview("");
                setDropActive(false);
                formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, "");
            }
        }
    };
    var handleDrag = function (e) {
        e.preventDefault();
        e.stopPropagation();
    };
    var labelWidth = props.labelWidth, labelColor = props.labelColor, labelFontFamily = props.labelFontFamily, labelFontSize = props.labelFontSize, labelFontWeight = props.labelFontWeight, labelMargin = props.labelMargin, labelPadding = props.labelPadding, spanMargin = props.spanMargin, customCSS = props.customCSS, label = props.label;
    return (jsxs(InputTextLabelStyled, __assign({ labelWidth: labelWidth, labelColor: labelColor, labelFontFamily: labelFontFamily, labelFontSize: labelFontSize, labelFontWeight: labelFontWeight, labelMargin: labelMargin, labelPadding: labelPadding, customCSS: customCSS }, { children: [label && (jsx(InputTextSpanStyled, __assign({ spanMargin: spanMargin }, { children: label }))), jsxs(FileInputStyled, __assign({ dropActive: dropActive, htmlFor: id, onDrop: Drop, onDragOver: function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    setDropActive(true);
                }, onDragEnter: function (event) { return handleDrag(event); }, onDragLeave: function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    setDropActive(false);
                } }, props, Animation$9, { children: [preview === "" ? (jsx(Wrapper$2, __assign({ flexDirection: "row", customCSS: wrapperCustomCSS }, { children: placeholderDragDrop ? (placeholderDragDrop(dropActive)) : (jsx(Fragment$1, { children: !dropActive ? (jsxs(Fragment$1, { children: [jsx(Image$2, { alt: "Drag and drop", height: "15px", width: "15px", margin: "0px 10px 0px 0px", src: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/PFS-0001/upload.svg" }), "ARRASTRA Y SUELTA"] })) : (jsx(Fragment$1, { children: "SUELTA" })) })) }))) : (jsx(Text$2, __assign({ customCSS: css$1(templateObject_1$15 || (templateObject_1$15 = __makeTemplateObject(["\n              text-align: center;\n            "], ["\n              text-align: center;\n            "]))) }, { children: preview }))), jsx("input", { type: "file", multiple: true, id: id, onChange: DropInput, style: { width: '100%', height: '100%' } })] })), children, jsx(AtomInputTextError, __assign({}, props))] })));
};
var templateObject_1$15;

var Animation$8 = {
    whileHover: { scale: 1.02, transition: { duration: 0.3 } },
    whileTap: { scale: 0.98, opacity: 0.8 },
};
var InputDragDropMultiple = function (props) {
    var id = props.id, children = props.children, formik = props.formik, wrapperCustomCSS = props.wrapperCustomCSS, imagePreviewArray = props.imagePreviewArray;
    var _a = __read(useState([]), 2), preview = _a[0], setPreview = _a[1];
    var _b = __read(useState(false), 2), dropActive = _b[0], setDropActive = _b[1];
    useEffect(function () {
        if (imagePreviewArray) {
            setPreview(imagePreviewArray);
        }
    }, [imagePreviewArray]);
    useEffect(function () {
        if (formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)]) {
            setPreview(formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)].map(function (item) { return item.url; }));
            setDropActive(false);
        }
        else {
            setPreview([]);
            setDropActive(false);
        }
    }, [formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)]]);
    var Drop = function (e) {
        e.preventDefault();
        e.stopPropagation();
        var files = e.dataTransfer.files;
        if (files.length !== 0) {
            var urlArray = Array.from(files).map(function (file) {
                var url = URL === null || URL === void 0 ? void 0 : URL.createObjectURL(file);
                return { url: url, file: file };
            });
            formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, urlArray);
            setPreview(urlArray.map(function (item) { return item.url; }));
            setDropActive(false);
        }
        else {
            setPreview([]);
            setDropActive(false);
            formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, "");
        }
    };
    var DropInput = function (e) {
        e.preventDefault();
        e.stopPropagation();
        var files = e.currentTarget.files;
        if (files) {
            if (files.length !== 0) {
                var urlArray = Array.from(files).map(function (file) {
                    var url = URL === null || URL === void 0 ? void 0 : URL.createObjectURL(file);
                    return { url: url, file: file };
                });
                formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, urlArray);
                setPreview(urlArray.map(function (item) { return item.url; }));
                setDropActive(false);
            }
            else {
                setPreview([]);
                setDropActive(false);
                formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, "");
            }
        }
    };
    var handleDrag = function (e) {
        e.preventDefault();
        e.stopPropagation();
    };
    var labelWidth = props.labelWidth, labelColor = props.labelColor, labelFontFamily = props.labelFontFamily, labelFontSize = props.labelFontSize, labelFontWeight = props.labelFontWeight, labelMargin = props.labelMargin, labelPadding = props.labelPadding, spanMargin = props.spanMargin, customCSS = props.customCSS, label = props.label, borderRadius = props.borderRadius, heightpreview = props.heightpreview;
    return (jsxs(InputTextLabelStyled, __assign({ labelWidth: labelWidth, labelColor: labelColor, labelFontFamily: labelFontFamily, labelFontSize: labelFontSize, labelFontWeight: labelFontWeight, labelMargin: labelMargin, labelPadding: labelPadding, customCSS: customCSS }, { children: [label && (jsx(InputTextSpanStyled, __assign({ spanMargin: spanMargin }, { children: label }))), jsxs(FileInputStyled, __assign({ dropActive: dropActive, htmlFor: id, onDrop: Drop, onDragOver: function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    setDropActive(true);
                }, onDragEnter: function (event) { return handleDrag(event); }, onDragLeave: function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    setDropActive(false);
                } }, props, Animation$8, { children: [preview.length === 0 && (jsx(Wrapper$2, __assign({ flexDirection: "row", customCSS: wrapperCustomCSS }, { children: !dropActive ? (jsxs(Fragment$1, { children: [jsx(Image$2, { alt: "Drag and drop", height: "15px", width: "15px", margin: "0px 10px 0px 0px", src: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/PFS-0001/upload.svg" }), "ARRASTRA Y SUELTA"] })) : (jsx(Fragment$1, { children: "SUELTA" })) }))), preview.length > 0 && preview.find(function (_, idx) { return idx === 0; }) && (jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_1$14 || (templateObject_1$14 = __makeTemplateObject(["\n              top: 0;\n              position: absolute;\n              width: 100%;\n              height: 100%;\n              flex-direction: column;\n              align-items: center;\n              justify-content: flex-start;\n            "], ["\n              top: 0;\n              position: absolute;\n              width: 100%;\n              height: 100%;\n              flex-direction: column;\n              align-items: center;\n              justify-content: flex-start;\n            "]))) }, { children: [jsx(Image$2, { alt: "Drag and drop Preview", src: "".concat(preview.find(function (_, idx) { return idx === 0; })), customCSS: css$1(templateObject_2$N || (templateObject_2$N = __makeTemplateObject(["\n                border-radius: ", ";\n                width: 100%;\n                height: ", ";\n                padding: 5px;\n                object-fit: cover;\n              "], ["\n                border-radius: ", ";\n                width: 100%;\n                height: ", ";\n                padding: 5px;\n                object-fit: cover;\n              "])), borderRadius || '4px', heightpreview || '100%') }), jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_3$E || (templateObject_3$E = __makeTemplateObject(["\n                flex-direction: row;\n                height: 30%;\n              "], ["\n                flex-direction: row;\n                height: 30%;\n              "]))) }, { children: [preview
                                        .filter(function (_, idx) { return idx !== 0 && idx < 5; })
                                        .map(function (e) { return (jsx(Image$2, { alt: "Drag and drop Preview", src: "".concat(e), customCSS: css$1(templateObject_4$s || (templateObject_4$s = __makeTemplateObject(["\n                      border-radius: ", ";\n                      width: 100%;\n                      height: 100%;\n                      object-fit: cover;\n                      margin: 5px;\n                    "], ["\n                      border-radius: ", ";\n                      width: 100%;\n                      height: 100%;\n                      object-fit: cover;\n                      margin: 5px;\n                    "])), borderRadius || '4px') }, "".concat(e, "moreimages"))); }), preview.length > 5 && (jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_5$n || (templateObject_5$n = __makeTemplateObject(["\n                    align-items: center;\n                    justify-content: center;\n                    height: 100%;\n                    margin: 5px;\n                    background-color: ", ";\n                  "], ["\n                    align-items: center;\n                    justify-content: center;\n                    height: 100%;\n                    margin: 5px;\n                    background-color: ", ";\n                  "])), props.color || '#00abb9') }, { children: jsxs(Text$2, __assign({ customCSS: css$1(templateObject_6$h || (templateObject_6$h = __makeTemplateObject(["\n                      font-size: 18px;\n                      color: white;\n                      margin: 0px;\n                      padding: 0px;\n                    "], ["\n                      font-size: 18px;\n                      color: white;\n                      margin: 0px;\n                      padding: 0px;\n                    "]))) }, { children: ["+", preview.length - 5] })) })))] }))] }))), jsx("input", { type: "file", multiple: true, id: id, onChange: DropInput, style: { width: '100%', height: '100%' } })] })), children, jsx(AtomInputTextError, __assign({}, props))] })));
};
var templateObject_1$14, templateObject_2$N, templateObject_3$E, templateObject_4$s, templateObject_5$n, templateObject_6$h;

var Animation$7 = {
    whileHover: { scale: 1.02, transition: { duration: 0.3 } },
    whileTap: { scale: 0.98, opacity: 0.8 },
};
var InputDragDropMultipleFiles = function (props) {
    var id = props.id, children = props.children, formik = props.formik, wrapperCustomCSS = props.wrapperCustomCSS;
    var _a = __read(useState(false), 2), dropActive = _a[0], setDropActive = _a[1];
    var _b = __read(useState(false), 2), filter = _b[0], setFilter = _b[1];
    var ref = useRef(null);
    useEffect(function () {
        if (filter !== false && formik) {
            formik.setFieldValue(id, filter);
            setFilter(false);
        }
    }, [filter]);
    var Drop = function (e) {
        e.preventDefault();
        e.stopPropagation();
        var files = e.dataTransfer.files;
        if (files.length !== 0) {
            var filesFilter = Array.from(files).map(function (i) { return ({
                id: v4(),
                file: i,
            }); });
            var group = __spreadArray(__spreadArray([], __read(formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)]), false), __read(filesFilter), false);
            formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, group);
            setDropActive(false);
        }
        else {
            setDropActive(false);
            formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, "");
        }
    };
    var DropInput = function (e) {
        e.preventDefault();
        e.stopPropagation();
        var files = e.currentTarget.files;
        if (files) {
            if (files.length !== 0) {
                var filesFilter = Array.from(files).map(function (i) { return ({
                    id: v4(),
                    file: i,
                }); });
                var group = __spreadArray(__spreadArray([], __read(formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)]), false), __read(filesFilter), false);
                formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, group);
                setDropActive(false);
            }
            else {
                setDropActive(false);
                formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, "");
            }
        }
    };
    var handleDrag = function (e) {
        e.preventDefault();
        e.stopPropagation();
    };
    var labelWidth = props.labelWidth, labelColor = props.labelColor, labelFontFamily = props.labelFontFamily, labelFontSize = props.labelFontSize, labelFontWeight = props.labelFontWeight, labelMargin = props.labelMargin, labelPadding = props.labelPadding, spanMargin = props.spanMargin, customCSS = props.customCSS, label = props.label;
    return (jsxs(InputTextLabelStyled, __assign({ labelWidth: labelWidth, labelColor: labelColor, labelFontFamily: labelFontFamily, labelFontSize: labelFontSize, labelFontWeight: labelFontWeight, labelMargin: labelMargin, labelPadding: labelPadding, customCSS: customCSS }, { children: [label && (jsx(InputTextSpanStyled, __assign({ spanMargin: spanMargin }, { children: label }))), jsxs(FileInputMultipleStyled, __assign({ dropActive: dropActive, htmlFor: id, onDrop: Drop, onDragOver: function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    setDropActive(true);
                }, onDragEnter: function (event) { return handleDrag(event); }, onDragLeave: function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    setDropActive(false);
                } }, props, Animation$7, { children: [(formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)].length) === 0 && (jsx(Wrapper$2, __assign({ flexDirection: "row", customCSS: wrapperCustomCSS }, { children: !dropActive ? (jsxs(Fragment$1, { children: [jsx(Image$2, { alt: "Drag and drop", height: "15px", width: "15px", margin: "0px 10px 0px 0px", src: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/PFS-0001/upload.svg" }), "ARRASTRA Y SUELTA"] })) : (jsx(Fragment$1, { children: "SUELTA" })) }))), (formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)].length) > 0 && (jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_1$13 || (templateObject_1$13 = __makeTemplateObject(["\n              top: 0;\n              position: absolute;\n              width: 100%;\n              height: 100%;\n              flex-direction: column;\n              align-items: center;\n              justify-content: flex-start;\n              z-index: 10;\n            "], ["\n              top: 0;\n              position: absolute;\n              width: 100%;\n              height: 100%;\n              flex-direction: column;\n              align-items: center;\n              justify-content: flex-start;\n              z-index: 10;\n            "]))) }, { children: jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_2$M || (templateObject_2$M = __makeTemplateObject(["\n                align-items: center;\n                justify-content: center;\n                flex-direction: column;\n                height: 100%;\n                flex-wrap: wrap;\n                gap: 5px;\n                overflow: hidden;\n              "], ["\n                align-items: center;\n                justify-content: center;\n                flex-direction: column;\n                height: 100%;\n                flex-wrap: wrap;\n                gap: 5px;\n                overflow: hidden;\n              "]))) }, { children: formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)].map(function (e) {
                                var _a;
                                return (jsxs(Wrapper$2, __assign({}, Animation$7, { customCSS: css$1(templateObject_3$D || (templateObject_3$D = __makeTemplateObject(["\n                    width: 100%;\n                    min-height: 25px;\n                    max-height: 100%;\n                    position: relative;\n                    align-items: center;\n                  "], ["\n                    width: 100%;\n                    min-height: 25px;\n                    max-height: 100%;\n                    position: relative;\n                    align-items: center;\n                  "]))) }, { children: [jsx(Text$2, __assign({ width: "80%" }, { children: (_a = e === null || e === void 0 ? void 0 : e.file) === null || _a === void 0 ? void 0 : _a.name })), jsx(AtomButton, __assign({ customCSS: css$1(templateObject_4$r || (templateObject_4$r = __makeTemplateObject(["\n                      display: flex;\n                      align-items: center;\n                      justify-content: center;\n                      position: absolute;\n                      background: #e52d27;\n                      border-radius: 50%;\n                      width: 22px;\n                      height: 22px;\n                      padding: 0;\n                      right: 2px;\n                      top: 0px;\n                    "], ["\n                      display: flex;\n                      align-items: center;\n                      justify-content: center;\n                      position: absolute;\n                      background: #e52d27;\n                      border-radius: 50%;\n                      width: 22px;\n                      height: 22px;\n                      padding: 0;\n                      right: 2px;\n                      top: 0px;\n                    "]))), onClick: function () {
                                                var filterArray = formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)].filter(function (e2) { return e2.id !== e.id; });
                                                setFilter(filterArray);
                                            }, type: "button" }, { children: jsx(Icon$1, { height: "17px", color: "transparent", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/JRO-0001/icons/Component%20199%20%E2%80%93%202.svg", customCSS: css$1(templateObject_5$m || (templateObject_5$m = __makeTemplateObject(["\n                        svg {\n                          g {\n                            path {\n                              stroke: #fff;\n                            }\n                          }\n                        }\n                      "], ["\n                        svg {\n                          g {\n                            path {\n                              stroke: #fff;\n                            }\n                          }\n                        }\n                      "]))) }) }))] }), e.id));
                            }) })) }))), jsx("input", { ref: ref, type: "file", multiple: true, id: id, onChange: DropInput, style: { width: '100%', height: '100%' }, accept: "*/*" })] })), jsx(AtomButton, __assign({ type: "button", width: "100%", backgroundColor: "#f6f7fb", border: "1px solid #c4c4c4", color: "#707070", fontWeight: "500", margin: "10px 0px 0px 0px", onClick: function () {
                    var _a;
                    (_a = ref === null || ref === void 0 ? void 0 : ref.current) === null || _a === void 0 ? void 0 : _a.click();
                } }, { children: "Cargar archivos" })), children, jsx(AtomInputTextError, __assign({}, props))] })));
};
var templateObject_1$13, templateObject_2$M, templateObject_3$D, templateObject_4$r, templateObject_5$m;

// import { AtomButton, AtomIcon, AtomImage, AtomWrapper } from '@ixulabs/ui';
var Animation$6 = {
    whileHover: { scale: 1.02, transition: { duration: 0.3 } },
    whileTap: { scale: 0.98, opacity: 0.8 },
};
var InputDragDropMultipleImages = function (props) {
    var id = props.id, children = props.children, formik = props.formik, wrapperCustomCSS = props.wrapperCustomCSS;
    var ref = useRef(null);
    var _a = __read(useState(false), 2), filter = _a[0], setFilter = _a[1];
    var _b = __read(useState(false), 2), dropActive = _b[0], setDropActive = _b[1];
    useEffect(function () {
        if (filter !== false && formik) {
            formik.setFieldValue(id, filter);
            setFilter(false);
        }
    }, [filter]);
    var Drop = function (e) {
        e.preventDefault();
        e.stopPropagation();
        var files = e.dataTransfer.files;
        if (files.length !== 0) {
            var urlArray = Array.from(files).map(function (file) {
                var url = URL === null || URL === void 0 ? void 0 : URL.createObjectURL(file);
                var idSet = v4();
                return { id: idSet, url: url, file: file };
            });
            var group = __spreadArray(__spreadArray([], __read(formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)]), false), __read(urlArray), false);
            formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, group);
            setDropActive(false);
        }
        else {
            setDropActive(false);
            formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, "");
        }
    };
    var DropInput = function (e) {
        e.preventDefault();
        e.stopPropagation();
        var files = e.currentTarget.files;
        if (files) {
            if (files.length !== 0) {
                var urlArray = Array.from(files).map(function (file) {
                    var url = URL === null || URL === void 0 ? void 0 : URL.createObjectURL(file);
                    var idSet = v4();
                    return { id: idSet, url: url, file: file };
                });
                var group = __spreadArray(__spreadArray([], __read(formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)]), false), __read(urlArray), false);
                formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, group);
                setDropActive(false);
            }
            else {
                setDropActive(false);
                formik === null || formik === void 0 ? void 0 : formik.setFieldValue(id, "");
            }
        }
    };
    var handleDrag = function (e) {
        e.preventDefault();
        e.stopPropagation();
    };
    var labelWidth = props.labelWidth, labelColor = props.labelColor, labelFontFamily = props.labelFontFamily, labelFontSize = props.labelFontSize, labelFontWeight = props.labelFontWeight, labelMargin = props.labelMargin, labelPadding = props.labelPadding, spanMargin = props.spanMargin, customCSS = props.customCSS, label = props.label, borderRadius = props.borderRadius;
    return (jsxs(InputTextLabelStyled, __assign({ labelWidth: labelWidth, labelColor: labelColor, labelFontFamily: labelFontFamily, labelFontSize: labelFontSize, labelFontWeight: labelFontWeight, labelMargin: labelMargin, labelPadding: labelPadding, customCSS: customCSS }, { children: [label && (jsx(InputTextSpanStyled, __assign({ spanMargin: spanMargin }, { children: label }))), jsxs(FileInputStyled, __assign({ dropActive: dropActive, htmlFor: id, onDrop: Drop, onDragOver: function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    setDropActive(true);
                }, onDragEnter: function (event) { return handleDrag(event); }, onDragLeave: function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    setDropActive(false);
                } }, props, { children: [(formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)].length) === 0 && (jsx(Wrapper$2, __assign({ flexDirection: "row", customCSS: wrapperCustomCSS }, { children: !dropActive ? (jsxs(Fragment$1, { children: [jsx(Image$2, { alt: "Drag and drop", height: "15px", width: "15px", margin: "0px 10px 0px 0px", src: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/PFS-0001/upload.svg" }), "ARRASTRA Y SUELTA"] })) : (jsx(Fragment$1, { children: "SUELTA" })) }))), (formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)].length) > 0 && (jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_1$12 || (templateObject_1$12 = __makeTemplateObject(["\n              top: 0;\n              position: absolute;\n              width: 100%;\n              height: 100%;\n              flex-direction: column;\n              align-items: center;\n              justify-content: flex-start;\n              z-index: 10;\n            "], ["\n              top: 0;\n              position: absolute;\n              width: 100%;\n              height: 100%;\n              flex-direction: column;\n              align-items: center;\n              justify-content: flex-start;\n              z-index: 10;\n            "]))) }, { children: jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_2$L || (templateObject_2$L = __makeTemplateObject(["\n                align-items: center;\n                justify-content: space-between;\n                flex-direction: row;\n                height: 100%;\n                flex-wrap: wrap;\n                gap: 5px;\n                overflow: hidden;\n              "], ["\n                align-items: center;\n                justify-content: space-between;\n                flex-direction: row;\n                height: 100%;\n                flex-wrap: wrap;\n                gap: 5px;\n                overflow: hidden;\n              "]))) }, { children: formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)].map(function (e) { return (jsxs(Wrapper$2, __assign({}, Animation$6, { customCSS: css$1(templateObject_3$C || (templateObject_3$C = __makeTemplateObject(["\n                    width: ", "%;\n                    height: ", "%;\n                    max-height: 100%;\n                    position: relative;\n                  "], ["\n                    width: ", "%;\n                    height: ", "%;\n                    max-height: 100%;\n                    position: relative;\n                  "])), 100 / (formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)].length) + 10, 100 / (formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)].length) + 15) }, { children: [jsx(Image$2, { alt: "Drag and drop Preview", src: "".concat(e.url), customCSS: css$1(templateObject_4$q || (templateObject_4$q = __makeTemplateObject(["\n                      border-radius: ", ";\n                      width: 100%;\n                      height: 100%;\n                      object-fit: cover;\n                    "], ["\n                      border-radius: ", ";\n                      width: 100%;\n                      height: 100%;\n                      object-fit: cover;\n                    "])), borderRadius || "4px") }, "".concat(e.id, "moreimages")), jsx(AtomButton, __assign({ customCSS: css$1(templateObject_5$l || (templateObject_5$l = __makeTemplateObject(["\n                      display: flex;\n                      align-items: center;\n                      justify-content: center;\n                      position: absolute;\n                      background: #e52d27;\n                      border-radius: 50%;\n                      width: 40px;\n                      height: 40px;\n                      padding: 0;\n                      right: 15px;\n                      top: 15px;\n                    "], ["\n                      display: flex;\n                      align-items: center;\n                      justify-content: center;\n                      position: absolute;\n                      background: #e52d27;\n                      border-radius: 50%;\n                      width: 40px;\n                      height: 40px;\n                      padding: 0;\n                      right: 15px;\n                      top: 15px;\n                    "]))), onClick: function () {
                                            var filterArray = formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)].filter(function (e2) { return e2.id !== e.id; });
                                            setFilter(filterArray);
                                        }, type: "button" }, { children: jsx(Icon$1, { height: "20px", color: "transparent", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/JRO-0001/icons/Component%20199%20%E2%80%93%202.svg", customCSS: css$1(templateObject_6$g || (templateObject_6$g = __makeTemplateObject(["\n                        svg {\n                          g {\n                            path {\n                              stroke: #fff;\n                            }\n                          }\n                        }\n                      "], ["\n                        svg {\n                          g {\n                            path {\n                              stroke: #fff;\n                            }\n                          }\n                        }\n                      "]))) }) }))] }), e.id)); }) })) }))), jsx("input", { ref: ref, type: "file", multiple: true, id: id, onChange: DropInput, style: { width: "100%", height: "100%" } })] })), jsx(AtomButton, __assign({ type: "button", width: "100%", backgroundColor: "#f6f7fb", border: "1px solid #c4c4c4", color: "#707070", fontWeight: "500", margin: "10px 0px 0px 0px", onClick: function () {
                    var _a;
                    (_a = ref === null || ref === void 0 ? void 0 : ref.current) === null || _a === void 0 ? void 0 : _a.click();
                } }, { children: "Cargar mas imagenes" })), children, jsx(AtomInputTextError, __assign({}, props))] })));
};
var templateObject_1$12, templateObject_2$L, templateObject_3$C, templateObject_4$q, templateObject_5$l, templateObject_6$g;

var Animation$5 = {
    whileTap: { scale: 0.98, opacity: 0.8 },
};
var InputRadioButton = function (props) {
    var value = props.value, onChange = props.onChange, onBlur = props.onBlur, formik = props.formik, id = props.id, options = props.options;
    var labelWidth = props.labelWidth, labelColor = props.labelColor, labelFontFamily = props.labelFontFamily, labelFontSize = props.labelFontSize, labelFontWeight = props.labelFontWeight, labelMargin = props.labelMargin, labelPadding = props.labelPadding, spanMargin = props.spanMargin, customCSS = props.customCSS;
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    useEffect(function () { }, [formik === null || formik === void 0 ? void 0 : formik.values[id]]);
    return (jsxs(InputTextLabelStyled, __assign({ labelWidth: labelWidth, labelColor: labelColor, labelFontFamily: labelFontFamily, labelFontSize: labelFontSize, labelFontWeight: labelFontWeight, labelMargin: labelMargin, labelPadding: labelPadding, spanMargin: spanMargin, customCSS: customCSS, id: id, htmlFor: id, defaultValue: formik && id && (formik === null || formik === void 0 ? void 0 : formik.values[id]) ? formik === null || formik === void 0 ? void 0 : formik.values[id] : value, onChange: formik ? formik === null || formik === void 0 ? void 0 : formik.handleChange : onChange, onBlur: function (e) {
            formik === null || formik === void 0 ? void 0 : formik.handleBlur(e);
            onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
        } }, { children: [options &&
                options.map(function (option) { return (jsx(Wrapper$2, __assign({ flexDirection: "row", alignItems: "center" }, { children: jsxs(LabelRadioButtonStyled, __assign({ htmlFor: option.id }, { children: [jsx(InputRadioButtonStyled, __assign({ id: option.id, type: "radio" }, Animation$5, { name: id, disabled: props.disabled, value: "".concat(option.value), defaultChecked: (formik && id && (formik === null || formik === void 0 ? void 0 : formik.values[id])
                                    ? formik === null || formik === void 0 ? void 0 : formik.values[id]
                                    : value) === option.value })), jsx(Text$2, { children: option.label })] })) }), option.id)); }), jsx(AtomInputTextError, __assign({}, props))] })));
};

var Animation$4 = {
    whileTap: { scale: 0.98, opacity: 0.8 },
};
var mapRange$1 = function (value, low1, high1, low2, high2) { return low2 + ((high2 - low2) * (value - low1)) / (high1 - low1); };
var isNegative = function (range, min, max) {
    var RangeMax = mapRange$1(range.max, 0, 100, min, max);
    var RangeMin = mapRange$1(range.min, 0, 100, min, max);
    return RangeMax - RangeMin < 0
        ? { min: RangeMax, max: RangeMin }
        : { min: RangeMin, max: RangeMax };
};
var InputRange = function (props) {
    var onUpdateValues = props.onUpdateValues, formik = props.formik, id = props.id, children = props.children;
    var _a = props.minRange, minRange = _a === void 0 ? 0 : _a, _b = props.maxRange, maxRange = _b === void 0 ? 100 : _b, _c = props.loadValues, loadValues = _c === void 0 ? {
        min: 0,
        max: 100,
    } : _c;
    var labelWidth = props.labelWidth, labelColor = props.labelColor, labelFontFamily = props.labelFontFamily, labelFontSize = props.labelFontSize, labelFontWeight = props.labelFontWeight, labelMargin = props.labelMargin, labelPadding = props.labelPadding, spanMargin = props.spanMargin, customCSS = props.customCSS, label = props.label;
    var _d = __read(useState({
        min: 0,
        max: 100,
    }), 2), rangeValue = _d[0], setRangeValue = _d[1];
    useEffect(function () {
        setRangeValue(loadValues);
    }, [loadValues.max, loadValues.min]);
    useEffect(function () {
        if (formik) {
            formik.setFieldValue(id || 'range', isNegative(rangeValue, minRange, maxRange));
        }
        else if (onUpdateValues) {
            onUpdateValues(isNegative(rangeValue, minRange, maxRange));
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [rangeValue]);
    return (jsxs(InputRangeLabelStyled, __assign({ labelWidth: labelWidth, labelColor: labelColor, labelFontFamily: labelFontFamily, labelFontSize: labelFontSize, labelFontWeight: labelFontWeight, labelMargin: labelMargin, labelPadding: labelPadding, spanMargin: spanMargin, customCSS: customCSS }, { children: [label && jsx("span", { children: label }), jsxs(SliderTrackStyled, __assign({}, props, { minTrack: rangeValue.min, maxTrack: rangeValue.max }, { children: [jsx(InputRangeStyled, __assign({}, Animation$4, { type: "range" }, props, { value: rangeValue.min.toString(), onChange: function (e) {
                            setRangeValue({
                                min: Number(e.target.value),
                                max: rangeValue.max,
                            });
                        } })), jsx(InputRangeStyled, __assign({}, Animation$4, { type: "range" }, props, { value: rangeValue.max.toString(), onChange: function (e) {
                            setRangeValue({
                                min: rangeValue.min,
                                max: Number(e.target.value),
                            });
                        } }))] })), children, label, jsx(AtomInputTextError, __assign({}, props))] })));
};

var Animation$3 = {
    whileTap: { scale: 0.98, opacity: 0.8 },
};
var DefaultAnimation$1 = {
    whileTap: { scale: 0.98, opacity: 0.8 },
    transition: {
        default: { duration: 0.3 },
    },
    initial: { opacity: 0 },
    animate: { opacity: 1 },
    exit: { opacity: 0 },
};
var InputSelect = function (props) {
    var value = props.value, onChange = props.onChange, onBlur = props.onBlur, formik = props.formik, id = props.id, children = props.children;
    var labelWidth = props.labelWidth, labelColor = props.labelColor, labelFontFamily = props.labelFontFamily, labelFontSize = props.labelFontSize, labelFontWeight = props.labelFontWeight, labelMargin = props.labelMargin, labelPadding = props.labelPadding, spanMargin = props.spanMargin, customCSS = props.customCSS, label = props.label, options = props.options, defaultText = props.defaultText;
    return (jsxs(InputTextLabelStyled, __assign({ labelWidth: labelWidth, labelColor: labelColor, labelFontFamily: labelFontFamily, labelFontSize: labelFontSize, labelFontWeight: labelFontWeight, labelMargin: labelMargin, labelPadding: labelPadding, customCSS: customCSS }, { children: [label && (jsx(InputTextSpanStyled, __assign({ spanMargin: spanMargin }, { children: label }))), jsxs(InputSelectStyled, __assign({ value: formik && id
                    ? lodash.get(formik === null || formik === void 0 ? void 0 : formik.values, id)
                    : formik && id && lodash.get(formik === null || formik === void 0 ? void 0 : formik.values, id) === ''
                        ? 'DEFAULT'
                        : value, onChange: formik ? formik === null || formik === void 0 ? void 0 : formik.handleChange : onChange, onBlur: function (e) {
                    formik === null || formik === void 0 ? void 0 : formik.handleBlur(e);
                    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
                } }, props, Animation$3, { children: [jsx(InputOptionStyled, __assign({}, DefaultAnimation$1, { value: "DEFAULT", disabled: true }, { children: defaultText !== null && defaultText !== void 0 ? defaultText : 'Selecciona una opción' })), options &&
                        options.length > 0 &&
                        (options === null || options === void 0 ? void 0 : options.map(function (e) { return (createElement(InputOptionStyled, __assign({}, DefaultAnimation$1, { value: e.value, key: e.id }), e.label)); }))] })), children, jsx(AtomInputTextError, __assign({}, props))] })));
};

var Animation$2 = {
    whileTap: { scale: 0.98, opacity: 0.8 },
};
var InputTextBox = function (props) {
    var _a, _b;
    var value = props.value, onChange = props.onChange, onBlur = props.onBlur, formik = props.formik, id = props.id, children = props.children;
    var labelWidth = props.labelWidth, labelColor = props.labelColor, labelFontFamily = props.labelFontFamily, labelFontSize = props.labelFontSize, labelFontWeight = props.labelFontWeight, labelMargin = props.labelMargin, labelPadding = props.labelPadding, spanMargin = props.spanMargin, customCSS = props.customCSS, label = props.label;
    return (jsxs(InputTextLabelStyled, __assign({ labelWidth: labelWidth, labelColor: labelColor, labelFontFamily: labelFontFamily, labelFontSize: labelFontSize, labelFontWeight: labelFontWeight, labelMargin: labelMargin, labelPadding: labelPadding, customCSS: customCSS, htmlFor: id }, { children: [label && (jsx(InputTextSpanStyled, __assign({ spanMargin: spanMargin }, { children: label }))), jsx(InputTextBoxStyled, __assign({}, Animation$2, props, { value: (_a = formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)]) !== null && _a !== void 0 ? _a : value, onChange: (_b = formik === null || formik === void 0 ? void 0 : formik.handleChange) !== null && _b !== void 0 ? _b : onChange, onBlur: function (e) {
                    formik === null || formik === void 0 ? void 0 : formik.handleBlur(e);
                    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
                } })), children, jsx(AtomInputTextError, __assign({}, props))] })));
};

var Animation$1 = {
    whileTap: { scale: 0.98, opacity: 0.8 },
};
var InputText = function (props) {
    var _a;
    var value = props.value, onChange = props.onChange, onBlur = props.onBlur, formik = props.formik, id = props.id, children = props.children;
    var labelWidth = props.labelWidth, labelColor = props.labelColor, labelFontFamily = props.labelFontFamily, labelFontSize = props.labelFontSize, labelFontWeight = props.labelFontWeight, labelMargin = props.labelMargin, labelPadding = props.labelPadding, spanMargin = props.spanMargin, customCSS = props.customCSS, label = props.label, step = props.step;
    return (jsxs(InputTextLabelStyled, __assign({ labelWidth: labelWidth, labelColor: labelColor, labelFontFamily: labelFontFamily, labelFontSize: labelFontSize, labelFontWeight: labelFontWeight, labelMargin: labelMargin, labelPadding: labelPadding, customCSS: customCSS, htmlFor: id, ref: props.refObject }, { children: [label && (jsx(InputTextSpanStyled, __assign({ spanMargin: spanMargin }, { children: label }))), jsx(InputTextStyled, __assign({}, Animation$1, props, { value: (_a = lodash.get(formik === null || formik === void 0 ? void 0 : formik.values, id)) !== null && _a !== void 0 ? _a : value, onChange: function (e) {
                    formik === null || formik === void 0 ? void 0 : formik.handleChange(e);
                    onChange === null || onChange === void 0 ? void 0 : onChange(e);
                }, onBlur: function (e) {
                    formik === null || formik === void 0 ? void 0 : formik.handleBlur(e);
                    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
                }, step: step })), children, jsx(AtomInputTextError, __assign({}, props))] })));
};

var Animation = {
    whileTap: { scale: 0.98, opacity: 0.8 },
};
var InputCheckbox = function (props) {
    var _a, _b, _c, _d;
    var value = props.value, onChange = props.onChange, onBlur = props.onBlur, formik = props.formik, id = props.id, children = props.children;
    var labelWidth = props.labelWidth, labelColor = props.labelColor, labelFontFamily = props.labelFontFamily, labelFontSize = props.labelFontSize, labelFontWeight = props.labelFontWeight, labelMargin = props.labelMargin, labelPadding = props.labelPadding, spanMargin = props.spanMargin, customCSS = props.customCSS, label = props.label, checked = props.checked;
    var customize = useSelector(function (state) { return state.customize; });
    return (jsxs(InputCheckboxLabelStyled, __assign({ labelWidth: labelWidth, labelColor: labelColor, labelFontFamily: labelFontFamily, labelFontSize: labelFontSize, labelFontWeight: labelFontWeight, labelMargin: labelMargin, labelPadding: labelPadding, spanMargin: spanMargin, customCSS: css$1(templateObject_1$11 || (templateObject_1$11 = __makeTemplateObject(["\n        input {\n          margin: 0px;\n        }\n        input[type='checkbox'] {\n          position: relative;\n          width: 40px;\n          height: 12px;\n          appearance: none;\n          background: #d8d8d8;\n          outline: none;\n          border-radius: 20px;\n          border: none;\n          box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);\n          transition: 0.5s;\n          cursor: pointer;\n        }\n        input:checked[type='checkbox'] {\n          background: ", ";\n        }\n        input[type='checkbox']:before {\n          content: '';\n          position: absolute;\n          height: 18px;\n          width: 18px;\n          border-radius: 50%;\n          top: -40%;\n          left: -5px;\n          background-color: #fff;\n          border: 2px solid ", ";\n          transform: translate(2px, 2px);\n          transition: 0.2s;\n        }\n        input:checked[type='checkbox']:before {\n          left: 20px;\n        }\n        ", "\n      "], ["\n        input {\n          margin: 0px;\n        }\n        input[type='checkbox'] {\n          position: relative;\n          width: 40px;\n          height: 12px;\n          appearance: none;\n          background: #d8d8d8;\n          outline: none;\n          border-radius: 20px;\n          border: none;\n          box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);\n          transition: 0.5s;\n          cursor: pointer;\n        }\n        input:checked[type='checkbox'] {\n          background: ", ";\n        }\n        input[type='checkbox']:before {\n          content: '';\n          position: absolute;\n          height: 18px;\n          width: 18px;\n          border-radius: 50%;\n          top: -40%;\n          left: -5px;\n          background-color: #fff;\n          border: 2px solid ", ";\n          transform: translate(2px, 2px);\n          transition: 0.2s;\n        }\n        input:checked[type='checkbox']:before {\n          left: 20px;\n        }\n        ", "\n      "])), (_b = (_a = customize === null || customize === void 0 ? void 0 : customize.colors) === null || _a === void 0 ? void 0 : _a.primary) !== null && _b !== void 0 ? _b : '#f1576c', (_d = (_c = customize === null || customize === void 0 ? void 0 : customize.colors) === null || _c === void 0 ? void 0 : _c.primary) !== null && _d !== void 0 ? _d : '#f1576c', customCSS) }, { children: [jsxs("div", __assign({ style: {
                    display: "flex",
                    flexDirection: "row",
                    width: '100%',
                    alignItems: 'center',
                } }, { children: [label && jsx("span", { children: label }), jsx(InputCheckboxToggleStyled, __assign({}, Animation, props, { type: "checkbox", id: label, name: id, disabled: props.disabled, value: formik && id ? formik === null || formik === void 0 ? void 0 : formik.values[id] : value, onChange: formik ? formik === null || formik === void 0 ? void 0 : formik.handleChange : onChange, onBlur: function (e) {
                            formik === null || formik === void 0 ? void 0 : formik.handleBlur(e);
                            onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
                        }, checked: formik && id
                            ? (formik === null || formik === void 0 ? void 0 : formik.values[id]) === true
                            : checked || value === "on" })), children, label] })), jsx(AtomInputTextError, __assign({}, props))] })));
};
var templateObject_1$11;

var Input = function (props) {
    var type = props.type;
    switch (type) {
        case "checkbox":
            return jsx(InputCheckbox$1, __assign({}, props));
        case "select":
            return jsx(InputSelect, __assign({}, props));
        case "range":
            return jsx(InputRange, __assign({}, props));
        case "textbox":
            return jsx(InputTextBox, __assign({}, props));
        case "dragdrop":
            return jsx(InputDragDrop, __assign({}, props));
        case "dragdropMultiple":
            return jsx(InputDragDropMultiple, __assign({}, props));
        case "dragdropMultipleImages":
            return jsx(InputDragDropMultipleImages, __assign({}, props));
        case "toggle":
            return jsx(InputCheckbox, __assign({}, props));
        case "radio":
            return jsx(InputRadioButton, __assign({}, props));
        case "dragDropFile":
            return jsx(InputDragDropFile, __assign({}, props));
        case "dragdropMultipleFiles":
            return jsx(InputDragDropMultipleFiles, __assign({}, props));
        default:
            return jsx(InputText, __assign({}, props));
    }
};

var AtomFilterCategory = function (props) {
    var _a;
    var onClick = props.onClick, componentsProps = props.componentsProps, options = props.options, children = props.children;
    var router = useRouter();
    var categories = router.query.categories;
    var _b = __read(useState([]), 2), categoriesSelected = _b[0], setCategoriesSelected = _b[1];
    var _c = __read(useState(false), 2), loadValue = _c[0], setLoadValue = _c[1];
    useEffect(function () {
        if (categories && loadValue === false) {
            setLoadValue(true);
            setCategoriesSelected([categories].flat());
        }
    }, [categories]);
    return (jsxs(Wrapper$2, __assign({}, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperProps, { customCSS: css$1(templateObject_1$10 || (templateObject_1$10 = __makeTemplateObject(["\n        @media only screen and (max-width: 1200px) {\n          max-width: 200px;\n          margin: 0px 10px;\n        }\n        @media only screen and (max-width: 520px) {\n          max-width: 100%;\n        }\n        ", "\n      "], ["\n        @media only screen and (max-width: 1200px) {\n          max-width: 200px;\n          margin: 0px 10px;\n        }\n        @media only screen and (max-width: 520px) {\n          max-width: 100%;\n        }\n        ", "\n      "])), (_a = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperProps) === null || _a === void 0 ? void 0 : _a.customCSS) }, { children: [jsx(Text$2, __assign({ margin: "30px 0px 15px 0px", color: "#f1576c", fontSize: "16px", fontWeight: 700 }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.titleProps, { children: "Filtrar por categoria" })), jsx(Separator, __assign({ height: "1px", width: "100%", color: "#cacaca", margin: "0px 0px 20px 0px" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.separatorProps)), jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_2$K || (templateObject_2$K = __makeTemplateObject(["\n          @media only screen and (max-width: 1200px) {\n            flex-direction: row;\n            justify-content: space-between;\n            flex-wrap: wrap;\n          }\n        "], ["\n          @media only screen and (max-width: 1200px) {\n            flex-direction: row;\n            justify-content: space-between;\n            flex-wrap: wrap;\n          }\n        "]))) }, { children: [children, options === null || options === void 0 ? void 0 : options.map(function (option) {
                        var _a;
                        return (jsx(Input, __assign({ type: "checkbox" }, option, { accentColor: "#f75e5e", label: "", errorHeight: "0px", value: "".concat(option.value), checked: !!categoriesSelected.find(function (item) { return item === option.id; }), onChange: function () {
                                setCategoriesSelected(categoriesSelected.includes(option.id)
                                    ? categoriesSelected.filter(function (item) { return item !== option.id; })
                                    : __spreadArray(__spreadArray([], __read(categoriesSelected), false), [option.id], false));
                            } }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.optionsProps, { customCSS: css$1(templateObject_3$B || (templateObject_3$B = __makeTemplateObject(["\n              input {\n                margin-right: 5px;\n                filter: hue-rotate(67deg);\n                :checked {\n                  filter: hue-rotate(0deg);\n                }\n              }\n              ", "\n            "], ["\n              input {\n                margin-right: 5px;\n                filter: hue-rotate(67deg);\n                :checked {\n                  filter: hue-rotate(0deg);\n                }\n              }\n              ", "\n            "])), (_a = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.optionsProps) === null || _a === void 0 ? void 0 : _a.customCSS) }, { children: jsx(Text$2, __assign({ margin: "3px 0px 0px 0px" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.textProps, { fontSize: "12px", color: "#494949", fontWeight: 600 }, { children: option.label })) }), option.id));
                    })] })), jsx(AtomButton, __assign({ backgroundColor: "#f1576c", padding: "8px 25px", margin: "15px 0px 0px 0px", onClick: function () {
                    router.push({
                        query: __assign(__assign({}, router.query), { categories: categoriesSelected }),
                        pathname: router.pathname,
                    });
                    onClick === null || onClick === void 0 ? void 0 : onClick(categoriesSelected);
                } }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.buttonProps, { children: "Filtrar" }))] })));
};
var templateObject_1$10, templateObject_2$K, templateObject_3$B;

var mapRange = function (value, low1, high1, low2, high2) { return low2 + ((high2 - low2) * (value - low1)) / (high1 - low1); };
var AtomFilterRange = function (props) {
    var _a;
    var _b = props.min, min = _b === void 0 ? 0 : _b, _c = props.max, max = _c === void 0 ? 100 : _c, onClick = props.onClick, route = props.route, componentsProps = props.componentsProps;
    var router = useRouter();
    var _d = router.query, priceMin = _d.priceMin, priceMax = _d.priceMax;
    var _e = __read(useState({ min: min, max: max }), 2), price = _e[0], setPrice = _e[1];
    var _f = __read(useState({
        status: false,
        value: { min: 0, max: 100 },
    }), 2), loadValue = _f[0], setLoadValue = _f[1];
    useEffect(function () {
        if (priceMin && priceMax && loadValue.status === false) {
            setLoadValue({
                status: true,
                value: {
                    min: mapRange(Number(priceMin), min, max, 0, 100),
                    max: mapRange(Number(priceMax), min, max, 0, 100),
                },
            });
        }
    }, [priceMin, priceMax]);
    return (jsxs(Wrapper$2, __assign({}, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperProps, { customCSS: css$1(templateObject_1$$ || (templateObject_1$$ = __makeTemplateObject(["\n        @media only screen and (max-width: 1200px) {\n          max-width: 200px;\n          margin: 0px 10px;\n        }\n        @media only screen and (max-width: 520px) {\n          max-width: 100%;\n        }\n        ", "\n      "], ["\n        @media only screen and (max-width: 1200px) {\n          max-width: 200px;\n          margin: 0px 10px;\n        }\n        @media only screen and (max-width: 520px) {\n          max-width: 100%;\n        }\n        ", "\n      "])), (_a = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperProps) === null || _a === void 0 ? void 0 : _a.customCSS) }, { children: [jsx(Text$2, __assign({ margin: "30px 0px 15px 0px", color: "#f1576c", fontSize: "16px", fontWeight: 700 }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.titleProps, { children: "Filtrar por precio" })), jsx(Separator, __assign({ height: "1px", width: "100%", color: "#cacaca", margin: "0px 0px 30px 0px" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.separatorProps)), jsx(Input, __assign({ type: "range", minRange: min, maxRange: max, thumbBorder: "2px solid #f1576c", trackColor: "#f1576c", loadValues: loadValue.value, onUpdateValues: function (range) {
                    setPrice(range);
                }, id: "priceRange" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.inputProps)), jsx(Text$2, __assign({ color: "#888888", fontWeight: 600 }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.descriptionProps, { children: "Precio: $".concat(price.min, " - $").concat(price.max) })), jsx(AtomButton, __assign({ backgroundColor: "#f1576c", padding: "8px 25px", margin: "15px 0px 0px 0px", onClick: function () {
                    router.push({
                        pathname: "".concat(route || "".concat(router.pathname, "/")),
                        query: __assign(__assign({}, router.query), { priceMin: price.min, priceMax: price.max }),
                    });
                    if (onClick) {
                        onClick(price);
                    }
                } }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.buttonProps, { children: "Filtrar" }))] })));
};
var templateObject_1$$;

var AtomFilterSearch = function (props) {
    var _a, _b, _c, _d, _e, _f, _g;
    var onClick = props.onClick, route = props.route, componentsProps = props.componentsProps;
    var router = useRouter();
    var search = router.query.search;
    var _h = __read(useState(''), 2), value = _h[0], setValue = _h[1];
    useEffect(function () {
        if (search) {
            setValue(search.toString());
        }
    }, [search]);
    var handleOnClick = function () {
        if (onClick) {
            onClick(value);
        }
        else {
            var query = __assign(__assign({}, router.query), { search: value });
            if (value === '') {
                delete query.search;
            }
            router.push({
                pathname: "".concat(route || "".concat(router.pathname, "/")),
                query: query,
            });
        }
    };
    return (jsxs(Wrapper$2, __assign({}, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperProps, { customCSS: css$1(templateObject_1$_ || (templateObject_1$_ = __makeTemplateObject(["\n        @media only screen and (max-width: 1200px) {\n          flex-direction: row;\n          padding: 40px 0px 10px 0px;\n        }\n        @media only screen and (max-width: 980px) {\n          flex-direction: row;\n          padding: 0px 0px;\n        }\n        ", "\n      "], ["\n        @media only screen and (max-width: 1200px) {\n          flex-direction: row;\n          padding: 40px 0px 10px 0px;\n        }\n        @media only screen and (max-width: 980px) {\n          flex-direction: row;\n          padding: 0px 0px;\n        }\n        ", "\n      "])), (_a = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperProps) === null || _a === void 0 ? void 0 : _a.customCSS) }, { children: [jsxs(Wrapper$2, __assign({ height: "max-content", backgroundColor: "#f8f9fa", border: "1px solid #ced4da", borderRadius: "5px", flexDirection: "row", alignItems: "center", justifyContent: "flex-start", padding: "0px 15px" }, (_b = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.inputProps) === null || _b === void 0 ? void 0 : _b.wrapperProps, { customCSS: css$1(templateObject_2$J || (templateObject_2$J = __makeTemplateObject(["\n          @media only screen and (max-width: 1200px) {\n            margin: 0px;\n          }\n          ", "\n        "], ["\n          @media only screen and (max-width: 1200px) {\n            margin: 0px;\n          }\n          ", "\n        "])), (_d = (_c = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.inputProps) === null || _c === void 0 ? void 0 : _c.wrapperProps) === null || _d === void 0 ? void 0 : _d.customCSS) }, { children: [jsx(Icon$1, __assign({ width: "18px", height: "18px", color: "#b3b3b3", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/commons/search.svg" }, (_e = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.inputProps) === null || _e === void 0 ? void 0 : _e.iconProps)), jsx(Input, __assign({ border: "none", height: "35px", labelWidth: "100%", placeholder: "Buscar producto", fontSize: "12px", color: "#484b4e", backgroundColor: "transparent", placeholderColor: "#abbac7", errorHeight: "0px", errorPadding: "0px", value: value, onKeyUp: function (e) {
                            if (e.key === 'Enter') {
                                handleOnClick();
                            }
                        }, onChange: function (e) { return setValue(e.target.value); } }, (_f = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.inputProps) === null || _f === void 0 ? void 0 : _f.inputProps))] })), jsx(AtomButton, __assign({ backgroundColor: "#fe6a6a", border: "1px solid #fe6a6a", padding: "7px 25px", margin: "15px 0px 0px 0px" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.buttonProps, { onClick: function () {
                    var _a;
                    handleOnClick();
                    (_a = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.buttonProps) === null || _a === void 0 ? void 0 : _a.onClick();
                }, customCSS: css$1(templateObject_3$A || (templateObject_3$A = __makeTemplateObject(["\n          @media only screen and (max-width: 1200px) {\n            margin: 15px 0px 0px 20px;\n          }\n          @media only screen and (max-width: 1200px) {\n            margin: 0px 0px 0px 20px;\n          }\n          ", "\n        "], ["\n          @media only screen and (max-width: 1200px) {\n            margin: 15px 0px 0px 20px;\n          }\n          @media only screen and (max-width: 1200px) {\n            margin: 0px 0px 0px 20px;\n          }\n          ", "\n        "])), (_g = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.buttonProps) === null || _g === void 0 ? void 0 : _g.customCSS) }, { children: "Buscar" }))] })));
};
var templateObject_1$_, templateObject_2$J, templateObject_3$A;

var AtomFilterSort = function (props) {
    var _a, _b, _c;
    var componentsProps = props.componentsProps, options = props.options, route = props.route;
    var router = useRouter();
    var sort = router.query.sort;
    var _d = __read(useState('DEFAULT'), 2), value = _d[0], setValue = _d[1];
    var _e = __read(useState(options || [
        {
            id: '1',
            label: 'Menor',
            value: '-1',
        },
        {
            id: '2',
            label: 'Mayor',
            value: '1',
        },
    ]), 2), optionsInput = _e[0], setOptionsInput = _e[1];
    useEffect(function () {
        setOptionsInput(options || optionsInput);
    }, [options]);
    useEffect(function () {
        if (sort) {
            setValue(sort.toString());
        }
    }, [sort]);
    return (jsxs(Wrapper$2, __assign({ width: "max-content", flexDirection: "row", alignItems: "center", justifyContent: "center", padding: "0px 5px 20px 0px" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperProps, { children: [jsx(Text$2, __assign({ margin: "0px 15px 0px 0px" }, { children: "Ordenar por:" })), jsx(Input, __assign({ border: "none", height: "35px", placeholder: "Buscar producto", fontSize: "12px", backgroundColor: "transparent", placeholderColor: "#6c757d", errorHeight: "0px", errorPadding: "0px", type: "select", value: value, options: optionsInput, onChange: function (e) {
                    setValue(e.target.value);
                    router.push({
                        pathname: "".concat(route || "".concat(router.pathname, "/")),
                        query: __assign(__assign({}, router.query), { sort: e.target.value }),
                    });
                } }, (_a = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.inputProps) === null || _a === void 0 ? void 0 : _a.inputProps, { customCSS: css$1(templateObject_1$Z || (templateObject_1$Z = __makeTemplateObject(["\n          select {\n            color: #f1576c;\n            font-weight: bold;\n            border-radius: 6px;\n            border: 1px solid #dadada;\n          }\n          ", "\n        "], ["\n          select {\n            color: #f1576c;\n            font-weight: bold;\n            border-radius: 6px;\n            border: 1px solid #dadada;\n          }\n          ", "\n        "])), (_c = (_b = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.inputProps) === null || _b === void 0 ? void 0 : _b.inputProps) === null || _c === void 0 ? void 0 : _c.customCSS) }))] })));
};
var templateObject_1$Z;

var capitalizeFirstLetter$1 = function (x) {
    return x.charAt(0).toUpperCase() + x.slice(1);
};

var changeBrightness = function (color, amount) {
    return "#".concat(color
        .replace(/^#/, '')
        .replace(/../g, function (colorReduce) {
        return "0".concat(Math.min(255, Math.max(0, parseInt(colorReduce, 16) + amount)).toString(16)).substr(-2);
    }));
};

/// convert date to string YYYY-MM-DD HH:mm:ss
function convertDate(date) {
    return date.toISOString().slice(0, 19).replace('T', ' ');
}

var convertDateWithOptions = function (date, locale, options) {
    if (locale === void 0) { locale = 'en-US'; }
    var DateFormat = new Date(date).toLocaleString(locale, options);
    return "".concat(DateFormat);
};

var convertLocalDateToUTC = function (vdate, time) {
    var _a, _b, _c, _d;
    if (vdate && time) {
        var dateb = "".concat(vdate, "T").concat(time);
        var isoDate = (_d = (_c = (_b = (_a = new Date(dateb)) === null || _a === void 0 ? void 0 : _a.toISOString()) === null || _b === void 0 ? void 0 : _b.replace('T', ' ')) === null || _c === void 0 ? void 0 : _c.replace('Z', '')) === null || _d === void 0 ? void 0 : _d.slice(0, -4);
        return isoDate;
    }
    return '';
};

var convertUTC = function (date) {
    var _a;
    var newdate = new Date(date).toString().replace('T', ' ');
    var year = newdate === null || newdate === void 0 ? void 0 : newdate.slice(11, 15);
    var hour = newdate === null || newdate === void 0 ? void 0 : newdate.slice(16, 25);
    var day = newdate === null || newdate === void 0 ? void 0 : newdate.slice(8, 10);
    var month = (_a = date === null || date === void 0 ? void 0 : date.toString()) === null || _a === void 0 ? void 0 : _a.slice(5, 7);
    return "".concat(year, "-").concat(month, "-").concat(day, " ").concat(hour);
};

var convertUTCtoLocalDate = function (date) {
    var _a, _b, _c;
    var convertDate = convertUTC(date);
    var toStringDate = (_a = convertDate.toString()) === null || _a === void 0 ? void 0 : _a.slice(0, 19).replace('T', ' ');
    var newDate = (_b = toStringDate === null || toStringDate === void 0 ? void 0 : toStringDate.slice(0, 10)) !== null && _b !== void 0 ? _b : '';
    var newTime = (_c = toStringDate === null || toStringDate === void 0 ? void 0 : toStringDate.slice(10, 16).replace(/ /g, '')) !== null && _c !== void 0 ? _c : '';
    return {
        date: newDate,
        time: newTime,
    };
};

var TrainedNet = function (input) {
    var convert = new Float32Array([input.r, input.g, input.b]);
    return {
        white: 1 /
            (1 +
                1 /
                    Math.exp(-10.37766170501709 +
                        (12.204835891723633 * 1) /
                            (1 +
                                1 /
                                    Math.exp(6.169667720794678 -
                                        4.042087078094482 * (convert[0] || 0) -
                                        19.438833236694336 * (convert[1] || 0) +
                                        14.434931755065918 * (convert[2] || 0))) +
                        (11.918014526367188 * 1) /
                            (1 +
                                1 /
                                    Math.exp(2.6512327194213867 -
                                        3.513329029083252 * (convert[0] || 0) -
                                        17.795860290527344 * (convert[1] || 0) +
                                        17.435640335083008 * (convert[2] || 0))) +
                        (9.877058982849121 * 1) /
                            (1 +
                                1 /
                                    Math.exp(5.760010242462158 -
                                        3.2945780754089355 * (convert[0] || 0) -
                                        8.6066312789917 * (convert[1] || 0) -
                                        7.926300525665283 * (convert[2] || 0))))),
        black: 1 /
            (1 +
                1 /
                    Math.exp(10.386853218078613 -
                        (12.263668060302734 * 1) /
                            (1 +
                                1 /
                                    Math.exp(6.169667720794678 -
                                        4.042087078094482 * (convert[0] || 0) -
                                        19.438833236694336 * (convert[1] || 0) +
                                        14.434931755065918 * (convert[2] || 0))) -
                        (11.879143714904785 * 1) /
                            (1 +
                                1 /
                                    Math.exp(2.6512327194213867 -
                                        3.513329029083252 * (convert[0] || 0) -
                                        17.795860290527344 * (convert[1] || 0) +
                                        17.435640335083008 * (convert[2] || 0))) -
                        (9.865546226501465 * 1) /
                            (1 +
                                1 /
                                    Math.exp(5.760010242462158 -
                                        3.2945780754089355 * (convert[0] || 0) -
                                        8.6066312789917 * (convert[1] || 0) -
                                        7.926300525665283 * (convert[2] || 0))))),
    };
};
var hexToRgb = function (hex) {
    var _a;
    var result = (_a = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)) !== null && _a !== void 0 ? _a : [];
    return {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16),
    };
};
var isBackDark = function (hex) {
    var color = TrainedNet(hexToRgb(hex));
    if (color.black > color.white) {
        return '#373737';
    }
    return '#fff';
};

/* eslint-disable no-unused-expressions */
/* eslint-disable prettier/prettier */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable react-hooks/rules-of-hooks */
var Countries = {
    es: {
        ALB: {
            name: 'Albania',
            code: 'ALB',
            phoneCode: '+355',
            currencyId: 'eb0e5c50-0be2-4554-bddc-c988df31098c',
            id: '9d24cdb3-7ebc-49ed-af85-3b66e77aa535',
            createdAt: '2021-11-23T18:10:06.082Z',
            updatedAt: '2021-11-23T18:10:06.082Z',
        },
        DZA: {
            name: 'Argelia',
            code: 'DZA',
            phoneCode: '+213',
            currencyId: '150968b5-da61-4ee3-ade0-c18b8c16d23f',
            id: '3835b761-9dcc-4dcf-b52c-88aeead57225',
            createdAt: '2021-11-23T18:10:06.085Z',
            updatedAt: '2021-11-23T18:10:06.085Z',
        },
        ARG: {
            name: 'Argentina',
            code: 'ARG',
            phoneCode: '+54',
            currencyId: 'f5ff6526-51a3-4ecc-8917-0ac15255f71f',
            id: '4e2f0581-4e6b-474f-b1bc-3a10fd666d64',
            createdAt: '2021-11-23T18:10:06.101Z',
            updatedAt: '2021-11-23T18:10:06.101Z',
        },
        AUT: {
            name: 'Austria',
            code: 'AUT',
            phoneCode: '+43',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'af79e72a-d496-4963-810f-e21fd577165c',
            createdAt: '2021-11-23T18:10:06.109Z',
            updatedAt: '2021-11-23T18:10:06.109Z',
        },
        IOT: {
            name: 'Territorio Británico del Océano Índico',
            code: 'IOT',
            phoneCode: '+246',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '5c1a3c67-9665-493c-8aca-461334e39454',
            createdAt: '2021-11-23T18:10:06.143Z',
            updatedAt: '2021-11-23T18:10:06.143Z',
        },
        BRN: {
            name: 'Brunéi',
            code: 'BRN',
            phoneCode: '+673',
            currencyId: 'fd40ef75-f2aa-4a38-ab89-c91da68c008c',
            id: '96b491b6-31d3-4f94-8ea6-aca0a6e46253',
            createdAt: '2021-11-23T18:10:06.144Z',
            updatedAt: '2021-11-23T18:10:06.144Z',
        },
        DJI: {
            name: 'Yibuti',
            code: 'DJI',
            phoneCode: '+253',
            currencyId: '4fe8edd6-8803-441f-ac16-f28ec1eb1ec8',
            id: 'b110e608-68d1-40f8-9fd3-711b32fc1b62',
            createdAt: '2021-11-23T18:10:06.195Z',
            updatedAt: '2021-11-23T18:10:06.195Z',
        },
        GUF: {
            name: 'Guayana Francesa',
            code: 'GUF',
            phoneCode: '+594',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '49afea96-2e0a-4965-bc2e-9c889242d414',
            createdAt: '2021-11-23T18:10:06.225Z',
            updatedAt: '2021-11-23T18:10:06.225Z',
        },
        GRD: {
            name: 'Granada',
            code: 'GRD',
            phoneCode: '+1473',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '9aed6edc-af06-44e4-990c-71969ee926d4',
            createdAt: '2021-11-23T18:10:06.244Z',
            updatedAt: '2021-11-23T18:10:06.244Z',
        },
        IRN: {
            name: 'Irán',
            code: 'IRN',
            phoneCode: '+98',
            currencyId: '2a513491-e5bb-4041-bfcd-6cb0239ff8bd',
            id: '60d57dd5-aee6-44d1-88c2-0e3cfb9dfa6a',
            createdAt: '2021-11-23T18:10:06.275Z',
            updatedAt: '2021-11-23T18:10:06.275Z',
        },
        KAZ: {
            name: 'Kazajistán',
            code: 'KAZ',
            phoneCode: '+7 7',
            currencyId: 'e6c1f631-53a7-4899-9ec1-fbcb66a93617',
            id: '75512aee-91f5-42d5-beef-59f371f7821d',
            createdAt: '2021-11-23T18:10:06.291Z',
            updatedAt: '2021-11-23T18:10:06.291Z',
        },
        LAO: {
            name: 'República Democrática Popular de Laos',
            code: 'LAO',
            phoneCode: '+856',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '1ea7e81b-8aa5-4e77-bc09-a045ceb7b267',
            createdAt: '2021-11-23T18:10:06.305Z',
            updatedAt: '2021-11-23T18:10:06.305Z',
        },
        FSM: {
            name: 'Estados Federados de Micronesia',
            code: 'FSM',
            phoneCode: '+691',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '8426fab0-f8fc-47f6-ad32-7042dfe1223d',
            createdAt: '2021-11-23T18:10:06.344Z',
            updatedAt: '2021-11-23T18:10:06.344Z',
        },
        NCL: {
            name: 'Nueva Caledonia',
            code: 'NCL',
            phoneCode: '+687',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '67784488-4985-42c6-af7e-46e21ab119ea',
            createdAt: '2021-11-23T18:10:06.369Z',
            updatedAt: '2021-11-23T18:10:06.369Z',
        },
        PCN: {
            name: 'Islas Pitcairn',
            code: 'PCN',
            phoneCode: '+64',
            currencyId: 'efbe73ee-afc6-43af-abd3-26d589f5b034',
            id: '9f92216a-37f3-45a0-9a97-b9a3e06dd395',
            createdAt: '2021-11-23T18:10:06.400Z',
            updatedAt: '2021-11-23T18:10:06.400Z',
        },
        KNA: {
            name: 'Saint Kitts y Nevis',
            code: 'KNA',
            phoneCode: '+1869',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '5a324077-aa0b-4799-a883-0063e5b094d5',
            createdAt: '2021-11-23T18:10:06.416Z',
            updatedAt: '2021-11-23T18:10:06.416Z',
        },
        SDN: {
            name: 'Sudán',
            code: 'SDN',
            phoneCode: '+249',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'a272613b-872a-4552-97dc-0c33be529e56',
            createdAt: '2021-11-23T18:10:06.448Z',
            updatedAt: '2021-11-23T18:10:06.448Z',
        },
        SJM: {
            name: 'Svalbard y Jan Mayen',
            code: 'SJM',
            phoneCode: '+47',
            currencyId: '2310830a-7726-4381-b259-6e3c2a13cac6',
            id: '1d1d1dde-11ef-49da-922c-d581d82096d1',
            createdAt: '2021-11-23T18:10:06.451Z',
            updatedAt: '2021-11-23T18:10:06.451Z',
        },
        UKR: {
            name: 'Ucrania',
            code: 'UKR',
            phoneCode: '+380',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '9339cdb4-1d00-4755-9333-156ab1a7540b',
            createdAt: '2021-11-23T18:10:06.490Z',
            updatedAt: '2021-11-23T18:10:06.490Z',
        },
        URY: {
            name: 'Uruguay',
            code: 'URY',
            phoneCode: '+598',
            currencyId: 'fa19d345-db1f-4e5e-ba45-cf8417dad58b',
            id: '00732b5b-b577-4b5c-b66b-30a25ac1e366',
            createdAt: '2021-11-23T18:10:06.499Z',
            updatedAt: '2021-11-23T18:10:06.499Z',
        },
        VGB: {
            name: 'Islas Vírgenes Británicas',
            code: 'VGB',
            phoneCode: '+1284',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '68dc9b91-a9fa-4fff-9ce7-29d75802872f',
            createdAt: '2021-11-23T18:10:06.510Z',
            updatedAt: '2021-11-23T18:10:06.510Z',
        },
        COG: {
            name: 'Congo',
            code: 'COG',
            phoneCode: '+242',
            currencyId: 'aced97b3-7bba-48b2-b5b1-5302e0b26b98',
            id: '028d986b-cf55-4b72-82da-5f4e2326a063',
            createdAt: '2021-11-23T18:10:06.179Z',
            updatedAt: '2021-11-23T18:10:06.179Z',
        },
        GNQ: {
            name: 'Guinea Ecuatorial',
            code: 'GNQ',
            phoneCode: '+240',
            currencyId: 'aced97b3-7bba-48b2-b5b1-5302e0b26b98',
            id: '090c7e9c-1b16-43b1-8c9d-3e4157589e0e',
            createdAt: '2021-11-23T18:10:06.208Z',
            updatedAt: '2021-11-23T18:10:06.208Z',
        },
        SWZ: {
            name: 'Suazilandia',
            code: 'SWZ',
            phoneCode: '+268',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '0c173b77-69ad-4f0d-a01d-fcc8d8081cb4',
            createdAt: '2021-11-23T18:10:06.453Z',
            updatedAt: '2021-11-23T18:10:06.453Z',
        },
        PYF: {
            name: 'Polinesia Francesa',
            code: 'PYF',
            phoneCode: '+689',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '132ba601-549f-44bd-9e81-3048252dad91',
            createdAt: '2021-11-23T18:10:06.226Z',
            updatedAt: '2021-11-23T18:10:06.226Z',
        },
        GHA: {
            name: 'Ghana',
            code: 'GHA',
            phoneCode: '+233',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '049edf43-a8c6-49cb-9c8f-da8fb5ad84df',
            createdAt: '2021-11-23T18:10:06.236Z',
            updatedAt: '2021-11-23T18:10:06.236Z',
        },
        GUM: {
            name: 'Guam',
            code: 'GUM',
            phoneCode: '+1671',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '05f9010f-4421-4f47-a3db-879de5e6a90e',
            createdAt: '2021-11-23T18:10:06.248Z',
            updatedAt: '2021-11-23T18:10:06.248Z',
        },
        GIN: {
            name: 'Guinea',
            code: 'GIN',
            phoneCode: '+224',
            currencyId: 'a634b776-45ee-4079-970a-9cfe2f19e5b6',
            id: '0517da4f-9bc6-4784-8de8-57d05c059245',
            createdAt: '2021-11-23T18:10:06.252Z',
            updatedAt: '2021-11-23T18:10:06.252Z',
        },
        LBR: {
            name: 'Liberia',
            code: 'LBR',
            phoneCode: '+231',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '1596fc35-17a0-46cb-8773-463a7b0ccc62',
            createdAt: '2021-11-23T18:10:06.313Z',
            updatedAt: '2021-11-23T18:10:06.313Z',
        },
        MYS: {
            name: 'Malasia',
            code: 'MYS',
            phoneCode: '+60',
            currencyId: '59a05c6e-58ed-4467-8ed4-03c7402af7a3',
            id: '08823c50-c24a-4b03-99ff-74f74791f7f7',
            createdAt: '2021-11-23T18:10:06.328Z',
            updatedAt: '2021-11-23T18:10:06.328Z',
        },
        MRT: {
            name: 'Mauritania',
            code: 'MRT',
            phoneCode: '+222',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '0da88a29-6828-41e8-855c-56f17e78e12a',
            createdAt: '2021-11-23T18:10:06.339Z',
            updatedAt: '2021-11-23T18:10:06.339Z',
        },
        MMR: {
            name: 'Myanmar',
            code: 'MMR',
            phoneCode: '+95',
            currencyId: '723b2aff-b17a-4cb1-8986-3256acc9be1f',
            id: '12aa09a9-476e-43b4-bb23-e7e0c1dc4727',
            createdAt: '2021-11-23T18:10:06.357Z',
            updatedAt: '2021-11-23T18:10:06.357Z',
        },
        SHN: {
            name: 'Santa Elena',
            code: 'SHN',
            phoneCode: '+290',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '0f078641-7236-4d89-8b7e-6a417b7385e1',
            createdAt: '2021-11-23T18:10:06.415Z',
            updatedAt: '2021-11-23T18:10:06.415Z',
        },
        LCA: {
            name: 'Santa Lucía',
            code: 'LCA',
            phoneCode: '+1758',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '113e154f-c66a-45a1-9311-b9b7bfd25c91',
            createdAt: '2021-11-23T18:10:06.418Z',
            updatedAt: '2021-11-23T18:10:06.418Z',
        },
        SLB: {
            name: 'Islas Salomón',
            code: 'SLB',
            phoneCode: '+677',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '16904cd7-99a6-403f-baaa-874e8230b7d8',
            createdAt: '2021-11-23T18:10:06.439Z',
            updatedAt: '2021-11-23T18:10:06.439Z',
        },
        GBR: {
            name: 'Reino Unido',
            code: 'GBR',
            phoneCode: '+44',
            currencyId: '51ce38bf-3798-4f79-81eb-004b6d96f96b',
            id: '03f93e79-c627-4a41-bff5-4c40d6f5109b',
            createdAt: '2021-11-23T18:10:06.494Z',
            updatedAt: '2021-11-23T18:10:06.494Z',
        },
        VIR: {
            name: 'Islas Vírgenes de los Estados Unidos',
            code: 'VIR',
            phoneCode: '+1340',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '029b3a31-37a0-4bcc-9ca5-479ede800193',
            createdAt: '2021-11-23T18:10:06.511Z',
            updatedAt: '2021-11-23T18:10:06.511Z',
        },
        BVT: {
            name: 'Isla Bouvet',
            code: 'BVT',
            phoneCode: null,
            currencyId: '2310830a-7726-4381-b259-6e3c2a13cac6',
            id: '436902f5-e4f2-438e-8158-ce44fb0fd99e',
            createdAt: '2021-11-23T18:10:06.139Z',
            updatedAt: '2021-11-23T18:10:06.139Z',
        },
        TMP: {
            name: 'Timor Oriental',
            code: 'TMP',
            phoneCode: null,
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '4dd142c7-0a4e-4389-a272-c10e14c0fa8a',
            createdAt: '2021-11-23T18:10:06.200Z',
            updatedAt: '2021-11-23T18:10:06.200Z',
        },
        UMI: {
            name: 'Islas Ultramarinas de los Estados Unidos',
            code: 'UMI',
            phoneCode: null,
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '4e4a9c89-e643-4bca-bd42-48e2c3e88704',
            createdAt: '2021-11-23T18:10:06.497Z',
            updatedAt: '2021-11-23T18:10:06.497Z',
        },
        BAT: {
            name: 'Ciudad del Vaticano (Santa Sede)',
            code: 'BAT',
            phoneCode: null,
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '51b70782-bfdf-488a-bd84-d1224c6786d6',
            createdAt: '2021-11-23T18:10:06.504Z',
            updatedAt: '2021-11-23T18:10:06.504Z',
        },
        AND: {
            name: 'Andorra',
            code: 'AND',
            phoneCode: '+376',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '2a5a3140-f293-4cb5-909e-053ed6223349',
            createdAt: '2021-11-23T18:10:06.090Z',
            updatedAt: '2021-11-23T18:10:06.090Z',
        },
        AGO: {
            name: 'Angola',
            code: 'AGO',
            phoneCode: '+244',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '275155c8-8e33-45db-9a1d-6b32faefd53f',
            createdAt: '2021-11-23T18:10:06.092Z',
            updatedAt: '2021-11-23T18:10:06.092Z',
        },
        ATA: {
            name: 'Antártida',
            code: 'ATA',
            phoneCode: '+672',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '4cd143f7-ea00-4c3a-a50d-2c9360d5f5c6',
            createdAt: '2021-11-23T18:10:06.096Z',
            updatedAt: '2021-11-23T18:10:06.096Z',
        },
        BHS: {
            name: 'Bahamas',
            code: 'BHS',
            phoneCode: '+1242',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '50fa3010-9be6-4299-94ba-a4ae1ff1d8d1',
            createdAt: '2021-11-23T18:10:06.112Z',
            updatedAt: '2021-11-23T18:10:06.112Z',
        },
        BGD: {
            name: 'Bangladesh',
            code: 'BGD',
            phoneCode: '+880',
            currencyId: 'c3a7a686-d17b-4774-a6e2-4077ace84923',
            id: '37b5f2b9-f71a-48be-96ad-05722418e902',
            createdAt: '2021-11-23T18:10:06.116Z',
            updatedAt: '2021-11-23T18:10:06.116Z',
        },
        BRB: {
            name: 'Barbados',
            code: 'BRB',
            phoneCode: '+1246',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '19049d0f-046f-4d6b-8fff-3c8f24246b9b',
            createdAt: '2021-11-23T18:10:06.118Z',
            updatedAt: '2021-11-23T18:10:06.118Z',
        },
        BMU: {
            name: 'Bermuda',
            code: 'BMU',
            phoneCode: '+1441',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '3f3f05eb-02f4-49a0-92df-23b354b8ecea',
            createdAt: '2021-11-23T18:10:06.127Z',
            updatedAt: '2021-11-23T18:10:06.127Z',
        },
        BTN: {
            name: 'Bhután',
            code: 'BTN',
            phoneCode: '+975',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '6e14b69a-7eb5-4580-a071-2478317fc377',
            createdAt: '2021-11-23T18:10:06.129Z',
            updatedAt: '2021-11-23T18:10:06.129Z',
        },
        BWA: {
            name: 'Botsuana',
            code: 'BWA',
            phoneCode: '+267',
            currencyId: '5eb6b9b6-2207-4f5e-9019-a61f5653d9a9',
            id: '2a35fac9-4507-4248-a402-65135acf1c05',
            createdAt: '2021-11-23T18:10:06.134Z',
            updatedAt: '2021-11-23T18:10:06.134Z',
        },
        KHM: {
            name: 'Camboya',
            code: 'KHM',
            phoneCode: '+855',
            currencyId: '8e9e5808-d509-44eb-9505-ecae43a8cc53',
            id: '3d3fe7e3-a0f3-4635-bbde-14fe8275aea0',
            createdAt: '2021-11-23T18:10:06.152Z',
            updatedAt: '2021-11-23T18:10:06.152Z',
        },
        TCD: {
            name: 'Chad',
            code: 'TCD',
            phoneCode: '+235',
            currencyId: 'aced97b3-7bba-48b2-b5b1-5302e0b26b98',
            id: '627ff4de-88fd-4277-97e5-519eb1443878',
            createdAt: '2021-11-23T18:10:06.166Z',
            updatedAt: '2021-11-23T18:10:06.166Z',
        },
        CHL: {
            name: 'Chile',
            code: 'CHL',
            phoneCode: '+56',
            currencyId: '2b7ff2f4-1749-4af0-a114-73d72f8efc2c',
            id: '6236cb66-d191-4f35-a212-64e7875c93e4',
            createdAt: '2021-11-23T18:10:06.168Z',
            updatedAt: '2021-11-23T18:10:06.168Z',
        },
        CUB: {
            name: 'Cuba',
            code: 'CUB',
            phoneCode: '+53',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '6577b27d-b93b-4c69-92f6-ea06ca29cfe3',
            createdAt: '2021-11-23T18:10:06.188Z',
            updatedAt: '2021-11-23T18:10:06.188Z',
        },
        CYP: {
            name: 'Chipre',
            code: 'CYP',
            phoneCode: '+357',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '1e111004-1279-4240-9029-782f15ad17bf',
            createdAt: '2021-11-23T18:10:06.190Z',
            updatedAt: '2021-11-23T18:10:06.190Z',
        },
        DNK: {
            name: 'Dinamarca',
            code: 'DNK',
            phoneCode: '+45',
            currencyId: 'd913f404-bd9b-4b1d-8bd4-a891aa646845',
            id: '666b019e-f243-47ee-8b55-66260a8a1d1b',
            createdAt: '2021-11-23T18:10:06.193Z',
            updatedAt: '2021-11-23T18:10:06.193Z',
        },
        DMA: {
            name: 'Dominica',
            code: 'DMA',
            phoneCode: '+1767',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '4efab13a-bcaf-428e-b527-17930bac359a',
            createdAt: '2021-11-23T18:10:06.197Z',
            updatedAt: '2021-11-23T18:10:06.197Z',
        },
        DOM: {
            name: 'República Dominicana',
            code: 'DOM',
            phoneCode: '+1849',
            currencyId: 'c195ae76-3bd0-413f-9783-64a6b4bff910',
            id: '3068bdf7-641b-40cd-ae1d-88efa4a967fc',
            createdAt: '2021-11-23T18:10:06.198Z',
            updatedAt: '2021-11-23T18:10:06.198Z',
        },
        EGY: {
            name: 'Egipto',
            code: 'EGY',
            phoneCode: '+20',
            currencyId: 'aca866f8-6408-4920-a7ca-13ba1bccae16',
            id: '325f7128-974e-40b8-bbc0-401be5a3ebe5',
            createdAt: '2021-11-23T18:10:06.205Z',
            updatedAt: '2021-11-23T18:10:06.205Z',
        },
        ERI: {
            name: 'Eritrea',
            code: 'ERI',
            phoneCode: '+291',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '38ea6990-03cd-4b80-8ac1-9c355353603b',
            createdAt: '2021-11-23T18:10:06.210Z',
            updatedAt: '2021-11-23T18:10:06.210Z',
        },
        GAB: {
            name: 'Gabón',
            code: 'GAB',
            phoneCode: '+241',
            currencyId: 'aced97b3-7bba-48b2-b5b1-5302e0b26b98',
            id: '34602294-fa74-4a35-8de4-31e01edb541f',
            createdAt: '2021-11-23T18:10:06.230Z',
            updatedAt: '2021-11-23T18:10:06.230Z',
        },
        DEU: {
            name: 'Alemania',
            code: 'DEU',
            phoneCode: '+49',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '6a32372a-59c9-4518-8e0d-49b592d7d576',
            createdAt: '2021-11-23T18:10:06.234Z',
            updatedAt: '2021-11-23T18:10:06.234Z',
        },
        GRL: {
            name: 'Groenlandia',
            code: 'GRL',
            phoneCode: '+299',
            currencyId: 'd913f404-bd9b-4b1d-8bd4-a891aa646845',
            id: '176e409a-84a8-4e9b-8ff8-f841770e2f74',
            createdAt: '2021-11-23T18:10:06.242Z',
            updatedAt: '2021-11-23T18:10:06.242Z',
        },
        GTM: {
            name: 'Guatemala',
            code: 'GTM',
            phoneCode: '+502',
            currencyId: 'e0ca51c1-3681-49f6-a41a-f379ab682d87',
            id: '293fdb79-6444-4cee-96db-8a5f3cadb382',
            createdAt: '2021-11-23T18:10:06.250Z',
            updatedAt: '2021-11-23T18:10:06.250Z',
        },
        GUY: {
            name: 'Guyana',
            code: 'GUY',
            phoneCode: '+592',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '5b60ed99-13be-4be9-952a-935002d8004a',
            createdAt: '2021-11-23T18:10:06.256Z',
            updatedAt: '2021-11-23T18:10:06.256Z',
        },
        HTI: {
            name: 'Haití',
            code: 'HTI',
            phoneCode: '+509',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '448beb55-739e-44a1-8b8e-80de385f628c',
            createdAt: '2021-11-23T18:10:06.258Z',
            updatedAt: '2021-11-23T18:10:06.258Z',
        },
        HND: {
            name: 'Honduras',
            code: 'HND',
            phoneCode: '+504',
            currencyId: '8074d69f-9932-4211-bb1c-2e57f572fab2',
            id: '4f91d419-43fa-40c5-ba26-54fc6e334d85',
            createdAt: '2021-11-23T18:10:06.263Z',
            updatedAt: '2021-11-23T18:10:06.263Z',
        },
        HKG: {
            name: 'Hong Kong',
            code: 'HKG',
            phoneCode: '+852',
            currencyId: 'cd15d696-b068-4813-aa02-2c3a4da8cc7a',
            id: '2e527e44-3457-4ce3-8bf4-d693c112e2f2',
            createdAt: '2021-11-23T18:10:06.265Z',
            updatedAt: '2021-11-23T18:10:06.265Z',
        },
        IND: {
            name: 'India',
            code: 'IND',
            phoneCode: '+91',
            currencyId: 'bf23bce7-99a1-4c2e-a527-f97385f17252',
            id: '58f57ff3-3afd-4063-8a3f-15497f79c044',
            createdAt: '2021-11-23T18:10:06.271Z',
            updatedAt: '2021-11-23T18:10:06.271Z',
        },
        IRQ: {
            name: 'Iraq',
            code: 'IRQ',
            phoneCode: '+964',
            currencyId: 'fd7be2ae-9e10-441a-a464-570fb1004bc2',
            id: '46a42b3f-830c-44e5-a247-cad759380a99',
            createdAt: '2021-11-23T18:10:06.277Z',
            updatedAt: '2021-11-23T18:10:06.277Z',
        },
        ISR: {
            name: 'Israel',
            code: 'ISR',
            phoneCode: '+972',
            currencyId: 'a5399d45-645e-4ec6-a1d7-9ad81c503047',
            id: '27b0811a-c752-4f4d-9a06-5ffe3992187b',
            createdAt: '2021-11-23T18:10:06.281Z',
            updatedAt: '2021-11-23T18:10:06.281Z',
        },
        JOR: {
            name: 'Jordania',
            code: 'JOR',
            phoneCode: '+962',
            currencyId: '8ac9dbfe-00a7-4855-aa64-8c497fcce3f8',
            id: '37057e45-61f6-4536-b3d9-18af1b09215f',
            createdAt: '2021-11-23T18:10:06.289Z',
            updatedAt: '2021-11-23T18:10:06.289Z',
        },
        KEN: {
            name: 'Kenia',
            code: 'KEN',
            phoneCode: '+254',
            currencyId: 'f4ecb773-a926-4cb0-bbe3-b4ef52b02a34',
            id: '65ce057a-3972-48cf-8577-4c340cc5acd2',
            createdAt: '2021-11-23T18:10:06.293Z',
            updatedAt: '2021-11-23T18:10:06.293Z',
        },
        KWT: {
            name: 'Kuwait',
            code: 'KWT',
            phoneCode: '+965',
            currencyId: 'caf6ed13-bf60-4ce2-96cb-7b3e4a99a1c1',
            id: '6228744a-3a36-477c-805c-dbbe579fdebe',
            createdAt: '2021-11-23T18:10:06.301Z',
            updatedAt: '2021-11-23T18:10:06.301Z',
        },
        KGZ: {
            name: 'Kirguistán',
            code: 'KGZ',
            phoneCode: '+996',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '5118da0d-d7f2-41b1-b7e4-44bb43ed9eca',
            createdAt: '2021-11-23T18:10:06.303Z',
            updatedAt: '2021-11-23T18:10:06.303Z',
        },
        LBN: {
            name: 'Líbano',
            code: 'LBN',
            phoneCode: '+961',
            currencyId: '7fe1f3d2-7aae-4a1f-a5fd-f68726f7430a',
            id: '435a5a3d-21dc-4c17-9ec9-c1cbcf2b0e97',
            createdAt: '2021-11-23T18:10:06.308Z',
            updatedAt: '2021-11-23T18:10:06.308Z',
        },
        LSO: {
            name: 'Lesoto',
            code: 'LSO',
            phoneCode: '+266',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '4b4d13ed-d05a-43de-a750-8c4b6743ebba',
            createdAt: '2021-11-23T18:10:06.310Z',
            updatedAt: '2021-11-23T18:10:06.310Z',
        },
        LIE: {
            name: 'Liechtenstein',
            code: 'LIE',
            phoneCode: '+423',
            currencyId: 'ee5db97d-61e2-497b-8499-9454c36d27f6',
            id: '23b6bd6c-8d84-4983-a787-3622e5b87044',
            createdAt: '2021-11-23T18:10:06.316Z',
            updatedAt: '2021-11-23T18:10:06.316Z',
        },
        LTU: {
            name: 'Lituania',
            code: 'LTU',
            phoneCode: '+370',
            currencyId: '78c55378-517d-4886-ab82-ddcc15f66290',
            id: '4ab5fd1b-f57e-4846-be58-4662ea1558b8',
            createdAt: '2021-11-23T18:10:06.318Z',
            updatedAt: '2021-11-23T18:10:06.318Z',
        },
        MDG: {
            name: 'Madagascar',
            code: 'MDG',
            phoneCode: '+261',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '21f46c70-c688-4b1b-9202-63066115d51b',
            createdAt: '2021-11-23T18:10:06.325Z',
            updatedAt: '2021-11-23T18:10:06.325Z',
        },
        MDV: {
            name: 'Maldivas',
            code: 'MDV',
            phoneCode: '+960',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '2bdae861-269a-4c56-b5dc-791616339fd1',
            createdAt: '2021-11-23T18:10:06.330Z',
            updatedAt: '2021-11-23T18:10:06.330Z',
        },
        MEX: {
            name: 'México',
            code: 'MEX',
            phoneCode: '+52',
            currencyId: '9eff788e-0f0a-4835-8fcf-70231effc739',
            id: '40edcc40-916d-4c61-a27d-4579a8273a4a',
            createdAt: '2021-11-23T18:10:06.342Z',
            updatedAt: '2021-11-23T18:10:06.342Z',
        },
        MDA: {
            name: 'Moldavia',
            code: 'MDA',
            phoneCode: '+373',
            currencyId: 'f252be72-ff03-44ff-bd68-46e739d1e8e7',
            id: '50e63359-ac4d-4272-8c72-a6b0388e0413',
            createdAt: '2021-11-23T18:10:06.346Z',
            updatedAt: '2021-11-23T18:10:06.346Z',
        },
        MCO: {
            name: 'Mónaco',
            code: 'MCO',
            phoneCode: '+377',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '5e13c0c2-1580-4d8a-85d8-f2f3e7e5b2f8',
            createdAt: '2021-11-23T18:10:06.348Z',
            updatedAt: '2021-11-23T18:10:06.348Z',
        },
        MSR: {
            name: 'Montserrat',
            code: 'MSR',
            phoneCode: '+1664',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '205549cb-35b8-4539-9dcf-e6ce15cfb180',
            createdAt: '2021-11-23T18:10:06.352Z',
            updatedAt: '2021-11-23T18:10:06.352Z',
        },
        NPL: {
            name: 'Nepal',
            code: 'NPL',
            phoneCode: '+977',
            currencyId: '51789fdd-2405-444f-990d-a46b38063616',
            id: '678c5c57-93d8-4b13-9480-7de793ae3c86',
            createdAt: '2021-11-23T18:10:06.362Z',
            updatedAt: '2021-11-23T18:10:06.362Z',
        },
        NIC: {
            name: 'Nicaragua',
            code: 'NIC',
            phoneCode: '+505',
            currencyId: 'd41de494-4deb-4a15-bc99-2bba0ac01974',
            id: '5ba21864-e16b-498a-aebc-4965f007b65f',
            createdAt: '2021-11-23T18:10:06.373Z',
            updatedAt: '2021-11-23T18:10:06.373Z',
        },
        NGA: {
            name: 'Nigeria',
            code: 'NGA',
            phoneCode: '+234',
            currencyId: '337a16d5-779d-4e7f-997f-769770f37675',
            id: '4a523081-41ad-41f5-be47-ed2ba59bd297',
            createdAt: '2021-11-23T18:10:06.376Z',
            updatedAt: '2021-11-23T18:10:06.376Z',
        },
        NFK: {
            name: 'Islas Norfolk',
            code: 'NFK',
            phoneCode: '+672',
            currencyId: 'f2246a5f-2bc3-465c-a888-efb4be277672',
            id: '499708ec-f6cc-499a-883e-558ec7d0b179',
            createdAt: '2021-11-23T18:10:06.379Z',
            updatedAt: '2021-11-23T18:10:06.379Z',
        },
        MNP: {
            name: 'Islas Marianas del Norte',
            code: 'MNP',
            phoneCode: '+1670',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '588080a0-b06c-401f-b693-3f02d360937f',
            createdAt: '2021-11-23T18:10:06.381Z',
            updatedAt: '2021-11-23T18:10:06.381Z',
        },
        PRY: {
            name: 'Paraguay',
            code: 'PRY',
            phoneCode: '+595',
            currencyId: '484672c1-7e84-4443-8288-05c886a788ac',
            id: '2b297b8c-734e-4e0f-afe6-c9d2270c10e4',
            createdAt: '2021-11-23T18:10:06.394Z',
            updatedAt: '2021-11-23T18:10:06.394Z',
        },
        PRT: {
            name: 'Portugal',
            code: 'PRT',
            phoneCode: '+351',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '4bc8d87b-4917-43e7-b4c3-68b12182b842',
            createdAt: '2021-11-23T18:10:06.403Z',
            updatedAt: '2021-11-23T18:10:06.403Z',
        },
        PRI: {
            name: 'Puerto Rico',
            code: 'PRI',
            phoneCode: '+1939',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '47d8fcac-d3db-409f-99e8-3d186c003717',
            createdAt: '2021-11-23T18:10:06.405Z',
            updatedAt: '2021-11-23T18:10:06.405Z',
        },
        RWA: {
            name: 'Ruanda',
            code: 'RWA',
            phoneCode: '+250',
            currencyId: 'fb7067b5-dc89-456f-8383-679a45c90300',
            id: '6bac12e4-ce55-4720-9b4d-d12c6bfcda6b',
            createdAt: '2021-11-23T18:10:06.413Z',
            updatedAt: '2021-11-23T18:10:06.413Z',
        },
        WSM: {
            name: 'Samoa',
            code: 'WSM',
            phoneCode: '+685',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '2acd11f5-4337-45eb-8d10-037b7d85145f',
            createdAt: '2021-11-23T18:10:06.423Z',
            updatedAt: '2021-11-23T18:10:06.423Z',
        },
        SAU: {
            name: 'Arabia Saudita',
            code: 'SAU',
            phoneCode: '+966',
            currencyId: 'e53afe9a-4de7-47f6-9577-1b20b70b2028',
            id: '4bb61f39-b80f-4ecc-a83c-d742801690a4',
            createdAt: '2021-11-23T18:10:06.427Z',
            updatedAt: '2021-11-23T18:10:06.427Z',
        },
        SEN: {
            name: 'Senegal',
            code: 'SEN',
            phoneCode: '+221',
            currencyId: '1c52955b-240f-477e-8658-d1bf0a6c7814',
            id: '2d66ec61-8911-4cd6-8494-737840d3250e',
            createdAt: '2021-11-23T18:10:06.429Z',
            updatedAt: '2021-11-23T18:10:06.429Z',
        },
        SGP: {
            name: 'Singapur',
            code: 'SGP',
            phoneCode: '+65',
            currencyId: '24dcc422-f58f-4ada-aa86-dc1bc84a63a3',
            id: '6428600d-48dd-4816-bf30-8cd0289db0f8',
            createdAt: '2021-11-23T18:10:06.433Z',
            updatedAt: '2021-11-23T18:10:06.433Z',
        },
        KOR: {
            name: 'Corea del Sur',
            code: 'KOR',
            phoneCode: '+82',
            currencyId: '7cf47ea9-f455-435a-896f-4a0156680c1f',
            id: '5ef2eac0-089b-4a79-96f2-1be8f2f212c8',
            createdAt: '2021-11-23T18:10:06.299Z',
            updatedAt: '2021-11-23T18:10:06.299Z',
        },
        ESP: {
            name: 'España',
            code: 'ESP',
            phoneCode: '+34',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '555ce75c-e70d-4fe2-8b73-4965756bbea0',
            createdAt: '2021-11-23T18:10:06.444Z',
            updatedAt: '2021-11-23T18:10:06.444Z',
        },
        SUR: {
            name: 'Surinam',
            code: 'SUR',
            phoneCode: '+597',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '4f788d6a-beeb-4860-8193-d22c0ba0ace5',
            createdAt: '2021-11-23T18:10:06.449Z',
            updatedAt: '2021-11-23T18:10:06.449Z',
        },
        SWE: {
            name: 'Suecia',
            code: 'SWE',
            phoneCode: '+46',
            currencyId: 'e23f6bc8-1536-446e-9b65-56bd4611de19',
            id: '1fd19a23-9725-489c-aafb-884f36141868',
            createdAt: '2021-11-23T18:10:06.458Z',
            updatedAt: '2021-11-23T18:10:06.458Z',
        },
        SYR: {
            name: 'Siria',
            code: 'SYR',
            phoneCode: '+963',
            currencyId: 'a9a99637-d52b-40d2-a1a3-10d3fe8d0763',
            id: '3b9fc0ef-33a4-4268-8348-f4208f13291d',
            createdAt: '2021-11-23T18:10:06.461Z',
            updatedAt: '2021-11-23T18:10:06.461Z',
        },
        TWN: {
            name: 'Taiwán',
            code: 'TWN',
            phoneCode: '+886',
            currencyId: '32a07c2c-f387-48f8-a8ee-7033f33cbd90',
            id: '27b366d2-58b2-46bb-bbb9-b9916f14404a',
            createdAt: '2021-11-23T18:10:06.463Z',
            updatedAt: '2021-11-23T18:10:06.463Z',
        },
        THA: {
            name: 'Tailandia',
            code: 'THA',
            phoneCode: '+66',
            currencyId: '032f7ded-6191-4d2e-9329-06d07131f463',
            id: '539ede25-4b47-4348-b23e-6cc66c5bc6bb',
            createdAt: '2021-11-23T18:10:06.469Z',
            updatedAt: '2021-11-23T18:10:06.469Z',
        },
        TKL: {
            name: 'Tokelau',
            code: 'TKL',
            phoneCode: '+690',
            currencyId: 'efbe73ee-afc6-43af-abd3-26d589f5b034',
            id: '35903d8d-5fe0-4898-924c-fa24f1d8026d',
            createdAt: '2021-11-23T18:10:06.473Z',
            updatedAt: '2021-11-23T18:10:06.473Z',
        },
        TON: {
            name: 'Tonga',
            code: 'TON',
            phoneCode: '+676',
            currencyId: '90344809-84be-4688-8c1e-6ab29a674235',
            id: '20fe4441-7cdd-4448-a909-d348e7bf65fc',
            createdAt: '2021-11-23T18:10:06.475Z',
            updatedAt: '2021-11-23T18:10:06.475Z',
        },
        TTO: {
            name: 'Trinidad y Tobago',
            code: 'TTO',
            phoneCode: '+1868',
            currencyId: '5d89214d-7193-4056-9db8-fbdfaba77f0e',
            id: '33f00b73-897a-4040-9dd5-11c0f0335d92',
            createdAt: '2021-11-23T18:10:06.477Z',
            updatedAt: '2021-11-23T18:10:06.477Z',
        },
        TCA: {
            name: 'Islas Turcas y Caicos',
            code: 'TCA',
            phoneCode: '+1649',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '6cd63b79-166f-448e-8034-116ad8c595f5',
            createdAt: '2021-11-23T18:10:06.484Z',
            updatedAt: '2021-11-23T18:10:06.484Z',
        },
        VEN: {
            name: 'Venezuela',
            code: 'VEN',
            phoneCode: '+58',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '46d55dbf-639e-4904-952f-e31689d3cbb0',
            createdAt: '2021-11-23T18:10:06.506Z',
            updatedAt: '2021-11-23T18:10:06.506Z',
        },
        VNM: {
            name: 'Vietnam',
            code: 'VNM',
            phoneCode: '+84',
            currencyId: '60a7a830-72b1-4fd6-a92a-c13459f7255e',
            id: '557a0edb-1359-4b8a-ac04-4041fdfa8c84',
            createdAt: '2021-11-23T18:10:06.508Z',
            updatedAt: '2021-11-23T18:10:06.508Z',
        },
        YEM: {
            name: 'Yemen',
            code: 'YEM',
            phoneCode: '+967',
            currencyId: 'e335257b-9b4c-4951-a7b3-18d827c60e3c',
            id: '3b88fdda-90a6-48fe-98d7-625e7acbbd4f',
            createdAt: '2021-11-23T18:10:06.517Z',
            updatedAt: '2021-11-23T18:10:06.517Z',
        },
        ANT: {
            name: 'Antigua y Barbuda',
            code: 'ANT',
            phoneCode: null,
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '7b116b55-72b8-4fc6-89c2-888ec181271e',
            createdAt: '2021-11-23T18:10:06.367Z',
            updatedAt: '2021-11-23T18:10:06.367Z',
        },
        '-': {
            name: undefined,
            code: '-',
            phoneCode: null,
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'da8727b0-c313-488f-bb02-6ee3742e434a',
            createdAt: '2021-11-23T18:10:06.527Z',
            updatedAt: '2021-11-23T18:10:06.527Z',
        },
        ZAR: {
            name: 'Sudafrica',
            code: 'ZAR',
            phoneCode: null,
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'a1a06bc1-e5cc-4c8e-a076-555db1dd464b',
            createdAt: '2021-11-23T18:10:06.521Z',
            updatedAt: '2021-11-23T18:10:06.521Z',
        },
        ROM: {
            name: 'Romania',
            code: 'ROM',
            phoneCode: null,
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'af74b34f-d0fd-4844-85c2-58c0a695e65d',
            createdAt: '2021-11-23T18:10:06.410Z',
            updatedAt: '2021-11-23T18:10:06.410Z',
        },
        ASM: {
            name: 'Islas Midway',
            code: 'ASM',
            phoneCode: '+1684',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'c30d5e48-174f-4c92-8b42-c2edce7df325',
            createdAt: '2021-11-23T18:10:06.087Z',
            updatedAt: '2021-11-23T18:10:06.087Z',
        },
        AIA: {
            name: 'Anguila',
            code: 'AIA',
            phoneCode: '+1264',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '7408ff3f-05c2-45ef-b6eb-85a3496d732f',
            createdAt: '2021-11-23T18:10:06.094Z',
            updatedAt: '2021-11-23T18:10:06.094Z',
        },
        ARM: {
            name: 'Armenia',
            code: 'ARM',
            phoneCode: '+374',
            currencyId: 'c4168f8d-bfad-4afb-a81c-10bbc9691ea7',
            id: '7e1bddc9-6d47-476b-a07a-c949bf4dfd2c',
            createdAt: '2021-11-23T18:10:06.103Z',
            updatedAt: '2021-11-23T18:10:06.103Z',
        },
        ABW: {
            name: 'Aruba',
            code: 'ABW',
            phoneCode: '+297',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '7ac4e682-467b-41bc-8462-b75724e52554',
            createdAt: '2021-11-23T18:10:06.105Z',
            updatedAt: '2021-11-23T18:10:06.105Z',
        },
        AZE: {
            name: 'Azerbaiyán',
            code: 'AZE',
            phoneCode: '+994',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'c134fbb4-fbb2-4786-95ca-42b73f8cc1f9',
            createdAt: '2021-11-23T18:10:06.110Z',
            updatedAt: '2021-11-23T18:10:06.110Z',
        },
        BHR: {
            name: 'Bahréin',
            code: 'BHR',
            phoneCode: '+973',
            currencyId: '8e185ce3-1f3c-4cb1-8b54-3f724ba01ae3',
            id: '909b2940-57cf-4df1-93d2-563506b41abb',
            createdAt: '2021-11-23T18:10:06.114Z',
            updatedAt: '2021-11-23T18:10:06.114Z',
        },
        BLZ: {
            name: 'Belice',
            code: 'BLZ',
            phoneCode: '+501',
            currencyId: 'e4fac30a-170d-4183-9525-26f882c956dd',
            id: '7ed9d67f-67ae-438e-a9c8-fe5a172236b9',
            createdAt: '2021-11-23T18:10:06.123Z',
            updatedAt: '2021-11-23T18:10:06.123Z',
        },
        BEN: {
            name: 'Benín',
            code: 'BEN',
            phoneCode: '+229',
            currencyId: '1c52955b-240f-477e-8658-d1bf0a6c7814',
            id: '7f09af38-d063-4254-8bd9-3748ae913594',
            createdAt: '2021-11-23T18:10:06.125Z',
            updatedAt: '2021-11-23T18:10:06.125Z',
        },
        BOL: {
            name: 'Bolivia',
            code: 'BOL',
            phoneCode: '+591',
            currencyId: '98724213-e274-482a-94ae-63fa5700bd90',
            id: '97ae1868-40e0-43f9-b7fb-8762006a853b',
            createdAt: '2021-11-23T18:10:06.130Z',
            updatedAt: '2021-11-23T18:10:06.130Z',
        },
        BIH: {
            name: 'Bosnia y Herzegovina',
            code: 'BIH',
            phoneCode: '+387',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '7ad4e184-7a3a-4fc6-b71a-ef0fff9ea218',
            createdAt: '2021-11-23T18:10:06.132Z',
            updatedAt: '2021-11-23T18:10:06.132Z',
        },
        BRA: {
            name: 'Brasil',
            code: 'BRA',
            phoneCode: '+55',
            currencyId: '16eace79-4f34-4964-a251-c47f6fb27c49',
            id: 'c47be127-bd36-40b8-acb2-1403c7e3997c',
            createdAt: '2021-11-23T18:10:06.141Z',
            updatedAt: '2021-11-23T18:10:06.141Z',
        },
        CAN: {
            name: 'Canadá',
            code: 'CAN',
            phoneCode: '+1',
            currencyId: '53f0c739-cc9f-427e-8916-7b32b66aea7b',
            id: 'c2abce57-2e18-492a-961e-0e28cc9e0670',
            createdAt: '2021-11-23T18:10:06.155Z',
            updatedAt: '2021-11-23T18:10:06.155Z',
        },
        CPV: {
            name: 'Cabo Verde',
            code: 'CPV',
            phoneCode: '+238',
            currencyId: '9c78d3f9-0b5e-439f-b134-4d0adfa151d0',
            id: 'cac375c8-e09b-411f-857d-822d2d238eef',
            createdAt: '2021-11-23T18:10:06.157Z',
            updatedAt: '2021-11-23T18:10:06.157Z',
        },
        CAF: {
            name: 'República Centroafricana',
            code: 'CAF',
            phoneCode: '+236',
            currencyId: 'aced97b3-7bba-48b2-b5b1-5302e0b26b98',
            id: 'a980f518-3ce4-4424-892b-ade397c9fc3b',
            createdAt: '2021-11-23T18:10:06.164Z',
            updatedAt: '2021-11-23T18:10:06.164Z',
        },
        CXR: {
            name: 'Isla Christmas',
            code: 'CXR',
            phoneCode: '+61',
            currencyId: 'f2246a5f-2bc3-465c-a888-efb4be277672',
            id: '89c1411e-db4e-4116-aae9-fe049bee5370',
            createdAt: '2021-11-23T18:10:06.172Z',
            updatedAt: '2021-11-23T18:10:06.172Z',
        },
        CCK: {
            name: 'Islas Cocos',
            code: 'CCK',
            phoneCode: '+61',
            currencyId: 'f2246a5f-2bc3-465c-a888-efb4be277672',
            id: '9aef09b6-a0f4-4d06-977b-f8e70ff035c8',
            createdAt: '2021-11-23T18:10:06.174Z',
            updatedAt: '2021-11-23T18:10:06.174Z',
        },
        COL: {
            name: 'Colombia',
            code: 'COL',
            phoneCode: '+57',
            currencyId: '8f9313f3-5522-44e0-8ebe-562863585535',
            id: 'afd9cf22-4267-4f04-bc9e-2ca718cb2403',
            createdAt: '2021-11-23T18:10:06.176Z',
            updatedAt: '2021-11-23T18:10:06.176Z',
        },
        CRI: {
            name: 'Costa Rica',
            code: 'CRI',
            phoneCode: '+506',
            currencyId: '24cf1c52-01e5-4b37-87ed-15b35fa4f3ab',
            id: 'be8d685f-0d70-4da8-9bc8-576ad3831fa1',
            createdAt: '2021-11-23T18:10:06.183Z',
            updatedAt: '2021-11-23T18:10:06.183Z',
        },
        HRV: {
            name: 'Croacia',
            code: 'HRV',
            phoneCode: '+385',
            currencyId: 'e14c122f-55df-43d8-8b4e-9de8a3401ef4',
            id: '6fdb14ce-2059-4022-88c6-0d7669297357',
            createdAt: '2021-11-23T18:10:06.186Z',
            updatedAt: '2021-11-23T18:10:06.186Z',
        },
        ECU: {
            name: 'Ecuador',
            code: 'ECU',
            phoneCode: '+593',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '71310c22-01e1-4e19-af5f-97610c523b82',
            createdAt: '2021-11-23T18:10:06.203Z',
            updatedAt: '2021-11-23T18:10:06.203Z',
        },
        SLV: {
            name: 'El Salvador',
            code: 'SLV',
            phoneCode: '+503',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '8fea1878-64e1-40d0-9c54-4012020e5e2a',
            createdAt: '2021-11-23T18:10:06.206Z',
            updatedAt: '2021-11-23T18:10:06.206Z',
        },
        FLK: {
            name: 'Islas Malvinas',
            code: 'FLK',
            phoneCode: '+500',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'b6dfbc03-382a-4aab-b2e0-93d3dafc49ad',
            createdAt: '2021-11-23T18:10:06.216Z',
            updatedAt: '2021-11-23T18:10:06.216Z',
        },
        FRO: {
            name: 'Islas Feroe',
            code: 'FRO',
            phoneCode: '+298',
            currencyId: 'd913f404-bd9b-4b1d-8bd4-a891aa646845',
            id: 'a2a72769-c168-4500-b7af-75953d019c6b',
            createdAt: '2021-11-23T18:10:06.218Z',
            updatedAt: '2021-11-23T18:10:06.218Z',
        },
        FJI: {
            name: 'Fiyi',
            code: 'FJI',
            phoneCode: '+679',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'b153c0c6-e3a8-40f6-a604-842b208bf90a',
            createdAt: '2021-11-23T18:10:06.219Z',
            updatedAt: '2021-11-23T18:10:06.219Z',
        },
        FIN: {
            name: 'Finlandia',
            code: 'FIN',
            phoneCode: '+358',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '7a6faddb-e070-43f3-ad2b-ffd91c06256d',
            createdAt: '2021-11-23T18:10:06.221Z',
            updatedAt: '2021-11-23T18:10:06.221Z',
        },
        GEO: {
            name: 'Georgia',
            code: 'GEO',
            phoneCode: '+995',
            currencyId: 'a56f2792-6699-4b35-960d-695d96c9de64',
            id: 'ac2bd754-0c11-424a-89ed-b8546d0711cd',
            createdAt: '2021-11-23T18:10:06.233Z',
            updatedAt: '2021-11-23T18:10:06.233Z',
        },
        GIB: {
            name: 'Gibraltar',
            code: 'GIB',
            phoneCode: '+350',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'bc175960-3973-4f28-85e9-ec8a5c55da19',
            createdAt: '2021-11-23T18:10:06.238Z',
            updatedAt: '2021-11-23T18:10:06.238Z',
        },
        HMD: {
            name: 'Islas Heard y McDonald',
            code: 'HMD',
            phoneCode: '+672',
            currencyId: 'f2246a5f-2bc3-465c-a888-efb4be277672',
            id: '9226d1e5-7f43-45c0-af38-5ee31e528fdd',
            createdAt: '2021-11-23T18:10:06.260Z',
            updatedAt: '2021-11-23T18:10:06.260Z',
        },
        HUN: {
            name: 'Hungría',
            code: 'HUN',
            phoneCode: '+36',
            currencyId: 'ac71ce40-a47c-4057-a1ce-cd1bd2a84bbb',
            id: 'a57051f7-ee31-4fc8-beee-b986eafe69a6',
            createdAt: '2021-11-23T18:10:06.266Z',
            updatedAt: '2021-11-23T18:10:06.266Z',
        },
        ISL: {
            name: 'Islandia',
            code: 'ISL',
            phoneCode: '+354',
            currencyId: 'ed697a29-8479-4244-add6-ee04e9abbf94',
            id: 'c2d0fe7f-19c7-4b01-9bb4-63fa67992d46',
            createdAt: '2021-11-23T18:10:06.269Z',
            updatedAt: '2021-11-23T18:10:06.269Z',
        },
        IDN: {
            name: 'Indonesia',
            code: 'IDN',
            phoneCode: '+62',
            currencyId: 'bd9f890e-a37b-46fe-80a3-29b8f78ce44c',
            id: '8a02f9fb-b23f-4bb2-9bd0-4477104e1057',
            createdAt: '2021-11-23T18:10:06.273Z',
            updatedAt: '2021-11-23T18:10:06.273Z',
        },
        IRL: {
            name: 'Irlanda',
            code: 'IRL',
            phoneCode: '+353',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'c69d9ef3-7419-42f0-b329-3a77a37dff4a',
            createdAt: '2021-11-23T18:10:06.279Z',
            updatedAt: '2021-11-23T18:10:06.279Z',
        },
        ITA: {
            name: 'Italia',
            code: 'ITA',
            phoneCode: '+39',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'b8e572d9-0564-4ce8-b147-1f9fdd167e22',
            createdAt: '2021-11-23T18:10:06.283Z',
            updatedAt: '2021-11-23T18:10:06.283Z',
        },
        JPN: {
            name: 'Japón',
            code: 'JPN',
            phoneCode: '+81',
            currencyId: 'c1371794-dc25-47f0-86a9-2118bf23ad9b',
            id: 'ad856abd-5610-45f0-8512-e0ed6c39538e',
            createdAt: '2021-11-23T18:10:06.287Z',
            updatedAt: '2021-11-23T18:10:06.287Z',
        },
        KIR: {
            name: 'Kiribati',
            code: 'KIR',
            phoneCode: '+686',
            currencyId: 'f2246a5f-2bc3-465c-a888-efb4be277672',
            id: 'beba2a58-60e3-4a76-b514-7d7df7d24c0f',
            createdAt: '2021-11-23T18:10:06.295Z',
            updatedAt: '2021-11-23T18:10:06.295Z',
        },
        LUX: {
            name: 'Luxemburgo',
            code: 'LUX',
            phoneCode: '+352',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '78e6f7d2-85a6-40ee-af1d-9296d37d241c',
            createdAt: '2021-11-23T18:10:06.320Z',
            updatedAt: '2021-11-23T18:10:06.320Z',
        },
        MWI: {
            name: 'Malawi',
            code: 'MWI',
            phoneCode: '+265',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'af25d35e-dc2a-4d21-8998-f75006727ae4',
            createdAt: '2021-11-23T18:10:06.326Z',
            updatedAt: '2021-11-23T18:10:06.326Z',
        },
        MLI: {
            name: 'Mali',
            code: 'MLI',
            phoneCode: '+223',
            currencyId: '1c52955b-240f-477e-8658-d1bf0a6c7814',
            id: '855ccc1b-f815-4afb-a78b-96e84c024843',
            createdAt: '2021-11-23T18:10:06.332Z',
            updatedAt: '2021-11-23T18:10:06.332Z',
        },
        MTQ: {
            name: 'Martinica',
            code: 'MTQ',
            phoneCode: '+596',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'bc612026-d319-4d95-8d5b-077934f8f081',
            createdAt: '2021-11-23T18:10:06.337Z',
            updatedAt: '2021-11-23T18:10:06.337Z',
        },
        MAR: {
            name: 'Marruecos',
            code: 'MAR',
            phoneCode: '+212',
            currencyId: '4b10eaad-b340-45ab-a0d6-c1879918cd80',
            id: '6ebba012-91b6-4d4f-aa33-ee2176eda32b',
            createdAt: '2021-11-23T18:10:06.353Z',
            updatedAt: '2021-11-23T18:10:06.353Z',
        },
        NAM: {
            name: 'Namibia',
            code: 'NAM',
            phoneCode: '+264',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '9d9abd0d-8a52-4f0d-a66e-ace69fb85ec9',
            createdAt: '2021-11-23T18:10:06.358Z',
            updatedAt: '2021-11-23T18:10:06.358Z',
        },
        NLD: {
            name: 'Países Bajos',
            code: 'NLD',
            phoneCode: '+31',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'b51bba5e-ba80-42f8-a740-f5c5ff7b1141',
            createdAt: '2021-11-23T18:10:06.364Z',
            updatedAt: '2021-11-23T18:10:06.364Z',
        },
        NZL: {
            name: 'Nueva Zelanda',
            code: 'NZL',
            phoneCode: '+64',
            currencyId: 'efbe73ee-afc6-43af-abd3-26d589f5b034',
            id: '786410d1-768c-4b43-99b3-35a34b57791d',
            createdAt: '2021-11-23T18:10:06.371Z',
            updatedAt: '2021-11-23T18:10:06.371Z',
        },
        NER: {
            name: 'Níger',
            code: 'NER',
            phoneCode: '+227',
            currencyId: '1c52955b-240f-477e-8658-d1bf0a6c7814',
            id: 'c3e33592-ba32-4b8d-8e17-351abe7ea1e2',
            createdAt: '2021-11-23T18:10:06.374Z',
            updatedAt: '2021-11-23T18:10:06.374Z',
        },
        NIU: {
            name: 'Niue',
            code: 'NIU',
            phoneCode: '+683',
            currencyId: 'efbe73ee-afc6-43af-abd3-26d589f5b034',
            id: '9940028f-3625-4654-a870-837ab75f95c7',
            createdAt: '2021-11-23T18:10:06.378Z',
            updatedAt: '2021-11-23T18:10:06.378Z',
        },
        PRK: {
            name: 'Corea del Norte',
            code: 'PRK',
            phoneCode: '+850',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'b3b4d3e9-ad84-4727-b601-dcc3595c6138',
            createdAt: '2021-11-23T18:10:06.297Z',
            updatedAt: '2021-11-23T18:10:06.297Z',
        },
        OMN: {
            name: 'Omán',
            code: 'OMN',
            phoneCode: '+968',
            currencyId: 'dc87776c-36f9-47c8-b4ab-59904655c2f2',
            id: 'b0e1c791-1c14-4096-8c6a-4ef00be6d38d',
            createdAt: '2021-11-23T18:10:06.385Z',
            updatedAt: '2021-11-23T18:10:06.385Z',
        },
        PAN: {
            name: 'Panamá',
            code: 'PAN',
            phoneCode: '+507',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'ad6bee98-03fd-4fd3-a569-f115d2f311a2',
            createdAt: '2021-11-23T18:10:06.390Z',
            updatedAt: '2021-11-23T18:10:06.390Z',
        },
        PNG: {
            name: 'Papúa Nueva Guinea',
            code: 'PNG',
            phoneCode: '+675',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '97525122-29b3-4552-80a0-bfdaf3a6c833',
            createdAt: '2021-11-23T18:10:06.392Z',
            updatedAt: '2021-11-23T18:10:06.392Z',
        },
        PER: {
            name: 'Perú',
            code: 'PER',
            phoneCode: '+51',
            currencyId: 'e7930298-256f-4ba9-9376-6bf45f5997ca',
            id: 'caf5885a-dcc3-4e7d-adeb-3c0a30447e76',
            createdAt: '2021-11-23T18:10:06.395Z',
            updatedAt: '2021-11-23T18:10:06.395Z',
        },
        PHL: {
            name: 'Filipinas',
            code: 'PHL',
            phoneCode: '+63',
            currencyId: '0a1b7953-0437-4d76-9c9d-6bcc378ca1a4',
            id: 'a9844cde-9846-4fe4-84ba-ac78bfc453b5',
            createdAt: '2021-11-23T18:10:06.397Z',
            updatedAt: '2021-11-23T18:10:06.397Z',
        },
        QAT: {
            name: 'Catar',
            code: 'QAT',
            phoneCode: '+974',
            currencyId: '5f5ed6a5-e778-4b38-858b-1a514418a8f6',
            id: 'b2600a62-5eed-4d15-aadf-cd6944a61e19',
            createdAt: '2021-11-23T18:10:06.407Z',
            updatedAt: '2021-11-23T18:10:06.407Z',
        },
        RUS: {
            name: 'Rusia',
            code: 'RUS',
            phoneCode: '+7',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'be8247ab-c056-450c-9114-6bf9e67d883a',
            createdAt: '2021-11-23T18:10:06.412Z',
            updatedAt: '2021-11-23T18:10:06.412Z',
        },
        SPM: {
            name: 'San Pedro y Miquelón',
            code: 'SPM',
            phoneCode: '+508',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'b5d6effd-7511-40da-9d05-de949b5efe07',
            createdAt: '2021-11-23T18:10:06.419Z',
            updatedAt: '2021-11-23T18:10:06.419Z',
        },
        SMR: {
            name: 'San Marino',
            code: 'SMR',
            phoneCode: '+378',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'be8ffaca-a24a-4730-ae56-ffb451cd101c',
            createdAt: '2021-11-23T18:10:06.424Z',
            updatedAt: '2021-11-23T18:10:06.424Z',
        },
        SVK: {
            name: 'Eslovaquia',
            code: 'SVK',
            phoneCode: '+421',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'bfb8f856-3361-4da0-9673-4679c5a8eef7',
            createdAt: '2021-11-23T18:10:06.436Z',
            updatedAt: '2021-11-23T18:10:06.436Z',
        },
        SVN: {
            name: 'Eslovenia',
            code: 'SVN',
            phoneCode: '+386',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'aa31449f-cac2-463b-a844-d831cac83cb3',
            createdAt: '2021-11-23T18:10:06.437Z',
            updatedAt: '2021-11-23T18:10:06.437Z',
        },
        LKA: {
            name: 'Sri Lanka',
            code: 'LKA',
            phoneCode: '+94',
            currencyId: '97acc4f7-0c5b-4e10-a5e8-f87b98dd96ac',
            id: '7d657a67-1d30-42ed-a2c4-a16bedc1e364',
            createdAt: '2021-11-23T18:10:06.446Z',
            updatedAt: '2021-11-23T18:10:06.446Z',
        },
        CHE: {
            name: 'Suiza',
            code: 'CHE',
            phoneCode: '+41',
            currencyId: 'ee5db97d-61e2-497b-8499-9454c36d27f6',
            id: 'a3cd5da6-af32-4e88-a314-8a99b863c3de',
            createdAt: '2021-11-23T18:10:06.459Z',
            updatedAt: '2021-11-23T18:10:06.459Z',
        },
        TZA: {
            name: 'Tanzania',
            code: 'TZA',
            phoneCode: '+255',
            currencyId: '03cd3fec-bd45-48a2-a426-07acd269d0c0',
            id: 'a8a4fdd5-0782-4bff-9643-da1eca44ac93',
            createdAt: '2021-11-23T18:10:06.467Z',
            updatedAt: '2021-11-23T18:10:06.467Z',
        },
        TGO: {
            name: 'Togo',
            code: 'TGO',
            phoneCode: '+228',
            currencyId: '1c52955b-240f-477e-8658-d1bf0a6c7814',
            id: 'c34c3426-ca1a-4fad-9a2e-d1bca34154cd',
            createdAt: '2021-11-23T18:10:06.471Z',
            updatedAt: '2021-11-23T18:10:06.471Z',
        },
        TUN: {
            name: 'Túnez',
            code: 'TUN',
            phoneCode: '+216',
            currencyId: '106f266e-ad73-40e9-8559-d66e4ff5ca95',
            id: '7f626d0b-7074-4a7e-ae53-11c5f3bb0e2a',
            createdAt: '2021-11-23T18:10:06.479Z',
            updatedAt: '2021-11-23T18:10:06.479Z',
        },
        TKM: {
            name: 'Turkmenistán',
            code: 'TKM',
            phoneCode: '+993',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'cd5dad45-5e06-4ee2-9170-277029045d85',
            createdAt: '2021-11-23T18:10:06.482Z',
            updatedAt: '2021-11-23T18:10:06.482Z',
        },
        TUR: {
            name: 'Turquía',
            code: 'TUR',
            phoneCode: '+90',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '8a4e1c4d-c990-4c9c-85d6-8906e93e7277',
            createdAt: '2021-11-23T18:10:06.481Z',
            updatedAt: '2021-11-23T18:10:06.481Z',
        },
        UGA: {
            name: 'Uganda',
            code: 'UGA',
            phoneCode: '+256',
            currencyId: '5e5fa773-b2d0-4af8-9d45-6ac5af8aad93',
            id: 'a286b7a3-356f-4b49-99af-efbc0c4169f7',
            createdAt: '2021-11-23T18:10:06.488Z',
            updatedAt: '2021-11-23T18:10:06.488Z',
        },
        ARE: {
            name: 'Emiratos Árabes Unidos',
            code: 'ARE',
            phoneCode: '+971',
            currencyId: '50957a49-fd4a-491e-803e-5b51fdce8d8d',
            id: '8f90f706-0008-4054-82c4-d961d0f598b6',
            createdAt: '2021-11-23T18:10:06.492Z',
            updatedAt: '2021-11-23T18:10:06.492Z',
        },
        VUT: {
            name: 'Vanuatu',
            code: 'VUT',
            phoneCode: '+678',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '9f851be5-d5e2-4032-8f9e-de9d33682683',
            createdAt: '2021-11-23T18:10:06.503Z',
            updatedAt: '2021-11-23T18:10:06.503Z',
        },
        WLF: {
            name: 'Wallis y Futuna',
            code: 'WLF',
            phoneCode: '+681',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'd1268d9b-aba2-4bf9-8e28-469bfa329a39',
            createdAt: '2021-11-23T18:10:06.513Z',
            updatedAt: '2021-11-23T18:10:06.513Z',
        },
        ESH: {
            name: 'Sahara Occidental',
            code: 'ESH',
            phoneCode: '+212',
            currencyId: '4b10eaad-b340-45ab-a0d6-c1879918cd80',
            id: '7fd02a5f-2653-4a56-a71a-8a272e4e08a1',
            createdAt: '2021-11-23T18:10:06.515Z',
            updatedAt: '2021-11-23T18:10:06.515Z',
        },
        ZMB: {
            name: 'Zambia',
            code: 'ZMB',
            phoneCode: '+260',
            currencyId: '42f582c4-77b0-467b-a8bd-b1e4a6a9563b',
            id: 'c87a2767-5c17-4513-bc73-51cead1cfc1d',
            createdAt: '2021-11-23T18:10:06.523Z',
            updatedAt: '2021-11-23T18:10:06.523Z',
        },
        ZWE: {
            name: 'Zimbabue',
            code: 'ZWE',
            phoneCode: '+263',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '95af3fee-ee20-4897-a172-3289be7734c6',
            createdAt: '2021-11-23T18:10:06.525Z',
            updatedAt: '2021-11-23T18:10:06.525Z',
        },
        YUG: {
            name: 'Yugoslavia',
            code: 'YUG',
            phoneCode: null,
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'd424e150-8b5c-4b2d-abef-c9a756580452',
            createdAt: '2021-11-23T18:10:06.520Z',
            updatedAt: '2021-11-23T18:10:06.520Z',
        },
        AFG: {
            name: 'Afganistán',
            code: 'AFG',
            phoneCode: '+93',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: '1d940fd1-fb5d-4202-9fd8-343c8f0e719f',
            createdAt: '2021-11-23T18:10:06.046Z',
            updatedAt: '2021-11-23T18:10:06.046Z',
        },
        ATG: {
            name: 'Antigua y Barbuda',
            code: 'ATG',
            phoneCode: '+1268',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'f47a6425-d1d1-49f0-b9a7-de69787a44af',
            createdAt: '2021-11-23T18:10:06.099Z',
            updatedAt: '2021-11-23T18:10:06.099Z',
        },
        AUS: {
            name: 'Australia',
            code: 'AUS',
            phoneCode: '+61',
            currencyId: 'f2246a5f-2bc3-465c-a888-efb4be277672',
            id: 'da679a6f-7330-4e17-8464-63c6ba335c96',
            createdAt: '2021-11-23T18:10:06.107Z',
            updatedAt: '2021-11-23T18:10:06.107Z',
        },
        BLR: {
            name: 'Bielorrusia',
            code: 'BLR',
            phoneCode: '+375',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'e4e52368-5ab7-444b-aca8-d4bf14d7d695',
            createdAt: '2021-11-23T18:10:06.119Z',
            updatedAt: '2021-11-23T18:10:06.119Z',
        },
        BEL: {
            name: 'Bélgica',
            code: 'BEL',
            phoneCode: '+32',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'e5be7efa-8963-471a-8dcd-33f6d722ab85',
            createdAt: '2021-11-23T18:10:06.121Z',
            updatedAt: '2021-11-23T18:10:06.121Z',
        },
        BGR: {
            name: 'Bulgaria',
            code: 'BGR',
            phoneCode: '+359',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'e73e7692-12e6-49d5-91e6-2a81ca8a7775',
            createdAt: '2021-11-23T18:10:06.146Z',
            updatedAt: '2021-11-23T18:10:06.146Z',
        },
        BFA: {
            name: 'Burkina Faso',
            code: 'BFA',
            phoneCode: '+226',
            currencyId: '1c52955b-240f-477e-8658-d1bf0a6c7814',
            id: 'f2c6a20a-4673-420c-aa63-37ee4e705ccb',
            createdAt: '2021-11-23T18:10:06.148Z',
            updatedAt: '2021-11-23T18:10:06.148Z',
        },
        BDI: {
            name: 'Burundi',
            code: 'BDI',
            phoneCode: '+257',
            currencyId: '2de49882-8917-4912-999a-98e581fb9634',
            id: 'e6dec82b-f531-47ed-a988-8b5f2f00d77c',
            createdAt: '2021-11-23T18:10:06.150Z',
            updatedAt: '2021-11-23T18:10:06.150Z',
        },
        CMR: {
            name: 'Camerún',
            code: 'CMR',
            phoneCode: '+237',
            currencyId: 'aced97b3-7bba-48b2-b5b1-5302e0b26b98',
            id: 'df13c9c7-8bfa-482b-ab6b-5dd24f4a9c0c',
            createdAt: '2021-11-23T18:10:06.153Z',
            updatedAt: '2021-11-23T18:10:06.153Z',
        },
        CYM: {
            name: 'Islas Caimán',
            code: 'CYM',
            phoneCode: '+1345',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'f57bf5c7-67ef-4b1d-91a1-0ddd1770e7cc',
            createdAt: '2021-11-23T18:10:06.158Z',
            updatedAt: '2021-11-23T18:10:06.158Z',
        },
        CHN: {
            name: 'China',
            code: 'CHN',
            phoneCode: '+86',
            currencyId: '05d8644a-0ab1-4a37-82bd-cad06017e7ee',
            id: 'fc658234-1688-4628-aa2f-da4db1977c47',
            createdAt: '2021-11-23T18:10:06.170Z',
            updatedAt: '2021-11-23T18:10:06.170Z',
        },
        COM: {
            name: 'Comoras',
            code: 'COM',
            phoneCode: '+269',
            currencyId: 'd84d748e-c750-4f6e-a51d-9fddaeb689b3',
            id: 'ee9c94a8-697a-42e5-9be5-2bf7ab1faecc',
            createdAt: '2021-11-23T18:10:06.177Z',
            updatedAt: '2021-11-23T18:10:06.177Z',
        },
        COK: {
            name: 'Islas Cook',
            code: 'COK',
            phoneCode: '+682',
            currencyId: 'efbe73ee-afc6-43af-abd3-26d589f5b034',
            id: 'd6132d30-becf-4482-a2e0-a81242673edc',
            createdAt: '2021-11-23T18:10:06.181Z',
            updatedAt: '2021-11-23T18:10:06.181Z',
        },
        CZE: {
            name: 'República Checa',
            code: 'CZE',
            phoneCode: '+420',
            currencyId: 'c6063153-0896-4cad-96a5-ef9bb0c36aff',
            id: 'fdee6d96-ccbb-4149-8446-86a1bede7473',
            createdAt: '2021-11-23T18:10:06.192Z',
            updatedAt: '2021-11-23T18:10:06.192Z',
        },
        CIV: {
            name: 'Costa de Marfil',
            code: 'CIV',
            phoneCode: '+225',
            currencyId: '1c52955b-240f-477e-8658-d1bf0a6c7814',
            id: 'e50ae556-fad9-468b-b88e-aace81d180c2',
            createdAt: '2021-11-23T18:10:06.184Z',
            updatedAt: '2021-11-23T18:10:06.184Z',
        },
        EST: {
            name: 'Estonia',
            code: 'EST',
            phoneCode: '+372',
            currencyId: '3547a362-57b6-4c39-8498-9a312356b258',
            id: 'e38ed443-6a2b-4c53-af6b-5f44b41dd067',
            createdAt: '2021-11-23T18:10:06.212Z',
            updatedAt: '2021-11-23T18:10:06.212Z',
        },
        ETH: {
            name: 'Etiopía',
            code: 'ETH',
            phoneCode: '+251',
            currencyId: '5ef160f9-3eff-45d8-ae20-118a7c1ef6bc',
            id: 'e0044728-a770-4137-b8d2-5cf412b64ede',
            createdAt: '2021-11-23T18:10:06.214Z',
            updatedAt: '2021-11-23T18:10:06.214Z',
        },
        FRA: {
            name: 'Francia',
            code: 'FRA',
            phoneCode: '+33',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'fcdb2ed6-44d5-4a51-b799-76e0798da11a',
            createdAt: '2021-11-23T18:10:06.223Z',
            updatedAt: '2021-11-23T18:10:06.223Z',
        },
        ATF: {
            name: 'Territorios Australes Franceses',
            code: 'ATF',
            phoneCode: '+262',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'f2529afc-cd9b-4238-9151-7440af7a4693',
            createdAt: '2021-11-23T18:10:06.228Z',
            updatedAt: '2021-11-23T18:10:06.228Z',
        },
        GMB: {
            name: 'Gambia',
            code: 'GMB',
            phoneCode: '+220',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'f7c90a87-830c-44c6-80e0-ce9869b5b4be',
            createdAt: '2021-11-23T18:10:06.231Z',
            updatedAt: '2021-11-23T18:10:06.231Z',
        },
        GRC: {
            name: 'Grecia',
            code: 'GRC',
            phoneCode: '+30',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'fac4ba57-ff8e-4c29-88b0-fbb81ee74873',
            createdAt: '2021-11-23T18:10:06.240Z',
            updatedAt: '2021-11-23T18:10:06.240Z',
        },
        GLP: {
            name: 'Guadalupe',
            code: 'GLP',
            phoneCode: '+590',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'e9aefe98-6e96-4909-85de-bc8ad7f3c885',
            createdAt: '2021-11-23T18:10:06.246Z',
            updatedAt: '2021-11-23T18:10:06.246Z',
        },
        GNB: {
            name: 'Guinea-Bissau',
            code: 'GNB',
            phoneCode: '+245',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'f43e84bc-26ff-4e46-9c79-aa55955bc722',
            createdAt: '2021-11-23T18:10:06.254Z',
            updatedAt: '2021-11-23T18:10:06.254Z',
        },
        JAM: {
            name: 'Jamaica',
            code: 'JAM',
            phoneCode: '+1 876',
            currencyId: '1ecfddb6-eb3f-4945-b7ea-76fe4ea36071',
            id: 'f77e351e-2689-421a-a712-c91417216546',
            createdAt: '2021-11-23T18:10:06.285Z',
            updatedAt: '2021-11-23T18:10:06.285Z',
        },
        LVA: {
            name: 'Letonia',
            code: 'LVA',
            phoneCode: '+371',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'f6d3b452-5cb4-41f2-973a-9b3b8d08a3fb',
            createdAt: '2021-11-23T18:10:06.307Z',
            updatedAt: '2021-11-23T18:10:06.307Z',
        },
        LBY: {
            name: 'Libia',
            code: 'LBY',
            phoneCode: '+218',
            currencyId: 'db3800e8-9a69-45db-bfe1-4085529b7e36',
            id: 'fefa9430-5851-48d5-b347-82a6982e5948',
            createdAt: '2021-11-23T18:10:06.314Z',
            updatedAt: '2021-11-23T18:10:06.314Z',
        },
        MAC: {
            name: 'Macao',
            code: 'MAC',
            phoneCode: '+853',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'eeb69bbf-5aca-4af6-b4e1-af43cecee742',
            createdAt: '2021-11-23T18:10:06.321Z',
            updatedAt: '2021-11-23T18:10:06.321Z',
        },
        MKD: {
            name: 'República de Macedonia del Norte',
            code: 'MKD',
            phoneCode: '+389',
            currencyId: 'a2fef18a-c61f-4432-84d8-2614a5cebdf5',
            id: 'd4e04f1e-6ddf-42f1-a410-dbccc991bd32',
            createdAt: '2021-11-23T18:10:06.323Z',
            updatedAt: '2021-11-23T18:10:06.323Z',
        },
        MLT: {
            name: 'Malta',
            code: 'MLT',
            phoneCode: '+356',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'f4553569-3fa3-4701-b9fd-6f88b6abbec7',
            createdAt: '2021-11-23T18:10:06.333Z',
            updatedAt: '2021-11-23T18:10:06.333Z',
        },
        MHL: {
            name: 'Islas Marshall',
            code: 'MHL',
            phoneCode: '+692',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'd30de06b-a9c7-46bc-86d8-bd63d1bd767e',
            createdAt: '2021-11-23T18:10:06.335Z',
            updatedAt: '2021-11-23T18:10:06.335Z',
        },
        MUS: {
            name: 'Mauricio',
            code: 'MUS',
            phoneCode: '+230',
            currencyId: '7138366f-97cb-49ed-90c9-366d1e9ff988',
            id: 'ed9b3dc3-c5e7-41f6-9abc-f5291f52b758',
            createdAt: '2021-11-23T18:10:06.340Z',
            updatedAt: '2021-11-23T18:10:06.340Z',
        },
        MNG: {
            name: 'Mongolia',
            code: 'MNG',
            phoneCode: '+976',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'eb817411-f1a2-406d-aaaf-9adbb6a549a4',
            createdAt: '2021-11-23T18:10:06.350Z',
            updatedAt: '2021-11-23T18:10:06.350Z',
        },
        MOZ: {
            name: 'Mozambique',
            code: 'MOZ',
            phoneCode: '+258',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'ed184ee3-a246-43a8-8437-95b7173bec34',
            createdAt: '2021-11-23T18:10:06.355Z',
            updatedAt: '2021-11-23T18:10:06.355Z',
        },
        NRU: {
            name: 'Nauru',
            code: 'NRU',
            phoneCode: '+674',
            currencyId: 'f2246a5f-2bc3-465c-a888-efb4be277672',
            id: 'fcc43213-29b8-4a72-9cda-30763ad185d0',
            createdAt: '2021-11-23T18:10:06.360Z',
            updatedAt: '2021-11-23T18:10:06.360Z',
        },
        NOR: {
            name: 'Noruega',
            code: 'NOR',
            phoneCode: '+47',
            currencyId: '2310830a-7726-4381-b259-6e3c2a13cac6',
            id: 'ffada2b3-368c-4f6d-a758-03ff812d8163',
            createdAt: '2021-11-23T18:10:06.383Z',
            updatedAt: '2021-11-23T18:10:06.383Z',
        },
        PAK: {
            name: 'Pakistán',
            code: 'PAK',
            phoneCode: '+92',
            currencyId: '1a9e9ddd-eaf3-44d4-9fc4-24137883777e',
            id: 'e1b2485a-3b69-4f37-afc0-5b10f531ee6c',
            createdAt: '2021-11-23T18:10:06.387Z',
            updatedAt: '2021-11-23T18:10:06.387Z',
        },
        PLW: {
            name: 'Palau',
            code: 'PLW',
            phoneCode: '+680',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'f2fcb8d0-b9a3-43c9-9a8b-fcf650fbbbed',
            createdAt: '2021-11-23T18:10:06.388Z',
            updatedAt: '2021-11-23T18:10:06.388Z',
        },
        POL: {
            name: 'Polonia',
            code: 'POL',
            phoneCode: '+48',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'e6cf23c6-31af-40c3-a054-490b9a01d7be',
            createdAt: '2021-11-23T18:10:06.401Z',
            updatedAt: '2021-11-23T18:10:06.401Z',
        },
        REU: {
            name: 'Reunión',
            code: 'REU',
            phoneCode: '+262',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'e0b2c99e-63c4-4d61-90e0-4e76d5892960',
            createdAt: '2021-11-23T18:10:06.408Z',
            updatedAt: '2021-11-23T18:10:06.408Z',
        },
        VCT: {
            name: 'San Vicente y las Granadinas',
            code: 'VCT',
            phoneCode: '+1784',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'de74918c-b161-4825-b5e1-18b9fef1f124',
            createdAt: '2021-11-23T18:10:06.421Z',
            updatedAt: '2021-11-23T18:10:06.421Z',
        },
        STP: {
            name: 'Santo Tomé y Príncipe',
            code: 'STP',
            phoneCode: '+239',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'e60c8ecc-ee1d-4f4d-aac9-57512df9efcc',
            createdAt: '2021-11-23T18:10:06.426Z',
            updatedAt: '2021-11-23T18:10:06.426Z',
        },
        SYC: {
            name: 'Seychelles',
            code: 'SYC',
            phoneCode: '+248',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'ed38320e-a178-40d3-bd94-f0cb2560a964',
            createdAt: '2021-11-23T18:10:06.430Z',
            updatedAt: '2021-11-23T18:10:06.430Z',
        },
        SLE: {
            name: 'Sierra Leona',
            code: 'SLE',
            phoneCode: '+232',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'daabe66c-d2c6-4fef-939e-d9076a2ff939',
            createdAt: '2021-11-23T18:10:06.432Z',
            updatedAt: '2021-11-23T18:10:06.432Z',
        },
        SOM: {
            name: 'Somalia',
            code: 'SOM',
            phoneCode: '+252',
            currencyId: 'de615227-65fb-426a-b819-c00ff87a6d9d',
            id: 'e206d383-6d4c-42a7-9adc-15687ce8b0fe',
            createdAt: '2021-11-23T18:10:06.441Z',
            updatedAt: '2021-11-23T18:10:06.441Z',
        },
        ZAF: {
            name: 'Sudáfrica',
            code: 'ZAF',
            phoneCode: '+27',
            currencyId: '442a254e-4544-47e6-afbc-86253c4071b5',
            id: 'd78a2e79-c35c-4fa5-89c0-40b8d9403e93',
            createdAt: '2021-11-23T18:10:06.442Z',
            updatedAt: '2021-11-23T18:10:06.442Z',
        },
        TJK: {
            name: 'Tayikistán',
            code: 'TJK',
            phoneCode: '+992',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'e1f1120e-e444-466f-a583-180e424d6150',
            createdAt: '2021-11-23T18:10:06.465Z',
            updatedAt: '2021-11-23T18:10:06.465Z',
        },
        TUV: {
            name: 'Tuvalu',
            code: 'TUV',
            phoneCode: '+688',
            currencyId: 'f2246a5f-2bc3-465c-a888-efb4be277672',
            id: 'df25c437-cdfc-4822-a410-91be6adbbfb7',
            createdAt: '2021-11-23T18:10:06.486Z',
            updatedAt: '2021-11-23T18:10:06.486Z',
        },
        USA: {
            name: 'Estados Unidos de América',
            code: 'USA',
            phoneCode: '+1',
            currencyId: '83029b5d-29f1-4707-87f3-fca0e00c415e',
            id: 'd6dec6d2-9a8a-47a3-9a2b-9ad3c5feb1cd',
            createdAt: '2021-11-23T18:10:06.495Z',
            updatedAt: '2021-11-23T18:10:06.495Z',
        },
        UZB: {
            name: 'Uzbekistán',
            code: 'UZB',
            phoneCode: '+998',
            currencyId: '381eae46-8873-46d7-b138-a7a1912529a0',
            id: 'fc5e40f6-da6f-49c3-99a1-7284631ca33e',
            createdAt: '2021-11-23T18:10:06.501Z',
            updatedAt: '2021-11-23T18:10:06.501Z',
        },
    },
};
var translateCountry = function (_a) {
    var language = _a.language;
    return Countries === null || Countries === void 0 ? void 0 : Countries[language !== null && language !== void 0 ? language : 'es'];
};

var queryUpload = gql(templateObject_1$Y || (templateObject_1$Y = __makeTemplateObject(["\n  query UploadFileUrl($orgCode: String!, $path: String!, $fileName: String!) {\n    uploadFileUrl(orgCode: $orgCode, path: $path, fileName: $fileName) {\n      url\n      fileName\n    }\n  }\n"], ["\n  query UploadFileUrl($orgCode: String!, $path: String!, $fileName: String!) {\n    uploadFileUrl(orgCode: $orgCode, path: $path, fileName: $fileName) {\n      url\n      fileName\n    }\n  }\n"])));
var removeWhiteSpaces$2 = function (name) { var _a, _b; return (_b = (_a = name === null || name === void 0 ? void 0 : name.replace(/\s+/g, '')) === null || _a === void 0 ? void 0 : _a.replace('(', '')) === null || _b === void 0 ? void 0 : _b.replace(')', ''); };
var uploadImage = function (image, options) { return __awaiter(void 0, void 0, void 0, function () {
    var endpoint, client, uploadFile, result;
    var _a, _b, _c;
    return __generator(this, function (_d) {
        switch (_d.label) {
            case 0:
                endpoint = 'https://file-service.staging.ixuapis.com/graphql/';
                client = new ApolloClient({
                    uri: endpoint,
                    cache: new InMemoryCache(),
                });
                uploadFile = function (url, file) {
                    return fetch(url, {
                        method: 'PUT',
                        body: file !== null && file !== void 0 ? file : new Blob(),
                        headers: {
                            'Content-Type': 'application/octet-stream',
                        },
                        mode: 'cors',
                    }).catch(function (e) { return console.error(e); });
                };
                return [4 /*yield*/, client
                        .query({
                        query: queryUpload,
                        variables: {
                            orgCode: removeWhiteSpaces$2((_a = options === null || options === void 0 ? void 0 : options.orgcode) !== null && _a !== void 0 ? _a : ''),
                            path: removeWhiteSpaces$2((_b = options === null || options === void 0 ? void 0 : options.name) !== null && _b !== void 0 ? _b : ''),
                            fileName: removeWhiteSpaces$2((_c = options === null || options === void 0 ? void 0 : options.name) !== null && _c !== void 0 ? _c : ''),
                        },
                    })
                        .then(function (res) { return __awaiter(void 0, void 0, void 0, function () {
                        var _a, _b, _c, _d, _e, _f;
                        return __generator(this, function (_g) {
                            switch (_g.label) {
                                case 0:
                                    if (!((_b = (_a = res === null || res === void 0 ? void 0 : res.data) === null || _a === void 0 ? void 0 : _a.uploadFileUrl) === null || _b === void 0 ? void 0 : _b.url)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, uploadFile((_d = (_c = res === null || res === void 0 ? void 0 : res.data) === null || _c === void 0 ? void 0 : _c.uploadFileUrl) === null || _d === void 0 ? void 0 : _d.url, image !== null && image !== void 0 ? image : {})];
                                case 1:
                                    _g.sent();
                                    return [2 /*return*/, (_f = (_e = res === null || res === void 0 ? void 0 : res.data) === null || _e === void 0 ? void 0 : _e.uploadFileUrl) === null || _f === void 0 ? void 0 : _f.fileName];
                                case 2: return [2 /*return*/, image !== null && image !== void 0 ? image : {}];
                            }
                        });
                    }); })];
            case 1:
                result = _d.sent();
                return [2 /*return*/, result];
        }
    });
}); };
var templateObject_1$Y;

var removeWhiteSpaces$1 = function (name) {
    return name.replace(/\s+/g, '').replace('(', '').replace(')', '');
};
var getUrlPrivate = function (privateData) { return __awaiter(void 0, void 0, void 0, function () {
    var mutation, memberId, projectId, folderId, fileInput, isProfile, sanitizedName, input, defaultEndpoint, values2, data;
    var _a, _b, _c, _d, _e;
    return __generator(this, function (_f) {
        switch (_f.label) {
            case 0:
                mutation = "\nmutation uploadFilePrivate($input: UploadFilePrivateInput!) {\n  uploadFilePrivate(input: $input) {\n    url\n    message\n    token\n    fileId\n    partialUrl\n  }\n}";
                memberId = privateData.memberId, projectId = privateData.projectId, folderId = privateData.folderId, fileInput = privateData.fileInput, isProfile = privateData.isProfile;
                return [4 /*yield*/, removeWhiteSpaces$1(fileInput.name)];
            case 1:
                sanitizedName = _f.sent();
                input = folderId
                    ? {
                        memberId: memberId,
                        projectId: projectId,
                        folderId: folderId,
                        isProfile: isProfile,
                        name: sanitizedName,
                        fileName: sanitizedName,
                        description: JSON.stringify({
                            size: fileInput.size,
                            type: "".concat(fileInput === null || fileInput === void 0 ? void 0 : fileInput.type),
                        }),
                    }
                    : {
                        memberId: memberId,
                        projectId: projectId,
                        isProfile: isProfile,
                        name: sanitizedName,
                        fileName: sanitizedName,
                        description: JSON.stringify({
                            size: fileInput.size,
                            type: "".concat(fileInput === null || fileInput === void 0 ? void 0 : fileInput.type),
                        }),
                    };
                defaultEndpoint = "https://gateway.staging.ixuapis.com/graphql/";
                return [4 /*yield*/, request((_a = CONFIG.GRAPHQL_URL) !== null && _a !== void 0 ? _a : defaultEndpoint, mutation, {
                        input: input,
                    })];
            case 2:
                values2 = _f.sent();
                return [4 /*yield*/, {
                        url: (_b = values2 === null || values2 === void 0 ? void 0 : values2.uploadFilePrivate) === null || _b === void 0 ? void 0 : _b.url,
                        partialUrl: (_c = values2 === null || values2 === void 0 ? void 0 : values2.uploadFilePrivate) === null || _c === void 0 ? void 0 : _c.partialUrl,
                        fileName: sanitizedName,
                        fileId: (_d = values2 === null || values2 === void 0 ? void 0 : values2.uploadFilePrivate) === null || _d === void 0 ? void 0 : _d.fileId,
                        token: (_e = values2 === null || values2 === void 0 ? void 0 : values2.uploadFilePrivate) === null || _e === void 0 ? void 0 : _e.token,
                    }];
            case 3:
                data = _f.sent();
                return [2 /*return*/, data];
        }
    });
}); };
var uploadFile$1 = function (url, file) {
    return fetch(url, {
        method: 'PUT',
        body: file,
        headers: {
            'Content-Type': 'application/octet-stream',
        },
        mode: 'cors',
    }).catch(function (e) { return console.error(e); });
};
var uploadPrivateFile = function (data) {
    return data
        ? getUrlPrivate(data).then(function (response) { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, uploadFile$1(response === null || response === void 0 ? void 0 : response.partialUrl, data === null || data === void 0 ? void 0 : data.fileInput)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, response];
                }
            });
        }); })
        : data;
};

var initialSeoValues = {
    slug: '',
    seo: {
        title: '',
        description: '',
        page: '',
        website: '',
        keywords: [],
        image: '',
        icon: '',
        locale: '',
    },
};
var AtomFormSeo = function (props) {
    var formik = props.formik;
    var _a = __read(useState(''), 2), keyword = _a[0], setKeyword = _a[1];
    return (jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_1$X || (templateObject_1$X = __makeTemplateObject(["\n        width: 100%;\n        gap: 20px;\n      "], ["\n        width: 100%;\n        gap: 20px;\n      "]))) }, { children: [jsxs(Wrapper$2, __assign({ width: "100%", backgroundColor: "#ffffff", padding: "30px 40px", customCSS: css$1(templateObject_2$I || (templateObject_2$I = __makeTemplateObject(["\n          box-shadow: 0px 3px 6px #0000001a;\n          @media (max-width: 980px) {\n            width: 100%;\n          }\n        "], ["\n          box-shadow: 0px 3px 6px #0000001a;\n          @media (max-width: 980px) {\n            width: 100%;\n          }\n        "]))) }, { children: [jsx(Text$2, __assign({ fontSize: "14px", color: "#023059", fontWeight: "bold" }, { children: "Slug" })), jsx(Input, { label: "Slug (URL)", border: "1px solid #0000003F", spanMargin: "5px 0px 10px 0px", labelColor: "#5c5c5c", labelFontSize: "14px", labelFontWeight: "bold", height: "35px", labelWidth: "100%", fontSize: "12px", formik: formik, id: "slug" })] })), jsxs(Wrapper$2, __assign({ width: "100%", backgroundColor: "#ffffff", padding: "30px 40px", customCSS: css$1(templateObject_3$z || (templateObject_3$z = __makeTemplateObject(["\n          box-shadow: 0px 3px 6px #0000001a;\n          @media (max-width: 980px) {\n            width: 100%;\n          }\n        "], ["\n          box-shadow: 0px 3px 6px #0000001a;\n          @media (max-width: 980px) {\n            width: 100%;\n          }\n        "]))) }, { children: [jsx(Wrapper$2, __assign({ width: "100%", margin: "0px 0px 10px 0px" }, { children: jsx(Text$2, __assign({ fontSize: "14px", color: "#023059", fontWeight: "bold" }, { children: "SEO" })) })), Object.entries(initialSeoValues.seo).map(function (_a) {
                        var _b, _c;
                        var _d = __read(_a, 1), key = _d[0];
                        switch (key) {
                            case 'keywords':
                                return (jsxs(Wrapper$2, { children: [jsx(Text$2, __assign({ fontSize: "14px", color: "#023059", fontWeight: "bold", margin: "0px 0px 10px 0px" }, { children: capitalizeFirstLetter$1(key) })), jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_4$p || (templateObject_4$p = __makeTemplateObject(["\n                      gap: 10px;\n                    "], ["\n                      gap: 10px;\n                    "]))) }, { children: [jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_5$k || (templateObject_5$k = __makeTemplateObject(["\n                        display: flex;\n                        flex-direction: row;\n                        gap: 20px;\n                      "], ["\n                        display: flex;\n                        flex-direction: row;\n                        gap: 20px;\n                      "]))) }, { children: [jsx(Input, { border: "1px solid #0000003F", spanMargin: "5px 0px 10px 0px", labelColor: "#5c5c5c", labelFontSize: "14px", labelFontWeight: "bold", height: "35px", labelWidth: "100%", fontSize: "12px", value: keyword, onChange: function (e) { return setKeyword(e.target.value); }, id: "seo.".concat(key) }), jsx(AtomButton, __assign({ onClick: function () {
                                                                formik.setFieldValue("seo.".concat(key), __spreadArray([], __read(new Set(__spreadArray(__spreadArray([], __read(formik.values.seo[key]), false), [keyword], false))), false));
                                                                setKeyword('');
                                                            }, customCSS: css$1(templateObject_6$f || (templateObject_6$f = __makeTemplateObject(["\n                          border-radius: 50%;\n                          padding: 0px 10px;\n                          height: 35px;\n                        "], ["\n                          border-radius: 50%;\n                          padding: 0px 10px;\n                          height: 35px;\n                        "]))) }, { children: jsx(Icon$1, { width: "15px", height: "15px", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/JRO-0001/iconmonstr-plus-2.svg", customCSS: css$1(templateObject_7$d || (templateObject_7$d = __makeTemplateObject(["\n                            svg {\n                              path {\n                                fill: white !important;\n                              }\n                            }\n                          "], ["\n                            svg {\n                              path {\n                                fill: white !important;\n                              }\n                            }\n                          "]))) }) }))] })), jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_8$8 || (templateObject_8$8 = __makeTemplateObject(["\n                        width: 100%;\n                        display: flex;\n                        flex-direction: row;\n                        flex-wrap: wrap;\n                        justify-content: flex-start;\n                        gap: 10px;\n                      "], ["\n                        width: 100%;\n                        display: flex;\n                        flex-direction: row;\n                        flex-wrap: wrap;\n                        justify-content: flex-start;\n                        gap: 10px;\n                      "]))) }, { children: (_c = (_b = formik.values.seo) === null || _b === void 0 ? void 0 : _b[key]) === null || _c === void 0 ? void 0 : _c.map(function (item) { return (jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_9$6 || (templateObject_9$6 = __makeTemplateObject(["\n                            max-width: max-content;\n                            flex-direction: row;\n                            align-items: center;\n                            justify-content: center;\n                            padding: 5px 10px;\n                            border-radius: 5px;\n                            background-color: #ececec;\n                            gap: 5px;\n                          "], ["\n                            max-width: max-content;\n                            flex-direction: row;\n                            align-items: center;\n                            justify-content: center;\n                            padding: 5px 10px;\n                            border-radius: 5px;\n                            background-color: #ececec;\n                            gap: 5px;\n                          "]))) }, { children: [jsx(Text$2, { children: item }), jsx(AtomButton, __assign({ onClick: function () {
                                                                    formik.setFieldValue("seo.".concat(key), formik.values.seo[key].filter(function (v) { return v !== item; }));
                                                                }, customCSS: css$1(templateObject_10$5 || (templateObject_10$5 = __makeTemplateObject(["\n                              padding: 0px;\n                              background-color: transparent;\n                              border-radius: 50%;\n                            "], ["\n                              padding: 0px;\n                              background-color: transparent;\n                              border-radius: 50%;\n                            "]))) }, { children: jsx(Icon$1, { width: "16px", height: "16px", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/JRO-0001/icons/Component%20199%20%E2%80%93%202.svg", customCSS: css$1(templateObject_11$5 || (templateObject_11$5 = __makeTemplateObject(["\n                                svg {\n                                  g {\n                                    path {\n                                      fill: none !important;\n                                      stroke: #fe6a6a !important;\n                                    }\n                                  }\n                                }\n                              "], ["\n                                svg {\n                                  g {\n                                    path {\n                                      fill: none !important;\n                                      stroke: #fe6a6a !important;\n                                    }\n                                  }\n                                }\n                              "]))) }) }))] }), item)); }) }))] }))] }));
                            default:
                                return (jsx(Input, { label: capitalizeFirstLetter$1(key), border: "1px solid #0000003F", spanMargin: "5px 0px 10px 0px", labelColor: "#5c5c5c", labelFontSize: "14px", labelFontWeight: "bold", height: "35px", labelWidth: "100%", fontSize: "12px", formik: formik, id: "seo.".concat(key) }));
                        }
                    })] }))] })));
};
var templateObject_1$X, templateObject_2$I, templateObject_3$z, templateObject_4$p, templateObject_5$k, templateObject_6$f, templateObject_7$d, templateObject_8$8, templateObject_9$6, templateObject_10$5, templateObject_11$5;

/*!
 * Pintura Image Editor 8.9.1
 * (c) 2018-2021 PQINA Inc. - All Rights Reserved
 * License: https://pqina.nl/pintura/license/
 */
/* eslint-disable */

const JFIF_MARKER = 0xffe0;
const EXIF_MARKER = 0xffe1;
const SOS_MARKER = 0xffda;
const Markers = {
    [EXIF_MARKER]: 'exif',
    [JFIF_MARKER]: 'jfif',
    [SOS_MARKER]: 'sos',
};
const JPEG_SOI_MARKER = 0xffd8; // start of JPEG
const JPEG_MARKER_PREFIX = 0xff;
var dataViewGetApplicationMarkers = (view) => {
    // If no SOI marker exit here because we're not going to find the APP1 header in a non-jpeg file
    if (view.getUint16(0) !== JPEG_SOI_MARKER)
        return undefined;
    const markerTypes = Object.keys(Markers).map((v) => parseInt(v, 10));
    const length = view.byteLength; // cache the length here
    let offset = 2; // start at 2 as we skip the SOI marker
    let marker; // this will hold the current marker
    // resulting markers
    let res = undefined;
    while (offset < length) {
        // test if marker is valid JPEG marker (starts with ff)
        if (view.getUint8(offset) !== JPEG_MARKER_PREFIX)
            break;
        // let's read the full marker
        marker = view.getUint16(offset);
        // read marker if included in marker types, don't
        if (markerTypes.includes(marker)) {
            const key = Markers[marker];
            if (!res)
                res = {};
            // prevent overwriting by double markers
            if (!res[key]) {
                res[key] = {
                    offset,
                    size: view.getUint16(offset + 2),
                };
            }
        }
        // Image stream starts here, no markers found
        if (marker === SOS_MARKER)
            break;
        // next offset is 2 to skip over marker type and then we add marker data size to skip to next marker
        offset += 2 + view.getUint16(offset + 2);
    }
    // no APP markers found
    return res;
};

const APP1_MARKER = 0xffe1;
const APP1_EXIF_IDENTIFIER = 0x45786966;
const TIFF_MARKER = 0x002a;
const BYTE_ALIGN_MOTOROLA = 0x4d4d;
const BYTE_ALIGN_INTEL = 0x4949;
// offset = start of APP1_MARKER
var dataViewGetExifTags = (view, offset) => {
    // If no APP1 marker exit here because we're not going to find the EXIF id header outside of APP1
    if (view.getUint16(offset) !== APP1_MARKER)
        return undefined;
    // get marker size
    const size = view.getUint16(offset + 2); // 14197
    // Let's skip over app1 marker and size marker (2 + 2 bytes)
    offset += 4;
    // We're now at the EXIF header marker (we'll only check the first 4 bytes, reads "exif"), if not there, exit
    if (view.getUint32(offset) !== APP1_EXIF_IDENTIFIER)
        return undefined;
    // Let's skip over 6 byte EXIF marker
    offset += 6;
    // Read byte alignment
    let byteAlignment = view.getUint16(offset);
    if (byteAlignment !== BYTE_ALIGN_INTEL && byteAlignment !== BYTE_ALIGN_MOTOROLA)
        return undefined;
    const storedAsLittleEndian = byteAlignment === BYTE_ALIGN_INTEL;
    // Skip over byte alignment
    offset += 2;
    // Test if valid tiff marker data, should always be 0x002a
    if (view.getUint16(offset, storedAsLittleEndian) !== TIFF_MARKER)
        return undefined;
    // Skip to first IDF, position of IDF is read after tiff marker (offset 2)
    offset += view.getUint32(offset + 2, storedAsLittleEndian);
    // helper method to find tag offset by marker
    const getTagOffsets = (marker) => {
        let offsets = [];
        let i = offset;
        let max = offset + size - 16;
        for (; i < max; i += 12) {
            let tagOffset = i;
            // see if is match, if not, next entry
            if (view.getUint16(tagOffset, storedAsLittleEndian) !== marker)
                continue;
            // add offset
            offsets.push(tagOffset);
        }
        return offsets;
    };
    return {
        read: (address) => {
            const tagOffsets = getTagOffsets(address);
            if (!tagOffsets.length)
                return undefined;
            // only return first found tag
            return view.getUint16(tagOffsets[0] + 8, storedAsLittleEndian);
        },
        write: (address, value) => {
            const tagOffsets = getTagOffsets(address);
            if (!tagOffsets.length)
                return false;
            // overwrite all found tags (sometimes images can have multiple tags with the same value, let's make sure they're all set)
            tagOffsets.forEach((offset) => view.setUint16(offset + 8, value, storedAsLittleEndian));
            return true;
        },
    };
};

const ORIENTATION_TAG = 0x0112;
var arrayBufferImageExif = (data, key, value) => {
    // no data, no go!
    if (!data)
        return;
    const view = new DataView(data);
    // Get app1 header offset
    const markers = dataViewGetApplicationMarkers(view);
    if (!markers || !markers.exif)
        return;
    // Get EXIF tags read/writer
    const tags = dataViewGetExifTags(view, markers.exif.offset);
    if (!tags)
        return;
    // Read the exif orientation marker
    return value === undefined ? tags.read(key) : tags.write(key, value);
};

const backup = '__pqina_webapi__';
var getNativeAPIRef = (API) => (window$1[backup] ? window$1[backup][API] : window$1[API]);

var noop$1 = (...args) => { };

const FileReaderDataFormat = {
    ArrayBuffer: 'readAsArrayBuffer',
};
var readFile = (file, onprogress = noop$1, options = {}) => new Promise((resolve, reject) => {
    const { dataFormat = FileReaderDataFormat.ArrayBuffer } = options;
    const reader = new (getNativeAPIRef('FileReader'))();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.onprogress = onprogress;
    reader[dataFormat](file);
});

var blobReadSection = async (blob, slice = [0, blob.size], onprogress) => (await readFile(blob.slice(...slice), onprogress));

var getImageOrientationFromFile = async (file, onprogress) => {
    const head = await blobReadSection(file, [0, 64 * 1024], onprogress);
    return arrayBufferImageExif(head, ORIENTATION_TAG) || 1;
};

let result$b = null;
var isBrowser = () => {
    if (result$b === null)
        result$b = typeof window$1 !== 'undefined' && typeof window$1.document !== 'undefined';
    return result$b;
};

let result$a = null;
var canOrientImages = () => new Promise((resolve) => {
    if (result$a === null) {
        // 2x1 pixel image 90CW rotated with orientation EXIF header
        const testSrc = 'data:image/jpg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/4QA6RXhpZgAATU0AKgAAAAgAAwESAAMAAAABAAYAAAEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAD/2wBDAP//////////////////////////////////////////////////////////////////////////////////////wAALCAABAAIBASIA/8QAJgABAAAAAAAAAAAAAAAAAAAAAxABAAAAAAAAAAAAAAAAAAAAAP/aAAgBAQAAPwBH/9k=';
        let testImage = isBrowser() ? new Image() : {};
        testImage.onload = () => {
            // should correct orientation if is presented in landscape,
            // in which case the browser doesn't autocorrect
            result$a = testImage.naturalWidth === 1;
            testImage = undefined;
            resolve(result$a);
        };
        testImage.src = testSrc;
        return;
    }
    return resolve(result$a);
});

var canvasToImageData = (canvas) => {
    const imageData = canvas
        .getContext('2d')
        .getImageData(0, 0, canvas.width, canvas.height);
    return imageData;
};

var h$1 = (name, attributes, children = []) => {
    const el = document.createElement(name);
    // @ts-ignore
    const descriptors = Object.getOwnPropertyDescriptors(el.__proto__);
    for (const key in attributes) {
        if (key === 'style') {
            el.style.cssText = attributes[key];
        }
        else if ((descriptors[key] && descriptors[key].set) ||
            /textContent|innerHTML/.test(key) ||
            typeof attributes[key] === 'function') {
            el[key] = attributes[key];
        }
        else {
            el.setAttribute(key, attributes[key]);
        }
    }
    children.forEach((child) => el.appendChild(child));
    return el;
};

const MATRICES = {
    1: () => [1, 0, 0, 1, 0, 0],
    2: (width) => [-1, 0, 0, 1, width, 0],
    3: (width, height) => [-1, 0, 0, -1, width, height],
    4: (width, height) => [1, 0, 0, -1, 0, height],
    5: () => [0, 1, 1, 0, 0, 0],
    6: (width, height) => [0, 1, -1, 0, height, 0],
    7: (width, height) => [0, -1, -1, 0, height, width],
    8: (width) => [0, -1, 1, 0, 0, width],
};
var getImageOrientationMatrix = (width, height, orientation = -1) => {
    if (orientation === -1)
        orientation = 1;
    return MATRICES[orientation](width, height);
};

var releaseCanvas = (canvas) => {
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext('2d');
    ctx && ctx.clearRect(0, 0, 1, 1);
};

var isImageData = (obj) => 'data' in obj;

var imageDataToCanvas = async (imageData, orientation = 1) => {
    const [width, height] = (await canOrientImages()) || orientation < 5
        ? [imageData.width, imageData.height]
        : [imageData.height, imageData.width];
    const canvas = h$1('canvas', { width, height });
    const ctx = canvas.getContext('2d');
    // transform image data ojects into in memory canvas elements so we can transform them (putImageData isn't affect by transforms)
    if (isImageData(imageData) && !(await canOrientImages()) && orientation > 1) {
        const inMemoryCanvas = h$1('canvas', {
            width: imageData.width,
            height: imageData.height,
        });
        const ctx = inMemoryCanvas.getContext('2d');
        ctx.putImageData(imageData, 0, 0);
        imageData = inMemoryCanvas;
    }
    // get base transformation matrix
    if (!(await canOrientImages()) && orientation > 1) {
        ctx.transform.apply(ctx, getImageOrientationMatrix(imageData.width, imageData.height, orientation));
    }
    // can't test for instanceof ImageBitmap as Safari doesn't support it
    // if still imageData object by this point, we'll use put
    if (isImageData(imageData)) {
        ctx.putImageData(imageData, 0, 0);
    }
    else {
        ctx.drawImage(imageData, 0, 0);
    }
    // if image data is of type canvas, clean it up
    if (imageData instanceof HTMLCanvasElement)
        releaseCanvas(imageData);
    return canvas;
};

var orientImageData = async (imageData, orientation = 1) => {
    if (orientation === 1)
        return imageData;
    // correct image data for when the browser does not correctly read exif orientation headers
    if (!(await canOrientImages()))
        return canvasToImageData(await imageDataToCanvas(imageData, orientation));
    return imageData;
};

var isObject$1 = (v) => typeof v === 'object';

const copy$1 = (val) => (isObject$1(val) ? deepCopy(val) : val);
const deepCopy = (src) => {
    let dst;
    if (Array.isArray(src)) {
        dst = [];
        src.forEach((val, i) => {
            dst[i] = copy$1(val);
        });
    }
    else {
        dst = {};
        Object.keys(src).forEach((key) => {
            const val = src[key];
            dst[key] = copy$1(val);
        });
    }
    return dst;
};

var isString = (v) => typeof v === 'string';

var imageToCanvas = (image, canvasMemoryLimit) => {
    // if these are 0 it's possible that we're trying to convert an SVG that doesn't have width or height attributes
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1328124
    let canvasWidth = image.naturalWidth;
    let canvasHeight = image.naturalHeight;
    // determine if requires more memory than limit, if so limit target size
    const requiredCanvasMemory = canvasWidth * canvasHeight;
    if (canvasMemoryLimit && requiredCanvasMemory > canvasMemoryLimit) {
        const canvasScalar = Math.sqrt(canvasMemoryLimit) / Math.sqrt(requiredCanvasMemory);
        canvasWidth = Math.floor(canvasWidth * canvasScalar);
        canvasHeight = Math.floor(canvasHeight * canvasScalar);
    }
    // create new canvas element
    const canvas = h$1('canvas');
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(image, 0, 0, canvasWidth, canvasHeight);
    return canvas;
};

// turns image into canvas only after it's fully loaded
var imageToCanvasSafe = (image, canvasMemoryLimit) => new Promise((resolve, reject) => {
    const ready = () => resolve(imageToCanvas(image, canvasMemoryLimit));
    if (image.complete && image.width) {
        // need to test for image.width, on ie11 it will be 0 for object urls
        ready();
    }
    else {
        image.onload = ready;
        image.onerror = reject;
    }
});

var blobToCanvas = async (imageBlob, canvasMemoryLimit) => {
    const imageElement = h$1('img', { src: URL.createObjectURL(imageBlob) });
    const canvas = await imageToCanvasSafe(imageElement, canvasMemoryLimit);
    URL.revokeObjectURL(imageElement.src);
    return canvas;
};

var canCreateImageBitmap = () => 'createImageBitmap' in window$1;

var canCreateOffscreenCanvas = () => 'OffscreenCanvas' in window$1;

var isSVGFile = (blob) => /svg/.test(blob.type);

var getUniqueId = () => Math.random()
    .toString(36)
    .substr(2, 9);

var functionToBlob = (fn) => new Blob(['(', typeof fn === 'function' ? fn.toString() : fn, ')()'], {
    type: 'application/javascript',
});

const wrapFunction = (fn) => `function () {self.onmessage = function (message) {(${fn.toString()}).apply(null, message.data.content.concat([function (err, response) {
    response = response || {};
    const transfer = 'data' in response ? [response.data.buffer] : 'width' in response ? [response] : [];
    return self.postMessage({ id: message.data.id, content: response, error: err }, transfer);
}]))}}`;
const workerPool = new Map();
var thread = (fn, args, transferList) => new Promise((resolve, reject) => {
    let workerKey = fn.toString();
    let pooledWorker = workerPool.get(workerKey);
    if (!pooledWorker) {
        // create worker for this function
        const workerFn = wrapFunction(fn);
        // create a new web worker
        const url = URL.createObjectURL(functionToBlob(workerFn));
        const messages = new Map();
        const worker = new Worker(url);
        // create a pooled worker, this object will contain the worker and active messages
        pooledWorker = {
            url,
            worker,
            messages,
            terminate: () => {
                pooledWorker.worker.terminate();
                URL.revokeObjectURL(url);
            },
        };
        // handle received messages
        worker.onmessage = function (e) {
            // should receive message id and message
            const { id, content, error } = e.data;
            // message route no longer valid
            if (!messages.has(id))
                return;
            // get related thread and resolve with returned content
            const message = messages.get(id);
            // remove thread from threads cache
            messages.delete(id);
            // resolve or reject message based on response from worker
            error != null ? message.reject(error) : message.resolve(content);
        };
        // pool this worker
        workerPool.set(workerKey, pooledWorker);
    }
    // we need a way to remember this message so we generate a unique id and use that as a key for this request, that way we can link the response back to request in the pooledWorker.onmessage handler
    const messageId = getUniqueId();
    pooledWorker.messages.set(messageId, { resolve, reject });
    // use pooled worker and await response
    pooledWorker.worker.postMessage({ id: messageId, content: args }, transferList);
});

var blobToImageData = async (imageBlob, canvasMemoryLimit) => {
    let imageData;
    // if can use OffscreenCanvas let's go for it as it will mean we can run this operation on a separate thread
    if (canCreateImageBitmap() && !isSVGFile(imageBlob) && canCreateOffscreenCanvas()) {
        try {
            imageData = await thread((file, canvasMemoryLimit, done) => {
                createImageBitmap(file)
                    .then((bitmap) => {
                    let canvasWidth = bitmap.width;
                    let canvasHeight = bitmap.height;
                    // determine if requires more memory than limit, if so limit target size
                    const requiredCanvasMemory = canvasWidth * canvasHeight;
                    if (canvasMemoryLimit && requiredCanvasMemory > canvasMemoryLimit) {
                        const canvasScalar = Math.sqrt(canvasMemoryLimit) / Math.sqrt(requiredCanvasMemory);
                        canvasWidth = Math.floor(canvasWidth * canvasScalar);
                        canvasHeight = Math.floor(canvasHeight * canvasScalar);
                    }
                    const canvas = new OffscreenCanvas(canvasWidth, canvasHeight);
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(bitmap, 0, 0, canvasWidth, canvasHeight);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    done(null, imageData);
                })
                    .catch((err) => {
                    // fail silently
                    done(err);
                });
            }, [imageBlob, canvasMemoryLimit]);
        }
        catch (err) {
            // fails silently on purpose, we'll try to turn the blob into image data in the main thread
            // console.error(err);
        }
    }
    // use main thread to generate ImageData
    if (!imageData || !imageData.width) {
        const canvas = await blobToCanvas(imageBlob, canvasMemoryLimit);
        imageData = canvasToImageData(canvas);
        releaseCanvas(canvas);
    }
    return imageData;
};

var canvasToBlob = (canvas, mimeType = undefined, quality = undefined) => new Promise((resolve, reject) => {
    try {
        canvas.toBlob((blob) => {
            resolve(blob);
        }, mimeType, quality);
    }
    catch (err) {
        reject(err);
    }
});

var imageDataToBlob = async (imageData, mimeType, quality) => {
    try {
        const canvas = await imageDataToCanvas(imageData);
        const blob = await canvasToBlob(canvas, mimeType, quality);
        releaseCanvas(canvas);
        return blob;
    }
    catch (err) {
        throw err;
    }
};

var blobWriteSection = (blob, section, slice = [0, blob.size]) => {
    if (!section)
        return blob;
    return new Blob([section, blob.slice(...slice)], { type: blob.type });
};

var getExtensionFromMimeType = (mimeType) => (mimeType.match(/\/([a-z]+)/) || [])[1];

var getFilenameWithoutExtension = (name) => name.substr(0, name.lastIndexOf('.')) || name;

var getExtensionFromFilename = (filename) => filename.split('.').pop();

const ImageExtensionsRegex = /avif|bmp|gif|jpg|jpeg|jpe|jif|jfif|png|svg|tiff|webp/;
/*
Support image mime types
- image/webp
- image/gif
- image/avif
- image/jpeg
- image/png
- image/bmp
- image/svg+xml
*/
var getMimeTypeFromExtension = (ext) => {
    // empty string returned if extension not found
    if (!ImageExtensionsRegex.test(ext))
        return '';
    // return MimeType for this extension
    return 'image/' + (/jfif|jif|jpe|jpg/.test(ext) ? 'jpeg' : ext === 'svg' ? 'svg+xml' : ext);
};

var getMimeTypeFromFilename = (name) => name && getMimeTypeFromExtension(getExtensionFromFilename(name).toLowerCase());

var matchFilenameToMimeType = (filename, mimeType) => {
    // get the mime type that matches this extension
    const fileMimeType = getMimeTypeFromFilename(filename);
    // test if type already matches current mime type, no need to change name
    if (fileMimeType === mimeType)
        return filename;
    // get the extension for this mimetype (gets all characters after the "image/" part)
    // if mimeType doesn't yield an extension, use the fileMimeType
    const targetMimeTypeExtension = getExtensionFromMimeType(mimeType) || fileMimeType;
    return `${getFilenameWithoutExtension(filename)}.${targetMimeTypeExtension}`;
};

var blobToFile = (blob, filename, mimetype) => {
    const lastModified = new Date().getTime();
    const blobHasMimeType = blob.type.length && !/null|text/.test(blob.type);
    const blobMimeType = blobHasMimeType ? blob.type : mimetype;
    const name = matchFilenameToMimeType(filename, blobMimeType);
    try {
        return new (getNativeAPIRef('File'))([blob], name, {
            lastModified,
            type: blobHasMimeType ? blob.type : blobMimeType,
        });
    }
    catch (err) {
        const file = blobHasMimeType ? blob.slice() : blob.slice(0, blob.size, blobMimeType);
        file.lastModified = lastModified;
        file.name = name;
        return file;
    }
};

var getAspectRatio = (w, h) => w / h;

var passthrough = (v) => (v);

const PI = Math.PI;
const HALF_PI = Math.PI / 2;
const QUART_PI = HALF_PI / 2;

var isRotatedSideways = (a) => {
    const rotationLimited = Math.abs(a) % Math.PI;
    return rotationLimited > QUART_PI && rotationLimited < Math.PI - QUART_PI;
};

//
// generic
//
const scale = (value, scalar, pivot) => pivot + (value - pivot) * scalar;
const ellipseCreateFromRect = (rect) => ({
    x: rect.x + rect.width * 0.5,
    y: rect.y + rect.height * 0.5,
    rx: rect.width * 0.5,
    ry: rect.height * 0.5,
});
//
// vector
//
const vectorCreateEmpty = () => vectorCreate(0, 0);
const vectorCreate = (x, y) => ({ x, y });
const vectorCreateFromSize = (size) => vectorCreate(size.width, size.height);
const vectorCreateFromPointerEvent = (e) => vectorCreate(e.pageX, e.pageY);
const vectorCreateFromPointerEventOffset = (e) => vectorCreate(e.offsetX, e.offsetY);
const vectorClone = (v) => vectorCreate(v.x, v.y);
const vectorInvert = (v) => {
    v.x = -v.x;
    v.y = -v.y;
    return v;
};
const vectorPerpendicular = (v) => {
    const x = v.x;
    v.x = -v.y;
    v.y = x;
    return v;
};
const vectorRotate = (v, radians, pivot = vectorCreateEmpty()) => {
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const tx = v.x - pivot.x;
    const ty = v.y - pivot.y;
    v.x = pivot.x + cos * tx - sin * ty;
    v.y = pivot.y + sin * tx + cos * ty;
    return v;
};
const vectorLength = (v) => Math.sqrt(v.x * v.x + v.y * v.y);
const vectorNormalize = (v) => {
    const length = Math.sqrt(v.x * v.x + v.y * v.y);
    if (length === 0)
        return vectorCreateEmpty();
    v.x /= length;
    v.y /= length;
    return v;
};
const vectorAngle = (v) => Math.atan2(v.y, v.x);
const vectorAngleBetween = (a, b) => Math.atan2(b.y - a.y, b.x - a.x);
const vectorEqual = (a, b) => a.x === b.x && a.y === b.y;
const vectorApply = (v, fn) => {
    v.x = fn(v.x);
    v.y = fn(v.y);
    return v;
};
const vectorAdd = (a, b) => {
    a.x += b.x;
    a.y += b.y;
    return a;
};
const vectorSubtract = (a, b) => {
    a.x -= b.x;
    a.y -= b.y;
    return a;
};
const vectorMultiply = (v, f) => {
    v.x *= f;
    v.y *= f;
    return v;
};
const vectorDot = (a, b) => a.x * b.x + a.y * b.y;
const vectorDistanceSquared = (a, b = vectorCreateEmpty()) => {
    const x = a.x - b.x;
    const y = a.y - b.y;
    return x * x + y * y;
};
const vectorDistance = (a, b = vectorCreateEmpty()) => Math.sqrt(vectorDistanceSquared(a, b));
const vectorCenter = (v) => {
    let x = 0;
    let y = 0;
    v.forEach((v) => {
        x += v.x;
        y += v.y;
    });
    return vectorCreate(x / v.length, y / v.length);
};
const vectorsFlip = (points, flipX, flipY, cx, cy) => {
    points.forEach((point) => {
        point.x = flipX ? cx - (point.x - cx) : point.x;
        point.y = flipY ? cy - (point.y - cy) : point.y;
    });
    return points;
};
const vectorsRotate = (points, angle, cx, cy) => {
    const s = Math.sin(angle);
    const c = Math.cos(angle);
    points.forEach((p) => {
        p.x -= cx;
        p.y -= cy;
        const rx = p.x * c - p.y * s;
        const ry = p.x * s + p.y * c;
        p.x = cx + rx;
        p.y = cy + ry;
    });
    return points;
};
//
// size
//
const toSize = (width, height) => ({ width, height });
const sizeClone = (size) => toSize(size.width, size.height);
const sizeCreateFromAny = (obj) => toSize(obj.width, obj.height);
const sizeCreateFromRect = (r) => toSize(r.width, r.height);
const sizeCreateFromArray = (a) => toSize(a[0], a[1]);
const sizeCreateFromImageNaturalSize = (image) => toSize(image.naturalWidth, image.naturalHeight);
const sizeCreateFromElement = (element) => {
    if (/img/i.test(element.nodeName)) {
        return sizeCreateFromImageNaturalSize(element);
    }
    return sizeCreateFromAny(element);
};
const sizeCreate = (width, height) => toSize(width, height);
const sizeEqual = (a, b, format = passthrough) => format(a.width) === format(b.width) && format(a.height) === format(b.height);
const sizeScale = (size, scalar) => {
    size.width *= scalar;
    size.height *= scalar;
    return size;
};
const sizeCenter = (size) => vectorCreate(size.width * 0.5, size.height * 0.5);
const sizeRotate = (size, radians) => {
    const r = Math.abs(radians);
    const cos = Math.cos(r);
    const sin = Math.sin(r);
    const w = cos * size.width + sin * size.height;
    const h = sin * size.width + cos * size.height;
    size.width = w;
    size.height = h;
    return size;
};
const sizeTurn = (size, radians) => {
    const w = size.width;
    const h = size.height;
    if (isRotatedSideways(radians)) {
        size.width = h;
        size.height = w;
    }
    return size;
};
const sizeContains = (a, b) => a.width >= b.width && a.height >= b.height;
const sizeApply = (size, fn) => {
    size.width = fn(size.width);
    size.height = fn(size.height);
    return size;
};
const sizeHypotenuse = (size) => Math.sqrt(size.width * size.width + size.height * size.height);
const sizeMin = (a, b) => sizeCreate(Math.min(a.width, b.width), Math.min(a.height, b.height));
//
// line
//
const lineCreate = (start, end) => ({ start, end });
const lineClone = (line) => lineCreate(vectorClone(line.start), vectorClone(line.end));
const lineExtend = (line, amount) => {
    if (amount === 0)
        return line;
    const v = vectorCreate(line.start.x - line.end.x, line.start.y - line.end.y);
    const n = vectorNormalize(v);
    const m = vectorMultiply(n, amount);
    line.start.x += m.x;
    line.start.y += m.y;
    line.end.x -= m.x;
    line.end.y -= m.y;
    return line;
};
const lineMultiply = (line, amount) => {
    if (amount === 0)
        return line;
    const v = vectorCreate(line.start.x - line.end.x, line.start.y - line.end.y);
    const n = vectorNormalize(v);
    const m = vectorMultiply(n, amount);
    line.end.x += m.x;
    line.end.y += m.y;
    return line;
};
const lineExtrude = ({ start, end }, amount) => {
    if (amount === 0)
        return [
            vectorCreate(start.x, start.y),
            vectorCreate(start.x, start.y),
            vectorCreate(end.x, end.y),
            vectorCreate(end.x, end.y),
        ];
    const a = Math.atan2(end.y - start.y, end.x - start.x);
    const sina = Math.sin(a) * amount;
    const cosa = Math.cos(a) * amount;
    return [
        vectorCreate(sina + start.x, -cosa + start.y),
        vectorCreate(-sina + start.x, cosa + start.y),
        vectorCreate(-sina + end.x, cosa + end.y),
        vectorCreate(sina + end.x, -cosa + end.y),
    ];
};
//
// rect
//
const CornerSigns = [
    vectorCreate(-1, -1),
    vectorCreate(-1, 1),
    vectorCreate(1, 1),
    vectorCreate(1, -1),
];
const toRect = (x, y, width, height) => ({
    x,
    y,
    width,
    height,
});
const rectClone = (rect) => toRect(rect.x, rect.y, rect.width, rect.height);
const rectCreateEmpty = () => toRect(0, 0, 0, 0);
const rectCreateFromDimensions = (width, height) => toRect(0, 0, width, height);
const rectCreateFromSize = (size) => toRect(0, 0, size.width, size.height);
const rectCreateFromAny = (obj) => toRect(obj.x || 0, obj.y || 0, obj.width || 0, obj.height || 0);
const rectCreateFromPoints = (...args) => {
    const pts = Array.isArray(args[0]) ? args[0] : args;
    let xMin = pts[0].x;
    let xMax = pts[0].x;
    let yMin = pts[0].y;
    let yMax = pts[0].y;
    pts.forEach((point) => {
        xMin = Math.min(xMin, point.x);
        xMax = Math.max(xMax, point.x);
        yMin = Math.min(yMin, point.y);
        yMax = Math.max(yMax, point.y);
    });
    return toRect(xMin, yMin, xMax - xMin, yMax - yMin);
};
const rectCreateFromEllipse = (ellipse) => rectCreate(ellipse.x - ellipse.rx, ellipse.y - ellipse.ry, ellipse.rx * 2, ellipse.ry * 2);
const rectCreateWithCenter = (center, size) => toRect(center.x - size.width * 0.5, center.y - size.height * 0.5, size.width, size.height);
const rectCreate = (x, y, width, height) => toRect(x, y, width, height);
const rectCenter = (rect) => vectorCreate(rect.x + rect.width * 0.5, rect.y + rect.height * 0.5);
const rectTranslate = (rect, t) => {
    rect.x += t.x;
    rect.y += t.y;
    return rect;
};
const rectScale = (rect, scalar, pivot) => {
    pivot = pivot || rectCenter(rect);
    rect.x = scalar * (rect.x - pivot.x) + pivot.x;
    rect.y = scalar * (rect.y - pivot.y) + pivot.y;
    rect.width = scalar * rect.width;
    rect.height = scalar * rect.height;
    return rect;
};
const rectMultiply = (rect, factor) => {
    rect.x *= factor;
    rect.y *= factor;
    rect.width *= factor;
    rect.height *= factor;
    return rect;
};
const rectDivide = (rect, factor) => {
    rect.x /= factor;
    rect.y /= factor;
    rect.width /= factor;
    rect.height /= factor;
    return rect;
};
const rectSubtract = (a, b) => {
    a.x -= b.x;
    a.y -= b.y;
    a.width -= b.width;
    a.height -= b.height;
    return a;
};
const rectAdd = (a, b) => {
    a.x += b.x;
    a.y += b.y;
    a.width += b.width;
    a.height += b.height;
    return a;
};
const rectEqual = (a, b, format = passthrough) => format(a.x) === format(b.x) &&
    format(a.y) === format(b.y) &&
    format(a.width) === format(b.width) &&
    format(a.height) === format(b.height);
const rectAspectRatio = (rect) => getAspectRatio(rect.width, rect.height);
const rectUpdate = (rect, x, y, width, height) => {
    rect.x = x;
    rect.y = y;
    rect.width = width;
    rect.height = height;
    return rect;
};
const rectUpdateWithRect = (a, b) => {
    a.x = b.x;
    a.y = b.y;
    a.width = b.width;
    a.height = b.height;
    return a;
};
const rectRotate = (rect, radians, pivot) => {
    if (!pivot)
        pivot = rectCenter(rect);
    return rectGetCorners(rect).map((vertex) => vectorRotate(vertex, radians, pivot));
};
const rectCenterRect = (a, b) => toRect(a.width * 0.5 - b.width * 0.5, a.height * 0.5 - b.height * 0.5, b.width, b.height);
const rectContainsPoint = (rect, point) => {
    if (point.x < rect.x)
        return false;
    if (point.y < rect.y)
        return false;
    if (point.x > rect.x + rect.width)
        return false;
    if (point.y > rect.y + rect.height)
        return false;
    return true;
};
const rectCoverRect = (rect, aspectRatio, offset = vectorCreateEmpty()) => {
    if (rect.width === 0 || rect.height === 0)
        return rectCreateEmpty();
    const inputAspectRatio = rectAspectRatio(rect);
    if (!aspectRatio)
        aspectRatio = inputAspectRatio;
    let width = rect.width;
    let height = rect.height;
    if (aspectRatio > inputAspectRatio) {
        // height remains the same, width is expanded
        width = height * aspectRatio;
    }
    else {
        // width remains the same, height is expanded
        height = width / aspectRatio;
    }
    return toRect(offset.x + (rect.width - width) * 0.5, offset.y + (rect.height - height) * 0.5, width, height);
};
const rectContainRect = (rect, aspectRatio = rectAspectRatio(rect), offset = vectorCreateEmpty()) => {
    if (rect.width === 0 || rect.height === 0)
        return rectCreateEmpty();
    let width = rect.width;
    let height = width / aspectRatio;
    if (height > rect.height) {
        height = rect.height;
        width = height * aspectRatio;
    }
    return toRect(offset.x + (rect.width - width) * 0.5, offset.y + (rect.height - height) * 0.5, width, height);
};
const rectToBounds = (rect) => [
    Math.min(rect.y, rect.y + rect.height),
    Math.max(rect.x, rect.x + rect.width),
    Math.max(rect.y, rect.y + rect.height),
    Math.min(rect.x, rect.x + rect.width),
];
const rectGetCorners = (rect) => [
    vectorCreate(rect.x, rect.y),
    vectorCreate(rect.x + rect.width, rect.y),
    vectorCreate(rect.x + rect.width, rect.y + rect.height),
    vectorCreate(rect.x, rect.y + rect.height),
];
const rectApply = (rect, fn) => {
    if (!rect)
        return;
    rect.x = fn(rect.x);
    rect.y = fn(rect.y);
    rect.width = fn(rect.width);
    rect.height = fn(rect.height);
    return rect;
};
const rectApplyPerspective = (rect, perspective, pivot = rectCenter(rect)) => rectGetCorners(rect).map((corner, index) => {
    const sign = CornerSigns[index];
    return vectorCreate(scale(corner.x, 1.0 + sign.x * perspective.x, pivot.x), scale(corner.y, 1.0 + sign.y * perspective.y, pivot.y));
});
const rectNormalizeOffset = (rect) => {
    rect.x = 0;
    rect.y = 0;
    return rect;
};
const convexPolyCentroid = (vertices) => {
    const first = vertices[0];
    const last = vertices[vertices.length - 1];
    // make sure is closed loop
    vertices = vectorEqual(first, last) ? vertices : [...vertices, first];
    let twiceArea = 0;
    let i = 0;
    let x = 0;
    let y = 0;
    let fx = first.x;
    let fy = first.y;
    let a;
    let b;
    let f;
    const l = vertices.length;
    for (; i < l; i++) {
        // current vertex
        a = vertices[i];
        // next vertex
        b = vertices[i + 1 > l - 1 ? 0 : i + 1];
        f = (a.y - fy) * (b.x - fx) - (b.y - fy) * (a.x - fx);
        twiceArea += f;
        x += (a.x + b.x - 2 * fx) * f;
        y += (a.y + b.y - 2 * fy) * f;
    }
    f = twiceArea * 3;
    return vectorCreate(fx + x / f, fy + y / f);
};
const lineLineIntersection = (a, b) => getLineLineIntersectionPoint(a.start, a.end, b.start, b.end);
const getLineLineIntersectionPoint = (a, b, c, d) => {
    const denominator = (d.y - c.y) * (b.x - a.x) - (d.x - c.x) * (b.y - a.y);
    // lines are parallel
    if (denominator === 0)
        return undefined;
    const uA = ((d.x - c.x) * (a.y - c.y) - (d.y - c.y) * (a.x - c.x)) / denominator;
    const uB = ((b.x - a.x) * (a.y - c.y) - (b.y - a.y) * (a.x - c.x)) / denominator;
    // intersection is not on the line itself
    if (uA < 0 || uA > 1 || uB < 0 || uB > 1)
        return undefined;
    // return intersection point
    return vectorCreate(a.x + uA * (b.x - a.x), a.y + uA * (b.y - a.y));
};
// checks if line intersects with one of the lines that can be drawn between the points (in sequence)
const linePointsIntersection = (line, points) => {
    const l = points.length;
    const intersections = [];
    for (let i = 0; i < l - 1; i++) {
        const intersection = getLineLineIntersectionPoint(line.start, line.end, points[i], points[i + 1]);
        if (!intersection)
            continue;
        intersections.push(intersection);
    }
    return intersections.length ? intersections : undefined;
};
// tests if a point is located in a convex polygon
const pointInPoly = (point, vertices) => {
    let i;
    let a;
    let b;
    let aX;
    let aY;
    let bX;
    let bY;
    let edgeX;
    let edgeY;
    let d;
    const l = vertices.length;
    for (i = 0; i < l; i++) {
        // current vertex
        a = vertices[i];
        // next vertex
        b = vertices[i + 1 > l - 1 ? 0 : i + 1];
        // translate so that point is the origin of the calculation
        aX = a.x - point.x;
        aY = a.y - point.y;
        bX = b.x - point.x;
        bY = b.y - point.y;
        edgeX = aX - bX;
        edgeY = aY - bY;
        d = edgeX * aY - edgeY * aX;
        // 0 is ON the edge, but we check for -0.00001 to fix floating point errors
        if (d < -0.00001)
            return false;
    }
    return true;
};
// first tests if points of a are to be found in b, then does the reverse
const polyIntersectsWithPoly = (a, b) => !!(a.find((point) => pointInPoly(point, b)) || b.find((point) => pointInPoly(point, a)));
const quadLines = (vertices) => {
    const arr = [];
    for (let i = 0; i < vertices.length; i++) {
        let next = i + 1;
        if (next === vertices.length)
            next = 0;
        arr.push(lineCreate(vectorClone(vertices[i]), vectorClone(vertices[next])));
    }
    return arr;
};
const ellipseToPolygon = (center, rx, ry, rotation = 0, flipX = false, flipY = false, resolution = 12) => {
    const points = [];
    for (let i = 0; i < resolution; i++) {
        points.push(vectorCreate(center.x + rx * Math.cos((i * (Math.PI * 2)) / resolution), center.y + ry * Math.sin((i * (Math.PI * 2)) / resolution)));
    }
    if (flipX || flipY)
        vectorsFlip(points, flipX, flipY, center.x, center.y);
    if (rotation)
        vectorsRotate(points, rotation, center.x, center.y);
    return points;
};

var getImageTransformedRect = (imageSize, imageRotation) => {
    const imageRect = rectCreateFromSize(imageSize);
    const imageCenter = rectCenter(imageRect);
    const imageTransformedVertices = rectRotate(imageRect, imageRotation, imageCenter);
    return rectNormalizeOffset(rectCreateFromPoints(imageTransformedVertices));
};

var isElement = (v, name) => v instanceof HTMLElement && (name ? new RegExp(`^${name}$`, 'i').test(v.nodeName) : true);

var isFile = (v) => v instanceof File;

var canvasToFile = async (canvas, mimeType, quality) => {
    const blob = await canvasToBlob(canvas, mimeType, quality);
    return blobToFile(blob, 'canvas');
};

var getFilenameFromURL = (url) => url
    .split('/')
    .pop()
    .split(/\?|\#/)
    .shift();

let isSafari = null;
var isSafari$1 = () => {
    if (isSafari === null)
        isSafari = isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    return isSafari;
};

var getImageElementSize = (imageElement) => new Promise((resolve, reject) => {
    let shouldAutoRemove = false;
    // test if image is attached to DOM, if not attached, attach so measurement is correct on Safari
    if (!imageElement.parentNode && isSafari$1()) {
        shouldAutoRemove = true;
        // has width 0 and height 0 to prevent rendering very big SVGs (without width and height) that will for one frame overflow the window and show a scrollbar
        imageElement.style.cssText = `position:absolute;visibility:hidden;pointer-events:none;left:0;top:0;width:0;height:0;`;
        document.body.appendChild(imageElement);
    }
    // start testing size
    const measure = () => {
        const width = imageElement.naturalWidth;
        const height = imageElement.naturalHeight;
        const hasSize = width && height;
        if (!hasSize)
            return;
        // clean up image if was attached for measuring
        if (shouldAutoRemove)
            imageElement.parentNode.removeChild(imageElement);
        clearInterval(intervalId);
        resolve({ width, height });
    };
    imageElement.onerror = (err) => {
        clearInterval(intervalId);
        reject(err);
    };
    const intervalId = setInterval(measure, 1);
    measure();
});

var getImageSize = async (image) => {
    // the image element we'll use to load the image
    let imageElement = image;
    // if is not an image element, it must be a valid image source
    if (!imageElement.src) {
        imageElement = new Image();
        imageElement.src = isString(image) ? image : URL.createObjectURL(image);
    }
    let size;
    try {
        size = await getImageElementSize(imageElement);
    }
    finally {
        isFile(image) && URL.revokeObjectURL(imageElement.src);
    }
    return size;
};

const awaitComplete = (image) => new Promise((resolve, reject) => {
    if (image.complete)
        return resolve(image);
    image.onload = () => resolve(image);
    image.onerror = reject;
});
var imageToFile = async (imageElement) => {
    try {
        const size = await getImageSize(imageElement);
        const image = await awaitComplete(imageElement);
        const canvas = document.createElement('canvas');
        canvas.width = size.width;
        canvas.height = size.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(image, 0, 0);
        const blob = await canvasToBlob(canvas);
        return blobToFile(blob, getFilenameFromURL(image.src));
    }
    catch (err) {
        throw err;
    }
};

var isDataURI = (str) => /^data:/.test(str);

var createProgressEvent = (loaded = 0, lengthComputable = true) => new (getNativeAPIRef('ProgressEvent'))('progress', {
    loaded: loaded * 100,
    total: 100,
    lengthComputable,
});

var isImage = (file) => /^image/.test(file.type);

var dataURIToFile = async (dataURI, filename = 'data-uri', onprogress = noop$1) => {
    // basic loader, no size info
    onprogress(createProgressEvent(0));
    const res = await fetch(dataURI);
    onprogress(createProgressEvent(0.33));
    const blob = await res.blob();
    let mimeType;
    if (!isImage(blob))
        mimeType = `image/${dataURI.includes(',/9j/') ? 'jpeg' : 'png'}`;
    onprogress(createProgressEvent(0.66));
    const file = blobToFile(blob, filename, mimeType);
    onprogress(createProgressEvent(1));
    return file;
};

var getResponseHeader = (xhr, header, parse = (header) => header) => xhr.getAllResponseHeaders().indexOf(header) >= 0
    ? parse(xhr.getResponseHeader(header))
    : undefined;

var getFilenameFromContentDisposition = (header) => {
    if (!header)
        return null;
    const matches = header.split(/filename=|filename\*=.+''/)
        .splice(1)
        .map(name => name.trim().replace(/^["']|[;"']{0,2}$/g, ''))
        .filter(name => name.length);
    return matches.length ? decodeURI(matches[matches.length - 1]) : null;
};

const EditorErrorCode = {
    URL_REQUEST: 'URL_REQUEST',
    DOCTYPE_MISSING: 'DOCTYPE_MISSING',
};
class EditorError extends Error {
    constructor(message, code, metadata) {
        super(message);
        this.name = 'EditorError';
        this.code = code;
        this.metadata = metadata;
    }
}

var fetchFile = (url, onprogress) => new Promise((resolve, reject) => {
    const handleError = () => reject(new EditorError('Error fetching image', EditorErrorCode.URL_REQUEST, xhr));
    const xhr = new XMLHttpRequest();
    xhr.onprogress = onprogress;
    (xhr.onerror = handleError),
        (xhr.onload = () => {
            if (!xhr.response || xhr.status >= 300 || xhr.status < 200)
                return handleError();
            // we store the response mime type so we can add it to the blob later on, if it's missing (happens on Safari 10)
            const mimetype = getResponseHeader(xhr, 'Content-Type');
            // try to get filename and any file instructions as well
            const filename = getResponseHeader(xhr, 'Content-Disposition', getFilenameFromContentDisposition) || getFilenameFromURL(url);
            // convert to actual file if possible
            resolve(blobToFile(xhr.response, filename, mimetype || getMimeTypeFromFilename(filename)));
        });
    xhr.open('GET', url);
    xhr.responseType = 'blob';
    xhr.send();
});

var urlToFile = (url, onprogress) => {
    // use fetch to create blob from data uri
    if (isDataURI(url))
        return dataURIToFile(url, undefined, onprogress);
    // load file from url
    return fetchFile(url, onprogress);
};

var isBlob = (v) => v instanceof Blob && !(v instanceof File);

var srcToFile = async (src, onprogress) => {
    if (isFile(src) || isBlob(src))
        return src;
    else if (isString(src))
        return await urlToFile(src, onprogress);
    else if (isElement(src, 'canvas'))
        return await canvasToFile(src);
    else if (isElement(src, 'img'))
        return await imageToFile(src);
    else {
        throw new EditorError('Invalid image source', 'invalid-image-source');
    }
};

let result$9 = null;
var isMac = () => {
    if (result$9 === null)
        result$9 = isBrowser() && /^mac/i.test(navigator.platform);
    return result$9;
};

var isUserAgent = (test) => (isBrowser() ? RegExp(test).test(window$1.navigator.userAgent) : undefined);

let result$8 = null;
var isIOS = () => {
    if (result$8 === null)
        // first part is for iPhones and iPads iOS 12 and below second part is for iPads with iOS 13 and up
        result$8 =
            isBrowser() &&
                (isUserAgent(/iPhone|iPad|iPod/) || (isMac() && navigator.maxTouchPoints >= 1));
    return result$8;
};

var orientImageSize = async (size, orientation = 1) => {
    // browser can handle image orientation
    if ((await canOrientImages()) || isIOS())
        return size;
    // no need to correct size
    if (orientation < 5)
        return size;
    // correct image size
    return sizeCreate(size.height, size.width);
};

var isJPEG = (file) => /jpeg/.test(file.type);

var isPlainObject$1 = (obj) => typeof obj == 'object' && obj.constructor == Object;

var stringify = (value) => (!isPlainObject$1(value) ? value : JSON.stringify(value));

var post = (url, dataset, options) => new Promise((resolve, reject) => {
    const { token = {}, beforeSend = noop$1, onprogress = noop$1 } = options;
    token.cancel = () => request.abort();
    const request = new XMLHttpRequest();
    request.upload.onprogress = onprogress;
    request.onload = () => request.status >= 200 && request.status < 300 ? resolve(request) : reject(request);
    request.onerror = () => reject(request);
    request.ontimeout = () => reject(request);
    request.open('POST', encodeURI(url));
    beforeSend(request);
    request.send(dataset.reduce((formData, args) => {
        // @ts-ignore
        formData.append(...args.map(stringify));
        return formData;
    }, new FormData()));
});

var ctxRotate = (ctx, rotation = 0, pivot) => {
    if (rotation === 0)
        return ctx;
    ctx.translate(pivot.x, pivot.y);
    ctx.rotate(rotation);
    ctx.translate(-pivot.x, -pivot.y);
    return ctx;
};

var ctxTranslate = (ctx, x, y) => {
    ctx.translate(x, y);
    return ctx;
};

var ctxScale = (ctx, x, y) => {
    ctx.scale(x, y);
    return ctx;
};

var cropImageData = async (imageData, options = {}) => {
    const { flipX, flipY, rotation, crop } = options;
    const imageSize = sizeCreateFromAny(imageData);
    const shouldFlip = flipX || flipY;
    const shouldRotate = !!rotation;
    const cropDefined = crop && (crop.x || crop.y || crop.width || crop.height);
    const cropCoversImage = cropDefined && rectEqual(crop, rectCreateFromSize(imageSize));
    const shouldCrop = cropDefined && !cropCoversImage;
    // skip!
    if (!shouldFlip && !shouldRotate && !shouldCrop)
        return imageData;
    // create drawing context
    let imageDataOut;
    let image = h$1('canvas', {
        width: imageData.width,
        height: imageData.height,
    });
    image.getContext('2d').putImageData(imageData, 0, 0);
    // flip image data
    if (shouldFlip) {
        const ctx = h$1('canvas', {
            width: image.width,
            height: image.height,
        }).getContext('2d');
        ctxScale(ctx, flipX ? -1 : 1, flipY ? -1 : 1);
        ctx.drawImage(image, flipX ? -image.width : 0, flipY ? -image.height : 0);
        ctx.restore();
        releaseCanvas(image);
        image = ctx.canvas;
    }
    // rotate image data
    if (shouldRotate) {
        // if shouldRotate is true we also receive a crop rect
        const outputSize = sizeApply(sizeCreateFromRect(rectCreateFromPoints(rectRotate(rectCreateFromAny(image), rotation))), Math.floor);
        const ctx = h$1('canvas', {
            width: crop.width,
            height: crop.height,
        }).getContext('2d');
        ctxTranslate(ctx, -crop.x, -crop.y);
        ctxRotate(ctx, rotation, sizeCenter(outputSize));
        ctx.drawImage(image, (outputSize.width - image.width) * 0.5, (outputSize.height - image.height) * 0.5);
        ctx.restore();
        releaseCanvas(image);
        image = ctx.canvas;
    }
    // crop image data
    else if (shouldCrop) {
        const ctx = image.getContext('2d');
        imageDataOut = ctx.getImageData(crop.x, crop.y, crop.width, crop.height);
        releaseCanvas(image);
        return imageDataOut;
    }
    // done, return resulting image data
    const ctx = image.getContext('2d');
    imageDataOut = ctx.getImageData(0, 0, image.width, image.height);
    releaseCanvas(image);
    return imageDataOut;
};

var resizeTransform = (options, done) => {
    const { imageData, width, height } = options;
    const originWidth = imageData.width;
    const originHeight = imageData.height;
    const targetWidth = Math.round(width);
    const targetHeight = Math.round(height);
    const inputData = imageData.data;
    const outputData = new Uint8ClampedArray(targetWidth * targetHeight * 4);
    const ratioWidth = originWidth / targetWidth;
    const ratioHeight = originHeight / targetHeight;
    const ratioWidthHalf = Math.ceil(ratioWidth * 0.5);
    const ratioHeightHalf = Math.ceil(ratioHeight * 0.5);
    for (let j = 0; j < targetHeight; j++) {
        for (let i = 0; i < targetWidth; i++) {
            const x2 = (i + j * targetWidth) * 4;
            let weight = 0;
            let weights = 0;
            let weightsAlpha = 0;
            let r = 0;
            let g = 0;
            let b = 0;
            let a = 0;
            const centerY = (j + 0.5) * ratioHeight;
            for (let yy = Math.floor(j * ratioHeight); yy < (j + 1) * ratioHeight; yy++) {
                const dy = Math.abs(centerY - (yy + 0.5)) / ratioHeightHalf;
                const centerX = (i + 0.5) * ratioWidth;
                const w0 = dy * dy;
                for (let xx = Math.floor(i * ratioWidth); xx < (i + 1) * ratioWidth; xx++) {
                    let dx = Math.abs(centerX - (xx + 0.5)) / ratioWidthHalf;
                    const w = Math.sqrt(w0 + dx * dx);
                    if (w >= -1 && w <= 1) {
                        weight = 2 * w * w * w - 3 * w * w + 1;
                        if (weight > 0) {
                            dx = 4 * (xx + yy * originWidth);
                            const ref = inputData[dx + 3];
                            a += weight * ref;
                            weightsAlpha += weight;
                            if (ref < 255) {
                                weight = (weight * ref) / 250;
                            }
                            r += weight * inputData[dx];
                            g += weight * inputData[dx + 1];
                            b += weight * inputData[dx + 2];
                            weights += weight;
                        }
                    }
                }
            }
            outputData[x2] = r / weights;
            outputData[x2 + 1] = g / weights;
            outputData[x2 + 2] = b / weights;
            outputData[x2 + 3] = a / weightsAlpha;
        }
    }
    done(null, {
        data: outputData,
        width: targetWidth,
        height: targetHeight,
    });
};

var imageDataObjectToImageData = (obj) => {
    if (obj instanceof ImageData) {
        return obj;
    }
    let imageData;
    try {
        imageData = new ImageData(obj.width, obj.height);
    }
    catch (err) {
        // IE + Old EDGE (tested on 12)
        const canvas = h$1('canvas');
        imageData = canvas.getContext('2d').createImageData(obj.width, obj.height);
    }
    imageData.data.set(obj.data);
    return imageData;
};

var resizeImageData = async (imageData, options = {}) => {
    const { width, height, fit, upscale } = options;
    // no need to rescale
    if (!width && !height)
        return imageData;
    let targetWidth = width;
    let targetHeight = height;
    if (!width) {
        targetWidth = height;
    }
    else if (!height) {
        targetHeight = width;
    }
    if (fit !== 'force') {
        let scalarWidth = targetWidth / imageData.width;
        let scalarHeight = targetHeight / imageData.height;
        let scalar = 1;
        if (fit === 'cover') {
            scalar = Math.max(scalarWidth, scalarHeight);
        }
        else if (fit === 'contain') {
            scalar = Math.min(scalarWidth, scalarHeight);
        }
        // if image is too small, exit here with original image
        if (scalar > 1 && upscale === false)
            return imageData;
        targetWidth = Math.round(imageData.width * scalar);
        targetHeight = Math.round(imageData.height * scalar);
    }
    // no need to resize?
    if (imageData.width === targetWidth && imageData.height === targetHeight)
        return imageData;
    // let's resize!
    imageData = await thread(resizeTransform, [{ imageData: imageData, width: targetWidth, height: targetHeight }], [imageData.data.buffer]);
    // the resizer returns a plain object, not an actual image data object, lets create one
    return imageDataObjectToImageData(imageData);
};

var colorEffect = (options, done) => {
    const { imageData, matrix } = options;
    if (!matrix)
        return done(null, imageData);
    const outputData = new Uint8ClampedArray(imageData.width * imageData.height * 4);
    const data = imageData.data;
    const l = data.length;
    const m11 = matrix[0];
    const m12 = matrix[1];
    const m13 = matrix[2];
    const m14 = matrix[3];
    const m15 = matrix[4];
    const m21 = matrix[5];
    const m22 = matrix[6];
    const m23 = matrix[7];
    const m24 = matrix[8];
    const m25 = matrix[9];
    const m31 = matrix[10];
    const m32 = matrix[11];
    const m33 = matrix[12];
    const m34 = matrix[13];
    const m35 = matrix[14];
    const m41 = matrix[15];
    const m42 = matrix[16];
    const m43 = matrix[17];
    const m44 = matrix[18];
    const m45 = matrix[19];
    let index = 0;
    let r = 0.0;
    let g = 0.0;
    let b = 0.0;
    let a = 0.0;
    let mr = 0.0;
    let mg = 0.0;
    let mb = 0.0;
    let ma = 0.0;
    let or = 0.0;
    let og = 0.0;
    let ob = 0.0;
    for (; index < l; index += 4) {
        r = data[index] / 255;
        g = data[index + 1] / 255;
        b = data[index + 2] / 255;
        a = data[index + 3] / 255;
        mr = r * m11 + g * m12 + b * m13 + a * m14 + m15;
        mg = r * m21 + g * m22 + b * m23 + a * m24 + m25;
        mb = r * m31 + g * m32 + b * m33 + a * m34 + m35;
        ma = r * m41 + g * m42 + b * m43 + a * m44 + m45;
        or = Math.max(0, mr * ma) + (1.0 - ma);
        og = Math.max(0, mg * ma) + (1.0 - ma);
        ob = Math.max(0, mb * ma) + (1.0 - ma);
        outputData[index] = Math.max(0.0, Math.min(1.0, or)) * 255;
        outputData[index + 1] = Math.max(0.0, Math.min(1.0, og)) * 255;
        outputData[index + 2] = Math.max(0.0, Math.min(1.0, ob)) * 255;
        outputData[index + 3] = a * 255;
    }
    done(null, {
        data: outputData,
        width: imageData.width,
        height: imageData.height,
    });
};

var convolutionEffect = (options, done) => {
    const { imageData, matrix } = options;
    if (!matrix)
        return done(null, imageData);
    // calculate kernel weight
    let kernelWeight = matrix.reduce((prev, curr) => prev + curr);
    // input info
    const inputWidth = imageData.width;
    const inputHeight = imageData.height;
    const inputData = imageData.data;
    let i = 0;
    let x = 0;
    let y = 0;
    const side = Math.round(Math.sqrt(matrix.length));
    const sideHalf = Math.floor(side / 2);
    let r = 0, g = 0, b = 0, a = 0, cx = 0, cy = 0, scy = 0, scx = 0, srcOff = 0, weight = 0;
    const outputData = new Uint8ClampedArray(inputWidth * inputHeight * 4);
    for (y = 0; y < inputHeight; y++) {
        for (x = 0; x < inputWidth; x++) {
            // calculate the weighed sum of the source image pixels that
            // fall under the convolution matrix
            r = 0;
            g = 0;
            b = 0;
            a = 0;
            for (cy = 0; cy < side; cy++) {
                for (cx = 0; cx < side; cx++) {
                    scy = y + cy - sideHalf;
                    scx = x + cx - sideHalf;
                    if (scy < 0 || scy >= inputHeight || scx < 0 || scx >= inputWidth)
                        continue;
                    srcOff = (scy * inputWidth + scx) * 4;
                    weight = matrix[cy * side + cx];
                    r += inputData[srcOff] * weight;
                    g += inputData[srcOff + 1] * weight;
                    b += inputData[srcOff + 2] * weight;
                    a += inputData[srcOff + 3] * weight;
                }
            }
            outputData[i] = r / kernelWeight;
            outputData[i + 1] = g / kernelWeight;
            outputData[i + 2] = b / kernelWeight;
            outputData[i + 3] = a / kernelWeight;
            i += 4;
        }
    }
    done(null, {
        data: outputData,
        width: inputWidth,
        height: inputHeight,
    });
};

var vignetteEffect = (options, done) => {
    let { imageData, strength } = options;
    if (!strength)
        return done(null, imageData);
    const outputData = new Uint8ClampedArray(imageData.width * imageData.height * 4);
    const inputWidth = imageData.width;
    const inputHeight = imageData.height;
    const inputData = imageData.data;
    const dist = (x, y) => {
        dx = x - cx;
        dy = y - cy;
        return Math.sqrt(dx * dx + dy * dy);
    };
    let x = 0;
    let y = 0;
    let cx = inputWidth * 0.5;
    let cy = inputHeight * 0.5;
    let dx;
    let dy;
    let dm = dist(0, 0);
    let fr, fg, fb;
    let br, bg, bb, ba;
    let fa;
    let ca;
    const blend = (index, input, output, alpha) => {
        br = input[index] / 255;
        bg = input[index + 1] / 255;
        bb = input[index + 2] / 255;
        ba = input[index + 3] / 255;
        fa = 1.0 - alpha;
        ca = fa * ba + alpha;
        output[index] = ((fa * ba * br + alpha * fr) / ca) * 255;
        output[index + 1] = ((fa * ba * bg + alpha * fg) / ca) * 255;
        output[index + 2] = ((fa * ba * bb + alpha * fb) / ca) * 255;
        output[index + 3] = ca * 255;
    };
    if (strength > 0) {
        fr = 0;
        fg = 0;
        fb = 0;
    }
    else {
        strength = Math.abs(strength);
        fr = 1;
        fg = 1;
        fb = 1;
    }
    for (y = 0; y < inputHeight; y++) {
        for (x = 0; x < inputWidth; x++) {
            blend(
            // index
            (x + y * inputWidth) * 4, 
            // data in
            inputData, 
            // data out
            outputData, 
            // opacity
            (dist(x, y) * strength) / dm);
        }
    }
    done(null, {
        data: outputData,
        width: imageData.width,
        height: imageData.height,
    });
};

var noiseEffect = (options, done) => {
    const { imageData, level, monochrome = false } = options;
    if (!level)
        return done(null, imageData);
    const outputData = new Uint8ClampedArray(imageData.width * imageData.height * 4);
    const data = imageData.data;
    const l = data.length;
    let index = 0;
    let r;
    let g;
    let b;
    const rand = () => (-1 + Math.random() * 2) * 255 * level;
    const pixel = monochrome
        ? () => {
            const average = rand();
            return [average, average, average];
        }
        : () => {
            return [rand(), rand(), rand()];
        };
    for (; index < l; index += 4) {
        [r, g, b] = pixel();
        outputData[index] = data[index] + r;
        outputData[index + 1] = data[index + 1] + g;
        outputData[index + 2] = data[index + 2] + b;
        outputData[index + 3] = data[index + 3];
    }
    done(null, {
        data: outputData,
        width: imageData.width,
        height: imageData.height,
    });
};

var gammaEffect = (options, done) => {
    const { imageData, level } = options;
    if (!level)
        return done(null, imageData);
    const outputData = new Uint8ClampedArray(imageData.width * imageData.height * 4);
    const data = imageData.data;
    const l = data.length;
    let index = 0;
    let r;
    let g;
    let b;
    for (; index < l; index += 4) {
        r = data[index] / 255;
        g = data[index + 1] / 255;
        b = data[index + 2] / 255;
        outputData[index] = Math.pow(r, level) * 255;
        outputData[index + 1] = Math.pow(g, level) * 255;
        outputData[index + 2] = Math.pow(b, level) * 255;
        outputData[index + 3] = data[index + 3];
    }
    done(null, {
        data: outputData,
        width: imageData.width,
        height: imageData.height,
    });
};

var isIdentityMatrix = (matrix) => {
    /*
    [
        1, 0, 0, 0, 0
        0, 1, 0, 0, 0
        0, 0, 1, 0, 0
        0, 0, 0, 1, 0
    ]
    */
    const l = matrix.length;
    let v;
    let s = l >= 20 ? 6 : l >= 16 ? 5 : 3;
    for (let i = 0; i < l; i++) {
        v = matrix[i];
        if (v === 1 && i % s !== 0)
            return false;
        else if (v !== 0 && v !== 1)
            return false;
    }
    return true;
};

var filterImageData = async (imageData, options = {}) => {
    const { colorMatrix, convolutionMatrix, gamma: gammaLevel, noise: noiseLevel, vignette: vignetteStrength, } = options;
    // filters
    const filters = [];
    // apply convolution matrix
    if (convolutionMatrix) {
        filters.push([convolutionEffect, { matrix: convolutionMatrix.clarity }]);
    }
    // apply noise
    if (gammaLevel > 0) {
        filters.push([gammaEffect, { level: 1.0 / gammaLevel }]);
    }
    // apply color matrix
    if (colorMatrix && !isIdentityMatrix(colorMatrix)) {
        filters.push([colorEffect, { matrix: colorMatrix }]);
    }
    // apply noise
    if (noiseLevel > 0 || noiseLevel < 0) {
        filters.push([noiseEffect, { level: noiseLevel }]);
    }
    // apply vignette
    if (vignetteStrength > 0 || vignetteStrength < 0) {
        filters.push([vignetteEffect, { strength: vignetteStrength }]);
    }
    // no changes
    if (!filters.length)
        return imageData;
    // builds effect chain
    const chain = (transforms, i) => `(err, imageData) => {
            (${transforms[i][0].toString()})(Object.assign({ imageData: imageData }, filterInstructions[${i}]), 
                ${transforms[i + 1] ? chain(transforms, i + 1) : 'done'})
        }`;
    const filterChain = `function (options, done) {
        const filterInstructions = options.filterInstructions;
        const imageData = options.imageData;
        (${chain(filters, 0)})(null, imageData)
    }`;
    imageData = await thread(filterChain, [
        {
            imageData: imageData,
            filterInstructions: filters.map((t) => t[1]),
        },
    ], [imageData.data.buffer]);
    // the resizer returns a plain object, not an actual image data object, lets create one
    return imageDataObjectToImageData(imageData);
};

var isNumber$1 = (v) => typeof v === 'number';

var isEmoji = (str) => isString(str) &&
    str.match(/(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff]|[\u0023-\u0039]\ufe0f?\u20e3|\u3299|\u3297|\u303d|\u3030|\u24c2|\ud83c[\udd70-\udd71]|\ud83c[\udd7e-\udd7f]|\ud83c\udd8e|\ud83c[\udd91-\udd9a]|\ud83c[\udde6-\uddff]|\ud83c[\ude01-\ude02]|\ud83c\ude1a|\ud83c\ude2f|\ud83c[\ude32-\ude3a]|\ud83c[\ude50-\ude51]|\u203c|\u2049|[\u25aa-\u25ab]|\u25b6|\u25c0|[\u25fb-\u25fe]|\u00a9|\u00ae|\u2122|\u2139|\ud83c\udc04|[\u2600-\u26FF]|\u2b05|\u2b06|\u2b07|\u2b1b|\u2b1c|\u2b50|\u2b55|\u231a|\u231b|\u2328|\u23cf|[\u23e9-\u23f3]|[\u23f8-\u23fa]|\ud83c\udccf|\u2934|\u2935|[\u2190-\u21ff])/g) !== null;

var hasProp = (obj, key) => obj.hasOwnProperty(key);

var isFunction$1 = (v) => typeof v === 'function';

var isArray = (arr) => Array.isArray(arr);

var isApple = () => isIOS() || isMac();

var isWindows = () => /^win/i.test(navigator.platform);

// macos:   font-size: 123, x: 63.5, y: 110
// windows: font-size: 112, x: 64, y: 103
// android: font-size: 112, x: 64, y: 102
let x$2 = 64;
let y$1 = 102;
let fontSize = 112;
let hasSetValues = false;
var getEmojiSVG = (emoji, alt) => {
    if (!hasSetValues && isBrowser()) {
        if (isWindows())
            y$1 = 103;
        if (isApple()) {
            x$2 = 63.5;
            y$1 = 110;
            fontSize = 123;
        }
        hasSetValues = true;
    }
    return `<svg${alt ? ` aria-label="${alt}"` : ''} width="128" height="128" viewBox="0 0 128 128" preserveAspectRatio="xMinYMin meet" xmlns="http://www.w3.org/2000/svg"><text x="${x$2}" y="${y$1}" alignment-baseline="text-top" dominant-baseline="text-top" text-anchor="middle" font-size="${fontSize}px">${emoji}</text></svg>`;
};

var SVGToDataURL = (svg) => `data:image/svg+xml,${svg.replace('<', '%3C').replace('>', '%3E')}`;

var isBinary = (v) => v instanceof Blob;

var toPercentage = (value, total) => `${(value / total) * 100}%`;

var colorArrayToRGBA = (color) => `rgba(${Math.round(color[0] * 255)}, ${Math.round(color[1] * 255)}, ${Math.round(color[2] * 255)}, ${isNumber$1(color[3]) ? color[3] : 1})`;

const textPadding = 20;
// font offset
// font size 16 -> 2, 4
// font size 32 -> 4, 6
// font size 64 -> 8, 12
// font size 128 -> 16, 24
// font size 256 -> 32, 48
let fontOffsetBrowser = undefined;
const getBrowserFontOffset = (fontSize) => {
    if (!fontOffsetBrowser) {
        // size
        const size = 32;
        // let's calculate it
        const ctx = createSimpleContext(size, size);
        updateTextContext(ctx, { fontSize: 100, color: '#fff' });
        ctx.fillText('F', 0, 0);
        // get pixel data so we can find the white pixels
        const data = ctx.getImageData(0, 0, size, size).data;
        // find x offset
        let p = 0;
        let step = 4;
        let to = data.length;
        let from = to - size * 4;
        for (p = from; p < to; p += step) {
            if (data[p])
                break;
        }
        const x = (p - from) / step;
        // find y offset
        from = (size - 1) * 4;
        step = size * 4;
        for (p = from; p < to; p += step) {
            if (data[p])
                break;
        }
        const y = (p - from) / step;
        fontOffsetBrowser = vectorCreate(x, y);
        // done with canvas
        releaseCanvas(ctx.canvas);
    }
    return vectorCreate(-fontOffsetBrowser.x * fontSize * 0.01, -fontOffsetBrowser.y * fontSize * 0.01);
};
const createSimpleContext = (width = 1, height = 1) => {
    const canvas = h$1('canvas');
    const ctx = canvas.getContext('2d');
    ctx.canvas.width = width;
    ctx.canvas.height = height;
    return ctx;
};
const updateTextContext = (ctx, options) => {
    const { fontSize = 16, fontFamily = 'sans-serif', fontWeight = 'normal', fontVariant = 'normal', fontStyle = 'normal', textAlign = 'left', color = '#000', } = options;
    ctx.font = `${fontStyle} ${fontVariant} ${fontWeight} ${fontSize}px ${fontFamily}`;
    ctx.textBaseline = 'top';
    ctx.textAlign = textAlign;
    ctx.fillStyle = Array.isArray(color) ? colorArrayToRGBA(color) : color;
};
const createSimpleTextContext = (options) => {
    const ctx = createSimpleContext();
    updateTextContext(ctx, options);
    return ctx;
};
const computeLineHeight = (fontSize, lineHeight) => isFunction$1(lineHeight) ? lineHeight(fontSize) : lineHeight;
const getMeasureVisibleWidth = (measure) => Math.abs(measure.actualBoundingBoxLeft) + Math.abs(measure.actualBoundingBoxRight);
const resizeContextToFitText = (ctx, text, options) => {
    const { width, height } = measureTextContext(ctx, text, computeLineHeight(options.fontSize, options.lineHeight));
    ctx.canvas.width = Math.ceil(width);
    ctx.canvas.height = Math.ceil(height);
    return ctx;
};
const measureTextContext = (ctx, text, computedLineHeight) => {
    const storedTextAlign = ctx.textAlign;
    ctx.textAlign = 'left';
    // calculate width
    const lines = text.split('\n');
    const width = lines.reduce((prev, curr) => {
        const lineWidth = getMeasureVisibleWidth(ctx.measureText(curr));
        if (lineWidth > prev) {
            prev = lineWidth;
        }
        return prev;
    }, 1);
    ctx.textAlign = storedTextAlign;
    // calculate height
    const height = computedLineHeight * lines.length;
    return sizeCreate(Math.ceil(width), Math.ceil(height));
};
const TextSizeCache = new Map();
const createTextSizeHash = (text, { fontSize, fontFamily, lineHeight, fontWeight, fontStyle, fontVariant }) => `${[text, fontSize, fontWeight, fontStyle, fontVariant, fontFamily].join('_')}_${isFunction$1(lineHeight) ? lineHeight(fontSize) : lineHeight}`;
const textSize = (text, options) => {
    const ctx = createSimpleTextContext(options);
    if (options.width)
        text = wrapText(ctx, text, options.width);
    const hash = createTextSizeHash(text, options);
    let size = TextSizeCache.get(hash);
    if (size)
        return { ...size };
    size = measureTextContext(ctx, text, computeLineHeight(options.fontSize, options.lineHeight));
    TextSizeCache.set(hash, size);
    return { ...size };
};
const wrapText = (ctx, text, lineWidth) => {
    // exit if no text
    if (text.length === 0)
        return '';
    const res = [];
    let lineBuffer = '';
    let lineIndex = 0;
    let measureWidth;
    const paragraphs = text.split('\n\n');
    // draw the current line
    const pushLine = () => {
        if (!lineBuffer.length)
            return;
        if (!res[lineIndex]) {
            res[lineIndex] = [];
        }
        res[lineIndex].push(lineBuffer);
        // clear buffer
        lineBuffer = '';
    };
    const fitChar = (char) => {
        const testLine = lineBuffer + char;
        // measure width of entire line if adding these chars
        measureWidth = ctx.measureText(testLine).width;
        // fits on line?
        if (measureWidth < lineWidth) {
            lineBuffer = testLine;
        }
        else {
            // doesn't fit but line buffer is empty, just print the character and move to next line
            if (!lineBuffer.length) {
                lineBuffer = testLine;
                pushLine();
            }
            // fits, lets print current line and move char to next line
            else {
                pushLine();
                lineBuffer = char;
            }
            lineIndex++;
        }
    };
    const fitWord = (word) => {
        const testLine = lineBuffer.length ? lineBuffer + ' ' + word : word;
        // measure width of entire line if adding these chars
        measureWidth = ctx.measureText(testLine).width;
        // fits on line?
        if (measureWidth < lineWidth) {
            lineBuffer = testLine;
        }
        // wrap to next line
        else {
            // if line buffer is empty, whole word doesn't fit, need to cut it up
            if (!lineBuffer.length) {
                word.split('').forEach(fitChar);
            }
            // there are words in the buffer that do fit, let's draw the line and move this word to the next line
            else {
                // draw current buffer
                pushLine();
                lineIndex++;
                // retry to fit this word
                fitWord(word);
            }
        }
    };
    paragraphs.forEach((p) => {
        const lines = p.split('\n');
        lines.forEach((l) => {
            l.split(' ').forEach(fitWord);
            // end of line reached, if we have words in our buffer
            // at this point we need to draw them and then move to the next line
            if (lineBuffer.length)
                pushLine();
            // forced new line
            lineIndex++;
        });
        // forced new line
        lineIndex++;
    });
    return res.map((line) => line.join(' ')).join('\n');
};
const drawText$1 = (ctx, text = '', options = {}) => {
    // exit if no text
    if (text.length === 0)
        return ctx;
    const { x = 0, y = 0, lineWidth = 0, textAlign, fontSize, lineHeight } = options;
    // determine where the browser will render the font and correct for browser differences
    const browserFontOffset = vectorAdd(getBrowserFontOffset(fontSize), vectorCreate(fontSize / 12, fontSize / 3.75));
    const fontOffsetX = x + browserFontOffset.x;
    const fontOffsetY = y + browserFontOffset.y;
    const lineHeightComputed = isFunction$1(lineHeight) ? lineHeight(fontSize) : lineHeight;
    let offset = textAlign === 'right' ? lineWidth : textAlign === 'center' ? lineWidth * 0.5 : 0;
    text.split('\n').forEach((line, i) => {
        ctx.fillText(line, fontOffsetX + offset, fontOffsetY + i * lineHeightComputed);
    });
    return ctx;
};

var fixPrecision = (value, precision = 12) => parseFloat(value.toFixed(precision));

const shapeEqual = (a, b) => {
    return JSON.stringify(a) === JSON.stringify(b);
};
const shapeDeepCopy = (shape) => {
    const shapeShallowCopy = { ...shape };
    const shapeDeepCopy = deepCopy(shapeShallowCopy);
    return shapeDeepCopy;
};
const getContextSize = (context, size = {}) => {
    const contextAspectRatio = rectAspectRatio(context);
    let xOut;
    let yOut;
    const xIn = size.width || size.rx;
    const yIn = size.height || size.ry;
    if (xIn && yIn)
        return sizeClone(size);
    if (xIn || yIn) {
        xOut = parseFloat(xIn || Number.MAX_SAFE_INTEGER);
        yOut = parseFloat(yIn || Number.MAX_SAFE_INTEGER);
        const min = Math.min(xOut, yOut);
        if (isString(xIn) || isString(yIn)) {
            xOut = `${min}%`;
            yOut = `${min * contextAspectRatio}%`;
        }
        else {
            xOut = min;
            yOut = min;
        }
    }
    else {
        const min = 10;
        xOut = `${min}%`;
        yOut = `${min * contextAspectRatio}%`;
    }
    const xProp = size.width ? 'width' : size.rx ? 'rx' : undefined;
    const yProp = size.width ? 'height' : size.rx ? 'ry' : undefined;
    return {
        [xProp || 'width']: xOut,
        [yProp || 'height']: yOut,
    };
};
const shapeCreateFromEmoji = (emoji, props = {}) => {
    return {
        width: undefined,
        height: undefined,
        ...props,
        aspectRatio: 1,
        backgroundImage: SVGToDataURL(getEmojiSVG(emoji)),
    };
};
const shapeCreateFromImage = (src, shapeProps = {}) => {
    const shapeDefaultLayout = shapeIsEllipse(shapeProps)
        ? {}
        : {
            width: undefined,
            height: undefined,
            aspectRatio: undefined,
        };
    const shape = {
        // required/default image shape props
        backgroundColor: [0, 0, 0, 0],
        // set default layout props
        ...shapeDefaultLayout,
        // merge with custom props
        ...shapeProps,
        // set image
        backgroundImage: 
        // is svg or URL
        isString(src) ? src : isBinary(src) ? URL.createObjectURL(src) : src,
    };
    return shape;
};
const shapeCreateFromPreset = (preset, parentRect) => {
    let shape;
    if (isString(preset) || isBinary(preset)) {
        // default props for "quick" preset
        const shapeOptions = {
            ...getContextSize(parentRect),
            backgroundSize: 'contain',
        };
        // if is emoji, create default markup,
        if (isEmoji(preset)) {
            shape = shapeCreateFromEmoji(preset, shapeOptions);
        }
        // is URL, create default markup for image
        else {
            shape = shapeCreateFromImage(preset, shapeOptions);
        }
    }
    else {
        // is using src shortcut
        if (preset.src) {
            const contextSize = getContextSize(parentRect, preset.shape || preset);
            // shape options
            const shapeOptions = {
                // default shape styles
                ...preset.shape,
                // precalcualte size of shape in context
                ...contextSize,
            };
            // should auto-fix aspect ratio
            if (preset.width && preset.height && !hasProp(shapeOptions, 'aspectRatio')) {
                const width = shapeGetPropPixelValue(contextSize, 'width', parentRect);
                const height = shapeGetPropPixelValue(contextSize, 'height', parentRect);
                shapeOptions.aspectRatio = getAspectRatio(width, height);
            }
            // should auto-contain sticker in container
            if (!shapeOptions.backgroundSize && !preset.shape && (!preset.width || !preset.height))
                shapeOptions.backgroundSize = 'contain';
            // emoji markup
            if (isEmoji(preset.src)) {
                shape = shapeCreateFromEmoji(preset.src, shapeOptions);
            }
            // is url
            else {
                shape = shapeCreateFromImage(preset.src, shapeOptions);
            }
        }
        // should have markup defined
        else if (preset.shape) {
            shape = shapeDeepCopy(preset.shape);
        }
    }
    if (hasProp(shape, 'backgroundImage')) {
        // set transparent background if no background color defined
        if (!hasProp(shape, 'backgroundColor')) {
            shape.backgroundColor = [0, 0, 0, 0];
        }
        // for image presets, disable styles by default
        if (!hasProp(shape, 'disableStyle')) {
            shape.disableStyle = ['backgroundColor', 'strokeColor', 'strokeWidth'];
        }
        // by default don't allow flipping
        if (!hasProp(shape, 'disableFlip')) {
            shape.disableFlip = true;
        }
    }
    return parentRect ? shapeComputeDisplay(shape, parentRect) : shape;
};
const shapeLineGetStartPoint = (line) => vectorCreate(line.x1, line.y1);
const shapeLineGetEndPoint = (line) => vectorCreate(line.x2, line.y2);
const shapeTextUID = ({ text, textAlign, fontSize, fontFamily, lineHeight, fontWeight, fontStyle, fontVariant, }) => `${[text, textAlign, fontSize, fontWeight, fontStyle, fontVariant, fontFamily].join('_')}_${isFunction$1(lineHeight) ? lineHeight(fontSize) : lineHeight}`;
//#endregion
//#region shape testing
// shape types
const shapeIsText = (shape) => hasProp(shape, 'text');
const shapeIsTextLine = (shape) => shapeIsText(shape) && !(shapeHasRelativeSize(shape) || hasProp(shape, 'width'));
const shapeIsTextBox = (shape) => shapeIsText(shape) && (shapeHasRelativeSize(shape) || hasProp(shape, 'width'));
const shapeIsRect = (shape) => !shapeIsText(shape) && shapeHasComputedSize(shape);
const shapeIsEllipse = (shape) => hasProp(shape, 'rx');
const shapeIsLine = (shape) => hasProp(shape, 'x1') && !shapeIsTriangle(shape);
const shapeIsTriangle = (shape) => hasProp(shape, 'x3');
const shapeIsPath = (shape) => hasProp(shape, 'points');
// shape state
const shapeIsTextEmpty = (shape) => shapeIsText(shape) && !shape.text.length;
const shapeIsTextEditing = (shape) => shapeIsText(shape) && shape.isEditing;
const shapeIsVisible = (shape) => hasProp(shape, 'opacity') ? shape.opacity > 0 : true;
const shapeIsSelected = (shape) => shape.isSelected;
const shapeIsDraft = (shape) => shape._isDraft;
const shapeHasSize = (shape) => hasProp(shape, 'width') && hasProp(shape, 'height');
const shapeHasNumericStroke = (shape) => isNumber$1(shape.strokeWidth) && shape.strokeWidth > 0; // only relevant if is bigger than 0
const shapeHasRelativePosition = (shape) => {
    const hasRight = hasProp(shape, 'right');
    const hasBottom = hasProp(shape, 'bottom');
    return hasRight || hasBottom;
};
const shapeHasTexture = (shape) => hasProp(shape, 'backgroundImage') || hasProp(shape, 'text');
const shapeHasRelativeSize = (shape) => ((hasProp(shape, 'x') || hasProp(shape, 'left')) && hasProp(shape, 'right')) ||
    ((hasProp(shape, 'y') || hasProp(shape, 'top')) && hasProp(shape, 'bottom'));
const shapeHasComputedSize = (shape) => shapeHasSize(shape) || shapeHasRelativeSize(shape);
// actions
const shapeSelect = (shape) => {
    shape.isSelected = true;
    return shape;
};
const shapeMakeDraft = (shape) => {
    shape._isDraft = true;
    return shape;
};
const shapeMakeFinal = (shape) => {
    shape._isDraft = false;
    return shape;
};
// rights
const shapeCanStyle = (shape, style) => {
    if (shape.disableStyle === true)
        return false;
    if (isArray(shape.disableStyle) && style) {
        return !shape.disableStyle.includes(style);
    }
    return true;
};
const shapeCanSelect = (shape) => shape.disableSelect !== true && !shapeIsPath(shape) && !shapeIsTriangle(shape);
const shapeCanRemove = (shape) => shape.disableRemove !== true;
const shapeCanDuplicate = (shape) => shape.disableDuplicate !== true && shapeCanMove(shape);
const shapeCanReorder = (shape) => shape.disableReorder !== true;
const shapeCanFlip = (shape) => {
    if (shape.disableFlip)
        return false;
    if (shapeIsDraft(shape) || shapeHasRelativePosition(shape))
        return false;
    return shapeHasTexture(shape);
};
const shapeCanInput = (shape, input) => {
    if (!shapeIsText(shape))
        return false;
    if (shape.disableInput === true)
        return false;
    if (isFunction$1(shape.disableInput))
        return shape.disableInput(input != null ? input : shape.text);
    return input || true;
};
const shapeCanChangeTextLayout = (shape, layout) => {
    if (shape.disableTextLayout === true)
        return false;
    if (isArray(shape.disableTextLayout) && layout) {
        return !shape.disableTextLayout.includes(layout);
    }
    return true;
};
const shapeCanManipulate = (shape) => shape.disableManipulate !== true && !shapeIsDraft(shape) && !shapeHasRelativePosition(shape);
const shapeCanMove = (shape) => shapeCanManipulate(shape) && shape.disableMove !== true && !shapeIsPath(shape);
const shapeCanResize = (shape) => shapeCanManipulate(shape) &&
    shapeCanMove(shape) &&
    shape.disableResize !== true &&
    (shapeHasSize(shape) || shapeIsTextBox(shape) || shapeIsEllipse(shape) || shapeIsLine(shape));
const shapeCanRotate = (shape) => shapeCanManipulate(shape) &&
    shape.disableRotate !== true &&
    (shapeHasSize(shape) || hasProp(shape, 'text') || shapeIsEllipse(shape));
//#endregion
//#region shape formatting
const shapeDeleteRelativeProps = (shape) => {
    delete shape.left;
    delete shape.right;
    delete shape.top;
    delete shape.bottom;
    return shape;
};
const shapeDeleteTransformProps = (shape) => {
    delete shape.rotation;
    return shape;
};
const shapeFormatStroke = (shape) => {
    shape.strokeWidth = shape.strokeWidth || 1;
    shape.strokeColor = shape.strokeColor || [0, 0, 0];
    return shape;
};
const shapeFormatFill = (shape) => {
    shape.backgroundColor = shape.backgroundColor
        ? shape.backgroundColor
        : shape.strokeWidth || shape.backgroundImage
            ? undefined
            : [0, 0, 0];
    return shape;
};
const autoLineHeight = (fontSize) => fontSize * 1.2;
const shapeFormatText = (shape) => {
    shape.fontSize = shape.fontSize || 16;
    shape.fontFamily = shape.fontFamily || 'sans-serif';
    shape.fontWeight = shape.fontWeight || 'normal';
    shape.fontStyle = shape.fontStyle || 'normal';
    shape.fontVariant = shape.fontVariant || 'normal';
    shape.lineHeight = isNumber$1(shape.lineHeight) ? shape.lineHeight : autoLineHeight;
    shape.color = shape.color || [0, 0, 0];
    return shapeIsTextLine(shape) ? shapeFormatTextLine(shape) : shapeFormatTextBox(shape);
};
const shapeFormatTextLine = (shape) => {
    delete shape.textAlign;
    return shapeDeleteRelativeProps(shape);
};
const shapeFormatTextBox = (shape) => {
    shape.textAlign = shape.textAlign || 'left';
    return shape;
};
const shapeFormatRect = (shape) => {
    shape.cornerRadius = shape.cornerRadius || 0;
    shape.strokeWidth = shape.strokeWidth || 0;
    shape.strokeColor = shape.strokeColor || [0, 0, 0];
    return shapeFormatFill(shape);
};
const shapeFormatTriangle = (shape) => {
    shape.strokeWidth = shape.strokeWidth || 0;
    shape.strokeColor = shape.strokeColor || [0, 0, 0];
    shapeFormatFill(shape);
    return shapeDeleteRelativeProps(shape);
};
const shapeFormatEllipse = (shape) => {
    shape.strokeWidth = shape.strokeWidth || 0;
    shape.strokeColor = shape.strokeColor || [0, 0, 0];
    return shapeFormatFill(shape);
};
const shapeFormatPath = (shape) => {
    shapeFormatStroke(shape);
    shapeDeleteTransformProps(shape);
    return shapeDeleteRelativeProps(shape);
};
const shapeFormatLine = (shape) => {
    shapeFormatStroke(shape);
    shape.lineStart = shape.lineStart || undefined;
    shape.lineEnd = shape.lineEnd || undefined;
    shapeDeleteTransformProps(shape);
    return shapeDeleteRelativeProps(shape);
};
const shapeFormatDefaults = (shape) => {
    if (!isString(shape.id))
        shape.id = getUniqueId();
    if (!hasProp(shape, 'rotation'))
        shape.rotation = 0;
    if (!hasProp(shape, 'opacity'))
        shape.opacity = 1;
    if (!hasProp(shape, 'disableErase'))
        shape.disableErase = true;
};
const shapeFormat = (shape) => {
    shapeFormatDefaults(shape);
    if (shapeIsText(shape)) {
        shapeFormatText(shape);
    }
    else if (shapeIsRect(shape)) {
        shapeFormatRect(shape);
    }
    else if (shapeIsPath(shape)) {
        shapeFormatPath(shape);
    }
    else if (shapeIsLine(shape)) {
        shapeFormatLine(shape);
    }
    else if (shapeIsEllipse(shape)) {
        shapeFormatEllipse(shape);
    }
    else if (shapeIsTriangle(shape)) {
        shapeFormatTriangle(shape);
    }
    return shape;
};
const shapeGetDescription = (shape) => {
    if (shapeIsText(shape)) {
        return 'text';
    }
    else if (shapeIsRect(shape)) {
        return 'rectangle';
    }
    else if (shapeIsPath(shape)) {
        return 'path';
    }
    else if (shapeIsLine(shape)) {
        return 'line';
    }
    else if (shapeIsEllipse(shape)) {
        return 'ellipse';
    }
    else if (shapeIsTriangle(shape)) {
        return 'triangle';
    }
    return;
};
//#endregion
const toPixelValue = (percentage, total) => (parseFloat(percentage) / 100) * total;
//#region shape transforming
const xRegExp = new RegExp(/^x|left|^width|rx|fontSize|cornerRadius|strokeWidth/, 'i');
const yRegExp = new RegExp(/^y|top|^height|ry/, 'i');
const rightRegExp = new RegExp(/right/, 'i');
const bottomRegExp = new RegExp(/bottom/, 'i');
const compute = (key, value, { width, height }) => {
    // handle array of percentage values
    if (Array.isArray(value)) {
        return value.map((v) => {
            if (isObject$1(v)) {
                // update the object itself
                computeProps(v, { width, height });
            }
            return v;
        });
    }
    // no need to compute (test with typeof instead of for perf)
    if (typeof value !== 'string')
        return value;
    if (!value.endsWith('%'))
        return value;
    const f = parseFloat(value) / 100;
    if (xRegExp.test(key))
        return fixPrecision(width * f, 6);
    if (yRegExp.test(key))
        return fixPrecision(height * f, 6);
    if (rightRegExp.test(key))
        return fixPrecision(width - width * f, 6);
    if (bottomRegExp.test(key))
        return fixPrecision(height - height * f, 6);
    // dont auto-compute
    return value;
};
const computeProps = (obj, size) => {
    return Object.entries(obj).map(([key, value]) => {
        obj[key] = compute(key, value, size);
    });
};
const shapeComputeDisplay = (shape, parentRect) => {
    computeProps(shape, parentRect);
    shapeComputeRect(shape, parentRect);
    return shape;
};
const shapeGetPropPixelTotal = (prop, parentRect) => {
    let total;
    if (/^x|width|rx|fontSize|strokeWidth|cornerRadius/.test(prop)) {
        total = parentRect.width;
    }
    else if (/^y|height|ry/.test(prop)) {
        total = parentRect.height;
    }
    return total;
};
const shapeUpdateProp = (shape, prop, value, parentRect) => {
    if (!isString(shape[prop])) {
        shape[prop] = value;
        return shape;
    }
    const total = shapeGetPropPixelTotal(prop, parentRect);
    shape[prop] = total === undefined ? value : toPercentage(value, total);
    return shape;
};
const shapeGetPropPixelValue = (shape, prop, parentRect) => {
    if (!isString(shape[prop]))
        return shape[prop];
    return toPixelValue(shape[prop], shapeGetPropPixelTotal(prop, parentRect));
};
const shapeGetPropsPixelValues = (shape, props, parentRect) => {
    return props.reduce((prev, prop) => {
        const value = shapeGetPropPixelValue(shape, prop, parentRect);
        prev[prop] = value;
        return prev;
    }, {});
};
const shapeUpdateProps = (shape, props, parentRect) => {
    Object.keys(props).forEach((key) => shapeUpdateProp(shape, key, props[key], parentRect));
    return shape;
};
const shapeBounds = (shape) => {
    const rect = rectCreateEmpty();
    const strokeWidth = shape.strokeWidth || 0;
    if (shapeIsRect(shape)) {
        rect.x = shape.x - strokeWidth * 0.5;
        rect.y = shape.y - strokeWidth * 0.5;
        rect.width = shape.width + strokeWidth;
        rect.height = shape.height + strokeWidth;
    }
    else if (shapeIsLine(shape)) {
        const { x1, y1, x2, y2 } = shape;
        const left = Math.abs(Math.min(x1, x2));
        const right = Math.abs(Math.max(x1, x2));
        const top = Math.abs(Math.min(y1, y2));
        const bottom = Math.abs(Math.min(y1, y2));
        rect.x = left + strokeWidth * 0.5;
        rect.y = right + strokeWidth * 0.5;
        rect.width = right - left + strokeWidth;
        rect.height = bottom - top + strokeWidth;
    }
    else if (shapeIsEllipse(shape)) {
        rect.x = shape.x - shape.rx + strokeWidth * 0.5;
        rect.y = shape.y - shape.ry + strokeWidth * 0.5;
        rect.width = shape.rx * 2 + strokeWidth;
        rect.height = shape.ry * 2 + strokeWidth;
    }
    if (rect && hasProp(shape, 'rotation')) {
        rectRotate(rect, shape.rotation);
    }
    return rectToBounds(rect);
};
const shapesBounds = (shapes, parentRect) => {
    const bounds = shapes
        .filter((shape) => shape.x < 0 || shape.y < 0 || shape.x1 < 0 || shape.y1 < 0)
        .reduce((bounds, shape) => {
        const [top, right, bottom, left] = shapeBounds(shape);
        bounds.top = Math.min(top, bounds.top);
        bounds.left = Math.min(left, bounds.left);
        bounds.bottom = Math.max(bottom, bounds.bottom);
        bounds.right = Math.max(right, bounds.right);
        return bounds;
    }, {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
    });
    if (bounds.right > 0)
        bounds.right -= parentRect.width;
    if (bounds.bottom > 0)
        bounds.bottom -= parentRect.height;
    return bounds;
};
const shapesFromCompositShape = (shape, parentRect, parser) => {
    const shapeCopy = shapeDeepCopy(shape);
    shapeComputeDisplay(shapeCopy, parentRect);
    return parser(shapeCopy);
};
const shapeComputeRect = (shape, parentRect) => {
    if (hasProp(shape, 'left'))
        shape.x = shape.left;
    if (hasProp(shape, 'right')) {
        const r = parentRect.width - shape.right;
        if (hasProp(shape, 'left')) {
            shape.x = shape.left;
            shape.width = Math.max(0, r - shape.left);
        }
        else if (hasProp(shape, 'width')) {
            shape.x = r - shape.width;
        }
    }
    if (hasProp(shape, 'top'))
        shape.y = shape.top;
    if (hasProp(shape, 'bottom')) {
        const b = parentRect.height - shape.bottom;
        if (hasProp(shape, 'top')) {
            shape.y = shape.top;
            shape.height = Math.max(0, b - shape.top);
        }
        else if (hasProp(shape, 'height')) {
            shape.y = b - shape.height;
        }
    }
    return shape;
};
const shapeComputeTransform = (shape, translate, scale) => {
    if (shapeIsPath(shape)) {
        shape.points
            .filter((point) => isNumber$1(point.x))
            .forEach((point) => {
            point.x *= scale;
            point.y *= scale;
            point.x += translate.x;
            point.y += translate.y;
        });
    }
    if (shapeIsTriangle(shape) && isNumber$1(shape.x1)) {
        shape.x1 *= scale;
        shape.y1 *= scale;
        shape.x2 *= scale;
        shape.y2 *= scale;
        shape.x3 *= scale;
        shape.y3 *= scale;
        shape.x1 += translate.x;
        shape.y1 += translate.y;
        shape.x2 += translate.x;
        shape.y2 += translate.y;
        shape.x3 += translate.x;
        shape.y3 += translate.y;
    }
    if (shapeIsLine(shape) && isNumber$1(shape.x1)) {
        shape.x1 *= scale;
        shape.y1 *= scale;
        shape.x2 *= scale;
        shape.y2 *= scale;
        shape.x1 += translate.x;
        shape.y1 += translate.y;
        shape.x2 += translate.x;
        shape.y2 += translate.y;
    }
    if (isNumber$1(shape.x) && isNumber$1(shape.y)) {
        shape.x *= scale;
        shape.y *= scale;
        shape.x += translate.x;
        shape.y += translate.y;
    }
    if (isNumber$1(shape.width) && isNumber$1(shape.height)) {
        shape.width *= scale;
        shape.height *= scale;
    }
    if (isNumber$1(shape.rx) && isNumber$1(shape.ry)) {
        shape.rx *= scale;
        shape.ry *= scale;
    }
    if (shapeHasNumericStroke(shape)) {
        shape.strokeWidth *= scale;
    }
    if (shapeIsText(shape) && isNumber$1(shape.fontSize)) {
        shape.fontSize *= scale;
        if (isNumber$1(shape.width) && !isNumber$1(shape.width))
            shape.width *= scale;
    }
    if (hasProp(shape, 'cornerRadius') && isNumber$1(shape.cornerRadius)) {
        shape.cornerRadius *= scale;
    }
    return shape;
};
const shapeGetCenter = (shape) => {
    if (shapeIsRect(shape)) {
        return vectorCreate(shape.x + shape.width * 0.5, shape.y + shape.height * 0.5);
    }
    if (shapeIsEllipse(shape)) {
        return vectorCreate(shape.x, shape.y);
    }
    if (shapeIsTextBox(shape)) {
        const height = shape.height || textSize(shape.text, shape).height;
        return vectorCreate(shape.x + shape.width * 0.5, shape.y + height * 0.5);
    }
    if (shapeIsTextLine(shape)) {
        const size = textSize(shape.text, shape);
        return vectorCreate(shape.x + size.width * 0.5, shape.y + size.height * 0.5);
    }
    if (shapeIsPath(shape)) {
        return vectorCenter(shape.points);
    }
    if (shapeIsLine(shape)) {
        return vectorCenter([
            shapeLineGetStartPoint(shape),
            shapeLineGetEndPoint(shape),
        ]);
    }
    return undefined;
};
//#endregion

var ctxRoundRect = (ctx, x, y, width, height, radius) => {
    if (width < 2 * radius)
        radius = width / 2;
    if (height < 2 * radius)
        radius = height / 2;
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + width, y, x + width, y + height, radius);
    ctx.arcTo(x + width, y + height, x, y + height, radius);
    ctx.arcTo(x, y + height, x, y, radius);
    ctx.arcTo(x, y, x + width, y, radius);
    ctx.closePath();
    return ctx;
};

var isCanvas = (element) => /canvas/i.test(element.nodeName);

var isRemoteURL = (url) => new URL(url, location.href).origin !== location.origin;

var loadImage = (image, onSize = undefined) => new Promise((resolve, reject) => {
    // the image element we'll use to load the image
    let imageElement = image;
    let sizeCalculated = false;
    const reportSize = () => {
        if (sizeCalculated)
            return;
        sizeCalculated = true;
        isFunction$1(onSize) &&
            /* Use Promise.resolve to make async but place before resolve of parent promise */
            Promise.resolve().then(() => onSize(sizeCreate(imageElement.naturalWidth, imageElement.naturalHeight)));
    };
    // if is not an image element, it must be a valid image source
    if (!imageElement.src) {
        imageElement = new Image();
        // if is remote image, set crossOrigin
        // why not always set crossOrigin? -> because when set this fires two requests,
        // one for asking permission and one for downloading the image
        if (isString(image) && isRemoteURL(image))
            imageElement.crossOrigin = 'anonymous';
        imageElement.src = isString(image) ? image : URL.createObjectURL(image);
    }
    if (imageElement.complete) {
        reportSize();
        return resolve(imageElement);
    }
    // try to calculate size faster
    if (isFunction$1(onSize))
        getImageElementSize(imageElement).then(reportSize).catch(reject);
    imageElement.onload = () => {
        reportSize();
        resolve(imageElement);
    };
    imageElement.onerror = reject;
});

var pubsub = () => {
    let subs = [];
    return {
        sub: (event, callback) => {
            subs.push({ event, callback });
            return () => (subs = subs.filter((subscriber) => subscriber.event !== event || subscriber.callback !== callback));
        },
        pub: (event, value) => {
            subs
                .filter((sub) => sub.event === event)
                .forEach((sub) => sub.callback(value));
        }
    };
};

const cache$2 = new Map([]);
const getImage = (src, options = {}) => new Promise((resolve, reject) => {
    const { onMetadata = noop$1, onLoad = resolve, onError = reject, onComplete = noop$1, } = options;
    let imageLoadState = cache$2.get(src);
    // start loading
    if (!imageLoadState) {
        imageLoadState = {
            loading: false,
            complete: false,
            error: false,
            image: undefined,
            size: undefined,
            bus: pubsub(),
        };
        // store
        cache$2.set(src, imageLoadState);
    }
    // wait for load
    imageLoadState.bus.sub('meta', onMetadata);
    imageLoadState.bus.sub('load', onLoad);
    imageLoadState.bus.sub('error', onError);
    imageLoadState.bus.sub('complete', onComplete);
    // if is canvas, it's already done
    if (isCanvas(src)) {
        const canvas = src;
        // get image
        const image = canvas.cloneNode();
        // update state
        imageLoadState.complete = true;
        imageLoadState.image = image;
        imageLoadState.size = sizeCreateFromElement(canvas);
    }
    // already loaded
    if (imageLoadState.complete) {
        imageLoadState.bus.pub('meta', { size: imageLoadState.size });
        if (imageLoadState.error) {
            imageLoadState.bus.pub('error', imageLoadState.error);
        }
        else {
            imageLoadState.bus.pub('load', imageLoadState.image);
        }
        imageLoadState.bus.pub('complete');
        // reset subscribers
        imageLoadState.bus = pubsub();
        return;
    }
    // already loading, exit here
    if (imageLoadState.loading)
        return;
    // now loading
    imageLoadState.loading = true;
    // resource needs to be loaded
    loadImage(src, (size) => {
        // setTimeout(() => {
        imageLoadState.size = size;
        imageLoadState.bus.pub('meta', { size });
        // }, 500);
    })
        .then((image) => {
        // setTimeout(() => {
        imageLoadState.image = image;
        imageLoadState.bus.pub('load', image);
        // }, 1500);
    })
        .catch((err) => {
        imageLoadState.error = err;
        imageLoadState.bus.pub('error', err);
    })
        .finally(() => {
        // setTimeout(() => {
        imageLoadState.complete = true;
        imageLoadState.loading = false;
        imageLoadState.bus.pub('complete');
        // reset subscribers
        imageLoadState.bus = pubsub();
        // }, 1750);
    });
});

const drawCanvas = (ctx, image, srcRect, destRect) => ctx.drawImage(image, srcRect.x, srcRect.x, srcRect.width, srcRect.height, destRect.x, destRect.y, destRect.width, destRect.height);
var ctxDrawImage = async (ctx, image, srcRect, destRect, draw = drawCanvas) => {
    ctx.save();
    ctx.clip();
    await draw(ctx, image, srcRect, destRect);
    ctx.restore();
};
const getDrawImageParams = (container, backgroundSize, imageSize) => {
    let srcRect = rectCreate(0, 0, imageSize.width, imageSize.height);
    const destRect = rectClone(container);
    if (backgroundSize === 'contain') {
        const rect = rectContainRect(container, rectAspectRatio(srcRect));
        destRect.width = rect.width;
        destRect.height = rect.height;
        destRect.x += rect.x;
        destRect.y += rect.y;
    }
    else if (backgroundSize === 'cover') {
        srcRect = rectContainRect(rectCreate(0, 0, srcRect.width, srcRect.height), rectAspectRatio(destRect));
    }
    return {
        srcRect,
        destRect,
    };
};

const defineRectShape = (ctx, shape) => {
    shape.cornerRadius > 0
        ? ctxRoundRect(ctx, shape.x, shape.y, shape.width, shape.height, shape.cornerRadius)
        : ctx.rect(shape.x, shape.y, shape.width, shape.height);
    return ctx;
};
const fillRectShape = (ctx, shape) => {
    shape.backgroundColor && ctx.fill();
    return ctx;
};
const strokeRectShape = (ctx, shape) => {
    shape.strokeWidth && ctx.stroke();
    return ctx;
};
var drawRect = async (ctx, shape, options = {}) => new Promise(async (resolve, reject) => {
    const { drawImage } = options;
    ctx.lineWidth = shape.strokeWidth ? shape.strokeWidth : 1; // 1 is default value for lineWidth prop
    ctx.strokeStyle = shape.strokeColor ? colorArrayToRGBA(shape.strokeColor) : 'none';
    ctx.fillStyle = shape.backgroundColor ? colorArrayToRGBA(shape.backgroundColor) : 'none';
    ctx.globalAlpha = shape.opacity;
    if (shape.backgroundImage) {
        let image;
        try {
            image = await getImage(shape.backgroundImage);
        }
        catch (err) {
            reject(err);
        }
        const { srcRect, destRect } = getDrawImageParams(shape, shape.backgroundSize, sizeCreateFromElement(image));
        defineRectShape(ctx, shape);
        fillRectShape(ctx, shape);
        // @ts-ignore
        await ctxDrawImage(ctx, image, srcRect, destRect, drawImage);
        strokeRectShape(ctx, shape);
        resolve([]);
    }
    else {
        defineRectShape(ctx, shape);
        fillRectShape(ctx, shape);
        strokeRectShape(ctx, shape);
        resolve([]);
    }
});

var drawEllipse = async (ctx, shape, options = {}) => new Promise(async (resolve, reject) => {
    const { drawImage } = options;
    ctx.lineWidth = shape.strokeWidth || 1; // 1 is default value for lineWidth prop
    ctx.strokeStyle = shape.strokeColor ? colorArrayToRGBA(shape.strokeColor) : 'none';
    ctx.fillStyle = shape.backgroundColor ? colorArrayToRGBA(shape.backgroundColor) : 'none';
    ctx.globalAlpha = shape.opacity;
    ctx.ellipse(shape.x, shape.y, shape.rx, shape.ry, 0, 0, Math.PI * 2);
    shape.backgroundColor && ctx.fill();
    if (shape.backgroundImage) {
        let image;
        try {
            image = await getImage(shape.backgroundImage);
        }
        catch (err) {
            reject(err);
        }
        const bounds = rectCreate(shape.x - shape.rx, shape.y - shape.ry, shape.rx * 2, shape.ry * 2);
        const { srcRect, destRect } = getDrawImageParams(bounds, shape.backgroundSize, sizeCreateFromElement(image));
        // @ts-ignore
        await ctxDrawImage(ctx, image, srcRect, destRect, drawImage);
        shape.strokeWidth && ctx.stroke();
        resolve([]);
    }
    else {
        shape.strokeWidth && ctx.stroke();
        resolve([]);
    }
});

var drawText = async (ctx, shape, options) => {
    const size = shape.width && shape.height
        ? sizeCreateFromAny(shape)
        : textSize(shape.text, shape);
    const rect = {
        x: shape.x,
        y: shape.y,
        width: shape.width || size.width,
        height: size.height,
    };
    drawRect(ctx, {
        ...shape,
        ...rect,
        options,
    });
    updateTextContext(ctx, shape);
    let tx = 0;
    if (shape.textAlign == 'center') {
        tx = -textPadding * 0.5;
    }
    else if (shape.textAlign === 'right') {
        tx = -textPadding;
    }
    ctx.rect(shape.x + tx, shape.y, shape.width + textPadding * 2, shape.height);
    ctx.save();
    ctx.clip();
    drawText$1(ctx, shape.width ? wrapText(ctx, shape.text, shape.width) : shape.text, {
        x: shape.x,
        y: shape.y,
        fontSize: shape.fontSize,
        textAlign: shape.textAlign,
        lineHeight: shape.lineHeight,
        lineWidth: shape.width,
    });
    ctx.restore();
    return [];
};

// TODO! START
// -----------
var drawLine = async (ctx, shape) => new Promise(async (resolve) => {
    ctx.lineWidth = shape.strokeWidth || 1; // 1 is default value for lineWidth prop
    ctx.strokeStyle = shape.strokeColor ? colorArrayToRGBA(shape.strokeColor) : 'none';
    ctx.globalAlpha = shape.opacity;
    let lineStartPosition = shapeLineGetStartPoint(shape);
    let lineEndPosition = shapeLineGetEndPoint(shape);
    // draw line
    ctx.moveTo(lineStartPosition.x, lineStartPosition.y);
    ctx.lineTo(lineEndPosition.x, lineEndPosition.y);
    shape.strokeWidth && ctx.stroke();
    // draw other shapes
    resolve([]);
});
// TODO! END
// -----------

var drawPath = async (ctx, shape) => new Promise((resolve, reject) => {
    ctx.lineWidth = shape.strokeWidth || 1; // 1 is default value for lineWidth prop
    ctx.strokeStyle = shape.strokeColor ? colorArrayToRGBA(shape.strokeColor) : 'none';
    ctx.fillStyle = shape.backgroundColor ? colorArrayToRGBA(shape.backgroundColor) : 'none';
    ctx.globalAlpha = shape.opacity;
    // draw line
    const { points } = shape;
    if (shape.pathClose)
        ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    const l = points.length;
    for (let i = 1; i < l; i++) {
        ctx.lineTo(points[i].x, points[i].y);
    }
    if (shape.pathClose)
        ctx.closePath();
    shape.strokeWidth && ctx.stroke();
    shape.backgroundColor && ctx.fill();
    resolve([]);
});

var ctxFlip = (ctx, flipX, flipY, pivot) => {
    if (!flipX && !flipY)
        return ctx;
    ctx.translate(pivot.x, pivot.y);
    ctx.scale(flipX ? -1 : 1, flipY ? -1 : 1);
    ctx.translate(-pivot.x, -pivot.y);
    return ctx;
};

const drawShape = async (ctx, shape, options) => {
    // center, needed for transforms
    const center = shapeGetCenter(shape);
    // rotate context
    ctxRotate(ctx, shape.rotation, center);
    // flip context
    ctxFlip(ctx, shape.flipX, shape.flipY, center);
    let fn;
    if (shapeIsRect(shape)) {
        fn = drawRect;
    }
    else if (shapeIsEllipse(shape)) {
        fn = drawEllipse;
    }
    else if (shapeIsLine(shape)) {
        fn = drawLine;
    }
    else if (shapeIsPath(shape)) {
        fn = drawPath;
    }
    else if (shapeIsText(shape)) {
        fn = drawText;
    }
    // get shapes
    return fn ? [shape, ...(await drawShapes(ctx, await fn(ctx, shape, options), options))] : [];
};

var drawShapes = async (ctx, shapes, options) => {
    let drawnShapes = [];
    for (const shape of shapes) {
        ctx.save();
        // clears previous shape's path
        ctx.beginPath();
        // wait for shape to draw before drawing next shape
        drawnShapes = [...drawnShapes, ...(await drawShape(ctx, shape, options))];
        ctx.restore();
    }
    return drawnShapes;
};

var drawImageData = async (imageData, options = {}) => {
    const { shapes = [], context = imageData, contextBounds = imageData, transform = noop$1, drawImage, preprocessShape = passthrough, } = options;
    // no shapes to draw
    if (!shapes.length)
        return imageData;
    // output
    let imageDataOut;
    // create drawing context
    const canvas = h$1('canvas');
    canvas.width = contextBounds.width;
    canvas.height = contextBounds.height;
    const ctx = canvas.getContext('2d');
    ctx.putImageData(imageData, contextBounds.x || 0, contextBounds.y || 0);
    // compute the position of all shapes
    const computedShapes = shapes
        .map(shapeDeepCopy)
        .map((shape) => shapeComputeDisplay(shape, {
        x: 0,
        y: 0,
        width: context.width,
        height: context.height,
    })) // need to take into account output size?
        .map(preprocessShape)
        .flat();
    // compute transforms for all shapes
    transform(ctx);
    // draw shapes to canvas
    await drawShapes(ctx, computedShapes, {
        drawImage,
    });
    imageDataOut = ctx.getImageData(0, 0, canvas.width, canvas.height);
    releaseCanvas(canvas);
    return imageDataOut;
};

var fillImageData = async (imageData, options = {}) => {
    const { backgroundColor } = options;
    // no background color set or is fully transparent background color
    if (!backgroundColor || (backgroundColor && backgroundColor[3] === 0))
        return imageData;
    // fill
    let imageDataOut;
    let image = h$1('canvas');
    image.width = imageData.width;
    image.height = imageData.height;
    const ctx = image.getContext('2d');
    ctx.putImageData(imageData, 0, 0);
    // fill behind image
    ctx.globalCompositeOperation = 'destination-over';
    ctx.fillStyle = colorArrayToRGBA(backgroundColor);
    ctx.fillRect(0, 0, image.width, image.height);
    imageDataOut = ctx.getImageData(0, 0, image.width, image.height);
    releaseCanvas(image);
    return imageDataOut;
};

var dotColorMatrix = (a, b) => {
    const res = new Array(20);
    // R
    res[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15];
    res[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16];
    res[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17];
    res[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18];
    res[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4];
    // G
    res[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15];
    res[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16];
    res[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17];
    res[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18];
    res[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9];
    // B
    res[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15];
    res[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16];
    res[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17];
    res[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18];
    res[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14];
    // A
    res[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15];
    res[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16];
    res[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17];
    res[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18];
    res[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19];
    return res;
};

var getColorMatrixFromColorMatrices = (colorMatrices) => colorMatrices.length
    ? colorMatrices.reduce((previous, current) => dotColorMatrix([...previous], current), colorMatrices.shift())
    : [];

function noop$2() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function run$3(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run$3);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop$2;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
    let value;
    subscribe(store, _ => value = _)();
    return value;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
        if (k[0] !== '$')
            result[k] = props[k];
    return result;
}
function compute_rest_props(props, keys) {
    const rest = {};
    keys = new Set(keys);
    for (const k in props)
        if (!keys.has(k) && k[0] !== '$')
            rest[k] = props[k];
    return rest;
}
function set_store_value(store, ret, value = ret) {
    store.set(value);
    return ret;
}
function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$2;
}

const is_client = typeof window$1 !== 'undefined';
let now = is_client
    ? () => window$1.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop$2;

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}

function append(target, node) {
    target.appendChild(node);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function element(name) {
    return document.createElement(name);
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text$1(data) {
    return document.createTextNode(data);
}
function space() {
    return text$1(' ');
}
function empty$1() {
    return text$1('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
    return function (event) {
        event.preventDefault();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function stop_propagation(fn) {
    return function (event) {
        event.stopPropagation();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function set_attributes(node, attributes) {
    // @ts-ignore
    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
    for (const key in attributes) {
        if (attributes[key] == null) {
            node.removeAttribute(key);
        }
        else if (key === 'style') {
            node.style.cssText = attributes[key];
        }
        else if (key === '__value') {
            node.value = node[key] = attributes[key];
        }
        else if (descriptors[key] && descriptors[key].set) {
            node[key] = attributes[key];
        }
        else {
            attr(node, key, attributes[key]);
        }
    }
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_data(text, data) {
    data = '' + data;
    if (text.wholeText !== data)
        text.data = data;
}
function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? 'important' : '');
}
function custom_event(type, detail) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, false, false, detail);
    return e;
}
class HtmlTag {
    constructor(anchor = null) {
        this.a = anchor;
        this.e = this.n = null;
    }
    m(html, target, anchor = null) {
        if (!this.e) {
            this.e = element(target.nodeName);
            this.t = target;
            this.h(html);
        }
        this.i(anchor);
    }
    h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert(this.t, this.n[i], anchor);
        }
    }
    p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
    }
    d() {
        this.n.forEach(detach);
    }
}

const active_docs = new Set();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = node.ownerDocument;
    active_docs.add(doc);
    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
    if (!current_rules[name]) {
        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        active_docs.forEach(doc => {
            const stylesheet = doc.__svelte_stylesheet;
            let i = stylesheet.cssRules.length;
            while (i--)
                stylesheet.deleteRule(i);
            doc.__svelte_rules = {};
        });
        active_docs.clear();
    });
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail);
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
        }
    };
}
function setContext(key, context) {
    get_current_component().$$.context.set(key, context);
}
function getContext(key) {
    return get_current_component().$$.context.get(key);
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        callbacks.slice().forEach(fn => fn(event));
    }
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
}
const null_transition = { duration: 0 };
function create_bidirectional_transition(node, fn, params, intro) {
    let config = fn(node, params);
    let t = intro ? 0 : 1;
    let running_program = null;
    let pending_program = null;
    let animation_name = null;
    function clear_animation() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function init(program, duration) {
        const d = program.b - t;
        duration *= Math.abs(d);
        return {
            a: t,
            b: program.b,
            d,
            duration,
            start: program.start,
            end: program.start + duration,
            group: program.group
        };
    }
    function go(b) {
        const { delay = 0, duration = 300, easing = identity, tick = noop$2, css } = config || null_transition;
        const program = {
            start: now() + delay,
            b
        };
        if (!b) {
            // @ts-ignore todo: improve typings
            program.group = outros;
            outros.r += 1;
        }
        if (running_program || pending_program) {
            pending_program = program;
        }
        else {
            // if this is an intro, and there's a delay, we need to do
            // an initial tick and/or apply CSS animation immediately
            if (css) {
                clear_animation();
                animation_name = create_rule(node, t, b, duration, delay, easing, css);
            }
            if (b)
                tick(0, 1);
            running_program = init(program, duration);
            add_render_callback(() => dispatch(node, b, 'start'));
            loop(now => {
                if (pending_program && now > pending_program.start) {
                    running_program = init(pending_program, duration);
                    pending_program = null;
                    dispatch(node, running_program.b, 'start');
                    if (css) {
                        clear_animation();
                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                    }
                }
                if (running_program) {
                    if (now >= running_program.end) {
                        tick(t = running_program.b, 1 - t);
                        dispatch(node, running_program.b, 'end');
                        if (!pending_program) {
                            // we're done
                            if (running_program.b) {
                                // intro — we can tidy up immediately
                                clear_animation();
                            }
                            else {
                                // outro — needs to be coordinated
                                if (!--running_program.group.r)
                                    run_all(running_program.group.c);
                            }
                        }
                        running_program = null;
                    }
                    else if (now >= running_program.start) {
                        const p = now - running_program.start;
                        t = running_program.a + running_program.d * easing(p / running_program.duration);
                        tick(t, 1 - t);
                    }
                }
                return !!(running_program || pending_program);
            });
        }
    }
    return {
        run(b) {
            if (is_function(config)) {
                wait().then(() => {
                    // @ts-ignore
                    config = config();
                    go(b);
                });
            }
            else {
                go(b);
            }
        },
        end() {
            clear_animation();
            running_program = pending_program = null;
        }
    };
}

const globals = (typeof window$1 !== 'undefined'
    ? window$1
    : typeof globalThis !== 'undefined'
        ? globalThis
        : global);

function destroy_block(block, lookup) {
    block.d(1);
    lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    return new_blocks;
}

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}
function get_spread_object(spread_props) {
    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
}

function bind$1(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run$3).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init$3(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop$2,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : options.context || []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false
    };
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop$2;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

const subscriber_queue = [];
/**
 * Creates a `Readable` store that allows reading by subscription.
 * @param value initial value
 * @param {StartStopNotifier}start start and stop notifications for subscriptions
 */
function readable(value, start) {
    return {
        subscribe: writable(value, start).subscribe
    };
}
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop$2) {
    let stop;
    const subscribers = [];
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (let i = 0; i < subscribers.length; i += 1) {
                    const s = subscribers[i];
                    s[1]();
                    subscriber_queue.push(s, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop$2) {
        const subscriber = [run, invalidate];
        subscribers.push(subscriber);
        if (subscribers.length === 1) {
            stop = start(set) || noop$2;
        }
        run(value);
        return () => {
            const index = subscribers.indexOf(subscriber);
            if (index !== -1) {
                subscribers.splice(index, 1);
            }
            if (subscribers.length === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}
function derived(stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single
        ? [stores]
        : stores;
    const auto = fn.length < 2;
    return readable(initial_value, (set) => {
        let inited = false;
        const values = [];
        let pending = 0;
        let cleanup = noop$2;
        const sync = () => {
            if (pending) {
                return;
            }
            cleanup();
            const result = fn(single ? values[0] : values, set);
            if (auto) {
                set(result);
            }
            else {
                cleanup = is_function(result) ? result : noop$2;
            }
        };
        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
            values[i] = value;
            pending &= ~(1 << i);
            if (inited) {
                sync();
            }
        }, () => {
            pending |= (1 << i);
        }));
        inited = true;
        sync();
        return function stop() {
            run_all(unsubscribers);
            cleanup();
        };
    });
}

var mergeObjects = (objects) => objects.reduce((prev, curr) => Object.assign(prev, curr), {});

// @ts-ignore
const UPDATE_VALUE = (updateValue) => ({ updateValue });
const DEFAULT_VALUE = (defaultValue) => ({ defaultValue });
const CUSTOM_STORE = (fn) => ({ store: fn });
// @ts-ignore
const DERIVED_STORE = (fn) => ({ store: (defaultValue, stores) => derived(...fn(stores)) });
const UNIQUE_DERIVED_STORE = (fn) => ({
    store: (defaultValue, stores) => {
        const [selectedStores, update, isEqual = () => false] = fn(stores);
        let isFirst = true;
        let currentValue;
        return derived(selectedStores, (storeValues, set) => {
            update(storeValues, (value) => {
                if (!isFirst && isEqual(currentValue, value))
                    return;
                currentValue = value;
                isFirst = false;
                set(value);
            });
        });
    },
});
const MAP_STORE = (fn) => ({
    store: (defaultValue, stores) => {
        const [valueMapper, observedStores = {}, sorter = undefined] = fn(stores);
        let storedItems = [];
        let $observedStores = {};
        const mapValue = (item) => valueMapper(item, $observedStores);
        // set default properties for each item
        const setValue = (items) => {
            // was empty, still empty
            if (!storedItems.length && !items.length)
                return;
            // update value
            storedItems = items;
            updateValue();
        };
        const updateValue = () => {
            const mappedItems = storedItems.map(mapValue);
            if (sorter)
                mappedItems.sort(sorter);
            storedItems = [...mappedItems];
            set(mappedItems);
        };
        // TODO: need to at some point unsub from these stores
        Object.entries(observedStores).map(([name, store]) => {
            return store.subscribe((value) => {
                $observedStores[name] = value;
                if (!value)
                    return;
                updateValue();
            });
        });
        const { subscribe, set } = writable(defaultValue || []);
        return {
            set: setValue,
            update: (fn) => setValue(fn(storedItems)),
            subscribe,
        };
    },
});
const createStore = (accessors, stores, options) => {
    const { store = (defaultValue) => writable(defaultValue), defaultValue = noop$1, // should be a function returning the default value
    updateValue = undefined, } = options;
    // create our private store
    const storeInstance = store(defaultValue(), stores, accessors);
    const { subscribe, update = noop$1 } = storeInstance; // update = noop because not all stores can be updated
    // on update private store
    let unsub;
    const onUpdate = (cb) => {
        let ignoreFirstCallback = true;
        if (unsub)
            unsub();
        unsub = subscribe((value) => {
            // need to ignore first callback because that returns current value
            if (ignoreFirstCallback)
                return (ignoreFirstCallback = false);
            // now we have the newly assigned value
            cb(value);
            unsub();
            unsub = undefined;
        });
    };
    // create the value updater function, needs access to stores so can read all store values
    const updateStoreValue = updateValue ? updateValue(accessors) : passthrough;
    // set and validate value
    storeInstance.set = (nextValue) => update((previousValue) => updateStoreValue(nextValue, previousValue, onUpdate));
    // set default value for external reference
    storeInstance.defaultValue = defaultValue;
    // expose store api
    return storeInstance;
};
var createStores = (props) => {
    const stores = {};
    const accessors = {};
    props.forEach(([name, ...options]) => {
        const opts = mergeObjects(options);
        const store = (stores[name] = createStore(accessors, stores, opts));
        const property = {
            get: () => get_store_value(store),
            set: store.set,
        };
        Object.defineProperty(accessors, name, property);
    });
    return {
        stores,
        accessors,
    };
};

var props = [
    // io
    ['src'],
    ['imageReader'],
    ['imageWriter'],
    // will process markup items before rendering, used by arrows and frames
    ['shapePreprocessor'],
    // current images
    ['images', DEFAULT_VALUE(() => [])],
];

var capitalizeFirstLetter = (str) => str.charAt(0).toUpperCase() + str.slice(1);

var defineMethods = (object, api) => {
    Object.keys(api).forEach((name) => {
        const descriptor = isFunction$1(api[name])
            ? {
                value: api[name],
                writable: false,
            }
            : api[name];
        Object.defineProperty(object, name, descriptor);
    });
};

const scalar = 10000;
var offsetRectToFitPolygon = (rect, poly) => {
    const polyLines = quadLines(poly);
    const offset = vectorCreateEmpty();
    const rectVertexes = rectGetCorners(rect);
    // we can fit it
    rectVertexes.forEach((vertex) => {
        // we update each corner by adding the current offset
        vectorAdd(vertex, offset);
        // test if point lies in polygon, if so, all is fine and we can exit
        if (pointInPoly(vertex, poly))
            return;
        polyLines.forEach((line) => {
            // get angle of edge and draw a ray from the corner perpendicular to the edge
            const a = Math.atan2(line.start.y - line.end.y, line.start.x - line.end.x);
            const x = Math.sin(Math.PI - a) * scalar;
            const y = Math.cos(Math.PI - a) * scalar;
            const ray = vectorCreate(vertex.x + x, vertex.y + y);
            // extend the poly line so even if we overshoot the polygon we hit it
            const lineExtended = lineExtend(lineClone(line), scalar);
            // get the resulting intersection (there's always an intersection)
            const intersection = lineLineIntersection(lineCreate(vertex, ray), lineExtended);
            // no intersection, no need to do anything
            if (!intersection)
                return;
            // update offset to move towards image
            vectorAdd(offset, vectorSubtract(vectorClone(intersection), vertex));
        });
    });
    // test if any vertexes still fall outside of poly, if so, we can't fit the rect
    const rectOffset = rectClone(rect);
    vectorAdd(rectOffset, offset);
    const rectOffsetVertices = rectGetCorners(rectOffset);
    const fits = rectOffsetVertices.every((vertex) => pointInPoly(vertex, poly));
    if (fits) {
        rectUpdateWithRect(rect, rectOffset);
        return true;
    }
    return false;
};

var limitCropRectToImage = (rect, poly) => {
    // get crop rect polygon vertexes
    const rectVertexes = rectGetCorners(rect);
    // if we end up here it doesn't fit, we might need to adjust
    const polyLines = quadLines(poly)
        // extend the poly lines a tiny bit so we
        // don't shoot rays between line gaps at corners
        // this caused one intersection to be missing resulting
        // in error while manipulating crop edges
        // (rotate image 90degrees -> drag bottom edge) (2021-04-09)
        .map((line) => lineExtend(line, 5));
    const rectCenterPosition = rectCenter(rect);
    const intersections = [];
    rectVertexes.forEach((rectVertex) => {
        const ray = lineMultiply(lineCreate(vectorClone(rectCenterPosition), vectorClone(rectVertex)), 1000000);
        let intersectionFound = false;
        polyLines.map(lineClone).forEach((line) => {
            const intersection = lineLineIntersection(ray, line);
            if (!intersection || intersectionFound)
                return;
            intersections.push(intersection);
            intersectionFound = true;
        });
    });
    // top left -> bottom right
    const tlbr = vectorDistance(intersections[0], intersections[2]);
    // top right -> bottom left
    const trbl = vectorDistance(intersections[1], intersections[3]);
    // calculate smallest rectangle we can make, use that
    const rectLimitedVertices = tlbr < trbl ? [intersections[0], intersections[2]] : [intersections[1], intersections[3]];
    const rectLimitedToImage = rectCreateFromPoints(rectLimitedVertices);
    // only use our fitted crop rectangle if it's smaller than our current rectangle,
    // this would mean that our current rectangle couldn't be moved to make it fit
    if (rectLimitedToImage.width < rect.width) {
        // need to center on previous rect
        rectUpdateWithRect(rect, rectLimitedToImage);
        return true;
    }
    return false;
};

var getImagePolygon = (image, imageRotation, imagePerspective = { x: 0, y: 0 }) => {
    const imageRect = rectCreateFromSize(image);
    const imageCenter = rectCenter(imageRect);
    const imagePoly = rectApplyPerspective(imageRect, imagePerspective, imageCenter).map((imageVertex) => vectorRotate(imageVertex, imageRotation, imageCenter));
    // get image poly bounds, we need this to offset the poly vertices from 0,0
    const imagePolyBounds = rectCreateFromPoints(imagePoly);
    // get image polygon vertexes
    return imagePoly.map((imageVertex) => vectorSubtract(imageVertex, imagePolyBounds));
};

var getMaxSizeInRect = (size, rotation = 0, aspectRatio = rectAspectRatio(size)) => {
    let width;
    let height;
    if (rotation !== 0) {
        const innerAngle = Math.atan2(1, aspectRatio);
        const rotationSigned = Math.sign(rotation) * rotation;
        const rotationSignedMod = rotationSigned % Math.PI;
        const rotationSignedModHalf = rotationSigned % HALF_PI;
        // determine if is turned on side
        let hyp;
        let r;
        if (rotationSignedMod > QUART_PI && rotationSignedMod < HALF_PI + QUART_PI) {
            r = rotationSignedModHalf > QUART_PI ? rotationSigned : HALF_PI - rotationSignedModHalf;
        }
        else {
            r = rotationSignedModHalf > QUART_PI ? HALF_PI - rotationSignedModHalf : rotationSigned;
        }
        hyp = Math.min(Math.abs(size.height / Math.sin(innerAngle + r)), Math.abs(size.width / Math.cos(innerAngle - r)));
        width = Math.cos(innerAngle) * hyp;
        height = width / aspectRatio;
    }
    else {
        width = size.width;
        height = width / aspectRatio;
        if (height > size.height) {
            height = size.height;
            width = height * aspectRatio;
        }
    }
    return sizeCreate(width, height);
};

var limitRectToImage = (rect, imageSize, imageRotation = 0, imagePerspective = vectorCreateEmpty(), minSize) => {
    // rotation and/or perspective, let's use the "advanced" collision detection method
    if ((isNumber$1(imageRotation) && imageRotation !== 0) ||
        imagePerspective.x ||
        imagePerspective.y) {
        const inputAspectRatio = rectAspectRatio(rect);
        // test if crop can fit image, if it can, offset the crop so it fits
        const imagePolygon = getImagePolygon(imageSize, imageRotation, imagePerspective);
        const maxSizeInRect = getMaxSizeInRect(imageSize, imageRotation, inputAspectRatio);
        const canFit = rect.width < maxSizeInRect.width && rect.height < maxSizeInRect.height;
        if (!canFit) {
            const dx = rect.width * 0.5 - maxSizeInRect.width * 0.5;
            const dy = rect.height * 0.5 - maxSizeInRect.height * 0.5;
            // adjust crop rect to max size
            if (rect.width > maxSizeInRect.width) {
                rect.width = maxSizeInRect.width;
                rect.x += dx;
            }
            if (rect.height > maxSizeInRect.height) {
                rect.height = maxSizeInRect.height;
                rect.y += dy;
            }
            // test if has exceeded min size, if so we need to limit the size and recalculate the other edge
            /*
                        -\
                       /  ---\
                      h2      ---\
                     /            ---\
                    +--------w---------+\
                   /|                  | ---\
                  / |                  |     ---\
                 /  |                  |         ---\
                /   |                  |             --
               h1   |                  |             /
              /     |                  |            /
             /      |                  |           /
            -\      |                  |          /
              ---\  |                  |         /
                  --+------------------+        /
                      ---\                     /
                          --\                 /
                             ---\            /
                                 ---\       /
                                     ---\  /
                                         --
            */
        }
        offsetRectToFitPolygon(rect, imagePolygon);
        const wasLimited = limitCropRectToImage(rect, imagePolygon);
        // this makes sure that after limiting the size, the crop rect is moved to a position that is inside the image
        if (wasLimited)
            offsetRectToFitPolygon(rect, imagePolygon);
    }
    // no rotation, no perspective, use simple bounds method
    else {
        // remember intended aspect ratio so we can try and recreate it
        let intendedAspectRatio = rectAspectRatio(rect);
        // limit to image size first, can never exceed that
        rect.width = Math.min(rect.width, imageSize.width);
        rect.height = Math.min(rect.height, imageSize.height);
        // reposition rect so it's always inside image bounds
        rect.x = Math.max(rect.x, 0);
        if (rect.x + rect.width > imageSize.width) {
            rect.x -= rect.x + rect.width - imageSize.width;
        }
        rect.y = Math.max(rect.y, 0);
        if (rect.y + rect.height > imageSize.height) {
            rect.y -= rect.y + rect.height - imageSize.height;
        }
        // we get the center of the current rect so we can center the contained rect to it
        const intendedCenter = rectCenter(rect);
        // make sure still adheres to aspect ratio
        const containedRect = rectContainRect(rect, intendedAspectRatio);
        containedRect.width = Math.max(minSize.width, containedRect.width);
        containedRect.height = Math.max(minSize.height, containedRect.height);
        containedRect.x = intendedCenter.x - containedRect.width * 0.5;
        containedRect.y = intendedCenter.y - containedRect.height * 0.5;
        rectUpdateWithRect(rect, containedRect);
    }
};

var applyCropRectAction = (cropRectPrevious, cropRectNext, imageSize, imageRotation, imagePerspective, cropLimitToImageBounds, cropMinSize, cropMaxSize) => {
    // clone
    const minSize = sizeClone(cropMinSize);
    // set upper bounds to crop max size
    const maxSize = sizeClone(cropMaxSize);
    // limit max size (more important that min size is respected so first limit max size)
    const maxScalar = fixPrecision(Math.max(cropRectNext.width / maxSize.width, cropRectNext.height / maxSize.height));
    const minScalar = fixPrecision(Math.min(cropRectNext.width / minSize.width, cropRectNext.height / minSize.height));
    // clone for resulting crop rect
    const cropRectOut = rectClone(cropRectNext);
    //
    // if exceeds min or max scale correct next crop rectangle to conform to bounds
    //
    if (minScalar < 1 || maxScalar > 1) {
        // center of both previous and next crop rects
        const previousCropRectCenter = rectCenter(cropRectPrevious);
        const nextCropRectCenter = rectCenter(cropRectNext);
        // calculate scales
        const scalar = minScalar < 1 ? minScalar : maxScalar;
        const cx = (nextCropRectCenter.x + previousCropRectCenter.x) / 2;
        const cy = (nextCropRectCenter.y + previousCropRectCenter.y) / 2;
        const cw = cropRectOut.width / scalar;
        const ch = cropRectOut.height / scalar;
        rectUpdate(cropRectOut, cx - cw * 0.5, cy - ch * 0.5, cw, ch);
    }
    // no need to limit to bounds, let's go!
    if (!cropLimitToImageBounds)
        return {
            crop: cropRectOut,
        };
    //
    // make sure the crop is made inside the bounds of the image
    //
    limitRectToImage(cropRectOut, imageSize, imageRotation, imagePerspective, minSize);
    return {
        crop: cropRectOut,
    };
};

var getBaseCropRect = (imageSize, transformedCropRect, imageRotation) => {
    const imageRect = rectCreateFromSize(imageSize);
    const imageCenter = rectCenter(imageRect);
    const imageTransformedVertices = rectRotate(imageRect, imageRotation, imageCenter);
    // get the rotated image bounds center (offset isn't relevant as crop is relative to top left image position)
    const imageRotatedBoundsCenter = rectCenter(rectNormalizeOffset(rectCreateFromPoints(imageTransformedVertices)));
    // get the center of the crop inside the rotated image
    const cropCenterInTransformedImage = rectCenter(transformedCropRect);
    // invert the rotation of the crop center around the rotated image center
    const deRotatedCropCenter = vectorRotate(cropCenterInTransformedImage, -imageRotation, imageRotatedBoundsCenter);
    // calculate crop distance from rotated image center
    const cropFromCenterOfTransformedImage = vectorSubtract(deRotatedCropCenter, imageRotatedBoundsCenter);
    // calculate original crop offset (from untransformed image)
    const originalCropCenterOffset = vectorApply(vectorAdd(imageCenter, cropFromCenterOfTransformedImage), fixPrecision);
    return rectCreate(originalCropCenterOffset.x - transformedCropRect.width * 0.5, originalCropCenterOffset.y - transformedCropRect.height * 0.5, transformedCropRect.width, transformedCropRect.height);
};

var clamp = (value, min, max) => Math.max(min, Math.min(value, max));

var applyRotationAction = (imageRotationPrevious, imageRotation, imageRotationRange, cropRect, imageSize, imagePerspective, cropLimitToImageBounds, cropRectOrigin, cropMinSize, cropMaxSize) => {
    // clone
    const minSize = sizeClone(cropMinSize);
    // set upper bounds to crop max size if image is bigger than max size,
    // else if should limit to image bounds use image size as limit
    const maxSize = sizeClone(cropMaxSize);
    if (cropLimitToImageBounds) {
        maxSize.width = Math.min(cropMaxSize.width, imageSize.width);
        maxSize.height = Math.min(cropMaxSize.height, imageSize.height);
    }
    let didAttemptDoubleTurn = false;
    const rotate = (rotationPrevious, rotation) => {
        // get the base crop rect (position of crop rect in untransformed image)
        // if we have the base crop rect we can apply the new rotation to it
        const cropRectBase = getBaseCropRect(imageSize, cropRect, rotationPrevious);
        // calculate transforms based on new rotation and base crop rect
        const imageRect = rectCreateFromSize(imageSize);
        const imageCenter = rectCenter(imageRect);
        const imageTransformedCorners = rectApplyPerspective(imageRect, imagePerspective, imageCenter);
        // need this to correct for perspective centroid displacement
        const perspectiveOffset = vectorSubtract(vectorClone(imageCenter), convexPolyCentroid(imageTransformedCorners));
        // rotate around center of image
        const cropCenter = vectorRotate(rectCenter(cropRectBase), rotation, imageCenter);
        const rotateCropOffset = vectorSubtract(vectorClone(imageCenter), cropCenter);
        // get center of image bounds and move to correct position
        imageTransformedCorners.forEach((imageVertex) => vectorRotate(imageVertex, rotation, imageCenter));
        const imageBoundsRect = rectCreateFromPoints(imageTransformedCorners);
        const imageCentroid = convexPolyCentroid(imageTransformedCorners);
        const cropOffset = vectorAdd(vectorSubtract(vectorSubtract(imageCentroid, rotateCropOffset), imageBoundsRect), perspectiveOffset);
        // create output cropRect
        const cropRectOut = rectCreate(cropOffset.x - cropRectBase.width * 0.5, cropOffset.y - cropRectBase.height * 0.5, cropRectBase.width, cropRectBase.height);
        // if has size target, scale croprect to target size
        if (cropRectOrigin) {
            rectScale(cropRectOut, cropRectOrigin.width / cropRectOut.width);
        }
        // if should limit to image bounds
        if (cropLimitToImageBounds) {
            const imagePoly = getImagePolygon(imageSize, rotation, imagePerspective);
            // offsetRectToFitPolygon(cropRectOut, imagePoly);
            // commenting this fixes poly sliding problem when adjusting rotation
            limitCropRectToImage(cropRectOut, imagePoly);
        }
        //#region if exceeds min or max adjust rotation to conform to bounds
        const minScalar = fixPrecision(Math.min(cropRectOut.width / minSize.width, cropRectOut.height / minSize.height), 8);
        const maxScalar = fixPrecision(Math.max(cropRectOut.width / maxSize.width, cropRectOut.height / maxSize.height), 8);
        if (minScalar < 1 || maxScalar > 1) {
            // determine if is full image turn
            const isTurn = fixPrecision(Math.abs(rotation - rotationPrevious)) === fixPrecision(Math.PI / 2);
            // try another turn if is turning image
            if (isTurn && !didAttemptDoubleTurn) {
                didAttemptDoubleTurn = true;
                return rotate(imageRotationPrevious, imageRotationPrevious + Math.sign(rotation - rotationPrevious) * Math.PI);
            }
        }
        //#endregion
        return {
            rotation,
            crop: rectApply(cropRectOut, (v) => fixPrecision(v, 8)),
        };
    };
    // amount of turns applied, we need this to correctly determine the allowed rotation range
    const imageTurns = Math.sign(imageRotation) * Math.round(Math.abs(imageRotation) / HALF_PI) * HALF_PI;
    const imageRotationClamped = clamp(imageRotation, imageTurns + imageRotationRange[0], imageTurns + imageRotationRange[1]);
    // set new crop position
    return rotate(imageRotationPrevious, imageRotationClamped);
};

const ORDERED_STATE_PROPS = [
    // requirements
    'cropLimitToImage',
    'cropMinSize',
    'cropMaxSize',
    'cropAspectRatio',
    // selection -> flip -> rotate -> perspective -> crop
    'flipX',
    'flipY',
    'rotation',
    'crop',
    // 'perspectiveX',
    // 'perspectiveY',
    // effects
    'colorMatrix',
    'convolutionMatrix',
    'gamma',
    'vignette',
    // 'noise',
    // shapes
    'annotation',
    'decoration',
    'frame',
    // other
    'backgroundColor',
    'targetSize',
    'metadata',
];
const clone = (value) => {
    if (isArray(value)) {
        return value.map(clone);
    }
    else if (isObject$1(value)) {
        return { ...value };
    }
    return value;
};
const filterShapeState = (shapes) => shapes.map((shape) => Object.entries(shape).reduce((copy, [key, value]) => {
    if (key.startsWith('_'))
        return copy;
    copy[key] = value;
    return copy;
}, {}));
var stateStore = (_, stores, accessors) => {
    const observedStores = ORDERED_STATE_PROPS.map((key) => stores[key]);
    // can only subscribe, setting is done directly through store accessors
    // @ts-ignore
    const { subscribe } = derived(observedStores, (values, set) => {
        // create new state by looping over props in certain order
        const state = ORDERED_STATE_PROPS.reduce((prev, curr, i) => {
            prev[curr] = clone(values[i]);
            return prev;
        }, {});
        // round crop if defined
        state.crop && rectApply(state.crop, Math.round);
        // remove internal state props from decoration and annotation
        state.annotation = state.annotation && filterShapeState(state.annotation);
        state.decoration = state.decoration && filterShapeState(state.decoration);
        // set new state
        set(state);
    });
    const setState = (state) => {
        // requires at least some state to be supplied
        if (!state)
            return;
        // make sure crop origin is reset
        accessors.cropOrigin = undefined;
        // apply new values
        ORDERED_STATE_PROPS
            // remove keys that weren't set
            .filter((key) => hasProp(state, key))
            // apply each key in order
            .forEach((key) => {
            accessors[key] = clone(state[key]);
        });
    };
    return {
        set: setState,
        update: (fn) => setState(fn(null)),
        subscribe,
    };
};

var toNumericAspectRatio = (v) => {
    if (!v)
        return undefined;
    if (/:/.test(v)) {
        const [w, h] = v.split(':');
        return w / h;
    }
    return parseFloat(v);
};

var arrayEqual = (a, b) => {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i])
            return false;
    }
    return true;
};

var padColorArray = (color = [0, 0, 0, 0], opacity = 1.0) => color.length === 4 ? color : [...color, opacity];

//
// constants
//
const MIN_ROTATION = -QUART_PI;
const MAX_ROTATION = QUART_PI;
//
// helper methods
//
const isCropCentered = (crop, imageSize, imageRotation) => {
    const cropCenter = vectorApply(rectCenter(crop), (v) => fixPrecision(v, 8));
    const imageRect = rectCreateFromSize(imageSize);
    const imageCenter = rectCenter(imageRect);
    const imageRotatedVertices = rectRotate(imageRect, imageRotation, imageCenter);
    const imageBoundsCenter = vectorApply(sizeCenter(rectCreateFromPoints(imageRotatedVertices)), (v) => fixPrecision(v, 8));
    const dx = Math.abs(imageBoundsCenter.x - cropCenter.x);
    const dy = Math.abs(imageBoundsCenter.y - cropCenter.y);
    return dx < 1 && dy < 1;
};
const isCropMaxSize = (cropRect, imageSize, rotation) => {
    const maxSize = getMaxSizeInRect(imageSize, rotation, rectAspectRatio(cropRect));
    return sizeEqual(sizeApply(maxSize, Math.round), sizeApply(sizeClone(cropRect), Math.round));
};
//
// updater methods
//
const updateCropRect = (props) => (cropNext, cropPrevious = cropNext) => {
    // wait for image to load
    const { loadState, size, cropMinSize, cropMaxSize, cropLimitToImage, cropAspectRatio, rotation, perspective, } = props;
    // image hasn't loaded yet, use supplied crop rect
    if ((!cropNext && !cropPrevious) || !loadState || !loadState.beforeComplete)
        return cropNext;
    // crop previous set, crop next set to undefined, set crop to fit image
    if (!cropNext)
        cropNext = rectCreateFromSize(getMaxSizeInRect(size, rotation, cropAspectRatio || rectAspectRatio(size)));
    // apply the action
    const res = applyCropRectAction(cropPrevious, cropNext, size, rotation, perspective, cropLimitToImage, cropMinSize, cropMaxSize);
    const cropOut = rectApply(res.crop, (v) => fixPrecision(v, 8));
    return cropOut;
};
const updateCropAspectRatio = (props) => (aspectRatioNext, aspectRatioPrevious) => {
    const { loadState, crop, size, rotation, cropLimitToImage } = props;
    const aspectRatio = toNumericAspectRatio(aspectRatioNext);
    // no aspect ratio means custom aspect ratio so set to undefined
    if (!aspectRatio)
        return undefined;
    // can't update crop if not defined yet
    if (!crop || !loadState || !loadState.beforeComplete)
        return aspectRatio;
    // calculate difference between aspect ratios, if big difference, re-align in image
    const aspectRatioDist = aspectRatioPrevious
        ? Math.abs(aspectRatioNext - aspectRatioPrevious)
        : 1;
    // if crop centered scale up
    if (isCropCentered(crop, size, rotation) && cropLimitToImage && aspectRatioDist >= 0.1) {
        const imageSize = sizeTurn(sizeClone(size), rotation);
        props.crop = rectApply(rectContainRect(rectCreateFromSize(imageSize), aspectRatioNext), fixPrecision);
    }
    else {
        const cropSize = {
            width: crop.height * aspectRatio,
            height: crop.height,
        };
        const tx = (crop.width - cropSize.width) * 0.5;
        const ty = (crop.height - cropSize.height) * 0.5;
        props.crop = rectApply(rectCreate(crop.x + tx, crop.y + ty, cropSize.width, cropSize.height), fixPrecision);
    }
    return aspectRatio;
};
const updateCropLimitToImage = (props) => (limitToImageNext, limitToImagePrevious, onUpdate) => {
    // skip if no crop defined
    const { crop } = props;
    if (!crop)
        return limitToImageNext;
    // if was not limiting previously and now set limiting make sure crop fits bounds
    if (!limitToImagePrevious && limitToImageNext) {
        onUpdate(() => (props.crop = rectClone(props.crop)));
    }
    return limitToImageNext;
};
const updateRotation = (props) => (rotationNext, rotationPrevious, onUpdate) => {
    // when image rotation is updated we need to adjust the
    // cropRect offset so rotation happens from cropRect center
    // no change
    if (rotationNext === rotationPrevious)
        return rotationNext;
    // get relevant data from store state
    const { loadState, size, rotationRange, cropMinSize, cropMaxSize, crop, perspective, cropLimitToImage, cropOrigin, } = props;
    // image not ready, exit!
    if (!crop || !loadState || !loadState.beforeComplete)
        return rotationNext;
    // remember if current crop was at max size and centered, if so, resulting crop should also be at max size
    const cropWasAtMaxSize = isCropMaxSize(crop, size, rotationPrevious);
    const cropWasCentered = isCropCentered(crop, size, rotationPrevious);
    // get new state
    const res = applyRotationAction(rotationPrevious, rotationNext, rotationRange, crop, size, perspective, cropLimitToImage, cropOrigin, cropMinSize, cropMaxSize);
    // if is centered, and initial crop was at max size expand crop to max size
    if (cropWasAtMaxSize && cropWasCentered) {
        const rect = getMaxSizeInRect(size, rotationNext, rectAspectRatio(res.crop));
        // move top left corner
        res.crop.x += res.crop.width * 0.5;
        res.crop.y += res.crop.height * 0.5;
        res.crop.x -= rect.width * 0.5;
        res.crop.y -= rect.height * 0.5;
        // update size to max size
        res.crop.width = rect.width;
        res.crop.height = rect.height;
    }
    // return validated rotation value, then, after we assign that value, we update the crop rect
    // we may only call onUpdate if a change was made
    onUpdate(() => {
        props.crop = rectApply(res.crop, (v) => fixPrecision(v, 8));
    });
    // return result rotation (might have been rotated twice to fit crop rectangle)
    return res.rotation;
};
// updates the range of valid rotation input
const updateRotationRange = (imageSize, imageIsRotatedSideways, cropMinSize, cropSize, cropLimitToImage) => {
    if (!cropLimitToImage)
        return [MIN_ROTATION, MAX_ROTATION];
    /*
    - 'a' is angle between diagonal and image height
    - 'b' is angle between diagonal and crop height
    - 'c' is angle between diagonal and image width
    - resulting range is then a - b
    +----------/\------------------------+
    |         / \ \                      |
    |        /   \  \                    |
    |       /     \   \                  |
    |       \      \    \                |
    |         \     \     \              |
    |           \    \      \            |
    |             \   \       /          |
    |               \  \     /           |
    |                 \ \   /            |
    |                   \\a/b            |
    +---------------------\--------------+
    */
    const scalar = Math.max(cropMinSize.width / cropSize.width, cropMinSize.height / cropSize.height);
    const minSize = sizeCreate(cropSize.width * scalar, cropSize.height * scalar);
    // the hypotenus is the length of the diagonal of the min crop size
    const requiredSpace = sizeHypotenuse(minSize);
    // minimum space available in horizontal / vertical direction
    const availableSpace = Math.min(imageSize.width, imageSize.height);
    // if there's enough space available, we can return the max range
    if (requiredSpace < availableSpace)
        return [MIN_ROTATION, MAX_ROTATION];
    // if the image is turned we need to swap the width and height
    const imageWidth = imageIsRotatedSideways ? imageSize.height : imageSize.width;
    const imageHeight = imageIsRotatedSideways ? imageSize.width : imageSize.height;
    // subtracting the angle between the hypotenuse and the crop itself
    const a = Math.acos(minSize.height / requiredSpace);
    const b = Math.acos(imageHeight / requiredSpace);
    const c = Math.asin(imageWidth / requiredSpace);
    const rangeHorizontal = a - b;
    const rangeVertical = c - a;
    // range is not a number, it means we can rotate as much as we want
    if (Number.isNaN(rangeHorizontal) && Number.isNaN(rangeVertical))
        return [MIN_ROTATION, MAX_ROTATION];
    // get minimum range
    const range = Number.isNaN(rangeHorizontal)
        ? rangeVertical
        : Number.isNaN(rangeVertical)
            ? rangeHorizontal
            : Math.min(rangeHorizontal, rangeVertical);
    // if not, limit range to min and max rotation
    const rangeMin = Math.max(-range, MIN_ROTATION);
    const rangeMax = Math.min(range, MAX_ROTATION);
    return [rangeMin, rangeMax];
};
// updates the range of valid crop rectangle input
const updateCropRange = (imageSize, rotation, cropAspectRatio, cropMinSize, cropMaxSize, cropLimitToImage) => {
    // ! rotation doesn't affect min size, only max size
    // set lower bounds to crop min size
    const minSize = sizeClone(cropMinSize);
    // set upper bounds to crop max size
    const maxSize = sizeClone(cropMaxSize);
    // now we got basic bounds, let's see if we should limit to the image bounds, else we done
    if (!cropLimitToImage)
        return [minSize, maxSize];
    return [minSize, sizeApply(getMaxSizeInRect(imageSize, rotation, cropAspectRatio), Math.round)];
};
const formatShape = (shape, options) => {
    // only auto-format once
    if (!shape._isFormatted) {
        shape = shapeFormat(shape);
        shape._isFormatted = true;
    }
    // we need to make sure shape is still correctly positioned relative to parent context
    // draft cannot be relative
    // if context changed
    // if has left top right or bottom
    if (!shape._isDraft &&
        shapeHasRelativeSize(shape) &&
        (!shape._context || !rectEqual(options.context, shape._context))) {
        shape = shapeComputeRect(shape, options.context);
        shape._context = { ...options.context };
    }
    return shape;
};
const updateFrame = () => (frameShapeNext) => {
    if (!frameShapeNext)
        return;
    const shape = {
        frameStyle: undefined,
        x: 0,
        y: 0,
        width: '100%',
        height: '100%',
        disableStyle: ['backgroundColor', 'strokeColor', 'strokeWidth'],
    };
    if (isString(frameShapeNext)) {
        shape.frameStyle = frameShapeNext;
    }
    else {
        Object.assign(shape, frameShapeNext);
    }
    return shape;
};
var imageProps = [
    // image info received from read
    ['file'],
    ['size'],
    // loading and processing state
    ['loadState'],
    ['processState'],
    // derived info
    [
        'aspectRatio',
        DERIVED_STORE(({ size }) => [
            size,
            ($size) => ($size ? rectAspectRatio($size) : undefined),
        ]),
    ],
    // image modifications
    ['perspectiveX', DEFAULT_VALUE(() => 0)],
    ['perspectiveY', DEFAULT_VALUE(() => 0)],
    [
        'perspective',
        DERIVED_STORE(({ perspectiveX, perspectiveY }) => [
            [perspectiveX, perspectiveY],
            ([x, y]) => ({ x, y }),
        ]),
    ],
    ['rotation', DEFAULT_VALUE(() => 0), UPDATE_VALUE(updateRotation)],
    ['flipX', DEFAULT_VALUE(() => false)],
    ['flipY', DEFAULT_VALUE(() => false)],
    ['flip', DERIVED_STORE(({ flipX, flipY }) => [[flipX, flipY], ([x, y]) => ({ x, y })])],
    [
        'isRotatedSideways',
        UNIQUE_DERIVED_STORE(({ rotation }) => [
            [rotation],
            ([$rotation], set) => set(isRotatedSideways($rotation)),
            (prevValue, nextValue) => prevValue !== nextValue,
        ]),
    ],
    ['crop', UPDATE_VALUE(updateCropRect)],
    ['cropAspectRatio', UPDATE_VALUE(updateCropAspectRatio)],
    ['cropOrigin'],
    ['cropMinSize', DEFAULT_VALUE(() => ({ width: 1, height: 1 }))],
    ['cropMaxSize', DEFAULT_VALUE(() => ({ width: 32768, height: 32768 }))],
    ['cropLimitToImage', DEFAULT_VALUE(() => true), UPDATE_VALUE(updateCropLimitToImage)],
    [
        'cropSize',
        UNIQUE_DERIVED_STORE(({ crop }) => [
            [crop],
            ([$crop], set) => {
                if (!$crop)
                    return;
                set(sizeCreate($crop.width, $crop.height));
            },
            // if is same as previous size, don't trigger update (happens when updating only the crop offset)
            (prevValue, nextValue) => sizeEqual(prevValue, nextValue),
        ]),
    ],
    [
        'cropRectAspectRatio',
        DERIVED_STORE(({ cropSize }) => [
            [cropSize],
            ([$cropSize], set) => {
                if (!$cropSize)
                    return;
                set(fixPrecision(rectAspectRatio($cropSize), 5));
            },
        ]),
    ],
    [
        'cropRange',
        UNIQUE_DERIVED_STORE(({ size, rotation, cropRectAspectRatio, cropMinSize, cropMaxSize, cropLimitToImage, }) => [
            [size, rotation, cropRectAspectRatio, cropMinSize, cropMaxSize, cropLimitToImage],
            ([$size, $rotation, $cropRectAspectRatio, $cropMinSize, $cropMaxSize, $cropLimitToImage,], set) => {
                // wait for image size
                if (!$size)
                    return;
                const range = updateCropRange($size, $rotation, $cropRectAspectRatio, $cropMinSize, $cropMaxSize, $cropLimitToImage);
                set(range);
            },
            // if is same range as previous range, don't trigger update
            (prevRange, nextRange) => arrayEqual(prevRange, nextRange),
        ]),
    ],
    [
        'rotationRange',
        UNIQUE_DERIVED_STORE(({ size, isRotatedSideways, cropMinSize, cropSize, cropLimitToImage }) => [
            [size, isRotatedSideways, cropMinSize, cropSize, cropLimitToImage],
            ([$size, $isRotatedSideways, $cropMinSize, $cropSize, $cropLimitToImage], set) => {
                // wait for image size
                if (!$size || !$cropSize)
                    return;
                const range = updateRotationRange($size, $isRotatedSideways, $cropMinSize, $cropSize, $cropLimitToImage);
                set(range);
            },
            // if is same range as previous range, don't trigger update
            (prevRange, nextRange) => arrayEqual(prevRange, nextRange),
        ]),
    ],
    // canvas
    ['backgroundColor', UPDATE_VALUE(() => (color) => padColorArray(color))],
    // size
    ['targetSize'],
    // effects
    ['colorMatrix'],
    ['convolutionMatrix'],
    ['gamma'],
    ['noise'],
    ['vignette'],
    // annotations live in image space
    ['annotation', MAP_STORE(({ size }) => [formatShape, { context: size }])],
    // decorations live in crop space
    ['decoration', MAP_STORE(({ crop }) => [formatShape, { context: crop }])],
    // frame to render on top of the image (or outside)
    ['frame', UPDATE_VALUE(updateFrame)],
    // custom metadata
    ['metadata'],
    // state of image, used to restore a previous state or request the current state
    ['state', CUSTOM_STORE(stateStore)],
];

var process$1 = async (value, chainTasks, chainOptions = {}, processOptions) => {
    // options relevant to the process method itself
    const { ontaskstart, ontaskprogress, ontaskend, token } = processOptions;
    // has been cancelled
    let cancelled = false;
    // set cancel handler method
    token.cancel = () => {
        // cancel called from outside of the process method
        cancelled = true;
    };
    // step through chain
    for (const [index, task] of chainTasks.entries()) {
        // exit when cancelled
        if (cancelled)
            return;
        // get the task function and the id so we can notify the callee of the task that is being started
        const [fn, id] = task;
        // start task
        ontaskstart(index, id);
        try {
            value = await fn(value, { ...chainOptions }, (event) => ontaskprogress(index, id, event));
        }
        catch (err) {
            // stop processing more items in the chain
            cancelled = true;
            // pass error back to parent
            throw err;
        }
        ontaskend(index, id);
    }
    return value;
};

// TODO: find better location for minSize / file load validation
var createImageCore = ({ minSize = { width: 1, height: 1 } } = {}) => {
    // create default store
    const { stores, accessors } = createStores(imageProps);
    // pub/sub
    const { pub, sub } = pubsub();
    // processing handler
    const createProcessingHandler = (stateProp, eventKey) => {
        const getStore = () => accessors[stateProp] || {};
        const setStore = (obj) => (accessors[stateProp] = {
            ...getStore(),
            ...obj,
            timeStamp: Date.now(),
        });
        const hasError = () => getStore().error;
        const handleError = (error) => {
            if (hasError())
                return;
            setStore({
                error: error,
            });
            pub(`${eventKey}error`, { ...getStore() });
        };
        return {
            start() {
                pub(`${eventKey}start`);
            },
            onabort() {
                setStore({
                    abort: true,
                });
                pub(`${eventKey}abort`, { ...getStore() });
            },
            ontaskstart(index, id) {
                if (hasError())
                    return;
                setStore({
                    index,
                    task: id,
                    taskProgress: undefined,
                    taskLengthComputable: undefined,
                });
                pub(`${eventKey}taskstart`, { ...getStore() });
            },
            ontaskprogress(index, id, event) {
                if (hasError())
                    return;
                setStore({
                    index,
                    task: id,
                    taskProgress: event.loaded / event.total,
                    taskLengthComputable: event.lengthComputable,
                });
                pub(`${eventKey}taskprogress`, { ...getStore() });
                pub(`${eventKey}progress`, { ...getStore() });
            },
            ontaskend(index, id) {
                if (hasError())
                    return;
                setStore({
                    index,
                    task: id,
                });
                pub(`${eventKey}taskend`, { ...getStore() });
            },
            ontaskerror(error) {
                handleError(error);
            },
            error(error) {
                handleError(error);
            },
            beforeComplete(data) {
                if (hasError())
                    return;
                setStore({ beforeComplete: true });
                pub(`before${eventKey}`, data);
            },
            complete(data) {
                if (hasError())
                    return;
                setStore({ complete: true });
                pub(eventKey, data);
            },
        };
    };
    //#region read image
    const read = (src, { reader }) => {
        // exit if no reader supplied
        if (!reader)
            return;
        // reset file data to undefined as we're loading a new image
        Object.assign(accessors, {
            file: undefined,
            size: undefined,
            loadState: undefined,
        });
        // our cancel token so we can abort load if needed, cancel will be set by process
        let imageReadToken = { cancel: noop$1 };
        let imageReadCancelled = false;
        const imageReadHandler = createProcessingHandler('loadState', 'load');
        const processOptions = {
            token: imageReadToken,
            ...imageReadHandler,
        };
        const readerState = {
            src,
            size: undefined,
            dest: undefined,
        };
        const readerOptions = {};
        // wait a tick before starting image read so the read can be cancelled in loadstart
        Promise.resolve().then(async () => {
            try {
                imageReadHandler.start();
                if (imageReadCancelled)
                    return imageReadHandler.onabort();
                const output = (await process$1(readerState, reader, readerOptions, processOptions));
                // was cancelled
                if (imageReadCancelled)
                    return imageReadHandler.onabort();
                // get shortcuts for validation
                const { size, dest } = output || {};
                // if we don't have a size
                if (!size || !size.width || !size.height)
                    throw new EditorError('Image size missing', 'IMAGE_SIZE_MISSING', output);
                // size of image is too small
                if (size.width < minSize.width || size.height < minSize.height)
                    throw new EditorError('Image too small', 'IMAGE_TOO_SMALL', {
                        ...output,
                        minWidth: minSize.width,
                        minHeight: minSize.height,
                    });
                // update internal data
                Object.assign(accessors, {
                    size: size,
                    file: dest,
                });
                // before load complete
                imageReadHandler.beforeComplete(output);
                // done loading image
                imageReadHandler.complete(output);
            }
            catch (err) {
                imageReadHandler.error(err);
            }
            finally {
                imageReadToken = undefined;
            }
        });
        // call to abort load
        return () => {
            imageReadCancelled = true;
            imageReadToken && imageReadToken.cancel();
            imageReadHandler.onabort();
        };
    };
    //#endregion
    //#region write image
    const write = (writer, options) => {
        // not ready to start processing
        if (!accessors.loadState.complete)
            return;
        // reset process state to undefined
        accessors.processState = undefined;
        const imageWriteHandler = createProcessingHandler('processState', 'process');
        const writerState = {
            src: accessors.file,
            imageState: accessors.state,
            dest: undefined,
        };
        // willProcessImageState
        if (!writer) {
            imageWriteHandler.start();
            imageWriteHandler.complete(writerState);
            return;
        }
        // we need this token to be a blet to cancel the processing operation
        let imageWriteToken = { cancel: noop$1 };
        let imageWriteCancelled = false;
        const writerOptions = options;
        const processOptions = {
            token: imageWriteToken,
            ...imageWriteHandler,
        };
        // wait a tick before starting image write so the write can be cancelled in processtart
        Promise.resolve().then(async () => {
            try {
                imageWriteHandler.start();
                if (imageWriteCancelled)
                    return imageWriteHandler.onabort();
                const output = (await process$1(writerState, writer, writerOptions, processOptions));
                imageWriteHandler.complete(output);
            }
            catch (err) {
                imageWriteHandler.error(err);
            }
            finally {
                imageWriteToken = undefined;
            }
        });
        // call to abort processing
        return () => {
            imageWriteCancelled = true;
            imageWriteToken && imageWriteToken.cancel();
        };
    };
    //#endregion
    //#region api
    defineMethods(accessors, {
        read,
        write,
        on: sub,
    });
    //#endregion
    // expose store API
    return {
        accessors,
        stores,
    };
};

// @ts-ignore
const editorEventsToBubble = [
    'loadstart',
    'loadabort',
    'loaderror',
    'loadprogress',
    'load',
    'processstart',
    'processabort',
    'processerror',
    'processprogress',
    'process',
];
const imagePrivateProps = [
    'flip',
    'cropOrigin',
    'isRotatedSideways',
    'perspective',
    'perspectiveX',
    'perspectiveY',
    'cropRange',
];
const imagePublicProps = imageProps
    .map(([prop]) => prop)
    .filter((prop) => !imagePrivateProps.includes(prop));
const getImagePropGroupedName = (prop) => `image${capitalizeFirstLetter(prop)}`;
const isImageSource = (src) => isString(src) || isBinary(src) || isElement(src);
const isImageState = (obj) => hasProp(obj, 'crop');
var createImageEditor = () => {
    // create default stores
    const { stores, accessors } = createStores(props);
    // set up pub/sub for the app layer
    const { sub, pub } = pubsub();
    const bubble = (name) => (value) => pub(name, value);
    // helper method
    const getImageObjSafe = () => (accessors.images ? accessors.images[0] : {});
    // initialImageProps is the list of transforms to apply when the image loads
    let initialImageProps = {};
    // create shortcuts to image props : `crop` -> `imageCrop`
    imagePublicProps.forEach((prop) => {
        Object.defineProperty(accessors, getImagePropGroupedName(prop), {
            get: () => {
                // no image, can't get
                const image = getImageObjSafe();
                if (!image)
                    return;
                // return from image state
                return image.accessors[prop];
            },
            set: (value) => {
                // always use as initial prop when loading a new image without reset
                initialImageProps[getImagePropGroupedName(prop)] = value;
                // no image, we can't update
                const image = getImageObjSafe();
                if (!image)
                    return;
                // update the image immidiately
                image.accessors[prop] = value;
            },
        });
    });
    // internal helper method to get active image
    const getImage = () => accessors.images && accessors.images[0];
    // handling loading an image if a src is set
    const unsubSrc = stores.src.subscribe((src) => {
        // no image set, means clear active image
        if (!src)
            return (accessors.images = []);
        // exit here if we don't have an imageReader we'll wait for an imageReader to be defined
        if (!accessors.imageReader)
            return;
        // reset initial image props if an image is already loaded, so props applied to previous image aren't applied to the new one
        if (accessors.images.length)
            initialImageProps = {};
        // load image in src prop
        loadSrc(src);
    });
    const unsubReader = stores.imageReader.subscribe((reader) => {
        // can't do anything without an image reader
        if (!reader)
            return;
        // an image has already been loaded no need to load images that were set earlier
        if (accessors.images.length)
            return;
        // no image to load, we'll wait for images to be set to the `src` prop
        if (!accessors.src)
            return;
        // src is waiting to be loaded so let's pick it up,
        loadSrc(accessors.src);
    });
    const loadSrc = (src) => {
        // push it back a tick so we know initialImageProps are set
        Promise.resolve()
            .then(() => {
            // load with initial props
            return loadImage(src, initialImageProps);
        })
            .catch(() => {
            // fail silently, any errors are handled with 'loaderror' event
        });
    };
    //#endregion
    //#region public method (note that these are also called from UI, name of method is name of dispatched event in UI)
    const applyImageOptionsOrState = (image, options) => {
        // test if options is image state, if so, apply and exit
        if (isImageState(options)) {
            accessors.imageState = options;
            return;
        }
        // create an initial crop rect if no crop supplied
        if (!options.imageCrop) {
            const imageSize = image.accessors.size;
            const imageRotation = options.imageRotation || 0;
            const cropRect = rectCreateFromSize(sizeRotate(sizeClone(imageSize), imageRotation));
            const aspectRatio = options.imageCropAspectRatio ||
                (options.imageCropLimitToImage
                    ? rectAspectRatio(imageSize) // use image size if should limit to image
                    : rectAspectRatio(cropRect)); // use rotated crop rect bounds if no limit
            const crop = rectContainRect(cropRect, aspectRatio);
            // center the image in the crop rectangle
            if (!options.imageCropLimitToImage) {
                crop.x = (imageSize.width - crop.width) / 2;
                crop.y = (imageSize.height - crop.height) / 2;
            }
            options.imageCrop = crop;
        }
        // we need to apply these props in the correct order
        ['imageCropLimitToImage', 'imageCrop', 'imageCropAspectRatio', 'imageRotation']
            .filter((prop) => hasProp(options, prop))
            .forEach((prop) => {
            // assign to `image`
            accessors[prop] = options[prop];
            // remove from normalizedOptions so it's not set twice
            delete options[prop];
        });
        // don't set the above options for a second time
        const { imageCropLimitToImage, imageCrop, imageCropAspectRatio, imageRotation, ...remainingOptions } = options;
        // trigger setState
        Object.assign(accessors, remainingOptions);
    };
    // load image, resolve when image is loaded
    let imageLoadAbort;
    const loadImage = (src, options = {}) => new Promise((resolve, reject) => {
        // get current image
        let image = getImage();
        // determine min defined image size (is crop min size)
        const cropLimitedToImage = !(options.cropLimitToImage === false || options.imageCropLimitToImage === false);
        const cropMinSize = options.cropMinSize || options.imageCropMinSize;
        const minImageSize = cropLimitedToImage
            ? cropMinSize
            : image && image.accessors.cropMinSize;
        // if already has image, remove existing image
        if (image)
            removeImage();
        // access image props and stores
        image = createImageCore({ minSize: minImageSize });
        editorEventsToBubble.map((event) => image.accessors.on(event, bubble(event)));
        // done, clean up listeners
        const fin = () => {
            // reset initial props (as now applied)
            initialImageProps = {};
            unsubs.forEach((unsub) => unsub());
        };
        const unsubs = [];
        unsubs.push(image.accessors.on('loaderror', (error) => {
            fin();
            reject(error);
        }));
        unsubs.push(image.accessors.on('loadabort', () => {
            fin();
            reject({ name: 'AbortError' });
        }));
        unsubs.push(image.accessors.on('load', (output) => {
            imageLoadAbort = undefined;
            fin();
            resolve(output);
        }));
        unsubs.push(image.accessors.on('beforeload', () => applyImageOptionsOrState(image, options)));
        // set new image
        accessors.images = [image];
        // assign passed options to editor accessors, we ignore 'src'
        if (options.imageReader)
            accessors.imageReader = options.imageReader;
        if (options.imageWriter)
            accessors.imageWriter = options.imageWriter;
        // start reading image
        imageLoadAbort = image.accessors.read(src, { reader: accessors.imageReader });
    });
    // start processing a loaded image, resolve when image is processed
    let imageProcessAbort;
    const processImage = (src, options) => new Promise(async (resolve, reject) => {
        // if src supplied, first load src, then process
        if (isImageSource(src)) {
            await loadImage(src, options);
        }
        // if first argument is not `src` but is set it's an options object, so we'll update the options before generating the image
        else if (src) {
            if (isImageState(src)) {
                accessors.imageState = src;
            }
            else {
                Object.assign(accessors, src);
            }
        }
        // get current active image
        const image = getImage();
        // needs image for processing
        if (!image)
            return reject('no image');
        // done, clean up listeners
        const fin = () => {
            imageProcessAbort = undefined;
            unsubs.forEach((unsub) => unsub());
        };
        const unsubs = [];
        unsubs.push(image.accessors.on('processerror', (error) => {
            fin();
            reject(error);
        }));
        unsubs.push(image.accessors.on('processabort', () => {
            fin();
            reject({ name: 'AbortError' });
        }));
        unsubs.push(image.accessors.on('process', (output) => {
            fin();
            resolve(output);
        }));
        imageProcessAbort = image.accessors.write(accessors.imageWriter, {
            shapePreprocessor: accessors.shapePreprocessor || passthrough,
        });
    });
    const abortProcessImage = () => {
        const image = getImage();
        if (!image)
            return;
        if (imageProcessAbort)
            imageProcessAbort();
        image.accessors.processState = undefined;
    };
    // used internally (triggered by 'x' button when error loading image in UI)
    const abortLoadImage = () => {
        if (imageLoadAbort)
            imageLoadAbort();
        accessors.images = [];
    };
    // edit image, loads an image and resolve when image is processed
    const editImage = (src, options) => new Promise((resolve, reject) => {
        loadImage(src, options)
            .then(() => {
            // access image props and stores
            const { images } = accessors;
            const image = images[0];
            // done, clean up listeners
            const done = () => {
                unsubReject();
                unsubResolve();
            };
            const unsubReject = image.accessors.on('processerror', (error) => {
                done();
                reject(error);
            });
            const unsubResolve = image.accessors.on('process', (output) => {
                done();
                resolve(output);
            });
        })
            .catch(reject);
    });
    const removeImage = () => {
        // no images, nothing to remove
        const image = getImage();
        if (!image)
            return;
        // try to abort image load
        if (imageLoadAbort)
            imageLoadAbort();
        image.accessors.loadState = undefined;
        // clear images
        accessors.images = [];
    };
    //#endregion
    Object.defineProperty(accessors, 'stores', {
        get: () => stores,
    });
    //#region API
    defineMethods(accessors, {
        on: sub,
        loadImage,
        abortLoadImage,
        editImage,
        removeImage,
        processImage,
        abortProcessImage,
        destroy: () => {
            unsubSrc();
            unsubReader();
        },
    });
    return accessors;
    //#endregion
};

const processImage = (src, options) => {
    const { processImage } = createImageEditor();
    return processImage(src, options);
};

// custom method to draw images
const canvasDrawImage = async (ctx, image, srcRect, destRect) => {
    // get resized image
    const { dest } = await processImage(image, {
        imageReader: createDefaultImageReader$1(),
        imageWriter: createDefaultImageWriter$1({
            format: 'canvas',
            targetSize: {
                ...destRect,
                upscale: true,
            },
        }),
        imageCrop: srcRect,
    });
    // draw processed image
    ctx.drawImage(dest, destRect.x, destRect.y, destRect.width, destRect.height);
    // release image canvas to free up memory
    releaseCanvas(dest);
};
// connect function in process chain
const connect = (fn, getter = (...args) => args, setter) => async (state, options, onprogress) => {
    // will hold function result
    // at this point we don't know if the length of this task can be computed
    onprogress(createProgressEvent(0, false));
    // try to run the function
    let progressUpdated = false;
    const res = await fn(...getter(state, options, (event) => {
        progressUpdated = true;
        onprogress(event);
    }));
    // a setter isn't required
    setter && setter(state, res);
    // if progress was updated, we expect the connected function to fire the 1/1 event, else we fire it here
    if (!progressUpdated)
        onprogress(createProgressEvent(1, false));
    return state;
};
//
// Reader/Writer Presets
//
const AnyToFile = ({ srcProp = 'src', destProp = 'dest' } = {}) => [
    connect(srcToFile, (state, options, onprogress) => [state[srcProp], onprogress], (state, file) => (state[destProp] = file)),
    'any-to-file',
];
const BlobReadImageSize = ({ srcProp = 'src', destProp = 'size' } = {}) => [
    connect(getImageSize, (state, options) => [state[srcProp]], (state, size) => (state[destProp] = size)),
    'read-image-size',
];
const ImageSizeMatchOrientation = ({ srcSize = 'size', srcOrientation = 'orientation', destSize = 'size', } = {}) => [
    connect(orientImageSize, (state) => [state[srcSize], state[srcOrientation]], (state, size) => (state[destSize] = size)),
    'image-size-match-orientation',
];
const BlobReadImageHead = ({ srcProp = 'src', destProp = 'head' } = {}) => [
    connect((blob, slice) => (isJPEG(blob) ? blobReadSection(blob, slice) : undefined), 
    // 64 * 1024 should be plenty to find extract header
    // Exif metadata are restricted in size to 64 kB in JPEG images because
    // according to the specification this information must be contained within a single JPEG APP1 segment.
    (state) => [state[srcProp], [0, 64 * 2048], onprogress], (state, head) => (state[destProp] = head)),
    'read-image-head',
];
const ImageHeadReadExifOrientationTag = ({ srcProp = 'head', destProp = 'orientation', } = {}) => [
    connect(arrayBufferImageExif, (state) => [state[srcProp], ORIENTATION_TAG], (state, orientation = 1) => (state[destProp] = orientation)),
    'read-exif-orientation-tag',
];
const ImageHeadClearExifOrientationTag = ({ srcProp = 'head' } = {}) => [
    connect(arrayBufferImageExif, (state) => [state[srcProp], ORIENTATION_TAG, 1]),
    'clear-exif-orientation-tag',
];
const ApplyCanvasScalar = ({ srcImageSize = 'size', srcCanvasSize = 'imageData', srcImageState = 'imageState', destImageSize = 'size', destScalar = 'scalar', } = {}) => [
    connect((naturalSize, canvasSize, imageState) => {
        // calculate canvas scalar
        const scalar = Math.min(canvasSize.width / naturalSize.width, canvasSize.height / naturalSize.height);
        // done because not scaling
        if (scalar !== 1) {
            const { crop, annotation, decoration } = imageState;
            // origin to scale to
            const origin = vectorCreateEmpty();
            // scale select.crop
            if (crop)
                imageState.crop = rectScale(crop, scalar, origin);
            // scale annotation
            const translate = vectorCreateEmpty();
            imageState.annotation = annotation.map((shape) => shapeComputeTransform(shape, translate, scalar));
            // scale decoration
            imageState.decoration = decoration.map((shape) => shapeComputeTransform(shape, translate, scalar));
        }
        return [scalar, sizeCreateFromAny(canvasSize)];
    }, (state) => [state[srcImageSize], state[srcCanvasSize], state[srcImageState]], (state, [scalar, imageSize]) => {
        state[destScalar] = scalar;
        state[destImageSize] = imageSize;
    }),
    'calculate-canvas-scalar',
];
const BlobToImageData = ({ srcProp = 'src', destProp = 'imageData', canvasMemoryLimit = undefined, }) => [
    connect(blobToImageData, (state) => [state[srcProp], canvasMemoryLimit], (state, imageData) => (state[destProp] = imageData)),
    'blob-to-image-data',
];
const ImageDataMatchOrientation = ({ srcImageData = 'imageData', srcOrientation = 'orientation', } = {}) => [
    connect(orientImageData, (state) => [state[srcImageData], state[srcOrientation]], (state, imageData) => (state.imageData = imageData)),
    'image-data-match-orientation',
];
const ImageDataFill = ({ srcImageData = 'imageData', srcImageState = 'imageState', } = {}) => [
    connect(fillImageData, (state) => [
        state[srcImageData],
        { backgroundColor: state[srcImageState].backgroundColor },
    ], (state, imageData) => (state.imageData = imageData)),
    'image-data-fill',
];
const ImageDataCrop = ({ srcImageData = 'imageData', srcImageState = 'imageState', } = {}) => [
    connect(cropImageData, (state) => [
        state[srcImageData],
        {
            crop: state[srcImageState].crop,
            rotation: state[srcImageState].rotation,
            flipX: state[srcImageState].flipX,
            flipY: state[srcImageState].flipY,
        },
    ], (state, imageData) => (state.imageData = imageData)),
    'image-data-crop',
];
const hasTargetSize = (imageState) => !!((imageState.targetSize && imageState.targetSize.width) ||
    (imageState.targetSize && imageState.targetSize.height));
const ImageDataResize = ({ resize = {
    width: undefined,
    height: undefined,
    fit: undefined,
    upscale: undefined,
}, srcProp = 'imageData', srcImageState = 'imageState', destImageScaledSize = 'imageScaledSize', }) => [
    connect(resizeImageData, (state) => [
        state[srcProp],
        {
            width: Math.min(resize.width || Number.MAX_SAFE_INTEGER, (state[srcImageState].targetSize && state[srcImageState].targetSize.width) ||
                Number.MAX_SAFE_INTEGER),
            height: Math.min(resize.height || Number.MAX_SAFE_INTEGER, (state[srcImageState].targetSize && state[srcImageState].targetSize.height) ||
                Number.MAX_SAFE_INTEGER),
            fit: resize.fit || 'contain',
            upscale: hasTargetSize(state[srcImageState]) ? true : resize.upscale || false,
        },
    ], (state, imageData) => {
        if (!sizeEqual(state.imageData, imageData))
            state[destImageScaledSize] = sizeCreateFromAny(imageData);
        state.imageData = imageData;
    }),
    'image-data-resize',
];
const ImageDataFilter = ({ srcImageData = 'imageData', srcImageState = 'imageState', destImageData = 'imageData', } = {}) => [
    connect(filterImageData, (state) => {
        const { colorMatrix } = state[srcImageState];
        const colorMatrices = colorMatrix &&
            Object.keys(colorMatrix)
                .map((name) => colorMatrix[name])
                .filter(Boolean);
        return [
            state[srcImageData],
            {
                colorMatrix: colorMatrices && getColorMatrixFromColorMatrices(colorMatrices),
                convolutionMatrix: state[srcImageState].convolutionMatrix,
                gamma: state[srcImageState].gamma,
                noise: state[srcImageState].noise,
                vignette: state[srcImageState].vignette,
            },
        ];
    }, (state, imageData) => (state[destImageData] = imageData)),
    'image-data-filter',
];
const ImageDataAnnotate = ({ srcImageData = 'imageData', srcSize = 'size', srcImageState = 'imageState', destImageData = 'imageData', destImageScaledSize = 'imageScaledSize', } = {}) => [
    connect(drawImageData, (state, { shapePreprocessor }) => [
        state[srcImageData],
        {
            shapes: state[srcImageState].annotation,
            context: state[srcSize],
            transform: (ctx) => {
                const imageSize = state[srcSize];
                const { crop = rectCreateFromSize(imageSize), rotation = 0, flipX, flipY, } = state[srcImageState];
                const rotatedRect = getImageTransformedRect(imageSize, rotation);
                const rotatedSize = {
                    width: rotatedRect.width,
                    height: rotatedRect.height,
                };
                // calculate image scalar so we can scale annotations accordingly
                const scaledSize = state[destImageScaledSize];
                const scalar = scaledSize
                    ? Math.min(scaledSize.width / crop.width, scaledSize.height / crop.height)
                    : 1;
                // calculate center
                const dx = imageSize.width * 0.5 - rotatedSize.width * 0.5;
                const dy = imageSize.height * 0.5 - rotatedSize.height * 0.5;
                const center = sizeCenter(imageSize);
                // image scalar
                ctx.scale(scalar, scalar);
                // offset
                ctx.translate(-dx, -dy);
                ctx.translate(-crop.x, -crop.y);
                // rotation
                ctx.translate(center.x, center.y);
                ctx.rotate(rotation);
                ctx.translate(-center.x, -center.y);
                // flipping
                ctx.scale(flipX ? -1 : 1, flipY ? -1 : 1);
                ctx.translate(flipX ? -imageSize.width : 0, flipY ? -imageSize.height : 0);
                // annotations are clipped clip to image
                ctx.rect(0, 0, imageSize.width, imageSize.height);
                ctx.clip();
            },
            drawImage: canvasDrawImage,
            preprocessShape: (shape) => shapePreprocessor(shape, { isPreview: false }),
        },
    ], (state, imageData) => (state[destImageData] = imageData)),
    'image-data-annotate',
];
const ImageDataDecorate = ({ srcImageData = 'imageData', srcImageState = 'imageState', destImageData = 'imageData', destImageScaledSize = 'imageScaledSize', } = {}) => [
    connect(drawImageData, (state, { shapePreprocessor }) => [
        state[srcImageData],
        {
            shapes: state[srcImageState].decoration,
            context: state[srcImageState].crop,
            transform: (ctx) => {
                // calculate image scalar so we can scale decoration accordingly
                const { crop } = state.imageState;
                const scaledSize = state[destImageScaledSize];
                const scalar = scaledSize
                    ? Math.min(scaledSize.width / crop.width, scaledSize.height / crop.height)
                    : 1;
                ctx.scale(scalar, scalar);
            },
            drawImage: canvasDrawImage,
            preprocessShape: (shape) => shapePreprocessor(shape, { isPreview: false }),
        },
    ], (state, imageData) => (state[destImageData] = imageData)),
    'image-data-decorate',
];
const ImageDataFrame = ({ srcImageData = 'imageData', srcImageState = 'imageState', destImageData = 'imageData', destImageScaledSize = 'imageScaledSize', } = {}) => [
    connect(drawImageData, (state, { shapePreprocessor }) => {
        const frame = state[srcImageState].frame;
        if (!frame)
            return [state[srcImageData]];
        const context = { ...state[srcImageState].crop };
        const bounds = shapesBounds(shapesFromCompositShape(frame, context, shapePreprocessor), context);
        context.x = Math.abs(bounds.left);
        context.y = Math.abs(bounds.top);
        context.width += Math.abs(bounds.left) + Math.abs(bounds.right);
        context.height += Math.abs(bounds.top) + Math.abs(bounds.bottom);
        const { crop } = state.imageState;
        const scaledSize = state[destImageScaledSize];
        const scalar = scaledSize
            ? Math.min(scaledSize.width / crop.width, scaledSize.height / crop.height)
            : 1;
        rectMultiply(context, scalar);
        // use floor because we can't fill up half pixels
        context.x = Math.floor(context.x);
        context.y = Math.floor(context.y);
        context.width = Math.floor(context.width);
        context.height = Math.floor(context.height);
        return [
            state[srcImageData],
            {
                shapes: [frame],
                contextBounds: context,
                transform: (ctx) => {
                    ctx.translate(context.x, context.y);
                },
                drawImage: canvasDrawImage,
                preprocessShape: (shape) => shapePreprocessor(shape, { isPreview: false }),
            },
        ];
    }, (state, imageData) => (state[destImageData] = imageData)),
    'image-data-frame',
];
const ImageDataToBlob = ({ mimeType = undefined, quality = undefined, srcImageData = 'imageData', srcFile = 'src', destBlob = 'blob', } = {}) => [
    connect(imageDataToBlob, (state) => [
        state[srcImageData],
        mimeType || getMimeTypeFromFilename(state[srcFile].name) || state[srcFile].type,
        quality,
    ], (state, blob) => (state[destBlob] = blob)),
    'image-data-to-blob',
];
const ImageDataToCanvas = ({ srcImageData = 'imageData', srcOrientation = 'orientation', destCanvas = 'dest', } = {}) => [
    connect(imageDataToCanvas, (state) => [state[srcImageData], state[srcOrientation]], (state, canvas) => (state[destCanvas] = canvas)),
    'image-data-to-canvas',
];
const writeImageHead = async (blob, head) => {
    if (!isJPEG(blob) || !head)
        return blob;
    // get exif section
    const view = new DataView(head);
    const markers = dataViewGetApplicationMarkers(view);
    if (!markers || !markers.exif)
        return blob;
    const { exif } = markers;
    // from byte 0 to end of exif header
    const exifBuffer = head.slice(0, exif.offset + exif.size + 2);
    return blobWriteSection(blob, 
    // insert head buffer into blob
    exifBuffer, 
    // current blob doesn't have exif header (as outputted by canvas), so we insert ours in
    // (jpeg header 2) + (jfif size 16) + (app1 header 2)
    [20]);
};
const BlobWriteImageHead = (srcBlob = 'blob', srcHead = 'head', destBlob = 'blob') => [
    connect(writeImageHead, (state) => [state[srcBlob], state[srcHead]], (state, blob) => (state[destBlob] = blob)),
    'blob-write-image-head',
];
const BlobToFile = ({ renameFile = undefined, srcBlob = 'blob', srcFile = 'src', destFile = 'dest', defaultFilename = undefined, } = {}) => [
    connect(blobToFile, (state) => [
        state[srcBlob],
        renameFile
            ? renameFile(state[srcFile])
            : state[srcFile].name ||
                `${defaultFilename}.${getExtensionFromMimeType(state[srcBlob].type)}`,
    ], (state, file) => (state[destFile] = file)),
    'blob-to-file',
];
const Store = ({ url = './', dataset = (state) => [
    ['dest', state.dest, state.dest.name],
    ['imageState', state.imageState],
], destStore = 'store', }) => [
    connect(
    // upload function
    async (dataset, onprogress) => await post(url, dataset, { onprogress }), 
    // get state values
    (state, options, onprogress) => [dataset(state), onprogress], 
    // set state values
    (state, xhr) => (state[destStore] = xhr) // logs XHR request returned by `post`
    ),
    'store',
];
const PropFilter = (allowlist) => [
    connect((state) => {
        // if no allowlist suppleid or is empty array we don't filter
        if (!allowlist || !allowlist.length)
            return state;
        // else we only allow the props defined in the list and delete non matching props
        Object.keys(state).forEach((key) => {
            if (allowlist.includes(key))
                return;
            delete state[key];
        });
        return state;
    }),
    'prop-filter',
];
// Generic image reader, suitable for most use cases
const createDefaultImageReader$1 = (options = {}) => {
    const { orientImage = true, outputProps = ['src', 'dest', 'size'], preprocessImageFile, } = options;
    return [
        // can read most source files and turn them into blobs
        AnyToFile(),
        // TODO: test if supported mime/type
        // called when file created, can be used to read unrecognized files
        preprocessImageFile && [
            connect(preprocessImageFile, (state, options, onprogress) => [
                state.dest,
                options,
                onprogress,
            ], (state, file) => (state.dest = file)),
            'preprocess-image-file',
        ],
        // quickly read size (only reads first part of image)
        BlobReadImageSize({ srcProp: 'dest' }),
        // fix image orientation
        orientImage && BlobReadImageHead({ srcProp: 'dest' }),
        orientImage && ImageHeadReadExifOrientationTag(),
        orientImage && ImageSizeMatchOrientation(),
        // remove unwanted props
        PropFilter(outputProps),
    ].filter(Boolean);
};
const createDefaultImageWriter$1 = (options = {}) => {
    const { canvasMemoryLimit = isIOS() ? 4096 * 4096 : Infinity, orientImage = true, copyImageHead = true, mimeType = undefined, quality = undefined, renameFile = undefined, targetSize = undefined, store = undefined, format = 'file', outputProps = ['src', 'dest', 'imageState', 'store'], preprocessImageSource, preprocessImageState, postprocessImageData, postprocessImageBlob, } = options;
    return [
        // allow preprocessing of image blob, should return a new blob, for example to automatically make image background transparent
        preprocessImageSource && [
            connect(preprocessImageSource, (state, options, onprogress) => [
                state.src,
                options,
                onprogress,
            ], (state, src) => (state.src = src)),
            'preprocess-image-source',
        ],
        // get orientation info (if is jpeg)
        (orientImage || copyImageHead) && BlobReadImageHead(),
        orientImage && ImageHeadReadExifOrientationTag(),
        // get image size
        BlobReadImageSize(),
        // allow preproccesing of image state for example to replace placeholders
        preprocessImageState && [
            connect(preprocessImageState, (state, options, onprogress) => [
                state.imageState,
                options,
                onprogress,
            ], (state, imageState) => (state.imageState = imageState)),
            'preprocess-image-state',
        ],
        // get image data
        BlobToImageData({ canvasMemoryLimit }),
        // fix image orientation
        orientImage && ImageSizeMatchOrientation(),
        orientImage && ImageDataMatchOrientation(),
        // apply canvas scalar to data
        ApplyCanvasScalar(),
        // apply image state
        ImageDataCrop(),
        ImageDataResize({ resize: targetSize }),
        ImageDataFilter(),
        ImageDataFill(),
        ImageDataAnnotate(),
        ImageDataDecorate(),
        ImageDataFrame(),
        // run post processing on image data, for example to apply circular crop
        postprocessImageData && [
            connect(postprocessImageData, (state, options, onprogress) => [
                state.imageData,
                options,
                onprogress,
            ], (state, imageData) => (state.imageData = imageData)),
            'postprocess-image-data',
        ],
        // convert to correct output format
        format === 'file'
            ? ImageDataToBlob({ mimeType, quality })
            : format === 'canvas'
                ? ImageDataToCanvas()
                : [
                    (state) => {
                        state.dest = state.imageData;
                        return state;
                    },
                ],
        // we overwite the exif orientation tag so the image is oriented correctly
        format === 'file' && orientImage && ImageHeadClearExifOrientationTag(),
        // we write the new image head to the target blob
        format === 'file' && copyImageHead && BlobWriteImageHead(),
        // allow converting the blob to a different format
        postprocessImageBlob && [
            connect(postprocessImageBlob, ({ blob, imageData, src }, options, onprogress) => [
                { blob, imageData, src },
                options,
                onprogress,
            ], (state, blob) => (state.blob = blob)),
            'postprocess-image-file',
        ],
        // turn the image blob into a file, will also rename the file
        format === 'file' && BlobToFile({ defaultFilename: 'image', renameFile }),
        // upload or process data if is a file
        format === 'file'
            ? // used for file output formats
                store &&
                    (isString(store)
                        ? // a basic store to post to
                            Store({ url: store })
                        : // see if is fully custom or store config
                            isFunction$1(store)
                                ? // fully custom store function
                                    [store, 'store']
                                : // a store configuration object
                                    Store(store))
            : // used for imageData and canvas output formats
                isFunction$1(store) && [store, 'store'],
        // remove unwanted props
        PropFilter(outputProps),
    ].filter(Boolean);
};

var getComponentExportedProps = (Component) => {
    const descriptors = Object.getOwnPropertyDescriptors(Component.prototype);
    return Object.keys(descriptors).filter((key) => !!descriptors[key]['get']);
};

function circOut(t) {
    return Math.sqrt(1 - --t * t);
}

function is_date(obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
}

function get_interpolator(a, b) {
    if (a === b || a !== a)
        return () => a;
    const type = typeof a;
    if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
        throw new Error('Cannot interpolate values of different type');
    }
    if (Array.isArray(a)) {
        const arr = b.map((bi, i) => {
            return get_interpolator(a[i], bi);
        });
        return t => arr.map(fn => fn(t));
    }
    if (type === 'object') {
        if (!a || !b)
            throw new Error('Object cannot be null');
        if (is_date(a) && is_date(b)) {
            a = a.getTime();
            b = b.getTime();
            const delta = b - a;
            return t => new Date(a + t * delta);
        }
        const keys = Object.keys(b);
        const interpolators = {};
        keys.forEach(key => {
            interpolators[key] = get_interpolator(a[key], b[key]);
        });
        return t => {
            const result = {};
            keys.forEach(key => {
                result[key] = interpolators[key](t);
            });
            return result;
        };
    }
    if (type === 'number') {
        const delta = b - a;
        return t => a + t * delta;
    }
    throw new Error(`Cannot interpolate ${type} values`);
}
function tweened(value, defaults = {}) {
    const store = writable(value);
    let task;
    let target_value = value;
    function set(new_value, opts) {
        if (value == null) {
            store.set(value = new_value);
            return Promise.resolve();
        }
        target_value = new_value;
        let previous_task = task;
        let started = false;
        let { delay = 0, duration = 400, easing = identity, interpolate = get_interpolator } = assign(assign({}, defaults), opts);
        if (duration === 0) {
            if (previous_task) {
                previous_task.abort();
                previous_task = null;
            }
            store.set(value = target_value);
            return Promise.resolve();
        }
        const start = now() + delay;
        let fn;
        task = loop(now => {
            if (now < start)
                return true;
            if (!started) {
                fn = interpolate(value, new_value);
                if (typeof duration === 'function')
                    duration = duration(value, new_value);
                started = true;
            }
            if (previous_task) {
                previous_task.abort();
                previous_task = null;
            }
            const elapsed = now - start;
            if (elapsed > duration) {
                store.set(value = new_value);
                return false;
            }
            // @ts-ignore
            store.set(value = fn(easing(elapsed / duration)));
            return true;
        });
        return task.promise;
    }
    return {
        set,
        update: (fn, opts) => set(fn(target_value, value), opts),
        subscribe: store.subscribe
    };
}

// @ts-ignore
function tick_spring(ctx, last_value, current_value, target_value) {
    if (typeof current_value === 'number') {
        // @ts-ignore
        const delta = target_value - current_value;
        // @ts-ignore
        const velocity = (current_value - last_value) / (ctx.dt || 1 / 60); // guard div by 0
        const spring = ctx.opts.stiffness * delta;
        const damper = ctx.opts.damping * velocity;
        const acceleration = (spring - damper) * ctx.inv_mass;
        const d = (velocity + acceleration) * ctx.dt;
        if (Math.abs(d) < ctx.opts.precision && Math.abs(delta) < ctx.opts.precision) {
            return target_value; // settled
        }
        else {
            ctx.settled = false; // signal loop to keep ticking
            // @ts-ignore
            return current_value + d;
        }
    }
    else if (isArray(current_value)) {
        // @ts-ignore
        return current_value.map((_, i) => tick_spring(ctx, last_value[i], current_value[i], target_value[i]));
    }
    else if (typeof current_value === 'object') {
        const next_value = {};
        // @ts-ignore
        for (const k in current_value) {
            // @ts-ignore
            next_value[k] = tick_spring(ctx, last_value[k], current_value[k], target_value[k]);
        }
        // @ts-ignore
        return next_value;
    }
    else {
        throw new Error(`Cannot spring ${typeof current_value} values`);
    }
}
// export interface Spring {
//     set: (new_value: any, opts?: SpringUpdateOpts) => Promise<void>;
//     update: (fn: Function, opts?: SpringUpdateOpts) => Promise<void>;
//     subscribe: Function;
//     precision: number;
//     damping: number;
//     stiffness: number;
// }
function spring$2(value, opts = {}) {
    const store = writable(value);
    const { stiffness = 0.15, damping = 0.8, precision = 0.01 } = opts;
    let last_time;
    let task;
    let current_token;
    let last_value = value;
    let target_value = value;
    let inv_mass = 1;
    let inv_mass_recovery_rate = 0;
    let cancel_task = false;
    function set(new_value, opts = {}) {
        target_value = new_value;
        const token = (current_token = {});
        if (value == null || opts.hard || (spring.stiffness >= 1 && spring.damping >= 1)) {
            cancel_task = true; // cancel any running animation
            last_time = null;
            last_value = new_value;
            store.set((value = target_value));
            return Promise.resolve();
        }
        else if (opts.soft) {
            const rate = opts.soft === true ? 0.5 : +opts.soft;
            inv_mass_recovery_rate = 1 / (rate * 60);
            inv_mass = 0; // infinite mass, unaffected by spring forces
        }
        if (!task) {
            last_time = null;
            cancel_task = false;
            const ctx = {
                inv_mass: undefined,
                opts: spring,
                settled: true,
                dt: undefined,
            };
            task = loop((now) => {
                if (last_time === null)
                    last_time = now;
                if (cancel_task) {
                    cancel_task = false;
                    task = null;
                    return false;
                }
                inv_mass = Math.min(inv_mass + inv_mass_recovery_rate, 1);
                // altered so doesn't create a new object
                ctx.inv_mass = inv_mass;
                ctx.opts = spring;
                ctx.settled = true; // tick_spring may signal false
                ctx.dt = ((now - last_time) * 60) / 1000;
                const next_value = tick_spring(ctx, last_value, value, target_value);
                last_time = now;
                last_value = value;
                store.set((value = next_value));
                if (ctx.settled)
                    task = null;
                return !ctx.settled;
            });
        }
        return new Promise((fulfil) => {
            task.promise.then(() => {
                if (token === current_token)
                    fulfil();
            });
        });
    }
    const spring = {
        set,
        update: (fn, opts) => set(fn(target_value, value), opts),
        subscribe: store.subscribe,
        stiffness,
        damping,
        precision,
    };
    return spring;
}

var prefersReducedMotion = readable(false, set => {
    const mql = window$1.matchMedia('(prefers-reduced-motion:reduce)');
    set(mql.matches);
    mql.onchange = () => set(mql.matches);
});

var hasResizeObserver = () => 'ResizeObserver' in window$1;

//
const rectNext = rectCreateEmpty();
const updateNodeRect = (node, x, y, width, height) => {
    if (!node.rect)
        node.rect = rectCreateEmpty();
    const rect = node.rect;
    rectUpdate(rectNext, x, y, width, height);
    if (rectEqual(rect, rectNext))
        return;
    rectUpdateWithRect(rect, rectNext);
    node.dispatchEvent(new CustomEvent('measure', { detail: rect }));
};
// measures the element
const r$1 = Math.round;
const measureViewRect = (node) => {
    const clientRect = node.getBoundingClientRect();
    updateNodeRect(node, r$1(clientRect.x), r$1(clientRect.y), r$1(clientRect.width), r$1(clientRect.height));
};
const measureOffset = (node) => updateNodeRect(node, node.offsetLeft, node.offsetTop, node.offsetWidth, node.offsetHeight);
// holds all the elements to measure using requestAnimationFrame
const elements = [];
// draw loop
let frame = null;
function tick() {
    if (!elements.length) {
        frame = null;
        return;
    }
    elements.forEach((node) => node.measure(node));
    frame = requestAnimationFrame(tick);
}
let observer; // ResizeObserver API not known by TypeScript
var measurable = (node, options = {}) => {
    const { observePosition = false, observeViewRect = false, once = false, disabled = false, } = options;
    // exit
    if (disabled)
        return;
    // use resize observe if available
    if (hasResizeObserver() && !observePosition && !observeViewRect) {
        // we only create one observer, it will observe all registered elements
        if (!observer) {
            // @ts-ignore: [2020-02-20] ResizeObserver API not known by TypeScript
            observer = new ResizeObserver((entries) => {
                // @ts-ignore
                entries.forEach((entry) => measureOffset(entry.target));
            });
        }
        // start observing this node
        observer.observe(node);
        // measure our node for the first time
        measureOffset(node);
        // if should only measure once, remove now
        if (once)
            observer.unobserve(node);
        // and we done, need to return a clean up method for when our node is destroyed
        return {
            destroy() {
                // already unobserved this node
                if (once)
                    return;
                observer.unobserve(node);
                // TODO: test if all nodes have been removed, if so, remove observer
            },
        };
    }
    // set measure function
    node.measure = observeViewRect ? measureViewRect : measureOffset;
    // add so the element is measured
    elements.push(node);
    // start measuring on next frame, we set up a single measure loop,
    // the loop will check if there's still elements that need to be measured,
    // else it will stop running
    if (!frame)
        frame = requestAnimationFrame(tick);
    // measure this element now
    node.measure(node);
    // remove method
    return {
        destroy() {
            const index = elements.indexOf(node);
            elements.splice(index, 1);
        },
    };
};

var focusvisible = (element) => {
    let isKeyboardInteraction = false;
    const handlePointerdown = () => {
        isKeyboardInteraction = false;
    };
    const handleKeydown = () => {
        isKeyboardInteraction = true;
    };
    const handleKeyup = () => {
        isKeyboardInteraction = false;
    };
    const handleFocus = (e) => {
        if (!isKeyboardInteraction)
            return;
        e.target.dataset.focusVisible = '';
    };
    const handleBlur = (e) => {
        delete e.target.dataset.focusVisible;
    };
    const map = {
        pointerdown: handlePointerdown,
        keydown: handleKeydown,
        keyup: handleKeyup,
        focus: handleFocus,
        blur: handleBlur,
    };
    Object.keys(map).forEach((event) => element.addEventListener(event, map[event], true));
    return {
        destroy() {
            Object.keys(map).forEach((event) => element.removeEventListener(event, map[event], true));
        },
    };
};

const getResourceFromItem = async (item) => new Promise((resolve) => {
    if (item.kind === 'file')
        return resolve(item.getAsFile());
    item.getAsString(resolve);
});
const getResourcesFromEvent = (e) => new Promise((resolve, reject) => {
    const { items } = e.dataTransfer;
    if (!items)
        return resolve([]);
    Promise.all(Array.from(items).map(getResourceFromItem))
        .then((res) => {
        resolve(res.filter((item) => (isBinary(item) && isImage(item)) || /^http/.test(item)));
    })
        .catch(reject);
});
var dropable = (node, options = {}) => {
    const handleDragOver = (e) => {
        // need to be prevent default to allow drop
        e.preventDefault();
    };
    const handleDrop = async (e) => {
        e.preventDefault();
        e.stopPropagation(); // prevents parents from catching this drop
        try {
            const resources = await getResourcesFromEvent(e);
            node.dispatchEvent(new CustomEvent('dropfiles', {
                detail: {
                    event: e,
                    resources,
                },
                ...options,
            }));
        }
        catch (err) {
            // silent, wasn't able to catch
        }
    };
    node.addEventListener('drop', handleDrop);
    node.addEventListener('dragover', handleDragOver);
    // remove method
    return {
        destroy() {
            node.removeEventListener('drop', handleDrop);
            node.removeEventListener('dragover', handleDragOver);
        },
    };
};

let result$7 = null;
var supportsWebGL2 = () => {
    if (result$7 === null) {
        if ('WebGL2RenderingContext' in window$1) {
            let canvas;
            try {
                canvas = h$1('canvas');
                result$7 = !!canvas.getContext('webgl2');
            }
            catch (err) {
                result$7 = false;
            }
            canvas && releaseCanvas(canvas);
        }
        else {
            result$7 = false;
        }
    }
    return result$7;
};

var getWebGLContext = (canvas, attrs) => {
    if (supportsWebGL2())
        return canvas.getContext('webgl2', attrs);
    return (canvas.getContext('webgl', attrs) ||
        canvas.getContext('experimental-webgl', attrs));
};

let result$6 = null;
var isSoftwareRendering = () => {
    if (result$6 === null) {
        if (isBrowser()) {
            const canvas = h$1('canvas');
            result$6 = !getWebGLContext(canvas, {
                failIfMajorPerformanceCaveat: true,
            });
            releaseCanvas(canvas);
        }
        else {
            result$6 = false;
        }
    }
    return result$6;
};

var isPowerOf2 = (value) => (value & (value - 1)) === 0;

var stringReplace = (str, entries = {}, prefix = '', postfix = '') => {
    return Object.keys(entries)
        .filter((key) => !isObject$1(entries[key]))
        .reduce((prev, curr) => {
        return prev.replace(new RegExp(prefix + curr + postfix), entries[curr]);
    }, str);
};

var SHADER_FRAG_HEAD = "#version 300 es\nprecision highp float;\n\nout vec4 fragColor;"; // eslint-disable-line

var SHADER_FRAG_INIT = "\nfloat a=1.0;vec4 fillColor=uColor;vec4 textureColor=texture(uTexture,vTexCoord);textureColor*=(1.0-step(1.0,vTexCoord.y))*step(0.0,vTexCoord.y)*(1.0-step(1.0,vTexCoord.x))*step(0.0,vTexCoord.x);"; // eslint-disable-line

var SHADER_FRAG_MASK = "\nuniform float uMaskFeather[8];uniform float uMaskBounds[4];uniform float uMaskOpacity;float mask(float x,float y,float bounds[4],float opacity){return 1.0-(1.0-(smoothstep(bounds[3],bounds[3]+1.0,x)*(1.0-smoothstep(bounds[1]-1.0,bounds[1],x))*(1.0-step(bounds[0],y))*step(bounds[2],y)))*(1.0-opacity);}"; // eslint-disable-line

var SHADER_FRAG_MASK_APPLY = "\nfloat m=mask(gl_FragCoord.x,gl_FragCoord.y,uMaskBounds,uMaskOpacity);"; // eslint-disable-line

var SHADER_FRAG_MASK_FEATHER_APPLY = "\nfloat leftFeatherOpacity=step(uMaskFeather[1],gl_FragCoord.x)*uMaskFeather[0]+((1.0-uMaskFeather[0])*smoothstep(uMaskFeather[1],uMaskFeather[3],gl_FragCoord.x));float rightFeatherOpacity=(1.0-step(uMaskFeather[7],gl_FragCoord.x))*uMaskFeather[4]+((1.0-uMaskFeather[4])*smoothstep(uMaskFeather[7],uMaskFeather[5],gl_FragCoord.x));a*=leftFeatherOpacity*rightFeatherOpacity;"; // eslint-disable-line

var SHADER_FRAG_RECT_AA = "\nvec2 scaledPoint=vec2(vRectCoord.x*uSize.x,vRectCoord.y*uSize.y);a*=smoothstep(0.0,1.0,uSize.x-scaledPoint.x);a*=smoothstep(0.0,1.0,uSize.y-scaledPoint.y);a*=smoothstep(0.0,1.0,scaledPoint.x);a*=smoothstep(0.0,1.0,scaledPoint.y);"; // eslint-disable-line

var SHADER_FRAG_CORNER_RADIUS = "\nvec2 s=(uSize-2.0)*.5;vec2 r=(vRectCoord*uSize);vec2 p=r-(uSize*.5);float cornerRadius=uCornerRadius[0];bool left=r.x<s.x;bool top=r.y<s.x;if(!left&&top){cornerRadius=uCornerRadius[1];}if(!left&&!top){cornerRadius=uCornerRadius[3];}if(left&&!top){cornerRadius=uCornerRadius[2];}a*=1.0-clamp(length(max(abs(p)-(s-cornerRadius),0.0))-cornerRadius,0.0,1.0);"; // eslint-disable-line

var SHADER_FRAG_SHAPE_BLEND_COLOR = "\nif(m<=0.0)discard;fillColor.a*=a;fillColor.rgb*=fillColor.a;fillColor.rgb*=m;fillColor.rgb+=(1.0-m)*(uCanvasColor.rgb*fillColor.a);textureColor*=uTextureOpacity;textureColor.a*=a;textureColor.rgb*=m*a;textureColor.rgb+=(1.0-m)*(uCanvasColor.rgb*textureColor.a);fragColor=textureColor+(fillColor*(1.0-textureColor.a));"; // eslint-disable-line

var SHADER_FRAG_TEXTURE_COLORIZE = "\nif(uTextureColor.a!=0.0&&textureColor.a>0.0){vec3 colorFlattened=textureColor.rgb/textureColor.a;if(colorFlattened.r>.999999&&colorFlattened.g==0.0&&colorFlattened.b>.999999){textureColor.rgb=uTextureColor.rgb*textureColor.a;}textureColor*=uTextureColor.a;}"; // eslint-disable-line

var SHADER_VERT_HEAD = "#version 300 es\n\nin vec4 aPosition;uniform mat4 uMatrix;"; // eslint-disable-line

var SHADER_VERT_MULTIPLY_MATRUX = "\ngl_Position=uMatrix*vec4(aPosition.x,aPosition.y,0,1);"; // eslint-disable-line

var SHADER_VERT_TEXTURE = "\nin vec2 aTexCoord;out vec2 vTexCoord;"; // eslint-disable-line

const SHADER_VERT_SNIPPETS = {
    head: SHADER_VERT_HEAD,
    text: SHADER_VERT_TEXTURE,
    matrix: SHADER_VERT_MULTIPLY_MATRUX,
};
const SHADER_FRAG_SNIPPETS = {
    head: SHADER_FRAG_HEAD,
    mask: SHADER_FRAG_MASK,
    init: SHADER_FRAG_INIT,
    colorize: SHADER_FRAG_TEXTURE_COLORIZE,
    maskapply: SHADER_FRAG_MASK_APPLY,
    maskfeatherapply: SHADER_FRAG_MASK_FEATHER_APPLY,
    edgeaa: SHADER_FRAG_RECT_AA,
    cornerradius: SHADER_FRAG_CORNER_RADIUS,
    fragcolor: SHADER_FRAG_SHAPE_BLEND_COLOR,
};
const transpileShader = (gl, src, type) => {
    src = stringReplace(src, type === gl.VERTEX_SHADER ? SHADER_VERT_SNIPPETS : SHADER_FRAG_SNIPPETS, '##').trim();
    // ready if supports webgl
    if (supportsWebGL2())
        return src;
    src = src.replace(/#version.+/gm, '').trim();
    src = src.replace(/^\/\/\#/gm, '#');
    if (type === gl.VERTEX_SHADER) {
        src = src.replace(/in /gm, 'attribute ').replace(/out /g, 'varying ');
    }
    if (type === gl.FRAGMENT_SHADER) {
        src = src
            .replace(/in /gm, 'varying ')
            .replace(/out.*?;/gm, '')
            .replace(/texture\(/g, 'texture2D(')
            .replace(/fragColor/g, 'gl_FragColor');
    }
    return `${src}`;
};
const compileShader = (gl, src, type) => {
    const shader = gl.createShader(type);
    const transpiledSrc = transpileShader(gl, src, type);
    gl.shaderSource(shader, transpiledSrc);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
    }
    return shader;
};
const createShader = (gl, vertexShader, fragmentShader, attribs, uniforms) => {
    const program = gl.createProgram();
    gl.attachShader(program, compileShader(gl, vertexShader, gl.VERTEX_SHADER));
    gl.attachShader(program, compileShader(gl, fragmentShader, gl.FRAGMENT_SHADER));
    gl.linkProgram(program);
    const locations = {};
    attribs.forEach((name) => {
        locations[name] = gl.getAttribLocation(program, name);
    });
    uniforms.forEach((name) => {
        locations[name] = gl.getUniformLocation(program, name);
    });
    return {
        program,
        locations,
    };
};
const canMipMap = (source) => {
    if (supportsWebGL2())
        return true;
    return isPowerOf2(source.width) && isPowerOf2(source.height);
};
const applyTextureProperties = (gl, source) => {
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, canMipMap(source) ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    if (canMipMap(source)) {
        gl.generateMipmap(gl.TEXTURE_2D);
    }
};
const updateTexture = (gl, texture, source) => {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
    applyTextureProperties(gl, source);
    gl.bindTexture(gl.TEXTURE_2D, null);
    return texture;
};
const applyOpacity = (color, opacity = 1) => color
    ? [color[0], color[1], color[2], isNumber$1(color[3]) ? opacity * color[3] : opacity]
    : [0, 0, 0, 0];

const mat4Create = () => {
    const mat = new Float32Array(16);
    mat[0] = 1;
    mat[5] = 1;
    mat[10] = 1;
    mat[15] = 1;
    return mat;
};
const mat4Perspective = (mat, fovy, aspect, near, far) => {
    const f = 1.0 / Math.tan(fovy / 2);
    const nf = 1 / (near - far);
    mat[0] = f / aspect;
    mat[1] = 0;
    mat[2] = 0;
    mat[3] = 0;
    mat[4] = 0;
    mat[5] = f;
    mat[6] = 0;
    mat[7] = 0;
    mat[8] = 0;
    mat[9] = 0;
    mat[10] = (far + near) * nf;
    mat[11] = -1;
    mat[12] = 0;
    mat[13] = 0;
    mat[14] = 2 * far * near * nf;
    mat[15] = 0;
};
const mat4Ortho = (mat, left, right, bottom, top, near, far) => {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    mat[0] = -2 * lr;
    mat[1] = 0;
    mat[2] = 0;
    mat[3] = 0;
    mat[4] = 0;
    mat[5] = -2 * bt;
    mat[6] = 0;
    mat[7] = 0;
    mat[8] = 0;
    mat[9] = 0;
    mat[10] = 2 * nf;
    mat[11] = 0;
    mat[12] = (left + right) * lr;
    mat[13] = (top + bottom) * bt;
    mat[14] = (far + near) * nf;
    mat[15] = 1;
};
const mat4Translate = (mat, x, y, z) => {
    mat[12] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
    mat[13] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
    mat[14] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];
    mat[15] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15];
};
const mat4Scale = (mat, s) => {
    mat[0] = mat[0] * s;
    mat[1] = mat[1] * s;
    mat[2] = mat[2] * s;
    mat[3] = mat[3] * s;
    mat[4] = mat[4] * s;
    mat[5] = mat[5] * s;
    mat[6] = mat[6] * s;
    mat[7] = mat[7] * s;
    mat[8] = mat[8] * s;
    mat[9] = mat[9] * s;
    mat[10] = mat[10] * s;
    mat[11] = mat[11] * s;
};
const mat4ScaleX = (mat, s) => {
    mat[0] = mat[0] * s;
    mat[1] = mat[1] * s;
    mat[2] = mat[2] * s;
    mat[3] = mat[3] * s;
};
const mat4ScaleY = (mat, s) => {
    mat[4] = mat[4] * s;
    mat[5] = mat[5] * s;
    mat[6] = mat[6] * s;
    mat[7] = mat[7] * s;
};
const mat4RotateX = (mat, rad) => {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a10 = mat[4];
    const a11 = mat[5];
    const a12 = mat[6];
    const a13 = mat[7];
    const a20 = mat[8];
    const a21 = mat[9];
    const a22 = mat[10];
    const a23 = mat[11];
    mat[4] = a10 * c + a20 * s;
    mat[5] = a11 * c + a21 * s;
    mat[6] = a12 * c + a22 * s;
    mat[7] = a13 * c + a23 * s;
    mat[8] = a20 * c - a10 * s;
    mat[9] = a21 * c - a11 * s;
    mat[10] = a22 * c - a12 * s;
    mat[11] = a23 * c - a13 * s;
};
const mat4RotateY = (mat, rad) => {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a00 = mat[0];
    const a01 = mat[1];
    const a02 = mat[2];
    const a03 = mat[3];
    const a20 = mat[8];
    const a21 = mat[9];
    const a22 = mat[10];
    const a23 = mat[11];
    mat[0] = a00 * c - a20 * s;
    mat[1] = a01 * c - a21 * s;
    mat[2] = a02 * c - a22 * s;
    mat[3] = a03 * c - a23 * s;
    mat[8] = a00 * s + a20 * c;
    mat[9] = a01 * s + a21 * c;
    mat[10] = a02 * s + a22 * c;
    mat[11] = a03 * s + a23 * c;
};
const mat4RotateZ = (mat, rad) => {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a00 = mat[0];
    const a01 = mat[1];
    const a02 = mat[2];
    const a03 = mat[3];
    const a10 = mat[4];
    const a11 = mat[5];
    const a12 = mat[6];
    const a13 = mat[7];
    mat[0] = a00 * c + a10 * s;
    mat[1] = a01 * c + a11 * s;
    mat[2] = a02 * c + a12 * s;
    mat[3] = a03 * c + a13 * s;
    mat[4] = a10 * c - a00 * s;
    mat[5] = a11 * c - a01 * s;
    mat[6] = a12 * c - a02 * s;
    mat[7] = a13 * c - a03 * s;
};

var degToRad = (degrees) => degrees * Math.PI / 180;

var imageFragmentShader = "\n##head\nin vec2 vTexCoord;uniform sampler2D uTexture;uniform sampler2D uTextureMarkup;uniform vec2 uTextureSize;uniform float uOpacity;uniform vec4 uFillColor;uniform vec4 uOverlayColor;uniform mat4 uColorMatrix;uniform vec4 uColorOffset;uniform float uClarityKernel[9];uniform float uClarityKernelWeight;uniform float uColorGamma;uniform float uColorVignette;uniform float uMaskClip;uniform float uMaskOpacity;uniform float uMaskBounds[4];uniform float uMaskCornerRadius[4];uniform float uMaskFeather[8];vec4 applyGamma(vec4 c,float g){c.r=pow(c.r,g);c.g=pow(c.g,g);c.b=pow(c.b,g);return c;}vec4 applyColorMatrix(vec4 c,mat4 m,vec4 o){vec4 cM=(c*m)+o;cM*=cM.a;return cM;}vec4 applyConvolutionMatrix(vec4 c,float k0,float k1,float k2,float k3,float k4,float k5,float k6,float k7,float k8,float w){vec2 pixel=vec2(1)/uTextureSize;vec4 colorSum=texture(uTexture,vTexCoord-pixel)*k0+texture(uTexture,vTexCoord+pixel*vec2(0.0,-1.0))*k1+texture(uTexture,vTexCoord+pixel*vec2(1.0,-1.0))*k2+texture(uTexture,vTexCoord+pixel*vec2(-1.0,0.0))*k3+texture(uTexture,vTexCoord)*k4+texture(uTexture,vTexCoord+pixel*vec2(1.0,0.0))*k5+texture(uTexture,vTexCoord+pixel*vec2(-1.0,1.0))*k6+texture(uTexture,vTexCoord+pixel*vec2(0.0,1.0))*k7+texture(uTexture,vTexCoord+pixel)*k8;vec4 color=vec4((colorSum/w).rgb,c.a);color.rgb=clamp(color.rgb,0.0,1.0);return color;}vec4 applyVignette(vec4 c,vec2 pos,vec2 center,float v){float d=distance(pos,center)/length(center);float f=1.0-(d*abs(v));if(v>0.0){c.rgb*=f;}else if(v<0.0){c.rgb+=(1.0-f)*(1.0-c.rgb);}return c;}vec4 blendPremultipliedAlpha(vec4 back,vec4 front){return front+(back*(1.0-front.a));}void main(){float x=gl_FragCoord.x;float y=gl_FragCoord.y;float a=1.0;float maskTop=uMaskBounds[0];float maskRight=uMaskBounds[1];float maskBottom=uMaskBounds[2];float maskLeft=uMaskBounds[3];float leftFeatherOpacity=step(uMaskFeather[1],x)*uMaskFeather[0]+((1.0-uMaskFeather[0])*smoothstep(uMaskFeather[1],uMaskFeather[3],x));float rightFeatherOpacity=(1.0-step(uMaskFeather[7],x))*uMaskFeather[4]+((1.0-uMaskFeather[4])*smoothstep(uMaskFeather[7],uMaskFeather[5],x));a*=leftFeatherOpacity*rightFeatherOpacity;float overlayColorAlpha=(smoothstep(maskLeft,maskLeft+1.0,x)*(1.0-smoothstep(maskRight-1.0,maskRight,x))*(1.0-step(maskTop,y))*step(maskBottom,y));if(uOverlayColor.a==0.0){a*=overlayColorAlpha;}vec2 offset=vec2(maskLeft,maskBottom);vec2 size=vec2(maskRight-maskLeft,maskTop-maskBottom)*.5;vec2 center=offset.xy+size.xy;int pixelX=int(step(center.x,x));int pixelY=int(step(y,center.y));float cornerRadius=0.0;if(pixelX==0&&pixelY==0)cornerRadius=uMaskCornerRadius[0];if(pixelX==1&&pixelY==0)cornerRadius=uMaskCornerRadius[1];if(pixelX==0&&pixelY==1)cornerRadius=uMaskCornerRadius[2];if(pixelX==1&&pixelY==1)cornerRadius=uMaskCornerRadius[3];float cornerOffset=sign(cornerRadius)*length(max(abs(gl_FragCoord.xy-size-offset)-size+cornerRadius,0.0))-cornerRadius;float cornerOpacity=1.0-smoothstep(0.0,1.0,cornerOffset);a*=cornerOpacity;vec2 scaledPoint=vec2(vTexCoord.x*uTextureSize.x,vTexCoord.y*uTextureSize.y);a*=smoothstep(0.0,1.0,uTextureSize.x-scaledPoint.x);a*=smoothstep(0.0,1.0,uTextureSize.y-scaledPoint.y);a*=smoothstep(0.0,1.0,scaledPoint.x);a*=smoothstep(0.0,1.0,scaledPoint.y);vec4 color=texture(uTexture,vTexCoord);if(uClarityKernelWeight!=-1.0){color=applyConvolutionMatrix(color,uClarityKernel[0],uClarityKernel[1],uClarityKernel[2],uClarityKernel[3],uClarityKernel[4],uClarityKernel[5],uClarityKernel[6],uClarityKernel[7],uClarityKernel[8],uClarityKernelWeight);}color=applyGamma(color,uColorGamma);color=applyColorMatrix(color,uColorMatrix,uColorOffset);color=blendPremultipliedAlpha(uFillColor,color);color*=a;if(uColorVignette!=0.0){vec2 pos=gl_FragCoord.xy-offset;color=applyVignette(color,pos,center-offset,uColorVignette);}color=blendPremultipliedAlpha(color,texture(uTextureMarkup,vTexCoord));vec4 overlayColor=uOverlayColor*(1.0-overlayColorAlpha);overlayColor.rgb*=overlayColor.a;color=blendPremultipliedAlpha(color,overlayColor);if(uOverlayColor.a>0.0&&color.a<1.0&&uFillColor.a>0.0){color=blendPremultipliedAlpha(uFillColor,overlayColor);}color*=uOpacity;fragColor=color;}"; // eslint-disable-line

var imageVertexShader = "\n##head\n##text\nvoid main(){vTexCoord=aTexCoord;gl_Position=uMatrix*aPosition;}"; // eslint-disable-line

var pathVertexShader = "#version 300 es\n\nin vec4 aPosition;in vec2 aNormal;in float aMiter;out vec2 vNormal;out float vMiter;out float vWidth;uniform float uWidth;uniform mat4 uMatrix;void main(){vMiter=aMiter;vNormal=aNormal;vWidth=(uWidth*.5)+1.0;gl_Position=uMatrix*vec4(aPosition.x+(aNormal.x*vWidth*aMiter),aPosition.y+(aNormal.y*vWidth*aMiter),0,1);}"; // eslint-disable-line

var pathFragmentShader = "\n##head\n##mask\nin vec2 vNormal;in float vMiter;in float vWidth;uniform float uWidth;uniform vec4 uColor;uniform vec4 uCanvasColor;void main(){vec4 fillColor=uColor;float m=mask(gl_FragCoord.x,gl_FragCoord.y,uMaskBounds,uMaskOpacity);if(m<=0.0)discard;fillColor.a*=clamp(smoothstep(vWidth-.5,vWidth-1.0,abs(vMiter)*vWidth),0.0,1.0);fillColor.rgb*=fillColor.a;fillColor.rgb*=m;fillColor.rgb+=(1.0-m)*(uCanvasColor.rgb*fillColor.a);fragColor=fillColor;}"; // eslint-disable-line

var rectVertexShader = "\n##head\n##text\nin vec2 aRectCoord;out vec2 vRectCoord;void main(){vTexCoord=aTexCoord;vRectCoord=aRectCoord;\n##matrix\n}"; // eslint-disable-line

var rectFragmentShader = "\n##head\n##mask\nin vec2 vTexCoord;in vec2 vRectCoord;uniform sampler2D uTexture;uniform vec4 uTextureColor;uniform float uTextureOpacity;uniform vec4 uColor;uniform float uCornerRadius[4];uniform vec2 uSize;uniform vec2 uPosition;uniform vec4 uCanvasColor;uniform int uInverted;void main(){\n##init\n##colorize\n##edgeaa\n##cornerradius\n##maskfeatherapply\nif(uInverted==1)a=1.0-a;\n##maskapply\n##fragcolor\n}"; // eslint-disable-line

var ellipseVertexShader = "\n##head\n##text\nout vec2 vTexCoordDouble;void main(){vTexCoordDouble=vec2(aTexCoord.x*2.0-1.0,aTexCoord.y*2.0-1.0);vTexCoord=aTexCoord;\n##matrix\n}"; // eslint-disable-line

var ellipseFragmentShader = "\n##head\n##mask\nin vec2 vTexCoord;in vec2 vTexCoordDouble;uniform sampler2D uTexture;uniform float uTextureOpacity;uniform vec2 uRadius;uniform vec4 uColor;uniform int uInverted;uniform vec4 uCanvasColor;void main(){\n##init\nfloat ar=uRadius.x/uRadius.y;vec2 rAA=vec2(uRadius.x-1.0,uRadius.y-(1.0/ar));vec2 scaledPointSq=vec2((vTexCoordDouble.x*uRadius.x)*(vTexCoordDouble.x*uRadius.x),(vTexCoordDouble.y*uRadius.y)*(vTexCoordDouble.y*uRadius.y));float p=(scaledPointSq.x/(uRadius.x*uRadius.x))+(scaledPointSq.y/(uRadius.y*uRadius.y));float pAA=(scaledPointSq.x/(rAA.x*rAA.x))+(scaledPointSq.y/(rAA.y*rAA.y));a=smoothstep(1.0,p/pAA,p);if(uInverted==1)a=1.0-a;\n##maskapply\n##fragcolor\n}"; // eslint-disable-line

var triangleVertexShader = "\n##head\nvoid main(){\n##matrix\n}"; // eslint-disable-line

var triangleFragmentShader = "\n##head\n##mask\nuniform vec4 uColor;uniform vec4 uCanvasColor;void main(){vec4 fillColor=uColor;\n##maskapply\nfillColor.rgb*=fillColor.a;fillColor.rgb*=m;fillColor.rgb+=(1.0-m)*(uCanvasColor.rgb*fillColor.a);fragColor=fillColor;}"; // eslint-disable-line

const createPathSegment = (vertices, index, a, b, c) => {
    const ab = vectorNormalize(vectorCreate(b.x - a.x, b.y - a.y));
    const bc = vectorNormalize(vectorCreate(c.x - b.x, c.y - b.y));
    const tangent = vectorNormalize(vectorCreate(ab.x + bc.x, ab.y + bc.y));
    const miter = vectorCreate(-tangent.y, tangent.x);
    const normal = vectorCreate(-ab.y, ab.x);
    // limit miter length (TEMP fix to prevent spikes, should eventually add caps)
    const miterLength = Math.min(1 / vectorDot(miter, normal), 5);
    vertices[index] = b.x;
    vertices[index + 1] = b.y;
    vertices[index + 2] = miter.x * miterLength;
    vertices[index + 3] = miter.y * miterLength;
    vertices[index + 4] = -1;
    vertices[index + 5] = b.x;
    vertices[index + 6] = b.y;
    vertices[index + 7] = miter.x * miterLength;
    vertices[index + 8] = miter.y * miterLength;
    vertices[index + 9] = 1;
};
const createPathVertices = (points, close) => {
    let a, b, c, i = 0;
    const l = points.length;
    const stride = 10;
    const vertices = new Float32Array((close ? l + 1 : l) * stride);
    const first = points[0];
    const last = points[l - 1];
    for (i = 0; i < l; i++) {
        a = points[i - 1];
        b = points[i];
        c = points[i + 1];
        // if previous point not available use inverse vector to next point
        if (!a)
            a = close ? last : vectorCreate(b.x + (b.x - c.x), b.y + (b.y - c.y));
        // if next point not available use inverse vector from previous point
        if (!c)
            c = close ? first : vectorCreate(b.x + (b.x - a.x), b.y + (b.y - a.y));
        createPathSegment(vertices, i * stride, a, b, c);
    }
    if (close)
        createPathSegment(vertices, l * stride, last, first, points[1]);
    return vertices;
};
const rectPointsToVertices = (points) => {
    // [tl, tr, br, bl]
    // B   D
    // | \ |
    // A  C
    const vertices = new Float32Array(8);
    vertices[0] = points[3].x;
    vertices[1] = points[3].y;
    vertices[2] = points[0].x;
    vertices[3] = points[0].y;
    vertices[4] = points[2].x;
    vertices[5] = points[2].y;
    vertices[6] = points[1].x;
    vertices[7] = points[1].y;
    return vertices;
};
const trianglePointToVertices = (points) => {
    const vertices = new Float32Array(6);
    vertices[0] = points[0].x;
    vertices[1] = points[0].y;
    vertices[2] = points[1].x;
    vertices[3] = points[1].y;
    vertices[4] = points[2].x;
    vertices[5] = points[2].y;
    return vertices;
};
const createRectPoints = (rect, rotation = 0, flipX, flipY) => {
    const corners = rectGetCorners(rect);
    const cx = rect.x + rect.width * 0.5;
    const cy = rect.y + rect.height * 0.5;
    if (flipX || flipY)
        vectorsFlip(corners, flipX, flipY, cx, cy);
    if (rotation !== 0)
        vectorsRotate(corners, rotation, cx, cy);
    return corners;
};
const createEllipseOutline = (x, y, width, height, rotation, flipX, flipY) => {
    const rx = Math.abs(width) * 0.5;
    const ry = Math.abs(height) * 0.5;
    const size = Math.abs(width) + Math.abs(height);
    const precision = Math.max(20, Math.round(size / 6));
    return ellipseToPolygon(vectorCreate(x + rx, y + ry), rx, ry, rotation, flipX, flipY, precision);
};
const createRectOutline = (x, y, width, height, rotation, cornerRadius, flipX, flipY) => {
    const points = [];
    if (cornerRadius.every((v) => v === 0)) {
        points.push(vectorCreate(x, y), // top left corner
        vectorCreate(x + width, y), // top right corner
        vectorCreate(x + width, y + height), // bottom right corner
        vectorCreate(x, y + height) // bottom left corner
        );
    }
    else {
        const [tl, tr, bl, br] = cornerRadius;
        const l = x;
        const r = x + width;
        const t = y;
        const b = y + height;
        // start at end of top left corner
        points.push(vectorCreate(l + tl, t));
        pushRectCornerPoints(points, r - tr, t + tr, tr, -1);
        // move to bottom right corner
        points.push(vectorCreate(r, t + tr));
        pushRectCornerPoints(points, r - br, b - br, br, 0);
        // move to bottom left corner
        points.push(vectorCreate(r - br, b));
        pushRectCornerPoints(points, l + bl, b - bl, bl, 1);
        // move to top left corner
        points.push(vectorCreate(l, b - bl));
        pushRectCornerPoints(points, l + tl, t + tl, tl, 2);
    }
    if (flipX || flipY)
        vectorsFlip(points, flipX, flipY, x + width * 0.5, y + height * 0.5);
    if (rotation)
        vectorsRotate(points, rotation, x + width * 0.5, y + height * 0.5);
    return points;
};
const pushRectCornerPoints = (points, x, y, radius, offset) => {
    const precision = Math.min(20, Math.max(4, Math.round(radius / 2)));
    let p = 0;
    let s = 0;
    let rx = 0;
    let ry = 0;
    let i = 0;
    for (; i < precision; i++) {
        p = i / precision;
        s = offset * HALF_PI + p * HALF_PI;
        rx = radius * Math.cos(s);
        ry = radius * Math.sin(s);
        points.push(vectorCreate(x + rx, y + ry));
    }
};

// prettier-ignore
// B   D
// | \ |
// A  C
const RECT_UV = new Float32Array([
    0.0, 1.0,
    0.0, 0.0,
    1.0, 1.0,
    1.0, 0.0,
]);
const CLARITY_IDENTITY = [0, 0, 0, 0, 1, 0, 0, 0, 0];
const COLOR_MATRIX_IDENTITY$1 = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
const TEXTURE_TRANSPARENT_INDEX = 0;
const TEXTURE_PREVIEW_MARKUP_INDEX = 1;
const TEXTURE_PREVIEW_INDEX = 2;
const TEXTURE_SHAPE_INDEX = 3;
const COLOR_TRANSPARENT = [0, 0, 0, 0];
const NO_CORNERS = [0, 0, 0, 0];
const getBackgroundUV = (width, height, backgroundSize, backgroundPosition, viewPixelDensity) => {
    if (!backgroundSize || !backgroundPosition)
        return RECT_UV;
    const x = backgroundPosition.x / backgroundSize.width;
    const y = backgroundPosition.y / backgroundSize.height;
    let w = width / backgroundSize.width / viewPixelDensity;
    let h = height / backgroundSize.height / viewPixelDensity;
    w -= x;
    h -= y;
    // prettier-ignore
    // B   D
    // | \ |
    // A  C
    // bottom left
    const ax = -x;
    const ay = h;
    // top left
    const bx = -x;
    const by = -y;
    // bottom right
    const cx = w;
    const cy = h;
    // top right
    const dx = w;
    const dy = -y;
    return new Float32Array([
        ax,
        ay,
        bx,
        by,
        cx,
        cy,
        dx,
        dy,
    ]);
};
const limitCornerRadius = (r, size) => {
    return Math.floor(clamp(r, 0, Math.min((size.width - 1) * 0.5, (size.height - 1) * 0.5)));
};
var createWebGLCanvas = (canvas) => {
    const viewSize = { width: 0, height: 0 };
    const viewSizeVisual = { width: 0, height: 0 };
    let viewAspectRatio;
    let viewPixelDensity;
    const markupMatrixCanvas = mat4Create();
    const markupMatrixFrameBuffer = mat4Create();
    let markupMatrix;
    let maskTop;
    let maskRight;
    let maskBottom;
    let maskLeft;
    let maskOpacity;
    let maskBounds;
    let IMAGE_MASK_FEATHER; // updated when viewport is resized
    let RECT_MASK_FEATHER;
    let CANVAS_COLOR_R = 0;
    let CANVAS_COLOR_G = 0;
    let CANVAS_COLOR_B = 0;
    const indexTextureMap = new Map([]);
    // resize view
    const resize = (width, height, pixelDensity) => {
        // density
        viewPixelDensity = pixelDensity;
        // visual size
        viewSizeVisual.width = width;
        viewSizeVisual.height = height;
        // size
        viewSize.width = width * viewPixelDensity;
        viewSize.height = height * viewPixelDensity;
        // calculate the aspect ratio, we use this to determine quad size
        viewAspectRatio = getAspectRatio(viewSize.width, viewSize.height);
        // sync dimensions with image data
        canvas.width = viewSize.width;
        canvas.height = viewSize.height;
        // update canvas markup matrix
        mat4Ortho(markupMatrixCanvas, 0, viewSize.width, viewSize.height, 0, -1, 1);
        IMAGE_MASK_FEATHER = [1, 0, 1, 0, 1, viewSizeVisual.width, 1, viewSizeVisual.width];
    };
    // fov is fixed
    const FOV = degToRad(30);
    const FOV_TAN_HALF = Math.tan(FOV / 2);
    // get gl drawing context
    const gl = getWebGLContext(canvas, {
        antialias: false,
        alpha: false,
        premultipliedAlpha: true,
    });
    // no drawing context received, exit
    if (!gl)
        return;
    // enable derivatives
    gl.getExtension('OES_standard_derivatives');
    // toggle gl settings
    gl.disable(gl.DEPTH_TEST);
    // set blend mode, we need it for alpha blending
    gl.enable(gl.BLEND);
    /*
    https://webglfundamentals.org/webgl/lessons/webgl-and-alpha.html
    most if not all Canvas 2D implementations work with pre-multiplied alpha.
    That means when you transfer them to WebGL and UNPACK_PREMULTIPLY_ALPHA_WEBGL
    is false WebGL will convert them back to un-premultipiled.
    With pre-multiplied alpha on, [1, .5, .5, 0] does not exist, it's always [0, 0, 0, 0]
    */
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
    // something to look into:
    // gl.UNPACK_COLORSPACE_CONVERSION_WEBGL
    const transparentTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, transparentTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, // width
    1, // height
    0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(COLOR_TRANSPARENT) // transparent background
    );
    indexTextureMap.set(TEXTURE_TRANSPARENT_INDEX, transparentTexture);
    // create image markup texture and framebuffer
    const imageMarkupTexture = gl.createTexture();
    indexTextureMap.set(TEXTURE_PREVIEW_MARKUP_INDEX, imageMarkupTexture);
    const fb = gl.createFramebuffer();
    // #region image
    // create default pixel drawing program, supports what we need
    const imageShader = createShader(gl, imageVertexShader, imageFragmentShader, ['aPosition', 'aTexCoord'], [
        'uMatrix',
        'uTexture',
        'uTextureMarkup',
        'uTextureSize',
        'uColorGamma',
        'uColorVignette',
        'uColorOffset',
        'uColorMatrix',
        'uClarityKernel',
        'uClarityKernelWeight',
        'uOpacity',
        'uMaskOpacity',
        'uMaskBounds',
        'uMaskCornerRadius',
        'uMaskFeather',
        'uFillColor',
        'uOverlayColor',
    ]);
    // create image buffers
    const imagePositionsBuffer = gl.createBuffer();
    const texturePositionsBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texturePositionsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, RECT_UV, gl.STATIC_DRAW);
    const drawImage = (texture, textureSize, originX, originY, translateX, translateY, rotateX, rotateY, rotateZ, scale, colorMatrix = COLOR_MATRIX_IDENTITY$1, opacity = 1, clarity, gamma = 1, vignette = 0, maskFeather = IMAGE_MASK_FEATHER, maskCornerRadius = NO_CORNERS, imageBackgroundColor = COLOR_TRANSPARENT, imageOverlayColor = COLOR_TRANSPARENT, enableMarkup = false) => {
        // update image texture
        const imageWidth = textureSize.width * viewPixelDensity;
        const imageHeight = textureSize.height * viewPixelDensity;
        const l = imageWidth * -0.5;
        const t = imageHeight * 0.5;
        const r = imageWidth * 0.5;
        const b = imageHeight * -0.5;
        // prettier-ignore
        // B   D
        // | \ |
        // A  C
        const imagePositions = new Float32Array([
            l, b, 0,
            l, t, 0,
            r, b, 0,
            r, t, 0,
        ]);
        gl.bindBuffer(gl.ARRAY_BUFFER, imagePositionsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, imagePositions, gl.STATIC_DRAW);
        // move image backwards so it's presented in actual pixel size
        const viewZ = // 1. we calculate the z offset required to have the
         
        //    image height match the view height
        /*        /|
                 / |
                /  | height / 2
               /   |
        f / 2 /__z_|
              \    |
               \   |
                \  |
                 \ |
                  \|
        */
        (textureSize.height / 2 / FOV_TAN_HALF) *
            // 2. we want to render the image at the actual height, viewsize / height gets us results in a 1:1 presentation
            (viewSize.height / textureSize.height) *
            // 3. z has to be negative, therefor multiply by -1
            -1;
        // convert to pixel density
        translateX *= viewPixelDensity;
        translateY *= viewPixelDensity;
        originX *= viewPixelDensity;
        originY *= viewPixelDensity;
        // get shader params
        const { program, locations } = imageShader;
        // apply
        const matrix = mat4Create();
        mat4Perspective(matrix, FOV, viewAspectRatio, 1, -viewZ * 2);
        // move image
        mat4Translate(matrix, translateX, -translateY, viewZ);
        // set rotation origin in view
        mat4Translate(matrix, originX, -originY, 0);
        // rotate image
        mat4RotateZ(matrix, -rotateZ);
        // resize
        mat4Scale(matrix, scale);
        // reset rotation origin
        mat4Translate(matrix, -originX, originY, 0);
        // flip
        mat4RotateY(matrix, rotateY);
        mat4RotateX(matrix, rotateX);
        //
        // tell context to draw preview
        //
        gl.useProgram(program);
        gl.enableVertexAttribArray(locations.aPosition);
        gl.enableVertexAttribArray(locations.aTexCoord);
        // set up texture
        gl.uniform1i(locations.uTexture, TEXTURE_PREVIEW_INDEX);
        gl.uniform2f(locations.uTextureSize, textureSize.width, textureSize.height);
        gl.activeTexture(gl.TEXTURE0 + TEXTURE_PREVIEW_INDEX);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        // TEXTURE_PREVIEW_INDEX
        // set up markup texture
        const textureIndex = enableMarkup
            ? TEXTURE_PREVIEW_MARKUP_INDEX
            : TEXTURE_TRANSPARENT_INDEX;
        const markupTexture = indexTextureMap.get(textureIndex);
        gl.uniform1i(locations.uTextureMarkup, textureIndex);
        gl.activeTexture(gl.TEXTURE0 + textureIndex);
        gl.bindTexture(gl.TEXTURE_2D, markupTexture);
        // set up buffers
        gl.bindBuffer(gl.ARRAY_BUFFER, imagePositionsBuffer);
        gl.vertexAttribPointer(locations.aPosition, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, texturePositionsBuffer);
        gl.vertexAttribPointer(locations.aTexCoord, 2, gl.FLOAT, false, 0, 0);
        // update matrix
        gl.uniformMatrix4fv(locations.uMatrix, false, matrix);
        // overlay color
        gl.uniform4fv(locations.uOverlayColor, imageOverlayColor);
        gl.uniform4fv(locations.uFillColor, imageBackgroundColor);
        // convolution
        let clarityWeight;
        if (!clarity || arrayEqual(clarity, CLARITY_IDENTITY)) {
            clarity = CLARITY_IDENTITY;
            clarityWeight = -1;
        }
        else {
            clarityWeight = clarity.reduce((prev, curr) => prev + curr, 0);
            clarityWeight = clarityWeight <= 0 ? 1 : clarityWeight;
        }
        gl.uniform1fv(locations.uClarityKernel, clarity);
        gl.uniform1f(locations.uClarityKernelWeight, clarityWeight);
        gl.uniform1f(locations.uColorGamma, 1.0 / gamma);
        gl.uniform1f(locations.uColorVignette, vignette);
        // set color matrix values
        gl.uniform4f(locations.uColorOffset, colorMatrix[4], colorMatrix[9], colorMatrix[14], colorMatrix[19]);
        gl.uniformMatrix4fv(locations.uColorMatrix, false, [
            colorMatrix[0],
            colorMatrix[1],
            colorMatrix[2],
            colorMatrix[3],
            colorMatrix[5],
            colorMatrix[6],
            colorMatrix[7],
            colorMatrix[8],
            colorMatrix[10],
            colorMatrix[11],
            colorMatrix[12],
            colorMatrix[13],
            colorMatrix[15],
            colorMatrix[16],
            colorMatrix[17],
            colorMatrix[18],
        ]);
        // opacity level
        gl.uniform1f(locations.uOpacity, opacity);
        // mask
        gl.uniform1f(locations.uMaskOpacity, maskOpacity);
        gl.uniform1fv(locations.uMaskBounds, maskBounds);
        gl.uniform1fv(locations.uMaskCornerRadius, maskCornerRadius.map((v) => v * viewPixelDensity));
        gl.uniform1fv(locations.uMaskFeather, maskFeather.map((v, i) => (i % 2 === 0 ? v : v * viewPixelDensity)));
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.disableVertexAttribArray(locations.aPosition);
        gl.disableVertexAttribArray(locations.aTexCoord);
    };
    //#endregion
    // #region path
    const pathShader = createShader(gl, pathVertexShader, pathFragmentShader, ['aPosition', 'aNormal', 'aMiter'], ['uColor', 'uCanvasColor', 'uMatrix', 'uWidth', 'uMaskBounds', 'uMaskOpacity']);
    const pathBuffer = gl.createBuffer();
    const strokePath = (points, width, color, close = false) => {
        const { program, locations } = pathShader;
        gl.useProgram(program);
        gl.enableVertexAttribArray(locations.aPosition);
        gl.enableVertexAttribArray(locations.aNormal);
        gl.enableVertexAttribArray(locations.aMiter);
        const vertices = createPathVertices(points, close);
        const stride = Float32Array.BYTES_PER_ELEMENT * 5;
        const normalOffset = Float32Array.BYTES_PER_ELEMENT * 2; // at position 2
        const miterOffset = Float32Array.BYTES_PER_ELEMENT * 4; // at position 4
        gl.uniform1f(locations.uWidth, width); // add 1 so we can feather the edges
        gl.uniform4fv(locations.uColor, color);
        gl.uniformMatrix4fv(locations.uMatrix, false, markupMatrix);
        gl.uniform4f(locations.uCanvasColor, CANVAS_COLOR_R, CANVAS_COLOR_G, CANVAS_COLOR_B, 1);
        gl.uniform1fv(locations.uMaskBounds, maskBounds);
        gl.uniform1f(locations.uMaskOpacity, maskOpacity);
        gl.bindBuffer(gl.ARRAY_BUFFER, pathBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.vertexAttribPointer(locations.aPosition, 2, gl.FLOAT, false, stride, 0);
        gl.vertexAttribPointer(locations.aNormal, 2, gl.FLOAT, false, stride, normalOffset);
        gl.vertexAttribPointer(locations.aMiter, 1, gl.FLOAT, false, stride, miterOffset);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertices.length / 5);
        gl.disableVertexAttribArray(locations.aPosition);
        gl.disableVertexAttribArray(locations.aNormal);
        gl.disableVertexAttribArray(locations.aMiter);
    };
    //#endregion
    // #region triangle
    const triangleShader = createShader(gl, triangleVertexShader, triangleFragmentShader, ['aPosition'], ['uColor', 'uCanvasColor', 'uMatrix', 'uMaskBounds', 'uMaskOpacity']);
    const triangleBuffer = gl.createBuffer();
    const fillTriangle = (vertices, backgroundColor) => {
        const { program, locations } = triangleShader;
        gl.useProgram(program);
        gl.enableVertexAttribArray(locations.aPosition);
        gl.uniform4fv(locations.uColor, backgroundColor);
        gl.uniformMatrix4fv(locations.uMatrix, false, markupMatrix);
        gl.uniform1fv(locations.uMaskBounds, maskBounds);
        gl.uniform1f(locations.uMaskOpacity, maskOpacity);
        gl.uniform4f(locations.uCanvasColor, CANVAS_COLOR_R, CANVAS_COLOR_G, CANVAS_COLOR_B, 1);
        gl.bindBuffer(gl.ARRAY_BUFFER, triangleBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.vertexAttribPointer(locations.aPosition, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertices.length / 2);
        gl.disableVertexAttribArray(locations.aPosition);
        return vertices;
    };
    //#endregion
    // #region rect
    const rectShaderAttributes = ['aPosition', 'aTexCoord', 'aRectCoord'];
    const rectShaderUniforms = [
        'uTexture',
        'uColor',
        'uMatrix',
        'uCanvasColor',
        'uTextureColor',
        'uTextureOpacity',
        'uPosition',
        'uSize',
        'uMaskBounds',
        'uMaskOpacity',
        'uMaskFeather',
        'uCornerRadius',
        'uInverted',
    ];
    const rectShader = createShader(gl, rectVertexShader, rectFragmentShader, rectShaderAttributes, rectShaderUniforms);
    const rectBuffer = gl.createBuffer();
    const rectTextureBuffer = gl.createBuffer();
    const rectCornerBuffer = gl.createBuffer();
    const fillRect = (vertices, width, height, cornerRadius, backgroundColor, backgroundImage = transparentTexture, opacity = 1.0, colorFilter = COLOR_TRANSPARENT, uv = RECT_UV, maskFeather = RECT_MASK_FEATHER, inverted) => {
        const { program, locations } = rectShader;
        gl.useProgram(program);
        gl.enableVertexAttribArray(locations.aPosition);
        gl.enableVertexAttribArray(locations.aTexCoord);
        gl.enableVertexAttribArray(locations.aRectCoord);
        gl.uniform4fv(locations.uColor, backgroundColor);
        gl.uniform2fv(locations.uSize, [width, height]);
        gl.uniform2fv(locations.uPosition, [vertices[2], vertices[3]]);
        gl.uniform1i(locations.uInverted, inverted ? 1 : 0);
        gl.uniform1fv(locations.uCornerRadius, cornerRadius);
        gl.uniform4f(locations.uCanvasColor, CANVAS_COLOR_R, CANVAS_COLOR_G, CANVAS_COLOR_B, 1);
        // mask
        gl.uniform1fv(locations.uMaskFeather, maskFeather.map((v, i) => (i % 2 === 0 ? v : v * viewPixelDensity)));
        gl.uniform1fv(locations.uMaskBounds, maskBounds);
        gl.uniform1f(locations.uMaskOpacity, maskOpacity);
        gl.uniformMatrix4fv(locations.uMatrix, false, markupMatrix);
        gl.uniform1i(locations.uTexture, TEXTURE_SHAPE_INDEX);
        gl.uniform4fv(locations.uTextureColor, colorFilter);
        gl.uniform1f(locations.uTextureOpacity, opacity);
        gl.activeTexture(gl.TEXTURE0 + TEXTURE_SHAPE_INDEX);
        gl.bindTexture(gl.TEXTURE_2D, backgroundImage);
        gl.bindBuffer(gl.ARRAY_BUFFER, rectTextureBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, uv, gl.STATIC_DRAW);
        gl.vertexAttribPointer(locations.aTexCoord, 2, gl.FLOAT, false, 0, 0);
        // we use these coordinates combined with the size of the rect to interpolate and alias edges
        gl.bindBuffer(gl.ARRAY_BUFFER, rectCornerBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, RECT_UV, gl.STATIC_DRAW);
        gl.vertexAttribPointer(locations.aRectCoord, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, rectBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.vertexAttribPointer(locations.aPosition, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertices.length / 2);
        gl.disableVertexAttribArray(locations.aPosition);
        gl.disableVertexAttribArray(locations.aTexCoord);
        gl.disableVertexAttribArray(locations.aRectCoord);
        return vertices;
    };
    //#endregion
    // #region ellipse
    const ellipseShader = createShader(gl, ellipseVertexShader, ellipseFragmentShader, ['aPosition', 'aTexCoord'], [
        'uTexture',
        'uTextureOpacity',
        'uColor',
        'uCanvasColor',
        'uMatrix',
        'uRadius',
        'uInverted',
        'uMaskBounds',
        'uMaskOpacity',
    ]);
    const ellipseBuffer = gl.createBuffer();
    const ellipseTextureBuffer = gl.createBuffer();
    const fillEllipse = (vertices, width, height, backgroundColor, backgroundImage = transparentTexture, uv = RECT_UV, opacity = 1.0, inverted = false) => {
        const { program, locations } = ellipseShader;
        gl.useProgram(program);
        gl.enableVertexAttribArray(locations.aPosition);
        gl.enableVertexAttribArray(locations.aTexCoord);
        gl.uniformMatrix4fv(locations.uMatrix, false, markupMatrix);
        gl.uniform2fv(locations.uRadius, [width * 0.5, height * 0.5]);
        gl.uniform1i(locations.uInverted, inverted ? 1 : 0);
        gl.uniform4fv(locations.uColor, backgroundColor);
        gl.uniform4f(locations.uCanvasColor, CANVAS_COLOR_R, CANVAS_COLOR_G, CANVAS_COLOR_B, 1);
        gl.uniform1fv(locations.uMaskBounds, maskBounds);
        gl.uniform1f(locations.uMaskOpacity, maskOpacity);
        gl.uniform1i(locations.uTexture, TEXTURE_SHAPE_INDEX);
        gl.uniform1f(locations.uTextureOpacity, opacity);
        gl.activeTexture(gl.TEXTURE0 + TEXTURE_SHAPE_INDEX);
        gl.bindTexture(gl.TEXTURE_2D, backgroundImage);
        gl.bindBuffer(gl.ARRAY_BUFFER, ellipseTextureBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, uv, gl.STATIC_DRAW);
        gl.vertexAttribPointer(locations.aTexCoord, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, ellipseBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.vertexAttribPointer(locations.aPosition, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertices.length / 2);
        gl.disableVertexAttribArray(locations.aPosition);
        gl.disableVertexAttribArray(locations.aTexCoord);
    };
    //#endregion
    //
    // draw calls
    //
    const drawPath = (points, strokeWidth, strokeColor, strokeClose, opacity) => {
        // is no line
        if (points.length < 2)
            return;
        strokePath(points.map((p) => ({
            x: p.x * viewPixelDensity,
            y: p.y * viewPixelDensity,
        })), strokeWidth * viewPixelDensity, applyOpacity(strokeColor, opacity), strokeClose);
    };
    const drawTriangle = (points, rotation = 0, flipX = false, flipY = false, backgroundColor, opacity) => {
        if (!backgroundColor)
            return;
        const clonedPoints = points.map((p) => ({
            x: p.x * viewPixelDensity,
            y: p.y * viewPixelDensity,
        }));
        const center = convexPolyCentroid(clonedPoints);
        if (flipX || flipY)
            vectorsFlip(clonedPoints, flipX, flipY, center.x, center.y);
        vectorsRotate(clonedPoints, rotation, center.x, center.y);
        const vertices = trianglePointToVertices(clonedPoints);
        fillTriangle(vertices, applyOpacity(backgroundColor, opacity));
    };
    const drawRect = (rect, rotation = 0, flipX = false, flipY = false, cornerRadius, backgroundColor, backgroundImage, backgroundSize = undefined, backgroundPosition = undefined, strokeWidth, strokeColor, opacity, maskFeather = undefined, colorize, inverted) => {
        // clone first
        const rectOut = rectMultiply(rectClone(rect), viewPixelDensity);
        // has radius, doesn't matter for coordinates
        const cornerRadiusOut = cornerRadius
            .map((r) => limitCornerRadius(r || 0, rect))
            .map((r) => r * viewPixelDensity);
        // should fill
        if (backgroundColor || backgroundImage) {
            // adjust for edge anti-aliasing, if we don't do this the
            // visible rectangle will be 1 pixel smaller than the actual rectangle
            const rectFill = rectClone(rectOut);
            rectFill.x -= 0.5;
            rectFill.y -= 0.5;
            rectFill.width += 1;
            rectFill.height += 1;
            const points = createRectPoints(rectFill, rotation, flipX, flipY);
            const vertices = rectPointsToVertices(points);
            let color;
            if (colorize) {
                color = applyOpacity(colorize);
                // as 0 transparancy is used to test if the colorize filter should be applied we set it to 0.001
                if (color[3] === 0)
                    color[3] = 0.001;
            }
            fillRect(vertices, rectFill.width, rectFill.height, cornerRadiusOut, applyOpacity(backgroundColor, opacity), backgroundImage, opacity, color, getBackgroundUV(rectFill.width, rectFill.height, backgroundSize, backgroundPosition, viewPixelDensity), maskFeather, inverted);
        }
        // should draw outline
        if (strokeWidth) {
            // fixes issue where stroke would render weirdly
            strokeWidth = Math.min(strokeWidth, rectOut.width, rectOut.height);
            strokePath(
            // rect out is already multiplied by pixel density
            createRectOutline(rectOut.x, rectOut.y, rectOut.width, rectOut.height, rotation, cornerRadiusOut, flipX, flipY), strokeWidth * viewPixelDensity, applyOpacity(strokeColor, opacity), true);
        }
    };
    const drawEllipse = (center, rx, ry, rotation, flipX, flipY, backgroundColor, backgroundImage, backgroundSize = undefined, backgroundPosition = undefined, strokeWidth, strokeColor, opacity, inverted) => {
        const rectOut = rectMultiply(rectCreate(center.x - rx, center.y - ry, rx * 2, ry * 2), viewPixelDensity);
        if (backgroundColor || backgroundImage) {
            // adjust for edge anti-aliasing, if we don't do this the
            // visible rectangle will be 1 pixel smaller than the actual rectangle
            const rectFill = rectClone(rectOut);
            rectFill.x -= 0.5;
            rectFill.y -= 0.5;
            rectFill.width += 1.0;
            rectFill.height += 1.0;
            const points = createRectPoints(rectFill, rotation, flipX, flipY);
            const vertices = rectPointsToVertices(points);
            fillEllipse(vertices, rectFill.width, rectFill.height, applyOpacity(backgroundColor, opacity), backgroundImage, getBackgroundUV(rectFill.width, rectFill.height, backgroundSize, backgroundPosition, viewPixelDensity), opacity, inverted);
        }
        if (strokeWidth)
            strokePath(
            // rect out is already multiplied by pixeldensity
            createEllipseOutline(rectOut.x, rectOut.y, rectOut.width, rectOut.height, rotation, flipX, flipY), strokeWidth * viewPixelDensity, applyOpacity(strokeColor, opacity), true);
    };
    //#endregion
    const glTextures = new Map();
    let currentMarkupFrameBufferSize = { width: 0, height: 0 };
    return {
        // draw api
        drawPath,
        drawTriangle,
        drawRect,
        drawEllipse,
        drawImage,
        //#region texture management
        textureCreate: () => {
            return gl.createTexture();
        },
        textureUpdate: (texture, source) => {
            glTextures.set(texture, source);
            return updateTexture(gl, texture, source);
        },
        textureSize: (texture) => {
            return sizeCreateFromAny(glTextures.get(texture));
        },
        textureDelete: (texture) => {
            const source = glTextures.get(texture);
            if (source instanceof HTMLCanvasElement)
                releaseCanvas(source);
            glTextures.delete(texture);
            gl.deleteTexture(texture);
        },
        //#endregion
        setCanvasColor(color) {
            CANVAS_COLOR_R = color[0];
            CANVAS_COLOR_G = color[1];
            CANVAS_COLOR_B = color[2];
        },
        drawToCanvas() {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            // switch transformMatrix
            markupMatrix = markupMatrixCanvas;
            // tell webgl about the viewport
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            // black (or other color depending on background)
            gl.colorMask(true, true, true, false);
            gl.clearColor(CANVAS_COLOR_R, CANVAS_COLOR_G, CANVAS_COLOR_B, 1);
            // gl.clearColor(0.25, 0.25, 0.25, 1); // for debugging
            gl.clear(gl.COLOR_BUFFER_BIT);
            // update rect mask
            RECT_MASK_FEATHER = [1, 0, 1, 0, 1, viewSize.width, 1, viewSize.width];
        },
        drawToFramebuffer(imageSize) {
            if (!sizeEqual(imageSize, currentMarkupFrameBufferSize)) {
                // update preview markup texture
                gl.bindTexture(gl.TEXTURE_2D, indexTextureMap.get(TEXTURE_PREVIEW_MARKUP_INDEX));
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, imageSize.width, // was imageData.width
                imageSize.height, // was imageData.height
                0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                // set the filtering, we don't need mips
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, indexTextureMap.get(TEXTURE_PREVIEW_MARKUP_INDEX), 0);
                // remember so we know when to update the framebuffer
                currentMarkupFrameBufferSize = imageSize;
            }
            else {
                gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            }
            // switch transformMatrix
            const w = imageSize.width * viewPixelDensity;
            const h = imageSize.height * viewPixelDensity;
            mat4Ortho(markupMatrixFrameBuffer, 0, w, h, 0, -1, 1);
            mat4Translate(markupMatrixFrameBuffer, 0, h, 0);
            mat4ScaleX(markupMatrixFrameBuffer, 1);
            mat4ScaleY(markupMatrixFrameBuffer, -1);
            markupMatrix = markupMatrixFrameBuffer;
            // framebuffer lives in image space
            gl.viewport(0, 0, imageSize.width, imageSize.height);
            // always transparent
            gl.colorMask(true, true, true, true);
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            // update rect mask
            RECT_MASK_FEATHER = [
                1,
                0,
                1,
                0,
                1,
                Math.max(viewSize.width, imageSize.width),
                1,
                Math.max(viewSize.width, imageSize.width),
            ];
        },
        // set mask
        enableMask(rect, opacity) {
            const maskX = rect.x * viewPixelDensity;
            const maskY = rect.y * viewPixelDensity;
            const maskWidth = rect.width * viewPixelDensity;
            const maskHeight = rect.height * viewPixelDensity;
            maskLeft = maskX;
            maskRight = maskLeft + maskWidth;
            maskTop = viewSize.height - maskY;
            maskBottom = viewSize.height - (maskY + maskHeight);
            maskOpacity = 1.0 - opacity;
            maskBounds = [maskTop, maskRight, maskBottom, maskLeft];
        },
        disableMask() {
            maskLeft = 0;
            maskRight = viewSize.width;
            maskTop = viewSize.height;
            maskBottom = 0;
            maskOpacity = 1;
            maskBounds = [maskTop, maskRight, maskBottom, maskLeft];
        },
        // canvas
        resize,
        release() {
            canvas.width = 1;
            canvas.height = 1;
        },
    };
};

var isImageBitmap = (obj) => 'close' in obj;

/* src/core/ui/components/Canvas.svelte generated by Svelte v3.37.0 */

function create_fragment$L(ctx) {
	let div;
	let canvas_1;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			canvas_1 = element("canvas");
			attr(div, "class", "PinturaCanvas");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, canvas_1);
			/*canvas_1_binding*/ ctx[24](canvas_1);

			if (!mounted) {
				dispose = [
					listen(canvas_1, "measure", /*measure_handler*/ ctx[25]),
					action_destroyer(measurable.call(null, canvas_1))
				];

				mounted = true;
			}
		},
		p: noop$2,
		i: noop$2,
		o: noop$2,
		d(detaching) {
			if (detaching) detach(div);
			/*canvas_1_binding*/ ctx[24](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$L($$self, $$props, $$invalidate) {
	let canDraw;
	let drawUpdate;
	let $background;
	let $maskOpacityStore;
	let $mask;
	let $imageOverlayColor;
	let $maskFrameOpacityStore;

	const blendWithCanvasBackground = (back, front) => {
		const [bR, bG, bB] = back;
		const [fR, fG, fB, fA] = front;
		return [fR * fA + bR * (1 - fA), fG * fA + bG * (1 - fA), fB * fA + bB * (1 - fA), 1];
	};

	// used to dispatch the 'measure' event
	const dispatch = createEventDispatcher();

	let { animate } = $$props;
	let { maskRect } = $$props;
	let { maskOpacity = 1 } = $$props;
	let { maskFrameOpacity = 0.95 } = $$props;
	let { pixelRatio = 1 } = $$props;
	let { backgroundColor } = $$props;
	let { willRender = passthrough } = $$props;
	let { loadImageData = passthrough } = $$props;
	let { images = [] } = $$props;
	let { interfaceImages = [] } = $$props;

	// internal props
	let canvas;

	let canvasGL = null;
	let width = null;
	let height = null;

	//
	// springyness for main preview
	//
	const updateSpring = (spring, value) => spring.set(value, { hard: !animate });

	const SPRING_PROPS = { precision: 0.0001 };
	const SPRING_PROPS_FRACTION = { precision: SPRING_PROPS.precision * 0.01 };

	// Editor UI
	const background = tweened(undefined, { duration: 250 });

	component_subscribe($$self, background, value => $$invalidate(20, $background = value));
	const maskOpacityStore = spring$2(1, SPRING_PROPS_FRACTION);
	component_subscribe($$self, maskOpacityStore, value => $$invalidate(21, $maskOpacityStore = value));
	const maskFrameOpacityStore = spring$2(1, SPRING_PROPS_FRACTION);
	component_subscribe($$self, maskFrameOpacityStore, value => $$invalidate(30, $maskFrameOpacityStore = value));
	const mask = writable();
	component_subscribe($$self, mask, value => $$invalidate(28, $mask = value));
	const imageOverlayColor = writable();
	component_subscribe($$self, imageOverlayColor, value => $$invalidate(29, $imageOverlayColor = value));

	//#region texture loading and binding
	const TEXT_TEXTURE_MEASURE_CONTEXT = createSimpleContext();

	const Textures = new Map([]);

	const getImageTexture = image => {
		// no texture yet for this source
		if (!Textures.has(image)) {
			// is in loading state when is same as source
			Textures.set(image, image);

			// already loaded
			if (!isString(image) && (isImageBitmap(image) || isImageData(image))) {
				// create texture
				const texture = canvasGL.textureCreate();

				// udpate texture in gl canvas
				canvasGL.textureUpdate(texture, image);

				// update state we now have a texture
				Textures.set(image, texture);
			} else // need to load the image
			{
				loadImageData(image).then(data => {
					// create texture
					const texture = canvasGL.textureCreate();

					// udpate texture in gl canvas
					canvasGL.textureUpdate(texture, data);

					// update state we now have a texture
					Textures.set(image, texture);

					// need to redraw because texture is now available
					requestAnimationFrame(drawUpdate);
				}).catch(err => {
					console.error(err);
				});
			}
		}

		return Textures.get(image);
	};

	const getTextTexture = shape => {
		let { text, textAlign, fontFamily, fontSize, fontWeight, fontVariant, fontStyle, lineHeight, width } = shape;

		// we need this context to correctly wrap text
		updateTextContext(TEXT_TEXTURE_MEASURE_CONTEXT, {
			fontSize,
			fontFamily,
			fontWeight,
			fontVariant,
			fontStyle,
			textAlign
		});

		// wrap the text
		const textString = width
		? wrapText(TEXT_TEXTURE_MEASURE_CONTEXT, text, width)
		: text;

		// create UID for this texture so we can cache it and fetch it later on
		const textUID = shapeTextUID({ ...shape, text: textString });

		// get texture unit assigned to this specific text shape
		if (!Textures.has(textUID)) {
			// TODO: Create power of 2 texture and update texture instead of delete -> replace
			// we need to create a new texture
			const ctx = createSimpleContext();

			updateTextContext(ctx, {
				fontSize,
				fontFamily,
				fontWeight,
				fontVariant,
				fontStyle,
				textAlign
			});

			// calculate canvas height
			resizeContextToFitText(ctx, textString, {
				fontSize,
				fontFamily,
				fontWeight,
				fontVariant,
				fontStyle,
				textAlign,
				lineHeight
			});

			const contextMinWidth = ctx.canvas.width;

			// scale context to account for italic styles
			ctx.canvas.width += textPadding;

			// context resized, we now need to re-apply style
			updateTextContext(ctx, {
				fontSize,
				fontFamily,
				fontWeight,
				fontVariant,
				fontStyle,
				textAlign,
				color: [1, 0, 1], // color we'll replace in the shader
				
			});

			// if so, draw text and update texture
			drawText$1(ctx, textString, {
				fontSize,
				textAlign,
				lineHeight,
				lineWidth: contextMinWidth
			});

			Textures.set(textUID, canvasGL.textureUpdate(canvasGL.textureCreate(), ctx.canvas));
		}

		return Textures.get(textUID);
	};

	const getShapeTexture = shape => {
		let texture;

		// let's create textures for backgrounds and texts
		if (shape.backgroundImage) {
			texture = getImageTexture(shape.backgroundImage);
		} else if (isString(shape.text)) {
			if (shape.width && shape.width < 1 || shape.height && shape.height < 1) return undefined;
			texture = getTextTexture(shape);
		}

		return texture;
	};

	const isTexture = texture => texture instanceof WebGLTexture;

	const releaseUnusedTextures = usedTextures => {
		Textures.forEach((registeredTexture, key) => {
			const isUsed = !!usedTextures.find(usedTexture => usedTexture === registeredTexture);

			// stil used, no need to release
			if (isUsed) return;

			// remove this texture
			Textures.delete(key);

			canvasGL.textureDelete(registeredTexture);
		});
	};

	//#endregion
	//#region drawing
	const drawImageHelper = ({ data, size, origin, translation, rotation, scale, colorMatrix, opacity, convolutionMatrix, gamma, vignette, maskFeather, maskCornerRadius, backgroundColor, overlayColor, enableShapes }) => {
		// calculate opaque backgroundColor if backgroundColor is transparent and visible
		if (backgroundColor && backgroundColor[3] < 1 && backgroundColor[3] > 0) {
			backgroundColor = blendWithCanvasBackground($background, backgroundColor);
		}

		// gets texture to use for this image
		const texture = getImageTexture(data);

		// draw the image
		canvasGL.drawImage(texture, size, origin.x, origin.y, translation.x, translation.y, rotation.x, rotation.y, rotation.z, scale, colorMatrix, clamp(opacity, 0, 1), convolutionMatrix, gamma, vignette, maskFeather, maskCornerRadius, backgroundColor, overlayColor, enableShapes);

		return texture;
	};

	const drawShapes = (shapes = []) => {
		return shapes.map(shape => {
			// only show texture if shape is finished loading
			let shapeTexture = !shape._isLoading && getShapeTexture(shape);

			// get the webgl texture
			let texture = isTexture(shapeTexture) ? shapeTexture : undefined;

			if (isArray(shape.points)) {
				// is triangle
				if (shape.points.length === 3 && shape.backgroundColor) {
					canvasGL.drawTriangle(shape.points, shape.rotation, shape.flipX, shape.flipY, shape.backgroundColor, shape.strokeWidth, shape.strokeColor, shape.opacity);
				} else // is normal path
				{
					canvasGL.drawPath(shape.points, shape.strokeWidth, shape.strokeColor, shape.pathClose, shape.opacity);
				}
			} else // is ellipse 
			if (isNumber$1(shape.rx) && isNumber$1(shape.ry)) {
				let backgroundSize;
				let backgroundPosition;
				canvasGL.drawEllipse(shape, shape.rx, shape.ry, shape.rotation, shape.flipX, shape.flipY, shape.backgroundColor, texture, backgroundSize, backgroundPosition, shape.strokeWidth, shape.strokeColor, shape.opacity, shape.inverted);
			} else // is rect
			if (isString(shape.text) && texture || shape.width) {
				const textureSize = texture && canvasGL.textureSize(texture);
				let colorize = undefined;
				let shapeRect;

				let shapeCornerRadius = [
					shape.cornerRadius,
					shape.cornerRadius,
					shape.cornerRadius,
					shape.cornerRadius
				];

				if (shape.width) {
					shapeRect = shape;
				} else {
					shapeRect = { x: shape.x, y: shape.y, ...textureSize };
				}

				let backgroundSize;
				let backgroundPosition;

				if (textureSize) {
					// background should be scaled
					if (shape.backgroundImage && shape.backgroundSize) {
						// always respect texture aspect ratio
						const textureAspectRatio = getAspectRatio(textureSize.width, textureSize.height);

						// adjust position of background
						if (shape.backgroundSize === "contain") {
							const rect = rectContainRect(shape, textureAspectRatio, shapeRect);
							backgroundSize = sizeCreateFromRect(rect);
							backgroundPosition = vectorCreate((shape.width - backgroundSize.width) * 0.5, (shape.height - backgroundSize.height) * 0.5);
						} else if (shape.backgroundSize === "cover") {
							const rect = rectCoverRect(shape, textureAspectRatio, shapeRect);
							backgroundSize = sizeCreateFromRect(rect);
							backgroundPosition = vectorCreate(rect.x, rect.y);
							backgroundPosition = vectorCreate((shape.width - backgroundSize.width) * 0.5, (shape.height - backgroundSize.height) * 0.5);
						}
					} else // is text, "background" should be texture size and be positioned based on alignment
					if (shape.text && shape.width) {
						// position texture based on text alignment
						backgroundSize = textureSize;

						backgroundPosition = vectorCreate(0, 0);

						// auto height
						if (!shape.height) shape.height = textureSize.height;

						// textPadding so text doesn't clip on left and right edges
						shape.x -= textPadding;

						shape.width += textPadding * 2;

						if (shape.textAlign === "left") {
							backgroundPosition.x = textPadding;
						}

						if (shape.textAlign === "center") {
							backgroundPosition.x = textPadding * 0.5 + (shape.width - textureSize.width) * 0.5;
						}

						if (shape.textAlign === "right") {
							backgroundPosition.x = shape.width - textureSize.width;
						}
					} else if (shape.text) {
						backgroundPosition = vectorCreate(0, 0);

						backgroundSize = {
							width: shapeRect.width,
							height: shapeRect.height
						};

						// texture is slightly larger because of text padding, need to compensate for this in single line mode
						shapeRect.width -= textPadding;
					}

					if (shape.text) colorize = shape.color;
				}

				canvasGL.drawRect(shapeRect, shape.rotation, shape.flipX, shape.flipY, shapeCornerRadius, shape.backgroundColor, texture, backgroundSize, backgroundPosition, shape.strokeWidth, shape.strokeColor, shape.opacity, undefined, colorize, shape.inverted);
			}

			return shapeTexture;
		}).filter(Boolean);
	};

	// redraws state
	const usedTextures = [];

	const redraw = () => {
		// reset array of textures used in this draw call
		usedTextures.length = 0;

		// get top image shortcut
		const imagesTop = images[0];

		// allow dev to inject more shapes
		const { annotationShapes, interfaceShapes, decorationShapes, frameShapes } = willRender({
			// top image state shortcut
			opacity: imagesTop.opacity,
			rotation: imagesTop.rotation,
			scale: imagesTop.scale,
			// active images
			images,
			// canvas size
			size: sizeCreate(width, height),
			// canvas background
			backgroundColor: [...$background]
		});

		const canvasBackgroundColor = [...$background];
		const imagesMask = $mask;
		const imagesMaskOpacity = clamp($maskOpacityStore, 0, 1);
		const imagesOverlayColor = $imageOverlayColor;
		const imagesSize = imagesTop.size;
		const imagesBackgroundColor = imagesTop.backgroundColor;

		// no need to draw to framebuffer is no annotations
		const hasAnnotations = annotationShapes.length > 0;

		// if image has background color
		const hasImageBackgroundColor = imagesBackgroundColor[3] > 0;

		// if the overlay is transparent so we can see the canvas
		const hasTransparentOverlay = imagesMaskOpacity < 1;

		// set canvas background color to image background color if is defined
		if (hasTransparentOverlay && hasImageBackgroundColor) {
			const backR = canvasBackgroundColor[0];
			const backG = canvasBackgroundColor[1];
			const backB = canvasBackgroundColor[2];
			const frontA = 1 - imagesMaskOpacity;
			const frontR = imagesBackgroundColor[0] * frontA;
			const frontG = imagesBackgroundColor[1] * frontA;
			const frontB = imagesBackgroundColor[2] * frontA;
			const fA = 1 - frontA;
			canvasBackgroundColor[0] = frontR + backR * fA;
			canvasBackgroundColor[1] = frontG + backG * fA;
			canvasBackgroundColor[2] = frontB + backB * fA;
			canvasBackgroundColor[3] = 1;
		}

		canvasGL.setCanvasColor(canvasBackgroundColor);

		// if has annotations draw annotation shapes to framebuffer
		// TODO: only run this if annotations have changed
		if (hasAnnotations) {
			canvasGL.disableMask();
			canvasGL.drawToFramebuffer(imagesSize);
			usedTextures.push(...drawShapes(annotationShapes));
		}

		// switch to canvas drawing for other elements
		canvasGL.drawToCanvas();

		canvasGL.enableMask(imagesMask, imagesMaskOpacity);

		// draw a colored rectangle behind main preview image
		if (hasImageBackgroundColor) {
			canvasGL.drawRect(imagesMask, 0, false, false, [0, 0, 0, 0], blendWithCanvasBackground($background, imagesBackgroundColor));
		}

		usedTextures.push(...[...images].reverse().map(image => {
			return drawImageHelper({
				...image,
				// enable drawing markup framebuffer on image
				enableShapes: hasAnnotations,
				// mask and overlay positions
				mask: imagesMask,
				maskOpacity: imagesMaskOpacity,
				overlayColor: imagesOverlayColor
			});
		}));

		// TODO: move vignette here (draw with colorized circular gradient texture instead of in shader)
		// draw decorations shapes relative to crop
		canvasGL.enableMask(imagesMask, 1);

		usedTextures.push(...drawShapes(decorationShapes));

		// draw frames
		if (frameShapes.length) {
			const shapesInside = frameShapes.filter(shape => !shape.expandsCanvas);
			const shapesOutside = frameShapes.filter(shape => shape.expandsCanvas);

			if (shapesInside.length) {
				usedTextures.push(...drawShapes(shapesInside));
			}

			if (shapesOutside.length) {
				// the half pixel helps mask the outside shapes at the correct position
				canvasGL.enableMask(
					{
						x: imagesMask.x + 0.5,
						y: imagesMask.y + 0.5,
						width: imagesMask.width - 1,
						height: imagesMask.height - 1
					},
					$maskFrameOpacityStore
				);

				usedTextures.push(...drawShapes(shapesOutside));
			}
		}

		// crop mask not used for interface
		canvasGL.disableMask();

		// frames rendered on the outside
		// draw custom interface shapes
		usedTextures.push(...drawShapes(interfaceShapes));

		interfaceImages.forEach(image => {
			canvasGL.enableMask(image.mask, image.maskOpacity);

			// draw background fill
			if (image.backgroundColor) {
				canvasGL.drawRect(image.mask, 0, false, false, image.maskCornerRadius, image.backgroundColor, undefined, undefined, undefined, undefined, undefined, image.opacity, image.maskFeather);
			}

			// draw image
			drawImageHelper({
				...image,
				// update translation to apply `offset` from top left
				translation: {
					x: image.translation.x + image.offset.x - width * 0.5,
					y: image.translation.y + image.offset.y - height * 0.5
				}
			});
		});

		canvasGL.disableMask();

		// determine which textures can be dropped
		releaseUnusedTextures(usedTextures);
	};

	//#endregion
	//#region set up
	// throttled redrawer
	let lastDraw = Date.now();

	const redrawThrottled = () => {
		const now = Date.now();
		const dist = now - lastDraw;
		if (dist < 48) return;
		lastDraw = now;
		redraw();
	};

	// returns the render function to use for this browser context
	const selectFittingRenderFunction = () => isSoftwareRendering() ? redrawThrottled : redraw;

	// after DOM has been altered, redraw to canvas
	afterUpdate(() => drawUpdate());

	// hook up canvas to WebGL drawer
	onMount(() => $$invalidate(19, canvasGL = createWebGLCanvas(canvas)));

	// clean up canvas
	onDestroy(() => {
		// if canvas wasn't created we don't need to release it
		if (!canvasGL) return;

		// done drawing
		canvasGL.release();

		// force release canvas for Safari
		releaseCanvas(TEXT_TEXTURE_MEASURE_CONTEXT.canvas);
	});

	function canvas_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			canvas = $$value;
			$$invalidate(2, canvas);
		});
	}

	const measure_handler = e => {
		$$invalidate(0, width = e.detail.width);
		$$invalidate(1, height = e.detail.height);
		dispatch("measure", { width, height });
	};

	$$self.$$set = $$props => {
		if ("animate" in $$props) $$invalidate(9, animate = $$props.animate);
		if ("maskRect" in $$props) $$invalidate(10, maskRect = $$props.maskRect);
		if ("maskOpacity" in $$props) $$invalidate(11, maskOpacity = $$props.maskOpacity);
		if ("maskFrameOpacity" in $$props) $$invalidate(12, maskFrameOpacity = $$props.maskFrameOpacity);
		if ("pixelRatio" in $$props) $$invalidate(13, pixelRatio = $$props.pixelRatio);
		if ("backgroundColor" in $$props) $$invalidate(14, backgroundColor = $$props.backgroundColor);
		if ("willRender" in $$props) $$invalidate(15, willRender = $$props.willRender);
		if ("loadImageData" in $$props) $$invalidate(16, loadImageData = $$props.loadImageData);
		if ("images" in $$props) $$invalidate(17, images = $$props.images);
		if ("interfaceImages" in $$props) $$invalidate(18, interfaceImages = $$props.interfaceImages);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*backgroundColor*/ 16384) {
			backgroundColor && updateSpring(background, backgroundColor);
		}

		if ($$self.$$.dirty[0] & /*maskOpacity*/ 2048) {
			updateSpring(maskOpacityStore, isNumber$1(maskOpacity) ? maskOpacity : 1);
		}

		if ($$self.$$.dirty[0] & /*maskFrameOpacity*/ 4096) {
			updateSpring(maskFrameOpacityStore, isNumber$1(maskFrameOpacity) ? maskFrameOpacity : 1);
		}

		if ($$self.$$.dirty[0] & /*maskRect*/ 1024) {
			maskRect && mask.set(maskRect);
		}

		if ($$self.$$.dirty[0] & /*$background, $maskOpacityStore*/ 3145728) {
			$background && imageOverlayColor.set([
				$background[0],
				$background[1],
				$background[2],
				clamp($maskOpacityStore, 0, 1)
			]);
		}

		if ($$self.$$.dirty[0] & /*canvasGL, width, height, images*/ 655363) {
			// can draw view
			$$invalidate(23, canDraw = !!(canvasGL && width && height && images.length));
		}

		if ($$self.$$.dirty[0] & /*width, height, canvasGL, pixelRatio*/ 532483) {
			// observe width and height changes and resize the canvas proportionally
			width && height && canvasGL && canvasGL.resize(width, height, pixelRatio);
		}

		if ($$self.$$.dirty[0] & /*canDraw*/ 8388608) {
			// switch to draw method when can draw
			$$invalidate(22, drawUpdate = canDraw ? selectFittingRenderFunction() : noop$1);
		}

		if ($$self.$$.dirty[0] & /*canDraw, drawUpdate*/ 12582912) {
			// if can draw state is updated and we have a draw update function, time to redraw
			canDraw && drawUpdate && drawUpdate();
		}
	};

	return [
		width,
		height,
		canvas,
		dispatch,
		background,
		maskOpacityStore,
		maskFrameOpacityStore,
		mask,
		imageOverlayColor,
		animate,
		maskRect,
		maskOpacity,
		maskFrameOpacity,
		pixelRatio,
		backgroundColor,
		willRender,
		loadImageData,
		images,
		interfaceImages,
		canvasGL,
		$background,
		$maskOpacityStore,
		drawUpdate,
		canDraw,
		canvas_1_binding,
		measure_handler
	];
}

class Canvas extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$L,
			create_fragment$L,
			safe_not_equal,
			{
				animate: 9,
				maskRect: 10,
				maskOpacity: 11,
				maskFrameOpacity: 12,
				pixelRatio: 13,
				backgroundColor: 14,
				willRender: 15,
				loadImageData: 16,
				images: 17,
				interfaceImages: 18
			},
			[-1, -1]
		);
	}
}

var arrayJoin = (arr, filter = Boolean, str = ' ') => arr.filter(filter).join(str);

/* src/core/ui/components/TabList.svelte generated by Svelte v3.37.0 */

function get_each_context$9(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[17] = list[i];
	return child_ctx;
}

const get_default_slot_changes$1 = dirty => ({ tab: dirty & /*tabNodes*/ 4 });
const get_default_slot_context$1 = ctx => ({ tab: /*tab*/ ctx[17] });

// (73:0) {#if shouldRender}
function create_if_block$e(ctx) {
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let ul_class_value;
	let current;
	let each_value = /*tabNodes*/ ctx[2];
	const get_key = ctx => /*tab*/ ctx[17].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$9(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$9(key, child_ctx));
	}

	return {
		c() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(ul, "class", ul_class_value = arrayJoin(["PinturaTabList", /*klass*/ ctx[0]]));
			attr(ul, "role", "tablist");
			attr(ul, "data-layout", /*layout*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			/*ul_binding*/ ctx[14](ul);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*tabNodes, handleKeyTab, handleClickTab, $$scope*/ 1124) {
				each_value = /*tabNodes*/ ctx[2];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$9, null, get_each_context$9);
				check_outros();
			}

			if (!current || dirty & /*klass*/ 1 && ul_class_value !== (ul_class_value = arrayJoin(["PinturaTabList", /*klass*/ ctx[0]]))) {
				attr(ul, "class", ul_class_value);
			}

			if (!current || dirty & /*layout*/ 2) {
				attr(ul, "data-layout", /*layout*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*ul_binding*/ ctx[14](null);
		}
	};
}

// (75:4) {#each tabNodes as tab (tab.id) }
function create_each_block$9(key_1, ctx) {
	let li;
	let button;
	let button_disabled_value;
	let t;
	let li_aria_controls_value;
	let li_id_value;
	let li_aria_selected_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], get_default_slot_context$1);

	function keydown_handler(...args) {
		return /*keydown_handler*/ ctx[12](/*tab*/ ctx[17], ...args);
	}

	function click_handler(...args) {
		return /*click_handler*/ ctx[13](/*tab*/ ctx[17], ...args);
	}

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			button = element("button");
			if (default_slot) default_slot.c();
			t = space();
			button.disabled = button_disabled_value = /*tab*/ ctx[17].disabled;
			attr(li, "role", "tab");
			attr(li, "aria-controls", li_aria_controls_value = /*tab*/ ctx[17].href.substr(1));
			attr(li, "id", li_id_value = /*tab*/ ctx[17].tabId);
			attr(li, "aria-selected", li_aria_selected_value = /*tab*/ ctx[17].selected);
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, button);

			if (default_slot) {
				default_slot.m(button, null);
			}

			append(li, t);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button, "keydown", keydown_handler),
					listen(button, "click", click_handler)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, tabNodes*/ 1028) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, get_default_slot_changes$1, get_default_slot_context$1);
				}
			}

			if (!current || dirty & /*tabNodes*/ 4 && button_disabled_value !== (button_disabled_value = /*tab*/ ctx[17].disabled)) {
				button.disabled = button_disabled_value;
			}

			if (!current || dirty & /*tabNodes*/ 4 && li_aria_controls_value !== (li_aria_controls_value = /*tab*/ ctx[17].href.substr(1))) {
				attr(li, "aria-controls", li_aria_controls_value);
			}

			if (!current || dirty & /*tabNodes*/ 4 && li_id_value !== (li_id_value = /*tab*/ ctx[17].tabId)) {
				attr(li, "id", li_id_value);
			}

			if (!current || dirty & /*tabNodes*/ 4 && li_aria_selected_value !== (li_aria_selected_value = /*tab*/ ctx[17].selected)) {
				attr(li, "aria-selected", li_aria_selected_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$K(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*shouldRender*/ ctx[4] && create_if_block$e(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty$1();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*shouldRender*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*shouldRender*/ 16) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$e(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$K($$self, $$props, $$invalidate) {
	let tabNodes;
	let shouldRender;
	let { $$slots: slots = {}, $$scope } = $$props;
	let root;
	let { class: klass = undefined } = $$props;
	let { name } = $$props;
	let { selected } = $$props;
	let { tabs = [] } = $$props;
	let { layout = undefined } = $$props;
	const dispatch = createEventDispatcher();

	const focusTab = index => {
		const tab = root.querySelectorAll("[role=\"tab\"] button")[index];
		if (!tab) return;
		tab.focus();
	};

	const handleClickTab = (e, id) => {
		e.preventDefault();
		e.stopPropagation();
		dispatch("select", id);
	};

	const handleKeyTab = ({ key }, id) => {
		if (!(/arrow/i).test(key)) return;
		const index = tabs.findIndex(tab => tab.id === id);

		// next
		if ((/right|down/i).test(key)) return focusTab(index < tabs.length - 1 ? index + 1 : 0);

		// prev
		if ((/left|up/i).test(key)) return focusTab(index > 0 ? index - 1 : tabs.length - 1);
	};

	const keydown_handler = (tab, e) => handleKeyTab(e, tab.id);
	const click_handler = (tab, e) => handleClickTab(e, tab.id);

	function ul_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			root = $$value;
			$$invalidate(3, root);
		});
	}

	$$self.$$set = $$props => {
		if ("class" in $$props) $$invalidate(0, klass = $$props.class);
		if ("name" in $$props) $$invalidate(7, name = $$props.name);
		if ("selected" in $$props) $$invalidate(8, selected = $$props.selected);
		if ("tabs" in $$props) $$invalidate(9, tabs = $$props.tabs);
		if ("layout" in $$props) $$invalidate(1, layout = $$props.layout);
		if ("$$scope" in $$props) $$invalidate(10, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*tabs, selected, name*/ 896) {
			$$invalidate(2, tabNodes = tabs.map(tab => {
				const isActive = tab.id === selected;

				return {
					...tab,
					tabId: `tab-${name}-${tab.id}`,
					href: `#panel-${name}-${tab.id}`,
					selected: isActive
				};
			}));
		}

		if ($$self.$$.dirty & /*tabNodes*/ 4) {
			$$invalidate(4, shouldRender = tabNodes.length > 1);
		}
	};

	return [
		klass,
		layout,
		tabNodes,
		root,
		shouldRender,
		handleClickTab,
		handleKeyTab,
		name,
		selected,
		tabs,
		$$scope,
		slots,
		keydown_handler,
		click_handler,
		ul_binding
	];
}

class TabList extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$K, create_fragment$K, safe_not_equal, {
			class: 0,
			name: 7,
			selected: 8,
			tabs: 9,
			layout: 1
		});
	}
}

/* src/core/ui/components/TabPanels.svelte generated by Svelte v3.37.0 */
const get_default_slot_changes_1 = dirty => ({ panel: dirty & /*panelNodes*/ 16 });

const get_default_slot_context_1 = ctx => ({
	panel: /*panelNodes*/ ctx[4][0].id,
	panelIsActive: true
});

function get_each_context$8(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i].id;
	child_ctx[15] = list[i].draw;
	child_ctx[16] = list[i].panelId;
	child_ctx[17] = list[i].tabindex;
	child_ctx[18] = list[i].labelledBy;
	child_ctx[19] = list[i].hidden;
	child_ctx[3] = list[i].visible;
	return child_ctx;
}

const get_default_slot_changes = dirty => ({
	panel: dirty & /*panelNodes*/ 16,
	panelIsActive: dirty & /*panelNodes*/ 16
});

const get_default_slot_context = ctx => ({
	panel: /*id*/ ctx[14],
	panelIsActive: !/*hidden*/ ctx[19]
});

// (75:0) {:else}
function create_else_block$5(ctx) {
	let div1;
	let div0;
	let div0_class_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], get_default_slot_context_1);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr(div0, "class", div0_class_value = arrayJoin([/*panelClass*/ ctx[1]]));
			attr(div1, "class", /*klass*/ ctx[0]);
			attr(div1, "style", /*style*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div1, "measure", /*measure_handler_1*/ ctx[13]),
					action_destroyer(measurable.call(null, div1))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, panelNodes*/ 1040) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, get_default_slot_changes_1, get_default_slot_context_1);
				}
			}

			if (!current || dirty & /*panelClass*/ 2 && div0_class_value !== (div0_class_value = arrayJoin([/*panelClass*/ ctx[1]]))) {
				attr(div0, "class", div0_class_value);
			}

			if (!current || dirty & /*klass*/ 1) {
				attr(div1, "class", /*klass*/ ctx[0]);
			}

			if (!current || dirty & /*style*/ 4) {
				attr(div1, "style", /*style*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (66:0) {#if shouldRender}
function create_if_block$d(ctx) {
	let div;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let div_class_value;
	let current;
	let mounted;
	let dispose;
	let each_value = /*panelNodes*/ ctx[4];
	const get_key = ctx => /*id*/ ctx[14];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$8(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$8(key, child_ctx));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", div_class_value = arrayJoin(["PinturaTabPanels", /*klass*/ ctx[0]]));
			attr(div, "style", /*style*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "measure", /*measure_handler*/ ctx[12]),
					action_destroyer(measurable.call(null, div))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*arrayJoin, panelClass, panelNodes, $$scope*/ 1042) {
				each_value = /*panelNodes*/ ctx[4];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$8, null, get_each_context$8);
				check_outros();
			}

			if (!current || dirty & /*klass*/ 1 && div_class_value !== (div_class_value = arrayJoin(["PinturaTabPanels", /*klass*/ ctx[0]]))) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 4) {
				attr(div, "style", /*style*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (71:8) {#if draw}
function create_if_block_1$e(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], get_default_slot_context);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, panelNodes*/ 1040) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, get_default_slot_changes, get_default_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (69:4) {#each panelNodes as { id, draw, panelId, tabindex, labelledBy, hidden, visible }
function create_each_block$8(key_1, ctx) {
	let div;
	let t;
	let div_class_value;
	let div_hidden_value;
	let div_id_value;
	let div_tabindex_value;
	let div_aria_labelledby_value;
	let div_data_inert_value;
	let current;
	let if_block = /*draw*/ ctx[15] && create_if_block_1$e(ctx);

	return {
		key: key_1,
		first: null,
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			attr(div, "class", div_class_value = arrayJoin(["PinturaTabPanel", /*panelClass*/ ctx[1]]));
			div.hidden = div_hidden_value = /*hidden*/ ctx[19];
			attr(div, "id", div_id_value = /*panelId*/ ctx[16]);
			attr(div, "tabindex", div_tabindex_value = /*tabindex*/ ctx[17]);
			attr(div, "aria-labelledby", div_aria_labelledby_value = /*labelledBy*/ ctx[18]);
			attr(div, "data-inert", div_data_inert_value = !/*visible*/ ctx[3]);
			this.first = div;
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append(div, t);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*draw*/ ctx[15]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*panelNodes*/ 16) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$e(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*panelClass*/ 2 && div_class_value !== (div_class_value = arrayJoin(["PinturaTabPanel", /*panelClass*/ ctx[1]]))) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty & /*panelNodes*/ 16 && div_hidden_value !== (div_hidden_value = /*hidden*/ ctx[19])) {
				div.hidden = div_hidden_value;
			}

			if (!current || dirty & /*panelNodes*/ 16 && div_id_value !== (div_id_value = /*panelId*/ ctx[16])) {
				attr(div, "id", div_id_value);
			}

			if (!current || dirty & /*panelNodes*/ 16 && div_tabindex_value !== (div_tabindex_value = /*tabindex*/ ctx[17])) {
				attr(div, "tabindex", div_tabindex_value);
			}

			if (!current || dirty & /*panelNodes*/ 16 && div_aria_labelledby_value !== (div_aria_labelledby_value = /*labelledBy*/ ctx[18])) {
				attr(div, "aria-labelledby", div_aria_labelledby_value);
			}

			if (!current || dirty & /*panelNodes*/ 16 && div_data_inert_value !== (div_data_inert_value = !/*visible*/ ctx[3])) {
				attr(div, "data-inert", div_data_inert_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
		}
	};
}

function create_fragment$J(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$d, create_else_block$5];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*shouldRender*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty$1();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$J($$self, $$props, $$invalidate) {
	let panelNodes;
	let shouldRender;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: klass = undefined } = $$props;
	let { name } = $$props;
	let { selected } = $$props;
	let { visible = undefined } = $$props;
	let { panelClass = undefined } = $$props;
	let { panels = [] } = $$props;
	let { style = undefined } = $$props;
	const drawCache = {};

	function measure_handler(event) {
		bubble($$self, event);
	}

	function measure_handler_1(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("class" in $$props) $$invalidate(0, klass = $$props.class);
		if ("name" in $$props) $$invalidate(6, name = $$props.name);
		if ("selected" in $$props) $$invalidate(7, selected = $$props.selected);
		if ("visible" in $$props) $$invalidate(3, visible = $$props.visible);
		if ("panelClass" in $$props) $$invalidate(1, panelClass = $$props.panelClass);
		if ("panels" in $$props) $$invalidate(8, panels = $$props.panels);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
		if ("$$scope" in $$props) $$invalidate(10, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*panels, selected, visible, name, drawCache*/ 968) {
			$$invalidate(4, panelNodes = panels.map(id => {
				const isActive = id === selected;
				const isVisible = visible ? visible.indexOf(id) !== -1 : true;

				// remember that this tab was active so we keep drawing it even when it's inactive
				if (isActive) $$invalidate(9, drawCache[id] = true, drawCache);

				return {
					id,
					panelId: `panel-${name}-${id}`,
					labelledBy: `tab-${name}-${id}`,
					hidden: !isActive,
					visible: isVisible,
					tabindex: isActive ? 0 : -1,
					draw: isActive || drawCache[id]
				};
			}));
		}

		if ($$self.$$.dirty & /*panelNodes*/ 16) {
			$$invalidate(5, shouldRender = panelNodes.length > 1);
		}
	};

	return [
		klass,
		panelClass,
		style,
		visible,
		panelNodes,
		shouldRender,
		name,
		selected,
		panels,
		drawCache,
		$$scope,
		slots,
		measure_handler,
		measure_handler_1
	];
}

class TabPanels extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$J, create_fragment$J, safe_not_equal, {
			class: 0,
			name: 6,
			selected: 7,
			visible: 3,
			panelClass: 1,
			panels: 8,
			style: 2
		});
	}
}

/* src/core/ui/components/Panel.svelte generated by Svelte v3.37.0 */

function create_fragment$I(ctx) {
	let div;
	let switch_instance;
	let updating_name;
	let div_class_value;
	let current;
	const switch_instance_spread_levels = [/*componentProps*/ ctx[7]];

	function switch_instance_name_binding(value) {
		/*switch_instance_name_binding*/ ctx[19](value);
	}

	var switch_value = /*componentView*/ ctx[11];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		if (/*panelName*/ ctx[5] !== void 0) {
			switch_instance_props.name = /*panelName*/ ctx[5];
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		binding_callbacks.push(() => bind$1(switch_instance, "name", switch_instance_name_binding));
		/*switch_instance_binding*/ ctx[20](switch_instance);
		switch_instance.$on("measure", /*measure_handler*/ ctx[21]);
	}

	return {
		c() {
			div = element("div");
			if (switch_instance) create_component(switch_instance.$$.fragment);
			attr(div, "data-util", /*panelName*/ ctx[5]);
			attr(div, "class", div_class_value = arrayJoin(["PinturaPanel", /*klass*/ ctx[2]]));
			attr(div, "style", /*style*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (switch_instance) {
				mount_component(switch_instance, div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			const switch_instance_changes = (dirty & /*componentProps*/ 128)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*componentProps*/ ctx[7])])
			: {};

			if (!updating_name && dirty & /*panelName*/ 32) {
				updating_name = true;
				switch_instance_changes.name = /*panelName*/ ctx[5];
				add_flush_callback(() => updating_name = false);
			}

			if (switch_value !== (switch_value = /*componentView*/ ctx[11])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					binding_callbacks.push(() => bind$1(switch_instance, "name", switch_instance_name_binding));
					/*switch_instance_binding*/ ctx[20](switch_instance);
					switch_instance.$on("measure", /*measure_handler*/ ctx[21]);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, div, null);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}

			if (!current || dirty & /*panelName*/ 32) {
				attr(div, "data-util", /*panelName*/ ctx[5]);
			}

			if (!current || dirty & /*klass*/ 4 && div_class_value !== (div_class_value = arrayJoin(["PinturaPanel", /*klass*/ ctx[2]]))) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 64) {
				attr(div, "style", /*style*/ ctx[6]);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			/*switch_instance_binding*/ ctx[20](null);
			if (switch_instance) destroy_component(switch_instance);
		}
	};
}

function instance$I($$self, $$props, $$invalidate) {
	let style;
	let componentProps;
	let $opacityClamped;
	let $isActivePrivateStore;
	const dispatch = createEventDispatcher();
	let { isActive = true } = $$props;
	let { isAnimated = true } = $$props;
	let { stores } = $$props;
	let { content } = $$props;
	let { component } = $$props;
	let { locale } = $$props;
	let { class: klass = undefined } = $$props;

	// we remember the view rect in this variable
	let rect;

	const opacity = spring$2(0);
	const opacityClamped = derived(opacity, $opacity => clamp($opacity, 0, 1));
	component_subscribe($$self, opacityClamped, value => $$invalidate(18, $opacityClamped = value));

	// throw hide / show events
	let isHidden = !isActive;

	// create active store so can be used in derived stores
	const isActivePrivateStore = writable(isActive);

	component_subscribe($$self, isActivePrivateStore, value => $$invalidate(22, $isActivePrivateStore = value));

	const stateProps = {
		isActive: derived(isActivePrivateStore, $isActivePrivateStore => $isActivePrivateStore),
		isActiveFraction: derived(opacityClamped, $opacityClamped => $opacityClamped),
		isVisible: derived(opacityClamped, $opacityClamped => $opacityClamped > 0)
	};

	// build the component props
	const componentView = content.view;

	const componentExportedProps = getComponentExportedProps(componentView);

	const componentComputedProps = Object.keys(content.props || {}).reduce(
		(computedProps, key) => {
			if (!componentExportedProps.includes(key)) return computedProps;
			computedProps[key] = content.props[key];
			return computedProps;
		},
		{}
	);

	const componentComputedStateProps = Object.keys(stateProps).reduce(
		(computedStateProps, key) => {
			if (!componentExportedProps.includes(key)) return computedStateProps;
			computedStateProps[key] = stateProps[key];
			return computedStateProps;
		},
		{}
	);

	// class used on panel element
	let panelName;

	// we use the `hasBeenMounted` bool to block rect updates until the entire panel is ready
	let hasBeenMounted = false;

	onMount(() => {
		$$invalidate(4, hasBeenMounted = true);
	});

	function switch_instance_name_binding(value) {
		panelName = value;
		$$invalidate(5, panelName);
	}

	function switch_instance_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			component = $$value;
			$$invalidate(0, component);
		});
	}

	const measure_handler = e => {
		if (!hasBeenMounted || !isActive) return;
		$$invalidate(3, rect = e.detail);
		dispatch("measure", { ...rect });
	};

	$$self.$$set = $$props => {
		if ("isActive" in $$props) $$invalidate(1, isActive = $$props.isActive);
		if ("isAnimated" in $$props) $$invalidate(12, isAnimated = $$props.isAnimated);
		if ("stores" in $$props) $$invalidate(13, stores = $$props.stores);
		if ("content" in $$props) $$invalidate(14, content = $$props.content);
		if ("component" in $$props) $$invalidate(0, component = $$props.component);
		if ("locale" in $$props) $$invalidate(15, locale = $$props.locale);
		if ("class" in $$props) $$invalidate(2, klass = $$props.class);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*rect, isActive, component*/ 11) {
			// when the view rect changes and the panel is in active state or became active, dispatch measure event
			if (rect && isActive && component) dispatch("measure", rect);
		}

		if ($$self.$$.dirty & /*isActive, isAnimated*/ 4098) {
			opacity.set(isActive ? 1 : 0, { hard: !isAnimated });
		}

		if ($$self.$$.dirty & /*$opacityClamped, isHidden*/ 393216) {
			if ($opacityClamped <= 0 && !isHidden) {
				$$invalidate(17, isHidden = true);
			} else if ($opacityClamped > 0 && isHidden) {
				$$invalidate(17, isHidden = false);
			}
		}

		if ($$self.$$.dirty & /*hasBeenMounted, isHidden*/ 131088) {
			hasBeenMounted && dispatch(isHidden ? "hide" : "show");
		}

		if ($$self.$$.dirty & /*$opacityClamped*/ 262144) {
			dispatch("fade", $opacityClamped);
		}

		if ($$self.$$.dirty & /*$opacityClamped*/ 262144) {
			// only set opacity prop if is below 0
			$$invalidate(6, style = $opacityClamped < 1
			? `opacity: ${$opacityClamped}`
			: undefined);
		}

		if ($$self.$$.dirty & /*isActive*/ 2) {
			set_store_value(isActivePrivateStore, $isActivePrivateStore = isActive, $isActivePrivateStore);
		}

		if ($$self.$$.dirty & /*stores, locale*/ 40960) {
			$$invalidate(7, componentProps = {
				...componentComputedProps,
				...componentComputedStateProps,
				stores,
				locale
			});
		}
	};

	return [
		component,
		isActive,
		klass,
		rect,
		hasBeenMounted,
		panelName,
		style,
		componentProps,
		dispatch,
		opacityClamped,
		isActivePrivateStore,
		componentView,
		isAnimated,
		stores,
		content,
		locale,
		opacity,
		isHidden,
		$opacityClamped,
		switch_instance_name_binding,
		switch_instance_binding,
		measure_handler
	];
}

class Panel extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$I, create_fragment$I, safe_not_equal, {
			isActive: 1,
			isAnimated: 12,
			stores: 13,
			content: 14,
			component: 0,
			locale: 15,
			class: 2,
			opacity: 16
		});
	}

	get opacity() {
		return this.$$.ctx[16];
	}
}

/* src/core/ui/components/Icon.svelte generated by Svelte v3.37.0 */

function create_fragment$H(ctx) {
	let svg;
	let svg_viewBox_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	return {
		c() {
			svg = svg_element("svg");
			if (default_slot) default_slot.c();
			attr(svg, "class", /*klass*/ ctx[3]);
			attr(svg, "style", /*style*/ ctx[2]);
			attr(svg, "width", /*width*/ ctx[0]);
			attr(svg, "height", /*height*/ ctx[1]);
			attr(svg, "viewBox", svg_viewBox_value = "0 0 " + /*width*/ ctx[0] + "\n    " + /*height*/ ctx[1]);
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "aria-hidden", "true");
			attr(svg, "focusable", "false");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
		},
		m(target, anchor) {
			insert(target, svg, anchor);

			if (default_slot) {
				default_slot.m(svg, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			if (!current || dirty & /*klass*/ 8) {
				attr(svg, "class", /*klass*/ ctx[3]);
			}

			if (!current || dirty & /*style*/ 4) {
				attr(svg, "style", /*style*/ ctx[2]);
			}

			if (!current || dirty & /*width*/ 1) {
				attr(svg, "width", /*width*/ ctx[0]);
			}

			if (!current || dirty & /*height*/ 2) {
				attr(svg, "height", /*height*/ ctx[1]);
			}

			if (!current || dirty & /*width, height*/ 3 && svg_viewBox_value !== (svg_viewBox_value = "0 0 " + /*width*/ ctx[0] + "\n    " + /*height*/ ctx[1])) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svg);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$H($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { width = 24 } = $$props;
	let { height = 24 } = $$props;
	let { style = undefined } = $$props;
	let { class: klass = undefined } = $$props;

	$$self.$$set = $$props => {
		if ("width" in $$props) $$invalidate(0, width = $$props.width);
		if ("height" in $$props) $$invalidate(1, height = $$props.height);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
		if ("class" in $$props) $$invalidate(3, klass = $$props.class);
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	return [width, height, style, klass, $$scope, slots];
}

class Icon extends SvelteComponent {
	constructor(options) {
		super();
		init$3(this, options, instance$H, create_fragment$H, safe_not_equal, { width: 0, height: 1, style: 2, class: 3 });
	}
}

var isEventTarget = (e, element) => element === e.target || element.contains(e.target);

/* src/core/ui/components/Button.svelte generated by Svelte v3.37.0 */

function create_if_block_1$d(ctx) {
	let icon_1;
	let current;

	icon_1 = new Icon({
			props: {
				class: "PinturaButtonIcon",
				$$slots: { default: [create_default_slot$h] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(icon_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icon_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const icon_1_changes = {};

			if (dirty & /*$$scope, icon*/ 1048578) {
				icon_1_changes.$$scope = { dirty, ctx };
			}

			icon_1.$set(icon_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon_1, detaching);
		}
	};
}

// (40:16) <Icon class="PinturaButtonIcon">
function create_default_slot$h(ctx) {
	let g;

	return {
		c() {
			g = svg_element("g");
		},
		m(target, anchor) {
			insert(target, g, anchor);
			g.innerHTML = /*icon*/ ctx[1];
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 2) g.innerHTML = /*icon*/ ctx[1];		},
		d(detaching) {
			if (detaching) detach(g);
		}
	};
}

// (46:12) {#if label}
function create_if_block$c(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(/*label*/ ctx[0]);
			attr(span, "class", /*elLabelClass*/ ctx[11]);
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 1) set_data(t, /*label*/ ctx[0]);

			if (dirty & /*elLabelClass*/ 2048) {
				attr(span, "class", /*elLabelClass*/ ctx[11]);
			}
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (37:10)          
function fallback_block$2(ctx) {
	let span;
	let t;
	let current;
	let if_block0 = /*icon*/ ctx[1] && create_if_block_1$d(ctx);
	let if_block1 = /*label*/ ctx[0] && create_if_block$c(ctx);

	return {
		c() {
			span = element("span");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr(span, "class", /*elButtonInnerClass*/ ctx[9]);
		},
		m(target, anchor) {
			insert(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append(span, t);
			if (if_block1) if_block1.m(span, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*icon*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$d(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(span, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*label*/ ctx[0]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$c(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || dirty & /*elButtonInnerClass*/ 512) {
				attr(span, "class", /*elButtonInnerClass*/ ctx[9]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

function create_fragment$G(ctx) {
	let button;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);
	const default_slot_or_fallback = default_slot || fallback_block$2(ctx);

	return {
		c() {
			button = element("button");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			attr(button, "type", /*type*/ ctx[4]);
			attr(button, "style", /*style*/ ctx[2]);
			button.disabled = /*disabled*/ ctx[3];
			attr(button, "class", /*elButtonClass*/ ctx[10]);
			attr(button, "title", /*label*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(button, null);
			}

			/*button_binding*/ ctx[19](button);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button, "keydown", function () {
						if (is_function(/*onkeydown*/ ctx[6])) /*onkeydown*/ ctx[6].apply(this, arguments);
					}),
					listen(button, "click", function () {
						if (is_function(/*onclick*/ ctx[5])) /*onclick*/ ctx[5].apply(this, arguments);
					}),
					action_destroyer(/*action*/ ctx[7].call(null, button))
				];

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[20], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*elButtonInnerClass, elLabelClass, label, icon*/ 2563) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*type*/ 16) {
				attr(button, "type", /*type*/ ctx[4]);
			}

			if (!current || dirty & /*style*/ 4) {
				attr(button, "style", /*style*/ ctx[2]);
			}

			if (!current || dirty & /*disabled*/ 8) {
				button.disabled = /*disabled*/ ctx[3];
			}

			if (!current || dirty & /*elButtonClass*/ 1024) {
				attr(button, "class", /*elButtonClass*/ ctx[10]);
			}

			if (!current || dirty & /*label*/ 1) {
				attr(button, "title", /*label*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(button);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			/*button_binding*/ ctx[19](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$G($$self, $$props, $$invalidate) {
	let elButtonInnerClass;
	let elButtonClass;
	let elLabelClass;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: klass = undefined } = $$props;
	let { label = undefined } = $$props;
	let { labelClass = undefined } = $$props;
	let { innerClass = undefined } = $$props;
	let { hideLabel = false } = $$props;
	let { icon = undefined } = $$props;
	let { style = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { type = "button" } = $$props;
	let { onclick = undefined } = $$props;
	let { onkeydown = undefined } = $$props;

	let { action = () => {
		
	} } = $$props;

	let root;
	const isEventTarget$1 = e => isEventTarget(e, root);
	const getElement = () => root;

	function button_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			root = $$value;
			$$invalidate(8, root);
		});
	}

	$$self.$$set = $$props => {
		if ("class" in $$props) $$invalidate(12, klass = $$props.class);
		if ("label" in $$props) $$invalidate(0, label = $$props.label);
		if ("labelClass" in $$props) $$invalidate(13, labelClass = $$props.labelClass);
		if ("innerClass" in $$props) $$invalidate(14, innerClass = $$props.innerClass);
		if ("hideLabel" in $$props) $$invalidate(15, hideLabel = $$props.hideLabel);
		if ("icon" in $$props) $$invalidate(1, icon = $$props.icon);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ("type" in $$props) $$invalidate(4, type = $$props.type);
		if ("onclick" in $$props) $$invalidate(5, onclick = $$props.onclick);
		if ("onkeydown" in $$props) $$invalidate(6, onkeydown = $$props.onkeydown);
		if ("action" in $$props) $$invalidate(7, action = $$props.action);
		if ("$$scope" in $$props) $$invalidate(20, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*innerClass*/ 16384) {
			$$invalidate(9, elButtonInnerClass = arrayJoin(["PinturaButtonInner", innerClass]));
		}

		if ($$self.$$.dirty & /*hideLabel, klass*/ 36864) {
			$$invalidate(10, elButtonClass = arrayJoin(["PinturaButton", hideLabel && "PinturaButtonIconOnly", klass]));
		}

		if ($$self.$$.dirty & /*hideLabel, labelClass*/ 40960) {
			$$invalidate(11, elLabelClass = arrayJoin([hideLabel ? "implicit" : "PinturaButtonLabel", labelClass]));
		}
	};

	return [
		label,
		icon,
		style,
		disabled,
		type,
		onclick,
		onkeydown,
		action,
		root,
		elButtonInnerClass,
		elButtonClass,
		elLabelClass,
		klass,
		labelClass,
		innerClass,
		hideLabel,
		isEventTarget$1,
		getElement,
		slots,
		button_binding,
		$$scope
	];
}

class Button extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$G, create_fragment$G, safe_not_equal, {
			class: 12,
			label: 0,
			labelClass: 13,
			innerClass: 14,
			hideLabel: 15,
			icon: 1,
			style: 2,
			disabled: 3,
			type: 4,
			onclick: 5,
			onkeydown: 6,
			action: 7,
			isEventTarget: 16,
			getElement: 17
		});
	}

	get isEventTarget() {
		return this.$$.ctx[16];
	}

	get getElement() {
		return this.$$.ctx[17];
	}
}

var arrayRemove = (array, predicate) => {
    const index = array.findIndex(predicate);
    if (index >= 0)
        return array.splice(index, 1);
    return undefined;
};

// svelte
// constants
const INERTIA_THRESHOLD = 0.25; // when force of velocity exceeds this value we drift
const INERTIA_DISTANCE_MULTIPLIER = 50;
const INERTIA_DURATION_MULTIPLIER = 80;
const TAP_DURATION_MAX = 300;
const TAP_DISTANCE_MAX = 64;
const DOUBLE_TAP_DURATION_MAX = 700;
const DOUBLE_TAP_DISTANCE_MAX = 128;
const isContextMenuAction = (e) => isNumber$1(e.button) && e.button !== 0;
var interactable = (node, options = {}) => {
    // set defaults
    const { inertia = false, matchTarget = false, pinch = false, getEventPosition = (e) => vectorCreate(e.clientX, e.clientY), } = options;
    //
    // helpers
    //
    function dispatch(type, detail) {
        node.dispatchEvent(new CustomEvent(type, { detail }));
    }
    function resetInertia() {
        if (inertiaTweenUnsubscribe)
            inertiaTweenUnsubscribe();
        inertiaTweenUnsubscribe = undefined;
    }
    //#region pointer registry
    const pointers = [];
    const addPointer = (e) => {
        const pointer = {
            timeStamp: e.timeStamp,
            timeStampInitial: e.timeStamp,
            position: getEventPosition(e),
            origin: getEventPosition(e),
            velocity: vectorCreateEmpty(),
            translation: vectorCreateEmpty(),
            interactionState: undefined,
            event: e,
        };
        pointers.push(pointer);
        pointer.interactionState = getInteractionState(pointers);
    };
    const removePointer = (e) => {
        const pointer = arrayRemove(pointers, (pointer) => pointer.event.pointerId === e.pointerId);
        if (pointer)
            return pointer[0];
    };
    const getPointerIndex = (e) => pointers.findIndex((pointer) => pointer.event.pointerId === e.pointerId);
    const flattenPointerOrigin = (pointer) => {
        pointer.origin.x = pointer.position.x;
        pointer.origin.y = pointer.position.y;
        pointer.translation.x = 0;
        pointer.translation.y = 0;
    };
    const updatePointer = (e) => {
        const pointer = getPointer(e);
        if (!pointer)
            return;
        const { timeStamp } = e;
        // position
        const eventPosition = getEventPosition(e);
        // duration between previous interaction and new interaction, an interaction duration cannot be faster than 1 millisecond
        const interactionDuration = Math.max(1, timeStamp - pointer.timeStamp);
        // calculate velocity
        pointer.velocity.x = (eventPosition.x - pointer.position.x) / interactionDuration;
        pointer.velocity.y = (eventPosition.y - pointer.position.y) / interactionDuration;
        // update the translation
        pointer.translation.x = eventPosition.x - pointer.origin.x;
        pointer.translation.y = eventPosition.y - pointer.origin.y;
        // set new state
        pointer.timeStamp = timeStamp;
        pointer.position.x = eventPosition.x;
        pointer.position.y = eventPosition.y;
        pointer.event = e;
    };
    const getPointer = (e) => {
        const i = getPointerIndex(e);
        if (i < 0)
            return;
        return pointers[i];
    };
    const isSingleTouching = () => pointers.length === 1;
    const isMultiTouching = () => pointers.length === 2;
    const getDistance = (pointers, position) => {
        const distanceTotal = pointers.reduce((prev, curr) => {
            prev += vectorDistance(position, curr.position);
            return prev;
        }, 0);
        return distanceTotal / pointers.length;
    };
    const getInteractionState = (pointers) => {
        const center = vectorCenter(pointers.map((pointer) => pointer.position));
        const distance = getDistance(pointers, center);
        return {
            center,
            distance,
            velocity: vectorCenter(pointers.map((pointer) => pointer.velocity)),
            translation: vectorCenter(pointers.map((pointer) => pointer.translation)),
        };
    };
    //#endregion
    let inertiaTween;
    let inertiaTweenUnsubscribe;
    let pinchOffsetDistance;
    let currentTranslation;
    let currentScale;
    let isGesture;
    let lastTapTimeStamp = 0;
    let lastTapPosition = undefined;
    // start handling interactions
    node.addEventListener('pointerdown', handlePointerdown);
    function handlePointerdown(e) {
        // ignore more than two pointers for now
        if (isMultiTouching())
            return;
        // not interested in context menu
        if (isContextMenuAction(e))
            return;
        // target should equal node, if it doesn't user might have clicked one of the nodes children
        if (matchTarget && e.target !== node)
            return;
        // stop any previous inertia tweens
        resetInertia();
        // register this pointer
        addPointer(e);
        // if is first pointer we need to init the drag gesture
        if (isSingleTouching()) {
            // handle pointer events
            document.documentElement.addEventListener('pointermove', handlePointermove);
            document.documentElement.addEventListener('pointerup', handlePointerup);
            document.documentElement.addEventListener('pointercancel', handlePointerup);
            // clear vars
            isGesture = false;
            currentScale = 1;
            currentTranslation = vectorCreateEmpty();
            pinchOffsetDistance = undefined;
            dispatch('interactionstart', {
                origin: vectorClone(getPointer(e).origin),
            });
        }
        else if (pinch) {
            isGesture = true;
            pinchOffsetDistance = vectorDistance(pointers[0].position, pointers[1].position);
            currentTranslation.x += pointers[0].translation.x;
            currentTranslation.y += pointers[0].translation.y;
            flattenPointerOrigin(pointers[0]);
        }
    }
    //
    // pointer move can only be a primary event (other pointers are not handled)
    //
    let moveLast = Date.now();
    function handlePointermove(e) {
        // prevent selection of text (Safari)
        e.preventDefault();
        // update pointer state
        updatePointer(e);
        let translation = vectorClone(pointers[0].translation);
        let scalar = currentScale;
        if (pinch && isMultiTouching()) {
            // current pinch distance
            const pinchCurrentDistance = vectorDistance(pointers[0].position, pointers[1].position);
            // to find out scalar we calculate the difference between the pinch offset and the new pinch
            const pinchScalar = pinchCurrentDistance / pinchOffsetDistance;
            // add to existing scalar
            scalar *= pinchScalar;
            // current offset
            vectorAdd(translation, pointers[1].translation);
            // multiply original by scalar
            // vectorMultiply(translation, 0.5 * (1 / scalar));
        }
        translation.x += currentTranslation.x;
        translation.y += currentTranslation.y;
        // skip update event if last interaction was less than 16 ms ago
        const now = Date.now();
        const dist = now - moveLast;
        if (dist < 16)
            return;
        moveLast = now;
        dispatch('interactionupdate', {
            translation,
            scalar: pinch ? scalar : undefined,
        });
    }
    //
    // pointer up can only be a primary event (other pointers are not handled)
    //
    function handlePointerup(e) {
        // test if is my pointer that was released, as we're listining on document it could be other pointers
        if (!getPointer(e))
            return;
        // remove pointer from active pointers array
        const removedPointer = removePointer(e);
        // store current size
        if (pinch && isSingleTouching()) {
            // calculate current scale
            const pinchCurrentDistance = vectorDistance(pointers[0].position, removedPointer.position);
            currentScale *= pinchCurrentDistance / pinchOffsetDistance;
            currentTranslation.x += pointers[0].translation.x + removedPointer.translation.x;
            currentTranslation.y += pointers[0].translation.y + removedPointer.translation.y;
            flattenPointerOrigin(pointers[0]);
        }
        // check if this was a tap
        let isTap = false;
        let isDoubleTap = false;
        if (!isGesture && removedPointer) {
            const interactionEnd = performance.now();
            const interactionDuration = interactionEnd - removedPointer.timeStampInitial;
            const interactionDistanceSquared = vectorDistanceSquared(removedPointer.translation);
            isTap =
                interactionDistanceSquared < TAP_DISTANCE_MAX &&
                    interactionDuration < TAP_DURATION_MAX;
            isDoubleTap = !!(lastTapPosition &&
                isTap &&
                interactionEnd - lastTapTimeStamp < DOUBLE_TAP_DURATION_MAX &&
                vectorDistanceSquared(lastTapPosition, removedPointer.position) <
                    DOUBLE_TAP_DISTANCE_MAX);
            if (isTap) {
                lastTapPosition = vectorClone(removedPointer.position);
                lastTapTimeStamp = interactionEnd;
            }
        }
        // we wait till last multi-touch interaction is finished, all pointers need to be de-registered before proceeding
        if (pointers.length > 0)
            return;
        // stop listening
        document.documentElement.removeEventListener('pointermove', handlePointermove);
        document.documentElement.removeEventListener('pointerup', handlePointerup);
        document.documentElement.removeEventListener('pointercancel', handlePointerup);
        const translation = vectorClone(removedPointer.translation);
        const velocity = vectorClone(removedPointer.velocity);
        // allows cancelling inertia from release handler
        let inertiaPrevented = false;
        // user has released interaction
        dispatch('interactionrelease', {
            isTap,
            isDoubleTap,
            translation,
            scalar: currentScale,
            preventInertia: () => (inertiaPrevented = true),
        });
        // stop intantly if not a lot of force applied
        const force = vectorDistance(velocity);
        if (inertiaPrevented || !inertia || force < INERTIA_THRESHOLD) {
            return handleEnd(translation, { isTap, isDoubleTap });
        }
        // drift
        inertiaTween = tweened(vectorClone(translation), {
            easing: circOut,
            duration: force * INERTIA_DURATION_MULTIPLIER,
        });
        inertiaTween
            .set({
            x: translation.x + velocity.x * INERTIA_DISTANCE_MULTIPLIER,
            y: translation.y + velocity.y * INERTIA_DISTANCE_MULTIPLIER,
        })
            .then(() => {
            // if has unsubscribed (tween was reset)
            if (!inertiaTweenUnsubscribe)
                return;
            // go!
            handleEnd(get_store_value(inertiaTween), { isTap, isDoubleTap });
        });
        inertiaTweenUnsubscribe = inertiaTween.subscribe(handleInertiaUpdate);
    }
    function handleInertiaUpdate(inertiaTranslation) {
        // if is same as previous position, ignore
        if (!inertiaTranslation)
            return; // || vectorEqual(inertiaTranslation, translation)) return;
        // this will handle drift interactions
        dispatch('interactionupdate', {
            translation: inertiaTranslation,
            scalar: pinch ? currentScale : undefined,
        });
    }
    function handleEnd(translation, tapState) {
        resetInertia();
        dispatch('interactionend', {
            ...tapState,
            translation,
            scalar: pinch ? currentScale : undefined,
        });
    }
    return {
        destroy() {
            resetInertia();
            node.removeEventListener('pointerdown', handlePointerdown);
        },
    };
};

var nudgeable = (element, options = {}) => {
    // if added as action on non focusable element you should add tabindex=0 attribute
    const { direction = undefined, shiftMultiplier = 10, bubbles = false, stopKeydownPropagation = true, } = options;
    const isHorizontalDirection = direction === 'horizontal';
    const isVerticalDirection = direction === 'vertical';
    const handleKeydown = (e) => {
        const { key } = e;
        const isShift = e.shiftKey;
        const isHorizontalAction = /up|down/i.test(key);
        const isVerticalAction = /left|right/i.test(key);
        // no directional key
        if (!isHorizontalAction && !isVerticalAction)
            return;
        // is horizontal but up or down pressed
        if (isHorizontalDirection && isVerticalAction)
            return;
        // is vertical but left or right pressed
        if (isVerticalDirection && isHorizontalAction)
            return;
        // if holding shift move by a factor 10
        const multiplier = isShift ? shiftMultiplier : 1;
        if (stopKeydownPropagation)
            e.stopPropagation();
        element.dispatchEvent(new CustomEvent('nudge', {
            bubbles,
            detail: vectorCreate((/left/i.test(key) ? -1 : /right/i.test(key) ? 1 : 0) * multiplier, (/up/i.test(key) ? -1 : /down/i.test(key) ? 1 : 0) * multiplier),
        }));
    };
    element.addEventListener('keydown', handleKeydown);
    return {
        destroy() {
            element.removeEventListener('keydown', handleKeydown);
        },
    };
};

function elastify(translation, dist) {
    return dist * Math.sign(translation) * Math.log10(1 + Math.abs(translation) / dist);
}
const elastifyRects = (a, b, dist) => {
    if (!b)
        return rectClone(a);
    const left = a.x + elastify(b.x - a.x, dist);
    const right = a.x + a.width + elastify(b.x + b.width - (a.x + a.width), dist);
    const top = a.y + elastify(b.y - a.y, dist);
    const bottom = a.y + a.height + elastify(b.y + b.height - (a.y + a.height), dist);
    return {
        x: left,
        y: top,
        width: right - left,
        height: bottom - top,
    };
};

var unitToPixels = (value, element) => {
    if (!value)
        return;
    if (/em/.test(value))
        return parseInt(value, 10) * 16;
    if (/px/.test(value))
        return parseInt(value, 10);
};

var getWheelDelta = (e) => {
    let d = e.detail || 0;
    // @ts-ignore
    const { deltaX, deltaY, wheelDelta, wheelDeltaX, wheelDeltaY } = e;
    // "detect" x axis interaction for MacOS trackpad
    if (isNumber$1(wheelDeltaX) && Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY)) {
        // blink & webkit
        d = wheelDeltaX / -120;
    }
    else if (isNumber$1(deltaX) && Math.abs(deltaX) > Math.abs(deltaY)) {
        // quantum
        d = deltaX / 20;
    }
    // @ts-ignore
    else if (wheelDelta || wheelDeltaY) {
        // blink & webkit
        d = (wheelDelta || wheelDeltaY) / -120;
    }
    if (!d) {
        // quantum
        d = deltaY / 20;
    }
    return d;
};

/* src/core/ui/components/Scrollable.svelte generated by Svelte v3.37.0 */

function create_fragment$F(ctx) {
	let div1;
	let div0;
	let div1_class_value;
	let nudgeable_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[37].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[36], null);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr(div0, "style", /*childStyle*/ ctx[6]);
			attr(div1, "class", div1_class_value = arrayJoin(["PinturaScrollable", /*klass*/ ctx[0]]));
			attr(div1, "style", /*overflowStyle*/ ctx[4]);
			attr(div1, "data-direction", /*scrollDirection*/ ctx[1]);
			attr(div1, "data-state", /*containerState*/ ctx[5]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div1_binding*/ ctx[39](div1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "interactionstart", /*handleDragStart*/ ctx[9]),
					listen(div0, "interactionupdate", /*handleDragMove*/ ctx[11]),
					listen(div0, "interactionend", /*handleDragEnd*/ ctx[12]),
					listen(div0, "interactionrelease", /*handleDragRelease*/ ctx[10]),
					action_destroyer(interactable.call(null, div0, { inertia: true })),
					listen(div0, "measure", /*measure_handler*/ ctx[38]),
					action_destroyer(measurable.call(null, div0)),
					listen(div1, "wheel", /*handleWheel*/ ctx[14], { passive: false }),
					listen(div1, "scroll", /*handleScroll*/ ctx[16]),
					listen(div1, "focusin", /*handleFocus*/ ctx[15]),
					listen(div1, "nudge", /*handleNudge*/ ctx[17]),
					listen(div1, "measure", /*handleResizeScrollContainer*/ ctx[13]),
					action_destroyer(measurable.call(null, div1, { observePosition: true })),
					action_destroyer(nudgeable_action = nudgeable.call(null, div1, {
						direction: /*scrollDirection*/ ctx[1] === "x"
						? "horizontal"
						: "vertical",
						stopKeydownPropagation: false
					}))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[36], dirty, null, null);
				}
			}

			if (!current || dirty[0] & /*childStyle*/ 64) {
				attr(div0, "style", /*childStyle*/ ctx[6]);
			}

			if (!current || dirty[0] & /*klass*/ 1 && div1_class_value !== (div1_class_value = arrayJoin(["PinturaScrollable", /*klass*/ ctx[0]]))) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty[0] & /*overflowStyle*/ 16) {
				attr(div1, "style", /*overflowStyle*/ ctx[4]);
			}

			if (!current || dirty[0] & /*scrollDirection*/ 2) {
				attr(div1, "data-direction", /*scrollDirection*/ ctx[1]);
			}

			if (!current || dirty[0] & /*containerState*/ 32) {
				attr(div1, "data-state", /*containerState*/ ctx[5]);
			}

			if (nudgeable_action && is_function(nudgeable_action.update) && dirty[0] & /*scrollDirection*/ 2) nudgeable_action.update.call(null, {
				direction: /*scrollDirection*/ ctx[1] === "x"
				? "horizontal"
				: "vertical",
				stopKeydownPropagation: false
			});
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
			/*div1_binding*/ ctx[39](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$F($$self, $$props, $$invalidate) {
	let size;
	let axis;
	let containerStyle;
	let containerFeatherSize;
	let overflows;
	let containerState;
	let childStyle;
	let $scrollOffset;
	let $keysPressedStore;
	let { $$slots: slots = {}, $$scope } = $$props;
	const dispatch = createEventDispatcher();
	const keysPressedStore = getContext("keysPressed");
	component_subscribe($$self, keysPressedStore, value => $$invalidate(46, $keysPressedStore = value));
	let scrollState = "idle";
	let scrollOrigin;
	let scrollRect;
	let scrollContainerRect;
	let scrollReleased;
	let scrollOffset = spring$2(0);
	component_subscribe($$self, scrollOffset, value => $$invalidate(34, $scrollOffset = value));
	let { class: klass = undefined } = $$props;
	let { scrollBlockInteractionDist = 5 } = $$props;
	let { scrollStep = 10 } = $$props; // the distance multiplier for each mouse scroll interaction (delta)
	let { scrollFocusMargin = 64 } = $$props; // the margin used around elements to decided where to move the focus so elements are positioned into view with some spacing around them, this allows peaking at next/previous elements
	let { scrollDirection = "x" } = $$props;
	let { scrollAutoCancel = false } = $$props;
	let { elasticity = 0 } = $$props;
	let { onscroll = noop$1 } = $$props;
	let { maskFeatherSize = undefined } = $$props;
	let { maskFeatherStartOpacity = undefined } = $$props;
	let { maskFeatherEndOpacity = undefined } = $$props;
	let { scroll = undefined } = $$props;

	// logic
	let container;

	let overflowStyle = "";

	// is scroll in reset state
	let scrollAtRest = true;

	// triggers onscroll callback
	scrollOffset.subscribe(value => {
		const pos = vectorCreateEmpty();
		pos[scrollDirection] = value;
		onscroll(pos);
	});

	const limitOffsetToContainer = offset => Math.max(Math.min(0, offset), scrollContainerRect[size] - scrollRect[size]);
	let scrollFirstMove;
	let scrollCancelled;
	let scrollTranslationPrev;

	const isHorizontalTranslation = translation => {
		const velocity = vectorApply(vectorCreate(translation.x - scrollTranslationPrev.x, translation.y - scrollTranslationPrev.y), Math.abs);
		scrollTranslationPrev = vectorClone(translation);
		const speed = vectorDistanceSquared(velocity);
		const diff = velocity.x - velocity.y;
		return !(speed > 1 && diff < -0.5);
	};

	const handleDragStart = () => {
		// not overflowing so no need to handle
		if (!overflows) return;

		scrollCancelled = false;
		scrollFirstMove = true;
		scrollTranslationPrev = vectorCreate(0, 0);
		scrollReleased = false;
		$$invalidate(28, scrollState = "idle");
		scrollOrigin = get_store_value(scrollOffset);
	};

	const handleDragRelease = ({ detail }) => {
		if (!overflows) return;
		scrollReleased = true;
		$$invalidate(28, scrollState = "idle");
	};

	const handleDragMove = ({ detail }) => {
		if (!overflows) return;
		if (scrollCancelled) return;

		// fixes problem with single move event fired when clicking
		if (scrollFirstMove) {
			scrollFirstMove = false;
			if (vectorDistanceSquared(detail.translation) < 0.1) return;
		}

		if (scrollAutoCancel && scrollDirection === "x" && !isHorizontalTranslation(detail.translation)) {
			scrollCancelled = true;
			return;
		}

		setScrollOffset(scrollOrigin + detail.translation[scrollDirection], { elastic: true });
	};

	const handleDragEnd = ({ detail }) => {
		if (!overflows) return;
		if (scrollCancelled) return;
		const offset = scrollOrigin + detail.translation[scrollDirection];
		const offsetLimited = limitOffsetToContainer(offset);
		scrollAtRest = false;

		scrollOffset.set(offsetLimited).then(res => {
			if (!scrollReleased) return;
			scrollAtRest = true;
		});
	};

	const handleResizeScrollContainer = ({ detail }) => {
		$$invalidate(29, scrollContainerRect = detail);

		dispatch("measure", {
			x: detail.x,
			y: detail.y,
			width: detail.width,
			height: detail.height
		});
	};

	const setScrollOffset = (offset, options = {}) => {
		const { elastic = false, animate = false } = options;

		// prevents clicks on child elements if the container is being scrolled
		if (Math.abs(offset) > scrollBlockInteractionDist && scrollState === "idle" && !scrollReleased) {
			$$invalidate(28, scrollState = "scrolling");
		}

		const offsetLimited = limitOffsetToContainer(offset);

		const offsetVisual = elastic && elasticity && !scrollReleased
		? offsetLimited + elastify(offset - offsetLimited, elasticity)
		: offsetLimited;

		let snapToPosition = true;

		if (animate) {
			snapToPosition = false;
		} else if (!scrollAtRest) {
			snapToPosition = !scrollReleased;
		}

		scrollAtRest = false;

		scrollOffset.set(offsetVisual, { hard: snapToPosition }).then(res => {
			if (!scrollReleased) return;
			scrollAtRest = true;
		});
	};

	const handleWheel = e => {
		// don't do anything if isn't overflowing
		if (!overflows) return;

		// scroll down -> move to right/down
		// scroll up -> move to left/up
		// don't run default actions, prevent other actions from running
		e.preventDefault();

		e.stopPropagation();

		// apply wheel delta to offset
		const delta = getWheelDelta(e);

		const offset = get_store_value(scrollOffset);
		setScrollOffset(offset + delta * scrollStep, { animate: true });
	};

	const handleFocus = e => {
		// don't do anything if isn't overflowing
		if (!overflows) return;

		// ignore this handler if is dragging
		if (!scrollReleased && !$keysPressedStore.length) return;

		let target = e.target;

		// when a target is marked as implicit we use its parent elemetn
		if (e.target.classList.contains("implicit")) target = target.parentNode;

		// get bounds
		const start = target[scrollDirection === "x" ? "offsetLeft" : "offsetTop"]; //.offsetLeft;

		const space = target[scrollDirection === "x" ? "offsetWidth" : "offsetHeight"]; //.offsetWidth;
		const end = start + space;

		// we need to know the current offset of the scroll so we can determine if the target is in view
		const currentScrollOffset = get_store_value(scrollOffset);

		// the margin around elements to keep in mind when focussing items
		const margin = scrollFocusMargin + maskFeatherSize;

		if (currentScrollOffset + start < margin) {
			setScrollOffset(-start + margin);
		} else if (currentScrollOffset + end > scrollContainerRect[size] - margin) {
			setScrollOffset(scrollContainerRect[size] - end - margin, { animate: true });
		}
	};

	const handleScroll = () => {
		// the scroll handler corrects auto browser scroll, 
		// is triggered when browser tries to focus an 
		// element outside of the scrollcontiner
		$$invalidate(3, container[scrollDirection === "x" ? "scrollLeft" : "scrollTop"] = 0, container);
	};

	const handleNudge = ({ detail }) => {
		const delta = -2 * detail[scrollDirection];
		const offset = get_store_value(scrollOffset);
		setScrollOffset(offset + delta * scrollStep, { animate: true });
	};

	const measure_handler = e => $$invalidate(2, scrollRect = e.detail);

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(3, container);
		});
	}

	$$self.$$set = $$props => {
		if ("class" in $$props) $$invalidate(0, klass = $$props.class);
		if ("scrollBlockInteractionDist" in $$props) $$invalidate(21, scrollBlockInteractionDist = $$props.scrollBlockInteractionDist);
		if ("scrollStep" in $$props) $$invalidate(22, scrollStep = $$props.scrollStep);
		if ("scrollFocusMargin" in $$props) $$invalidate(23, scrollFocusMargin = $$props.scrollFocusMargin);
		if ("scrollDirection" in $$props) $$invalidate(1, scrollDirection = $$props.scrollDirection);
		if ("scrollAutoCancel" in $$props) $$invalidate(24, scrollAutoCancel = $$props.scrollAutoCancel);
		if ("elasticity" in $$props) $$invalidate(25, elasticity = $$props.elasticity);
		if ("onscroll" in $$props) $$invalidate(26, onscroll = $$props.onscroll);
		if ("maskFeatherSize" in $$props) $$invalidate(20, maskFeatherSize = $$props.maskFeatherSize);
		if ("maskFeatherStartOpacity" in $$props) $$invalidate(18, maskFeatherStartOpacity = $$props.maskFeatherStartOpacity);
		if ("maskFeatherEndOpacity" in $$props) $$invalidate(19, maskFeatherEndOpacity = $$props.maskFeatherEndOpacity);
		if ("scroll" in $$props) $$invalidate(27, scroll = $$props.scroll);
		if ("$$scope" in $$props) $$invalidate(36, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*scrollDirection*/ 2) {
			$$invalidate(30, size = scrollDirection === "x" ? "width" : "height");
		}

		if ($$self.$$.dirty[0] & /*scrollDirection*/ 2) {
			$$invalidate(31, axis = scrollDirection.toUpperCase());
		}

		if ($$self.$$.dirty[0] & /*container*/ 8) {
			$$invalidate(32, containerStyle = container && getComputedStyle(container));
		}

		if ($$self.$$.dirty[0] & /*container*/ 8 | $$self.$$.dirty[1] & /*containerStyle*/ 2) {
			$$invalidate(33, containerFeatherSize = containerStyle && unitToPixels(containerStyle.getPropertyValue("--scrollable-feather-size")));
		}

		if ($$self.$$.dirty[0] & /*scrollContainerRect, scrollRect, size, maskFeatherStartOpacity, maskFeatherEndOpacity*/ 1611399172 | $$self.$$.dirty[1] & /*$scrollOffset, containerFeatherSize*/ 12) {
			if ($scrollOffset != null && scrollContainerRect && containerFeatherSize != null && scrollRect) {
				const startOffset = -$scrollOffset / containerFeatherSize;
				const endOffset = -(scrollContainerRect[size] - scrollRect[size] - $scrollOffset) / containerFeatherSize;
				$$invalidate(18, maskFeatherStartOpacity = clamp(1 - startOffset, 0, 1));
				$$invalidate(19, maskFeatherEndOpacity = clamp(1 - endOffset, 0, 1));
				$$invalidate(20, maskFeatherSize = containerFeatherSize);
				$$invalidate(4, overflowStyle = `--scrollable-feather-start-opacity: ${maskFeatherStartOpacity};--scrollable-feather-end-opacity: ${maskFeatherEndOpacity}`);
			}
		}

		if ($$self.$$.dirty[0] & /*container, scroll*/ 134217736) {
			// update scroll position
			if (container && scroll !== undefined) {
				if (isNumber$1(scroll)) setScrollOffset(scroll); else setScrollOffset(scroll.scrollOffset, scroll);
			}
		}

		if ($$self.$$.dirty[0] & /*scrollContainerRect, scrollRect, size*/ 1610612740) {
			$$invalidate(35, overflows = scrollContainerRect && scrollRect
			? scrollRect[size] > scrollContainerRect[size]
			: undefined);
		}

		if ($$self.$$.dirty[0] & /*scrollState*/ 268435456 | $$self.$$.dirty[1] & /*overflows*/ 16) {
			$$invalidate(5, containerState = arrayJoin([scrollState, overflows ? "overflows" : undefined]));
		}

		if ($$self.$$.dirty[1] & /*overflows, axis, $scrollOffset*/ 25) {
			$$invalidate(6, childStyle = overflows
			? `transform: translate${axis}(${$scrollOffset}px)`
			: undefined);
		}
	};

	return [
		klass,
		scrollDirection,
		scrollRect,
		container,
		overflowStyle,
		containerState,
		childStyle,
		keysPressedStore,
		scrollOffset,
		handleDragStart,
		handleDragRelease,
		handleDragMove,
		handleDragEnd,
		handleResizeScrollContainer,
		handleWheel,
		handleFocus,
		handleScroll,
		handleNudge,
		maskFeatherStartOpacity,
		maskFeatherEndOpacity,
		maskFeatherSize,
		scrollBlockInteractionDist,
		scrollStep,
		scrollFocusMargin,
		scrollAutoCancel,
		elasticity,
		onscroll,
		scroll,
		scrollState,
		scrollContainerRect,
		size,
		axis,
		containerStyle,
		containerFeatherSize,
		$scrollOffset,
		overflows,
		$$scope,
		slots,
		measure_handler,
		div1_binding
	];
}

class Scrollable extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$F,
			create_fragment$F,
			safe_not_equal,
			{
				class: 0,
				scrollBlockInteractionDist: 21,
				scrollStep: 22,
				scrollFocusMargin: 23,
				scrollDirection: 1,
				scrollAutoCancel: 24,
				elasticity: 25,
				onscroll: 26,
				maskFeatherSize: 20,
				maskFeatherStartOpacity: 18,
				maskFeatherEndOpacity: 19,
				scroll: 27
			},
			[-1, -1]
		);
	}
}

function fade$1(node, { delay = 0, duration = 400, easing = identity } = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}

/* src/core/ui/components/StatusMessage.svelte generated by Svelte v3.37.0 */

function create_fragment$E(ctx) {
	let span;
	let t;
	let span_transition;
	let current;
	let mounted;
	let dispose;

	return {
		c() {
			span = element("span");
			t = text$1(/*text*/ ctx[0]);
			attr(span, "class", "PinturaStatusMessage");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
			current = true;

			if (!mounted) {
				dispose = [
					listen(span, "measure", function () {
						if (is_function(/*onmeasure*/ ctx[1])) /*onmeasure*/ ctx[1].apply(this, arguments);
					}),
					action_destroyer(measurable.call(null, span))
				];

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;
			if (!current || dirty & /*text*/ 1) set_data(t, /*text*/ ctx[0]);
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (!span_transition) span_transition = create_bidirectional_transition(span, fade$1, {}, true);
				span_transition.run(1);
			});

			current = true;
		},
		o(local) {
			if (!span_transition) span_transition = create_bidirectional_transition(span, fade$1, {}, false);
			span_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (detaching && span_transition) span_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$E($$self, $$props, $$invalidate) {
	let { text } = $$props;
	let { onmeasure = noop$1 } = $$props;

	$$self.$$set = $$props => {
		if ("text" in $$props) $$invalidate(0, text = $$props.text);
		if ("onmeasure" in $$props) $$invalidate(1, onmeasure = $$props.onmeasure);
	};

	return [text, onmeasure];
}

class StatusMessage extends SvelteComponent {
	constructor(options) {
		super();
		init$3(this, options, instance$E, create_fragment$E, safe_not_equal, { text: 0, onmeasure: 1 });
	}
}

/* src/core/ui/components/ProgressIndicator.svelte generated by Svelte v3.37.0 */

function create_fragment$D(ctx) {
	let span1;
	let svg;
	let g;
	let circle0;
	let circle1;
	let t0;
	let span0;
	let t1;

	return {
		c() {
			span1 = element("span");
			svg = svg_element("svg");
			g = svg_element("g");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			t0 = space();
			span0 = element("span");
			t1 = text$1(/*formattedValue*/ ctx[0]);
			attr(circle0, "class", "PinturaProgressIndicatorBar");
			attr(circle0, "r", "8.5");
			attr(circle0, "cx", "10");
			attr(circle0, "cy", "10");
			attr(circle0, "stroke-linecap", "round");
			attr(circle0, "opacity", ".25");
			attr(circle1, "class", "PinturaProgressIndicatorFill");
			attr(circle1, "r", "8.5");
			attr(circle1, "stroke-dasharray", /*circleValue*/ ctx[1]);
			attr(circle1, "cx", "10");
			attr(circle1, "cy", "10");
			attr(circle1, "transform", "rotate(-90) translate(-20)");
			attr(g, "fill", "none");
			attr(g, "stroke", "currentColor");
			attr(g, "stroke-width", "2.5");
			attr(g, "stroke-linecap", "round");
			attr(g, "opacity", /*circleOpacity*/ ctx[2]);
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "0 0 20 20");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "aria-hidden", "true");
			attr(svg, "focusable", "false");
			attr(span0, "class", "implicit");
			attr(span1, "class", "PinturaProgressIndicator");
			attr(span1, "data-status", /*status*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, span1, anchor);
			append(span1, svg);
			append(svg, g);
			append(g, circle0);
			append(g, circle1);
			append(span1, t0);
			append(span1, span0);
			append(span0, t1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*circleValue*/ 2) {
				attr(circle1, "stroke-dasharray", /*circleValue*/ ctx[1]);
			}

			if (dirty & /*circleOpacity*/ 4) {
				attr(g, "opacity", /*circleOpacity*/ ctx[2]);
			}

			if (dirty & /*formattedValue*/ 1) set_data(t1, /*formattedValue*/ ctx[0]);

			if (dirty & /*status*/ 8) {
				attr(span1, "data-status", /*status*/ ctx[3]);
			}
		},
		i: noop$2,
		o: noop$2,
		d(detaching) {
			if (detaching) detach(span1);
		}
	};
}

function instance$D($$self, $$props, $$invalidate) {
	let formattedValue;
	let circleValue;
	let circleOpacity;
	let status;
	let $animatedProgressClamped;
	const dispatch = createEventDispatcher();
	let { progress } = $$props;
	let { min = 0 } = $$props;
	let { max = 100 } = $$props;
	let { labelBusy = "Busy" } = $$props;
	const animatedValue = spring$2(0, { precision: 0.01 });
	const animatedProgressClamped = derived([animatedValue], $animatedValue => clamp($animatedValue, min, max));
	component_subscribe($$self, animatedProgressClamped, value => $$invalidate(9, $animatedProgressClamped = value));

	animatedProgressClamped.subscribe(value => {
		if (progress === 1 && Math.round(value) >= 100) dispatch("complete");
	});

	$$self.$$set = $$props => {
		if ("progress" in $$props) $$invalidate(5, progress = $$props.progress);
		if ("min" in $$props) $$invalidate(6, min = $$props.min);
		if ("max" in $$props) $$invalidate(7, max = $$props.max);
		if ("labelBusy" in $$props) $$invalidate(8, labelBusy = $$props.labelBusy);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*progress*/ 32) {
			progress && progress !== Infinity && animatedValue.set(progress * 100);
		}

		if ($$self.$$.dirty & /*progress, labelBusy, $animatedProgressClamped*/ 800) {
			$$invalidate(0, formattedValue = progress === Infinity
			? labelBusy
			: `${Math.round($animatedProgressClamped)}%`);
		}

		if ($$self.$$.dirty & /*progress, $animatedProgressClamped*/ 544) {
			$$invalidate(1, circleValue = progress === Infinity
			? "26.5 53"
			: `${$animatedProgressClamped / 100 * 53} 53`);
		}

		if ($$self.$$.dirty & /*progress, $animatedProgressClamped*/ 544) {
			$$invalidate(2, circleOpacity = Math.min(1, progress === Infinity
			? 1
			: $animatedProgressClamped / 10));
		}

		if ($$self.$$.dirty & /*progress*/ 32) {
			$$invalidate(3, status = progress === Infinity ? "busy" : "loading");
		}
	};

	return [
		formattedValue,
		circleValue,
		circleOpacity,
		status,
		animatedProgressClamped,
		progress,
		min,
		max,
		labelBusy,
		$animatedProgressClamped
	];
}

class ProgressIndicator extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$D, create_fragment$D, safe_not_equal, {
			progress: 5,
			min: 6,
			max: 7,
			labelBusy: 8
		});
	}
}

/* src/core/ui/components/StatusAside.svelte generated by Svelte v3.37.0 */

function create_fragment$C(ctx) {
	let span;
	let span_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	return {
		c() {
			span = element("span");
			if (default_slot) default_slot.c();
			attr(span, "class", span_class_value = `PinturaStatusAside ${/*klass*/ ctx[0]}`);
			attr(span, "style", /*style*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			if (!current || dirty & /*klass*/ 1 && span_class_value !== (span_class_value = `PinturaStatusAside ${/*klass*/ ctx[0]}`)) {
				attr(span, "class", span_class_value);
			}

			if (!current || dirty & /*style*/ 2) {
				attr(span, "style", /*style*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$C($$self, $$props, $$invalidate) {
	let style;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { offset = 0 } = $$props;
	let { opacity = 0 } = $$props;
	let { class: klass = undefined } = $$props;

	$$self.$$set = $$props => {
		if ("offset" in $$props) $$invalidate(2, offset = $$props.offset);
		if ("opacity" in $$props) $$invalidate(3, opacity = $$props.opacity);
		if ("class" in $$props) $$invalidate(0, klass = $$props.class);
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*offset, opacity*/ 12) {
			$$invalidate(1, style = `transform:translateX(${offset}px);opacity:${opacity}`);
		}
	};

	return [klass, style, offset, opacity, $$scope, slots];
}

class StatusAside extends SvelteComponent {
	constructor(options) {
		super();
		init$3(this, options, instance$C, create_fragment$C, safe_not_equal, { offset: 2, opacity: 3, class: 0 });
	}
}

/* src/core/ui/components/Tag.svelte generated by Svelte v3.37.0 */

function create_if_block_2$9(ctx) {
	let label;
	let label_for_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);
	let label_levels = [{ for: label_for_value = "_" }, /*attributes*/ ctx[1]];
	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	return {
		c() {
			label = element("label");
			if (default_slot) default_slot.c();
			set_attributes(label, label_data);
		},
		m(target, anchor) {
			insert(target, label, anchor);

			if (default_slot) {
				default_slot.m(label, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				{ for: label_for_value },
				dirty & /*attributes*/ 2 && /*attributes*/ ctx[1]
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (11:26) 
function create_if_block_1$c(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);
	let div_levels = [/*attributes*/ ctx[1]];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*attributes*/ 2 && /*attributes*/ ctx[1]]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (7:0) {#if name === 'div'}
function create_if_block$b(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);
	let div_levels = [/*attributes*/ ctx[1]];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*attributes*/ 2 && /*attributes*/ ctx[1]]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$B(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$b, create_if_block_1$c, create_if_block_2$9];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*name*/ ctx[0] === "div") return 0;
		if (/*name*/ ctx[0] === "span") return 1;
		if (/*name*/ ctx[0] === "label") return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty$1();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$B($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { name = "div" } = $$props;
	let { attributes = {} } = $$props;

	$$self.$$set = $$props => {
		if ("name" in $$props) $$invalidate(0, name = $$props.name);
		if ("attributes" in $$props) $$invalidate(1, attributes = $$props.attributes);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [name, attributes, $$scope, slots];
}

class Tag extends SvelteComponent {
	constructor(options) {
		super();
		init$3(this, options, instance$B, create_fragment$B, safe_not_equal, { name: 0, attributes: 1 });
	}
}

var getDevicePixelRatio = () => (isBrowser() && window$1.devicePixelRatio) || 1;

// if this is a non retina display snap to pixel
let fn = null;
var snapToPixel = (v) => {
    if (fn === null)
        fn = getDevicePixelRatio() === 1 ? (v) => Math.round(v) : (v) => v;
    return fn(v);
};

/* src/core/ui/components/Details.svelte generated by Svelte v3.37.0 */
const get_details_slot_changes = dirty => ({});
const get_details_slot_context = ctx => ({});
const get_label_slot_changes = dirty => ({});
const get_label_slot_context = ctx => ({});

// (162:0) <Button bind:this={buttonComponent}      class={arrayJoin(['PinturaDetailsButton', buttonClass])}      onkeydown={handleButtonKeydown}      onclick={handleClick}>
function create_default_slot$g(ctx) {
	let current;
	const label_slot_template = /*#slots*/ ctx[35].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[39], get_label_slot_context);

	return {
		c() {
			if (label_slot) label_slot.c();
		},
		m(target, anchor) {
			if (label_slot) {
				label_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (label_slot) {
				if (label_slot.p && dirty[1] & /*$$scope*/ 256) {
					update_slot(label_slot, label_slot_template, ctx, /*$$scope*/ ctx[39], dirty, get_label_slot_changes, get_label_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(label_slot, local);
			current = true;
		},
		o(local) {
			transition_out(label_slot, local);
			current = false;
		},
		d(detaching) {
			if (label_slot) label_slot.d(detaching);
		}
	};
}

// (169:0) {#if isVisible}
function create_if_block_1$b(ctx) {
	let div;
	let t;
	let span;
	let div_class_value;
	let current;
	let mounted;
	let dispose;
	const details_slot_template = /*#slots*/ ctx[35].details;
	const details_slot = create_slot(details_slot_template, ctx, /*$$scope*/ ctx[39], get_details_slot_context);

	return {
		c() {
			div = element("div");
			if (details_slot) details_slot.c();
			t = space();
			span = element("span");
			attr(span, "class", "PinturaDetailsPanelTip");
			attr(span, "style", /*tipStyle*/ ctx[7]);
			attr(div, "class", div_class_value = arrayJoin(["PinturaDetailsPanel", /*panelClass*/ ctx[1]]));
			attr(div, "tabindex", "-1");
			attr(div, "style", /*style*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (details_slot) {
				details_slot.m(div, null);
			}

			append(div, t);
			append(div, span);
			/*div_binding*/ ctx[37](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "keydown", /*handlePanelKeydown*/ ctx[17]),
					listen(div, "measure", /*measure_handler*/ ctx[38]),
					action_destroyer(measurable.call(null, div))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (details_slot) {
				if (details_slot.p && dirty[1] & /*$$scope*/ 256) {
					update_slot(details_slot, details_slot_template, ctx, /*$$scope*/ ctx[39], dirty, get_details_slot_changes, get_details_slot_context);
				}
			}

			if (!current || dirty[0] & /*tipStyle*/ 128) {
				attr(span, "style", /*tipStyle*/ ctx[7]);
			}

			if (!current || dirty[0] & /*panelClass*/ 2 && div_class_value !== (div_class_value = arrayJoin(["PinturaDetailsPanel", /*panelClass*/ ctx[1]]))) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty[0] & /*style*/ 64) {
				attr(div, "style", /*style*/ ctx[6]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(details_slot, local);
			current = true;
		},
		o(local) {
			transition_out(details_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (details_slot) details_slot.d(detaching);
			/*div_binding*/ ctx[37](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$A(ctx) {
	let t0;
	let button;
	let t1;
	let t2;
	let if_block1_anchor;
	let current;
	let mounted;
	let dispose;

	let button_props = {
		class: arrayJoin(["PinturaDetailsButton", /*buttonClass*/ ctx[0]]),
		onkeydown: /*handleButtonKeydown*/ ctx[16],
		onclick: /*handleClick*/ ctx[15],
		$$slots: { default: [create_default_slot$g] },
		$$scope: { ctx }
	};

	button = new Button({ props: button_props });
	/*button_binding*/ ctx[36](button);
	let if_block0 = /*isVisible*/ ctx[5] && create_if_block_1$b(ctx);
	let if_block1 = false ;

	return {
		c() {
			t0 = space();
			create_component(button.$$.fragment);
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if_block1_anchor = empty$1();
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			mount_component(button, target, anchor);
			insert(target, t1, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t2, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen(document.body, "pointerdown", function () {
						if (is_function(/*handleDown*/ ctx[8])) /*handleDown*/ ctx[8].apply(this, arguments);
					}),
					listen(document.body, "pointerup", function () {
						if (is_function(/*handleUp*/ ctx[9])) /*handleUp*/ ctx[9].apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};
			if (dirty[0] & /*buttonClass*/ 1) button_changes.class = arrayJoin(["PinturaDetailsButton", /*buttonClass*/ ctx[0]]);

			if (dirty[1] & /*$$scope*/ 256) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);

			if (/*isVisible*/ ctx[5]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*isVisible*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$b(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t2.parentNode, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t0);
			/*button_binding*/ ctx[36](null);
			destroy_component(button, detaching);
			if (detaching) detach(t1);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t2);
			if (detaching) detach(if_block1_anchor);
			mounted = false;
			run_all(dispose);
		}
	};
}

let panelMargin = 12;

function instance$A($$self, $$props, $$invalidate) {
	let buttonElement;
	let offsetProgress;
	let isVisible;
	let isAnimating;
	let transform;
	let style;
	let tipScale;
	let tipOpacity;
	let tipStyle;
	let handleDown;
	let handleUp;
	let $offset;
	let $portalRootRect;
	let $position;
	let $opacity;
	let $portal;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { buttonClass = undefined } = $$props;
	let { panelClass = undefined } = $$props;
	let { isActive = false } = $$props;
	let { onshow = ({ panel }) => panel.focus() } = $$props;
	const portal = getContext("rootPortal");
	component_subscribe($$self, portal, value => $$invalidate(34, $portal = value));
	const portalRootRect = getContext("rootRect");
	component_subscribe($$self, portalRootRect, value => $$invalidate(27, $portalRootRect = value));
	let panelSize;
	let buttonComponent;
	let buttonRect;
	let dir = vectorCreateEmpty();
	let opacity = spring$2(0);
	component_subscribe($$self, opacity, value => $$invalidate(29, $opacity = value));
	let shift = vectorCreateEmpty();
	const position = writable({ x: 0, y: 0 });
	component_subscribe($$self, position, value => $$invalidate(28, $position = value));

	const offset = spring$2(-5, {
		stiffness: 0.1,
		damping: 0.35,
		precision: 0.001
	});

	component_subscribe($$self, offset, value => $$invalidate(26, $offset = value));
	const isTargetSelf = e => isEventTarget(e, $portal) || buttonComponent.isEventTarget(e);
	let downOutsidePanel = false;

	// move detail panel to portal
	let detailPanel;

	let trigger;

	// test keydown press to open
	const handleClick = e => {
		if (!isActive) $$invalidate(20, buttonRect = buttonElement.getBoundingClientRect());
		$$invalidate(24, trigger = e);
		$$invalidate(18, isActive = !isActive);
	};

	const handleButtonKeydown = e => {
		if (!(/down/i).test(e.key)) return;
		$$invalidate(18, isActive = true);
		$$invalidate(24, trigger = e);
	};

	const handlePanelKeydown = e => {
		if (!(/esc/i).test(e.key)) return;
		$$invalidate(18, isActive = false);
		buttonElement.focus();
	};

	// clean up panel if it was appended to a portal
	onDestroy(() => {
		if (!$portal || !detailPanel || detailPanel.parentNode) return;
		$portal.removeChild(detailPanel);
	});

	function button_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			buttonComponent = $$value;
			$$invalidate(3, buttonComponent);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			detailPanel = $$value;
			$$invalidate(4, detailPanel);
		});
	}

	const measure_handler = e => $$invalidate(2, panelSize = sizeCreateFromAny(e.detail));

	$$self.$$set = $$props => {
		if ("buttonClass" in $$props) $$invalidate(0, buttonClass = $$props.buttonClass);
		if ("panelClass" in $$props) $$invalidate(1, panelClass = $$props.panelClass);
		if ("isActive" in $$props) $$invalidate(18, isActive = $$props.isActive);
		if ("onshow" in $$props) $$invalidate(19, onshow = $$props.onshow);
		if ("$$scope" in $$props) $$invalidate(39, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*buttonComponent*/ 8) {
			buttonElement = buttonComponent && buttonComponent.getElement();
		}

		if ($$self.$$.dirty[0] & /*isActive, downOutsidePanel*/ 8650752) {
			$$invalidate(9, handleUp = isActive
			? e => {
					if (!downOutsidePanel) return;
					$$invalidate(23, downOutsidePanel = false);
					if (isTargetSelf(e)) return;
					$$invalidate(18, isActive = false);
				}
			: undefined);
		}

		if ($$self.$$.dirty[0] & /*isActive*/ 262144) {
			opacity.set(isActive ? 1 : 0);
		}

		if ($$self.$$.dirty[0] & /*isActive*/ 262144) {
			offset.set(isActive ? 0 : -5);
		}

		if ($$self.$$.dirty[0] & /*$offset*/ 67108864) {
			$$invalidate(25, offsetProgress = 1 - $offset / -5);
		}

		if ($$self.$$.dirty[0] & /*$portalRootRect, panelSize, buttonRect*/ 135266308) {
			if ($portalRootRect && panelSize && buttonRect) {
				// as a starting point we'll align panel to center of button and position below
				let x = buttonRect.x - $portalRootRect.x + buttonRect.width * 0.5 - panelSize.width * 0.5;

				let y = buttonRect.y - $portalRootRect.y + buttonRect.height;
				const parentLeft = panelMargin;
				const parentTop = panelMargin;
				const parentRight = $portalRootRect.width - panelMargin;
				const parentBottom = $portalRootRect.height - panelMargin;
				const panelLeft = x;
				const panelTop = y;
				const panelRight = panelLeft + panelSize.width;
				const panelBottom = panelTop + panelSize.height;

				// move to right
				if (panelLeft < parentLeft) {
					$$invalidate(22, shift.x = panelLeft - parentLeft, shift);
					x = parentLeft;
				}

				// move to left
				if (panelRight > parentRight) {
					$$invalidate(22, shift.x = panelRight - parentRight, shift);
					x = parentRight - panelSize.width;
				}

				if (panelBottom > parentBottom) {
					// doesn't fit vertically, push up
					$$invalidate(21, dir.y = -1, dir);

					const positionedAboveButtonY = y - panelSize.height - buttonRect.height;
					const panelFitsAboveButton = parentTop < positionedAboveButtonY;

					if (panelFitsAboveButton) {
						$$invalidate(22, shift.y = 0, shift);
						y -= panelSize.height + buttonRect.height;
					} else {
						// overlap with button
						$$invalidate(22, shift.y = y - (panelBottom - parentBottom), shift);

						y -= panelBottom - parentBottom;
					}
				} else {
					// all is fine
					$$invalidate(21, dir.y = 1, dir);
				}

				set_store_value(position, $position = vectorApply(vectorCreate(x, y), snapToPixel), $position);
			}
		}

		if ($$self.$$.dirty[0] & /*$opacity*/ 536870912) {
			$$invalidate(5, isVisible = $opacity > 0);
		}

		if ($$self.$$.dirty[0] & /*$opacity*/ 536870912) {
			$$invalidate(30, isAnimating = $opacity < 1);
		}

		if ($$self.$$.dirty[0] & /*$position, dir, $offset*/ 337641472) {
			$$invalidate(31, transform = `translateX(${$position.x + dir.x * panelMargin}px) translateY(${$position.y + dir.y * panelMargin + dir.y * $offset}px)`);
		}

		if ($$self.$$.dirty[0] & /*isAnimating, $opacity*/ 1610612736 | $$self.$$.dirty[1] & /*transform*/ 1) {
			$$invalidate(6, style = isAnimating
			? `opacity: ${$opacity}; pointer-events: ${$opacity < 1 ? "none" : "all"}; transform: ${transform};`
			: `transform: ${transform}`);
		}

		if ($$self.$$.dirty[0] & /*offsetProgress*/ 33554432) {
			$$invalidate(32, tipScale = 0.5 + offsetProgress * 0.5);
		}

		if ($$self.$$.dirty[0] & /*offsetProgress*/ 33554432) {
			$$invalidate(33, tipOpacity = offsetProgress);
		}

		if ($$self.$$.dirty[0] & /*$position, panelSize, dir, shift*/ 274726916 | $$self.$$.dirty[1] & /*tipOpacity, tipScale*/ 6) {
			$$invalidate(7, tipStyle = $position && panelSize && `opacity:${tipOpacity};transform:scaleX(${tipScale})rotate(45deg);top:${dir.y < 0 ? shift.y + panelSize.height : 0}px;left:${shift.x + panelSize.width * 0.5}px`);
		}

		if ($$self.$$.dirty[0] & /*isActive*/ 262144) {
			$$invalidate(8, handleDown = isActive
			? e => {
					if (isTargetSelf(e)) return;
					$$invalidate(23, downOutsidePanel = true);
				}
			: undefined);
		}

		if ($$self.$$.dirty[0] & /*isVisible, detailPanel*/ 48 | $$self.$$.dirty[1] & /*$portal*/ 8) {
			if (isVisible && $portal && detailPanel && detailPanel.parentNode !== $portal) $portal.appendChild(detailPanel);
		}

		if ($$self.$$.dirty[0] & /*isActive*/ 262144) {
			if (!isActive) $$invalidate(24, trigger = undefined);
		}

		if ($$self.$$.dirty[0] & /*isVisible, detailPanel, onshow, trigger*/ 17301552) {
			if (isVisible && detailPanel) onshow({ e: trigger, panel: detailPanel });
		}
	};

	return [
		buttonClass,
		panelClass,
		panelSize,
		buttonComponent,
		detailPanel,
		isVisible,
		style,
		tipStyle,
		handleDown,
		handleUp,
		portal,
		portalRootRect,
		opacity,
		position,
		offset,
		handleClick,
		handleButtonKeydown,
		handlePanelKeydown,
		isActive,
		onshow,
		buttonRect,
		dir,
		shift,
		downOutsidePanel,
		trigger,
		offsetProgress,
		$offset,
		$portalRootRect,
		$position,
		$opacity,
		isAnimating,
		transform,
		tipScale,
		tipOpacity,
		$portal,
		slots,
		button_binding,
		div_binding,
		measure_handler,
		$$scope
	];
}

class Details extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$A,
			create_fragment$A,
			safe_not_equal,
			{
				buttonClass: 0,
				panelClass: 1,
				isActive: 18,
				onshow: 19
			},
			[-1, -1]
		);
	}
}

/* src/core/ui/components/RadioItem.svelte generated by Svelte v3.37.0 */

function create_fragment$z(ctx) {
	let li;
	let input;
	let t;
	let label_1;
	let li_class_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	return {
		c() {
			li = element("li");
			input = element("input");
			t = space();
			label_1 = element("label");
			if (default_slot) default_slot.c();
			attr(input, "type", "radio");
			attr(input, "class", "implicit");
			attr(input, "id", /*inputId*/ ctx[6]);
			attr(input, "name", /*name*/ ctx[0]);
			input.value = /*value*/ ctx[3];
			input.disabled = /*disabled*/ ctx[5];
			input.checked = /*checked*/ ctx[4];
			attr(label_1, "for", /*inputId*/ ctx[6]);
			attr(label_1, "title", /*label*/ ctx[2]);
			attr(li, "class", li_class_value = arrayJoin(["PinturaRadioGroupOption", /*klass*/ ctx[1]]));
			attr(li, "data-disabled", /*disabled*/ ctx[5]);
			attr(li, "data-selected", /*checked*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, input);
			append(li, t);
			append(li, label_1);

			if (default_slot) {
				default_slot.m(label_1, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "change", stop_propagation(/*change_handler*/ ctx[15])),
					listen(input, "keydown", /*handleKeydown*/ ctx[8]),
					listen(input, "click", /*handleClick*/ ctx[9])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*inputId*/ 64) {
				attr(input, "id", /*inputId*/ ctx[6]);
			}

			if (!current || dirty & /*name*/ 1) {
				attr(input, "name", /*name*/ ctx[0]);
			}

			if (!current || dirty & /*value*/ 8) {
				input.value = /*value*/ ctx[3];
			}

			if (!current || dirty & /*disabled*/ 32) {
				input.disabled = /*disabled*/ ctx[5];
			}

			if (!current || dirty & /*checked*/ 16) {
				input.checked = /*checked*/ ctx[4];
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8192) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[13], dirty, null, null);
				}
			}

			if (!current || dirty & /*inputId*/ 64) {
				attr(label_1, "for", /*inputId*/ ctx[6]);
			}

			if (!current || dirty & /*label*/ 4) {
				attr(label_1, "title", /*label*/ ctx[2]);
			}

			if (!current || dirty & /*klass*/ 2 && li_class_value !== (li_class_value = arrayJoin(["PinturaRadioGroupOption", /*klass*/ ctx[1]]))) {
				attr(li, "class", li_class_value);
			}

			if (!current || dirty & /*disabled*/ 32) {
				attr(li, "data-disabled", /*disabled*/ ctx[5]);
			}

			if (!current || dirty & /*checked*/ 16) {
				attr(li, "data-selected", /*checked*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$z($$self, $$props, $$invalidate) {
	let inputId;
	let $keysPressedStored;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { name } = $$props;
	let { class: klass = undefined } = $$props;
	let { label } = $$props;
	let { id } = $$props;
	let { value } = $$props;
	let { checked } = $$props;
	let { onkeydown } = $$props;
	let { onclick } = $$props;
	let { disabled = false } = $$props;
	const keysPressedStored = getContext("keysPressed");
	component_subscribe($$self, keysPressedStored, value => $$invalidate(16, $keysPressedStored = value));

	const handleKeydown = e => {
		onkeydown(e);
	};

	const handleClick = e => {
		if ($keysPressedStored.length) return;
		onclick(e);
	};

	function change_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("name" in $$props) $$invalidate(0, name = $$props.name);
		if ("class" in $$props) $$invalidate(1, klass = $$props.class);
		if ("label" in $$props) $$invalidate(2, label = $$props.label);
		if ("id" in $$props) $$invalidate(10, id = $$props.id);
		if ("value" in $$props) $$invalidate(3, value = $$props.value);
		if ("checked" in $$props) $$invalidate(4, checked = $$props.checked);
		if ("onkeydown" in $$props) $$invalidate(11, onkeydown = $$props.onkeydown);
		if ("onclick" in $$props) $$invalidate(12, onclick = $$props.onclick);
		if ("disabled" in $$props) $$invalidate(5, disabled = $$props.disabled);
		if ("$$scope" in $$props) $$invalidate(13, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*name, id*/ 1025) {
			$$invalidate(6, inputId = `${name}-${id}`);
		}
	};

	return [
		name,
		klass,
		label,
		value,
		checked,
		disabled,
		inputId,
		keysPressedStored,
		handleKeydown,
		handleClick,
		id,
		onkeydown,
		onclick,
		$$scope,
		slots,
		change_handler
	];
}

class RadioItem extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$z, create_fragment$z, safe_not_equal, {
			name: 0,
			class: 1,
			label: 2,
			id: 10,
			value: 3,
			checked: 4,
			onkeydown: 11,
			onclick: 12,
			disabled: 5
		});
	}
}

var flattenOptions = (options = []) => options.reduce((prev, current) => {
    const isGroup = isArray(current) ? isArray(current[1]) : !!current.options;
    if (isGroup) {
        return prev.concat(isArray(current) ? current[1] : current.options);
    }
    prev.push(current);
    return prev;
}, []);

const mapOption = (option, index, optionMapper) => {
    let mappedOption;
    if (isArray(option)) {
        mappedOption = {
            id: index,
            value: option[0],
            label: option[1],
            ...(option[2] || {}),
        };
    }
    else {
        mappedOption = option;
        mappedOption.id = mappedOption.id != null ? mappedOption.id : index;
    }
    return optionMapper ? optionMapper(mappedOption) : mappedOption;
};
var mapOptions = (options = [], optionMapper) => {
    let index = 0;
    return options.map((option) => {
        index++;
        if (isArray(option)) {
            // is either [label, options] or [value, label]
            if (isArray(option[1])) {
                return {
                    id: index,
                    label: option[0],
                    options: option[1].map((option) => mapOption(option, ++index, optionMapper)),
                };
            }
            return mapOption(option, index, optionMapper);
        }
        else {
            // is either { id?, label, options } or { id?, value, label }
            if (option.options) {
                return {
                    id: option.id || index,
                    label: option.label,
                    options: option.options.map((option) => mapOption(option, ++index, optionMapper)),
                };
            }
            return mapOption(option, index, optionMapper);
        }
    });
};

var opop = (fn, ...args) => fn && fn(...args);

var localize = (prop, locale, params) => isFunction$1(prop) ? prop(locale, params) : prop;

const localizeOptions = (options, locale) => options.map(([value, label, props]) => {
    if (isArray(label)) {
        return [localize(value, locale), localizeOptions(label, locale)];
    }
    else {
        const res = [value, localize(label, locale)];
        if (props) {
            let obj = { ...props };
            if (props.icon)
                obj.icon = localize(props.icon, locale);
            res.push(obj);
        }
        return res;
    }
});
var localizeOptions$1 = (options, locale) => localizeOptions(options, locale);

var isConfirmKey = (key) => /enter| /i.test(key);

/* src/core/ui/components/RadioGroup.svelte generated by Svelte v3.37.0 */

function get_each_context$7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[26] = list[i];
	return child_ctx;
}

const get_option_slot_changes_1 = dirty => ({ option: dirty & /*mappedOptions*/ 2048 });
const get_option_slot_context_1 = ctx => ({ option: /*option*/ ctx[26] });

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[26] = list[i];
	return child_ctx;
}

const get_option_slot_changes = dirty => ({ option: dirty & /*mappedOptions*/ 2048 });
const get_option_slot_context = ctx => ({ option: /*option*/ ctx[26] });
const get_group_slot_changes = dirty => ({ option: dirty & /*mappedOptions*/ 2048 });
const get_group_slot_context = ctx => ({ option: /*option*/ ctx[26] });

// (68:0) {#if localizedOptions.length}
function create_if_block_1$a(ctx) {
	let fieldset;
	let t;
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let fieldset_class_value;
	let current;
	let if_block = /*label*/ ctx[1] && create_if_block_7$1(ctx);
	let each_value = /*mappedOptions*/ ctx[11];
	const get_key = ctx => /*option*/ ctx[26].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$7(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$7(key, child_ctx));
	}

	return {
		c() {
			fieldset = element("fieldset");
			if (if_block) if_block.c();
			t = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(ul, "class", "PinturaRadioGroupOptions");
			attr(fieldset, "class", fieldset_class_value = arrayJoin(["PinturaRadioGroup", /*klass*/ ctx[3]]));
			attr(fieldset, "data-layout", /*layout*/ ctx[5]);
			attr(fieldset, "title", /*title*/ ctx[7]);
		},
		m(target, anchor) {
			insert(target, fieldset, anchor);
			if (if_block) if_block.m(fieldset, null);
			append(fieldset, t);
			append(fieldset, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_7$1(ctx);
					if_block.c();
					if_block.m(fieldset, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*arrayJoin, optionGroupClass, mappedOptions, name, optionClass, getOptionIndex, selectedIndex, handleRadioKeydown, handleRadioClick, optionLabelClass, $$scope*/ 8420177) {
				each_value = /*mappedOptions*/ ctx[11];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$7, null, get_each_context$7);
				check_outros();
			}

			if (!current || dirty & /*klass*/ 8 && fieldset_class_value !== (fieldset_class_value = arrayJoin(["PinturaRadioGroup", /*klass*/ ctx[3]]))) {
				attr(fieldset, "class", fieldset_class_value);
			}

			if (!current || dirty & /*layout*/ 32) {
				attr(fieldset, "data-layout", /*layout*/ ctx[5]);
			}

			if (!current || dirty & /*title*/ 128) {
				attr(fieldset, "title", /*title*/ ctx[7]);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(fieldset);
			if (if_block) if_block.d();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

// (70:4) {#if label}
function create_if_block_7$1(ctx) {
	let legend;
	let t;
	let legend_class_value;

	return {
		c() {
			legend = element("legend");
			t = text$1(/*label*/ ctx[1]);
			attr(legend, "class", legend_class_value = /*hideLabel*/ ctx[2] && "implicit");
		},
		m(target, anchor) {
			insert(target, legend, anchor);
			append(legend, t);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 2) set_data(t, /*label*/ ctx[1]);

			if (dirty & /*hideLabel*/ 4 && legend_class_value !== (legend_class_value = /*hideLabel*/ ctx[2] && "implicit")) {
				attr(legend, "class", legend_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(legend);
		}
	};
}

// (100:8) {:else}
function create_else_block$4(ctx) {
	let radioitem;
	let current;

	radioitem = new RadioItem({
			props: {
				name: /*name*/ ctx[4],
				label: /*option*/ ctx[26].label,
				id: /*option*/ ctx[26].id,
				value: /*option*/ ctx[26].value,
				disabled: /*option*/ ctx[26].disabled,
				class: /*optionClass*/ ctx[8],
				checked: /*getOptionIndex*/ ctx[12](/*option*/ ctx[26]) === /*selectedIndex*/ ctx[0],
				onkeydown: /*handleRadioKeydown*/ ctx[13](/*option*/ ctx[26]),
				onclick: /*handleRadioClick*/ ctx[14](/*option*/ ctx[26]),
				$$slots: { default: [create_default_slot_2$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(radioitem.$$.fragment);
		},
		m(target, anchor) {
			mount_component(radioitem, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const radioitem_changes = {};
			if (dirty & /*name*/ 16) radioitem_changes.name = /*name*/ ctx[4];
			if (dirty & /*mappedOptions*/ 2048) radioitem_changes.label = /*option*/ ctx[26].label;
			if (dirty & /*mappedOptions*/ 2048) radioitem_changes.id = /*option*/ ctx[26].id;
			if (dirty & /*mappedOptions*/ 2048) radioitem_changes.value = /*option*/ ctx[26].value;
			if (dirty & /*mappedOptions*/ 2048) radioitem_changes.disabled = /*option*/ ctx[26].disabled;
			if (dirty & /*optionClass*/ 256) radioitem_changes.class = /*optionClass*/ ctx[8];
			if (dirty & /*mappedOptions, selectedIndex*/ 2049) radioitem_changes.checked = /*getOptionIndex*/ ctx[12](/*option*/ ctx[26]) === /*selectedIndex*/ ctx[0];
			if (dirty & /*mappedOptions*/ 2048) radioitem_changes.onkeydown = /*handleRadioKeydown*/ ctx[13](/*option*/ ctx[26]);
			if (dirty & /*mappedOptions*/ 2048) radioitem_changes.onclick = /*handleRadioClick*/ ctx[14](/*option*/ ctx[26]);

			if (dirty & /*$$scope, optionLabelClass, mappedOptions*/ 8390720) {
				radioitem_changes.$$scope = { dirty, ctx };
			}

			radioitem.$set(radioitem_changes);
		},
		i(local) {
			if (current) return;
			transition_in(radioitem.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(radioitem.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(radioitem, detaching);
		}
	};
}

// (75:8) {#if option.options}
function create_if_block_2$8(ctx) {
	let li;
	let t0;
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t1;
	let li_class_value;
	let current;
	const group_slot_template = /*#slots*/ ctx[22].group;
	const group_slot = create_slot(group_slot_template, ctx, /*$$scope*/ ctx[23], get_group_slot_context);
	const group_slot_or_fallback = group_slot || fallback_block_1(ctx);
	let each_value_1 = /*option*/ ctx[26].options;
	const get_key = ctx => /*option*/ ctx[26].id;

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
	}

	return {
		c() {
			li = element("li");
			if (group_slot_or_fallback) group_slot_or_fallback.c();
			t0 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			attr(ul, "class", "PinturaRadioGroupOptions");
			attr(li, "class", li_class_value = arrayJoin(["PinturaRadioGroupOptionGroup", /*optionGroupClass*/ ctx[9]]));
		},
		m(target, anchor) {
			insert(target, li, anchor);

			if (group_slot_or_fallback) {
				group_slot_or_fallback.m(li, null);
			}

			append(li, t0);
			append(li, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			append(li, t1);
			current = true;
		},
		p(ctx, dirty) {
			if (group_slot) {
				if (group_slot.p && dirty & /*$$scope, mappedOptions*/ 8390656) {
					update_slot(group_slot, group_slot_template, ctx, /*$$scope*/ ctx[23], dirty, get_group_slot_changes, get_group_slot_context);
				}
			} else {
				if (group_slot_or_fallback && group_slot_or_fallback.p && dirty & /*mappedOptions*/ 2048) {
					group_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (dirty & /*name, mappedOptions, optionClass, getOptionIndex, selectedIndex, handleRadioKeydown, handleRadioClick, optionLabelClass, $$scope*/ 8419665) {
				each_value_1 = /*option*/ ctx[26].options;
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, ul, outro_and_destroy_block, create_each_block_1, null, get_each_context_1);
				check_outros();
			}

			if (!current || dirty & /*optionGroupClass*/ 512 && li_class_value !== (li_class_value = arrayJoin(["PinturaRadioGroupOptionGroup", /*optionGroupClass*/ ctx[9]]))) {
				attr(li, "class", li_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(group_slot_or_fallback, local);

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			transition_out(group_slot_or_fallback, local);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (group_slot_or_fallback) group_slot_or_fallback.d(detaching);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

// (111:16) {#if option.icon}
function create_if_block_6$2(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				$$slots: { default: [create_default_slot_3$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(icon.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope, mappedOptions*/ 8390656) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon, detaching);
		}
	};
}

// (112:16) <Icon>
function create_default_slot_3$2(ctx) {
	let g;
	let raw_value = /*option*/ ctx[26].icon + "";

	return {
		c() {
			g = svg_element("g");
		},
		m(target, anchor) {
			insert(target, g, anchor);
			g.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty & /*mappedOptions*/ 2048 && raw_value !== (raw_value = /*option*/ ctx[26].icon + "")) g.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) detach(g);
		}
	};
}

// (114:16) {#if !option.hideLabel}
function create_if_block_5$4(ctx) {
	let span;
	let t_value = /*option*/ ctx[26].label + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(t_value);
			attr(span, "class", /*optionLabelClass*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*mappedOptions*/ 2048 && t_value !== (t_value = /*option*/ ctx[26].label + "")) set_data(t, t_value);

			if (dirty & /*optionLabelClass*/ 64) {
				attr(span, "class", /*optionLabelClass*/ ctx[6]);
			}
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (110:76)                  
function fallback_block_2(ctx) {
	let t0;
	let t1;
	let current;
	let if_block0 = /*option*/ ctx[26].icon && create_if_block_6$2(ctx);
	let if_block1 = !/*option*/ ctx[26].hideLabel && create_if_block_5$4(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*option*/ ctx[26].icon) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*mappedOptions*/ 2048) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_6$2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (!/*option*/ ctx[26].hideLabel) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_5$4(ctx);
					if_block1.c();
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t1);
		}
	};
}

// (101:8) <RadioItem              {name}              label={option.label}             id={option.id}             value={option.value}             disabled={option.disabled}             class={optionClass}             checked={getOptionIndex(option) === selectedIndex}             onkeydown={handleRadioKeydown(option)}             onclick={handleRadioClick(option)}>
function create_default_slot_2$4(ctx) {
	let current;
	const option_slot_template = /*#slots*/ ctx[22].option;
	const option_slot = create_slot(option_slot_template, ctx, /*$$scope*/ ctx[23], get_option_slot_context_1);
	const option_slot_or_fallback = option_slot || fallback_block_2(ctx);

	return {
		c() {
			if (option_slot_or_fallback) option_slot_or_fallback.c();
		},
		m(target, anchor) {
			if (option_slot_or_fallback) {
				option_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (option_slot) {
				if (option_slot.p && dirty & /*$$scope, mappedOptions*/ 8390656) {
					update_slot(option_slot, option_slot_template, ctx, /*$$scope*/ ctx[23], dirty, get_option_slot_changes_1, get_option_slot_context_1);
				}
			} else {
				if (option_slot_or_fallback && option_slot_or_fallback.p && dirty & /*optionLabelClass, mappedOptions*/ 2112) {
					option_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(option_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(option_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (option_slot_or_fallback) option_slot_or_fallback.d(detaching);
		}
	};
}

// (77:47) <span class="PinturaRadioGroupOptionGroupLabel">
function fallback_block_1(ctx) {
	let span;
	let t_value = /*option*/ ctx[26].label + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(t_value);
			attr(span, "class", "PinturaRadioGroupOptionGroupLabel");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*mappedOptions*/ 2048 && t_value !== (t_value = /*option*/ ctx[26].label + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (90:24) {#if option.icon}
function create_if_block_4$5(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				$$slots: { default: [create_default_slot_1$7] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(icon.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope, mappedOptions*/ 8390656) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon, detaching);
		}
	};
}

// (91:24) <Icon>
function create_default_slot_1$7(ctx) {
	let g;
	let raw_value = /*option*/ ctx[26].icon + "";

	return {
		c() {
			g = svg_element("g");
		},
		m(target, anchor) {
			insert(target, g, anchor);
			g.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty & /*mappedOptions*/ 2048 && raw_value !== (raw_value = /*option*/ ctx[26].icon + "")) g.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) detach(g);
		}
	};
}

// (93:24) {#if !option.hideLabel}
function create_if_block_3$6(ctx) {
	let span;
	let t_value = /*option*/ ctx[26].label + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(t_value);
			attr(span, "class", /*optionLabelClass*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*mappedOptions*/ 2048 && t_value !== (t_value = /*option*/ ctx[26].label + "")) set_data(t, t_value);

			if (dirty & /*optionLabelClass*/ 64) {
				attr(span, "class", /*optionLabelClass*/ ctx[6]);
			}
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (89:84)                          
function fallback_block$1(ctx) {
	let t0;
	let t1;
	let current;
	let if_block0 = /*option*/ ctx[26].icon && create_if_block_4$5(ctx);
	let if_block1 = !/*option*/ ctx[26].hideLabel && create_if_block_3$6(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*option*/ ctx[26].icon) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*mappedOptions*/ 2048) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4$5(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (!/*option*/ ctx[26].hideLabel) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3$6(ctx);
					if_block1.c();
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t1);
		}
	};
}

// (80:16) <RadioItem                      {name}                      label={option.label}                     id={option.id}                     value={option.value}                     disabled={option.disabled}                     class={optionClass}                     checked={getOptionIndex(option) === selectedIndex}                     onkeydown={handleRadioKeydown(option)}                     onclick={handleRadioClick(option)}>
function create_default_slot$f(ctx) {
	let current;
	const option_slot_template = /*#slots*/ ctx[22].option;
	const option_slot = create_slot(option_slot_template, ctx, /*$$scope*/ ctx[23], get_option_slot_context);
	const option_slot_or_fallback = option_slot || fallback_block$1(ctx);

	return {
		c() {
			if (option_slot_or_fallback) option_slot_or_fallback.c();
		},
		m(target, anchor) {
			if (option_slot_or_fallback) {
				option_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (option_slot) {
				if (option_slot.p && dirty & /*$$scope, mappedOptions*/ 8390656) {
					update_slot(option_slot, option_slot_template, ctx, /*$$scope*/ ctx[23], dirty, get_option_slot_changes, get_option_slot_context);
				}
			} else {
				if (option_slot_or_fallback && option_slot_or_fallback.p && dirty & /*optionLabelClass, mappedOptions*/ 2112) {
					option_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(option_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(option_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (option_slot_or_fallback) option_slot_or_fallback.d(detaching);
		}
	};
}

// (79:16) {#each option.options as option (option.id) }
function create_each_block_1(key_1, ctx) {
	let first;
	let radioitem;
	let current;

	radioitem = new RadioItem({
			props: {
				name: /*name*/ ctx[4],
				label: /*option*/ ctx[26].label,
				id: /*option*/ ctx[26].id,
				value: /*option*/ ctx[26].value,
				disabled: /*option*/ ctx[26].disabled,
				class: /*optionClass*/ ctx[8],
				checked: /*getOptionIndex*/ ctx[12](/*option*/ ctx[26]) === /*selectedIndex*/ ctx[0],
				onkeydown: /*handleRadioKeydown*/ ctx[13](/*option*/ ctx[26]),
				onclick: /*handleRadioClick*/ ctx[14](/*option*/ ctx[26]),
				$$slots: { default: [create_default_slot$f] },
				$$scope: { ctx }
			}
		});

	return {
		key: key_1,
		first: null,
		c() {
			first = empty$1();
			create_component(radioitem.$$.fragment);
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);
			mount_component(radioitem, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const radioitem_changes = {};
			if (dirty & /*name*/ 16) radioitem_changes.name = /*name*/ ctx[4];
			if (dirty & /*mappedOptions*/ 2048) radioitem_changes.label = /*option*/ ctx[26].label;
			if (dirty & /*mappedOptions*/ 2048) radioitem_changes.id = /*option*/ ctx[26].id;
			if (dirty & /*mappedOptions*/ 2048) radioitem_changes.value = /*option*/ ctx[26].value;
			if (dirty & /*mappedOptions*/ 2048) radioitem_changes.disabled = /*option*/ ctx[26].disabled;
			if (dirty & /*optionClass*/ 256) radioitem_changes.class = /*optionClass*/ ctx[8];
			if (dirty & /*mappedOptions, selectedIndex*/ 2049) radioitem_changes.checked = /*getOptionIndex*/ ctx[12](/*option*/ ctx[26]) === /*selectedIndex*/ ctx[0];
			if (dirty & /*mappedOptions*/ 2048) radioitem_changes.onkeydown = /*handleRadioKeydown*/ ctx[13](/*option*/ ctx[26]);
			if (dirty & /*mappedOptions*/ 2048) radioitem_changes.onclick = /*handleRadioClick*/ ctx[14](/*option*/ ctx[26]);

			if (dirty & /*$$scope, optionLabelClass, mappedOptions*/ 8390720) {
				radioitem_changes.$$scope = { dirty, ctx };
			}

			radioitem.$set(radioitem_changes);
		},
		i(local) {
			if (current) return;
			transition_in(radioitem.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(radioitem.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			destroy_component(radioitem, detaching);
		}
	};
}

// (74:8) {#each mappedOptions as option (option.id) }
function create_each_block$7(key_1, ctx) {
	let first;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_2$8, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*option*/ ctx[26].options) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		key: key_1,
		first: null,
		c() {
			first = empty$1();
			if_block.c();
			if_block_anchor = empty$1();
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$y(ctx) {
	let t;
	let if_block1_anchor;
	let current;
	let if_block0 = /*localizedOptions*/ ctx[10].length && create_if_block_1$a(ctx);
	let if_block1 = false ;

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if_block1_anchor = empty$1();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*localizedOptions*/ ctx[10].length) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*localizedOptions*/ 1024) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$a(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

function instance$y($$self, $$props, $$invalidate) {
	let localizedOptions;
	let mappedOptions;
	let flattenedOptions;
	let { $$slots: slots = {}, $$scope } = $$props;
	const dispatch = createEventDispatcher();
	let { label = undefined } = $$props;
	let { hideLabel = true } = $$props;
	let { class: klass = undefined } = $$props;
	let { name = `radio-group-${getUniqueId()}` } = $$props;
	let { selectedIndex = -1 } = $$props;
	let { options = [] } = $$props;
	let { onchange = undefined } = $$props;
	let { layout = undefined } = $$props;
	let { optionMapper = undefined } = $$props;
	let { optionFilter = undefined } = $$props;
	let { value = undefined } = $$props;
	let { optionLabelClass = undefined } = $$props;
	let { title = undefined } = $$props;
	let { locale = undefined } = $$props;
	let { optionClass = undefined } = $$props;
	let { optionGroupClass = undefined } = $$props;
	const getOptionIndex = option => flattenedOptions.findIndex(flattenedOption => flattenedOption.id === option.id);

	const changeSelection = (option, e) => {
		$$invalidate(0, selectedIndex = getOptionIndex(option));
		const payload = { index: selectedIndex, ...option };
		opop(onchange, payload, e);
		dispatch("change", payload);
	};

	const handleRadioKeydown = option => e => {
		// is confirm key ([enter] or [space])
		if (!isConfirmKey(e.key)) return;

		changeSelection(option, e);
	};

	const handleRadioClick = option => e => {
		changeSelection(option, e);
	};

	$$self.$$set = $$props => {
		if ("label" in $$props) $$invalidate(1, label = $$props.label);
		if ("hideLabel" in $$props) $$invalidate(2, hideLabel = $$props.hideLabel);
		if ("class" in $$props) $$invalidate(3, klass = $$props.class);
		if ("name" in $$props) $$invalidate(4, name = $$props.name);
		if ("selectedIndex" in $$props) $$invalidate(0, selectedIndex = $$props.selectedIndex);
		if ("options" in $$props) $$invalidate(15, options = $$props.options);
		if ("onchange" in $$props) $$invalidate(16, onchange = $$props.onchange);
		if ("layout" in $$props) $$invalidate(5, layout = $$props.layout);
		if ("optionMapper" in $$props) $$invalidate(17, optionMapper = $$props.optionMapper);
		if ("optionFilter" in $$props) $$invalidate(18, optionFilter = $$props.optionFilter);
		if ("value" in $$props) $$invalidate(19, value = $$props.value);
		if ("optionLabelClass" in $$props) $$invalidate(6, optionLabelClass = $$props.optionLabelClass);
		if ("title" in $$props) $$invalidate(7, title = $$props.title);
		if ("locale" in $$props) $$invalidate(20, locale = $$props.locale);
		if ("optionClass" in $$props) $$invalidate(8, optionClass = $$props.optionClass);
		if ("optionGroupClass" in $$props) $$invalidate(9, optionGroupClass = $$props.optionGroupClass);
		if ("$$scope" in $$props) $$invalidate(23, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*optionFilter, options, locale*/ 1343488) {
			$$invalidate(10, localizedOptions = localizeOptions$1(optionFilter ? options.filter(optionFilter) : options, locale));
		}

		if ($$self.$$.dirty & /*localizedOptions, optionMapper*/ 132096) {
			$$invalidate(11, mappedOptions = mapOptions(localizedOptions, optionMapper));
		}

		if ($$self.$$.dirty & /*mappedOptions*/ 2048) {
			$$invalidate(21, flattenedOptions = flattenOptions(mappedOptions));
		}

		if ($$self.$$.dirty & /*value, selectedIndex, flattenedOptions*/ 2621441) {
			// can optionally pass value to have radio button group try to auto-select the right option
			if (value && selectedIndex < 0) {
				$$invalidate(0, selectedIndex = flattenedOptions.findIndex(option => option.value === value));
			}
		}
	};

	return [
		selectedIndex,
		label,
		hideLabel,
		klass,
		name,
		layout,
		optionLabelClass,
		title,
		optionClass,
		optionGroupClass,
		localizedOptions,
		mappedOptions,
		getOptionIndex,
		handleRadioKeydown,
		handleRadioClick,
		options,
		onchange,
		optionMapper,
		optionFilter,
		value,
		locale,
		flattenedOptions,
		slots,
		$$scope
	];
}

class RadioGroup extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$y, create_fragment$y, safe_not_equal, {
			label: 1,
			hideLabel: 2,
			class: 3,
			name: 4,
			selectedIndex: 0,
			options: 15,
			onchange: 16,
			layout: 5,
			optionMapper: 17,
			optionFilter: 18,
			value: 19,
			optionLabelClass: 6,
			title: 7,
			locale: 20,
			optionClass: 8,
			optionGroupClass: 9
		});
	}
}

var isDeepEqual = (a, b) => {
    if (Array.isArray(a) && Array.isArray(b))
        return arrayEqual(a, b);
    return a === b;
};

/* src/core/ui/components/Dropdown.svelte generated by Svelte v3.37.0 */

function create_if_block_1$9(ctx) {
	let icon_1;
	let current;

	icon_1 = new Icon({
			props: {
				class: "PinturaButtonIcon",
				$$slots: { default: [create_default_slot_1$6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(icon_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icon_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const icon_1_changes = {};

			if (dirty & /*$$scope, icon*/ 536870976) {
				icon_1_changes.$$scope = { dirty, ctx };
			}

			icon_1.$set(icon_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon_1, detaching);
		}
	};
}

// (160:8) <Icon class="PinturaButtonIcon">
function create_default_slot_1$6(ctx) {
	let g;

	return {
		c() {
			g = svg_element("g");
		},
		m(target, anchor) {
			insert(target, g, anchor);
			g.innerHTML = /*icon*/ ctx[6];
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 64) g.innerHTML = /*icon*/ ctx[6];		},
		d(detaching) {
			if (detaching) detach(g);
		}
	};
}

// (158:4) 
function create_label_slot$2(ctx) {
	let span1;
	let t0;
	let span0;
	let t1_value = (/*label*/ ctx[2] || /*selectedLabel*/ ctx[18]) + "";
	let t1;
	let span0_class_value;
	let span1_title_value;
	let span1_class_value;
	let current;
	let if_block = /*icon*/ ctx[6] && create_if_block_1$9(ctx);

	return {
		c() {
			span1 = element("span");
			if (if_block) if_block.c();
			t0 = space();
			span0 = element("span");
			t1 = text$1(t1_value);

			attr(span0, "class", span0_class_value = arrayJoin([
				"PinturaButtonLabel",
				/*labelClass*/ ctx[3],
				/*hideLabel*/ ctx[5] && "implicit"
			]));

			attr(span1, "slot", "label");
			attr(span1, "title", span1_title_value = localize(/*title*/ ctx[1], /*locale*/ ctx[15]));
			attr(span1, "class", span1_class_value = arrayJoin(["PinturaButtonInner", /*innerClass*/ ctx[4]]));
		},
		m(target, anchor) {
			insert(target, span1, anchor);
			if (if_block) if_block.m(span1, null);
			append(span1, t0);
			append(span1, span0);
			append(span0, t1);
			current = true;
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*icon*/ 64) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$9(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(span1, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if ((!current || dirty & /*label, selectedLabel*/ 262148) && t1_value !== (t1_value = (/*label*/ ctx[2] || /*selectedLabel*/ ctx[18]) + "")) set_data(t1, t1_value);

			if (!current || dirty & /*labelClass, hideLabel*/ 40 && span0_class_value !== (span0_class_value = arrayJoin([
				"PinturaButtonLabel",
				/*labelClass*/ ctx[3],
				/*hideLabel*/ ctx[5] && "implicit"
			]))) {
				attr(span0, "class", span0_class_value);
			}

			if (!current || dirty & /*title, locale*/ 32770 && span1_title_value !== (span1_title_value = localize(/*title*/ ctx[1], /*locale*/ ctx[15]))) {
				attr(span1, "title", span1_title_value);
			}

			if (!current || dirty & /*innerClass*/ 16 && span1_class_value !== (span1_class_value = arrayJoin(["PinturaButtonInner", /*innerClass*/ ctx[4]]))) {
				attr(span1, "class", span1_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span1);
			if (if_block) if_block.d();
		}
	};
}

// (178:12) 
function create_group_slot$1(ctx) {
	let span;
	let t_value = /*option*/ ctx[28].label + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(t_value);
			attr(span, "slot", "group");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*option*/ 268435456 && t_value !== (t_value = /*option*/ ctx[28].label + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (180:16) {#if option.icon}
function create_if_block$a(ctx) {
	let icon_1;
	let current;

	icon_1 = new Icon({
			props: {
				style: isFunction$1(/*optionIconStyle*/ ctx[13])
				? /*optionIconStyle*/ ctx[13](/*option*/ ctx[28].value)
				: /*optionIconStyle*/ ctx[13],
				$$slots: { default: [create_default_slot$e] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(icon_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icon_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const icon_1_changes = {};

			if (dirty & /*optionIconStyle, option*/ 268443648) icon_1_changes.style = isFunction$1(/*optionIconStyle*/ ctx[13])
			? /*optionIconStyle*/ ctx[13](/*option*/ ctx[28].value)
			: /*optionIconStyle*/ ctx[13];

			if (dirty & /*$$scope, option*/ 805306368) {
				icon_1_changes.$$scope = { dirty, ctx };
			}

			icon_1.$set(icon_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon_1, detaching);
		}
	};
}

// (181:16) <Icon style={isFunction(optionIconStyle) ? optionIconStyle(option.value) : optionIconStyle}>
function create_default_slot$e(ctx) {
	let g;
	let raw_value = /*option*/ ctx[28].icon + "";

	return {
		c() {
			g = svg_element("g");
		},
		m(target, anchor) {
			insert(target, g, anchor);
			g.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty & /*option*/ 268435456 && raw_value !== (raw_value = /*option*/ ctx[28].icon + "")) g.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) detach(g);
		}
	};
}

// (179:12) 
function create_option_slot$4(ctx) {
	let span1;
	let t0;
	let span0;
	let t1_value = /*option*/ ctx[28].label + "";
	let t1;
	let span0_style_value;
	let span0_class_value;
	let current;
	let if_block = /*option*/ ctx[28].icon && create_if_block$a(ctx);

	return {
		c() {
			span1 = element("span");
			if (if_block) if_block.c();
			t0 = space();
			span0 = element("span");
			t1 = text$1(t1_value);

			attr(span0, "style", span0_style_value = isFunction$1(/*optionLabelStyle*/ ctx[14])
			? /*optionLabelStyle*/ ctx[14](/*option*/ ctx[28].value)
			: /*optionLabelStyle*/ ctx[14]);

			attr(span0, "class", span0_class_value = arrayJoin(["PinturaDropdownOptionLabel", /*optionLabelClass*/ ctx[10]]));
			attr(span1, "slot", "option");
		},
		m(target, anchor) {
			insert(target, span1, anchor);
			if (if_block) if_block.m(span1, null);
			append(span1, t0);
			append(span1, span0);
			append(span0, t1);
			current = true;
		},
		p(ctx, dirty) {
			if (/*option*/ ctx[28].icon) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*option*/ 268435456) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$a(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(span1, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if ((!current || dirty & /*option*/ 268435456) && t1_value !== (t1_value = /*option*/ ctx[28].label + "")) set_data(t1, t1_value);

			if (!current || dirty & /*optionLabelStyle, option*/ 268451840 && span0_style_value !== (span0_style_value = isFunction$1(/*optionLabelStyle*/ ctx[14])
			? /*optionLabelStyle*/ ctx[14](/*option*/ ctx[28].value)
			: /*optionLabelStyle*/ ctx[14])) {
				attr(span0, "style", span0_style_value);
			}

			if (!current || dirty & /*optionLabelClass*/ 1024 && span0_class_value !== (span0_class_value = arrayJoin(["PinturaDropdownOptionLabel", /*optionLabelClass*/ ctx[10]]))) {
				attr(span0, "class", span0_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span1);
			if (if_block) if_block.d();
		}
	};
}

// (165:4) 
function create_details_slot$2(ctx) {
	let div;
	let radiogroup;
	let current;
	let mounted;
	let dispose;

	radiogroup = new RadioGroup({
			props: {
				name: /*name*/ ctx[7],
				value: /*value*/ ctx[9],
				selectedIndex: /*selectedIndex*/ ctx[8],
				optionFilter: /*optionFilter*/ ctx[11],
				optionMapper: /*optionMapper*/ ctx[12],
				optionLabelClass: arrayJoin(["PinturaDropdownOptionLabel", /*optionLabelClass*/ ctx[10]]),
				optionGroupClass: "PinturaDropdownOptionGroup",
				optionClass: "PinturaDropdownOption",
				options: /*localizedOptions*/ ctx[16],
				onchange: /*handleSelect*/ ctx[19],
				$$slots: {
					option: [
						create_option_slot$4,
						({ option }) => ({ 28: option }),
						({ option }) => option ? 268435456 : 0
					],
					group: [
						create_group_slot$1,
						({ option }) => ({ 28: option }),
						({ option }) => option ? 268435456 : 0
					]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(radiogroup.$$.fragment);
			attr(div, "class", "PinturaDropdownPanel");
			attr(div, "slot", "details");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(radiogroup, div, null);
			current = true;

			if (!mounted) {
				dispose = listen(div, "keydown", /*handleKeydown*/ ctx[21]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			const radiogroup_changes = {};
			if (dirty & /*name*/ 128) radiogroup_changes.name = /*name*/ ctx[7];
			if (dirty & /*value*/ 512) radiogroup_changes.value = /*value*/ ctx[9];
			if (dirty & /*selectedIndex*/ 256) radiogroup_changes.selectedIndex = /*selectedIndex*/ ctx[8];
			if (dirty & /*optionFilter*/ 2048) radiogroup_changes.optionFilter = /*optionFilter*/ ctx[11];
			if (dirty & /*optionMapper*/ 4096) radiogroup_changes.optionMapper = /*optionMapper*/ ctx[12];
			if (dirty & /*optionLabelClass*/ 1024) radiogroup_changes.optionLabelClass = arrayJoin(["PinturaDropdownOptionLabel", /*optionLabelClass*/ ctx[10]]);
			if (dirty & /*localizedOptions*/ 65536) radiogroup_changes.options = /*localizedOptions*/ ctx[16];

			if (dirty & /*$$scope, optionLabelStyle, option, optionLabelClass, optionIconStyle*/ 805331968) {
				radiogroup_changes.$$scope = { dirty, ctx };
			}

			radiogroup.$set(radiogroup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(radiogroup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(radiogroup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(radiogroup);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$x(ctx) {
	let details;
	let updating_isActive;
	let current;

	function details_isActive_binding(value) {
		/*details_isActive_binding*/ ctx[26](value);
	}

	let details_props = {
		onshow: /*handleShowPanel*/ ctx[20],
		buttonClass: arrayJoin([
			"PinturaDropdownButton",
			/*klass*/ ctx[0],
			/*hideLabel*/ ctx[5] && "PinturaDropdownIconOnly"
		]),
		$$slots: {
			details: [create_details_slot$2],
			label: [create_label_slot$2]
		},
		$$scope: { ctx }
	};

	if (/*dropdownVisible*/ ctx[17] !== void 0) {
		details_props.isActive = /*dropdownVisible*/ ctx[17];
	}

	details = new Details({ props: details_props });
	binding_callbacks.push(() => bind$1(details, "isActive", details_isActive_binding));

	return {
		c() {
			create_component(details.$$.fragment);
		},
		m(target, anchor) {
			mount_component(details, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const details_changes = {};

			if (dirty & /*klass, hideLabel*/ 33) details_changes.buttonClass = arrayJoin([
				"PinturaDropdownButton",
				/*klass*/ ctx[0],
				/*hideLabel*/ ctx[5] && "PinturaDropdownIconOnly"
			]);

			if (dirty & /*$$scope, name, value, selectedIndex, optionFilter, optionMapper, optionLabelClass, localizedOptions, optionLabelStyle, optionIconStyle, title, locale, innerClass, labelClass, hideLabel, label, selectedLabel, icon*/ 537264126) {
				details_changes.$$scope = { dirty, ctx };
			}

			if (!updating_isActive && dirty & /*dropdownVisible*/ 131072) {
				updating_isActive = true;
				details_changes.isActive = /*dropdownVisible*/ ctx[17];
				add_flush_callback(() => updating_isActive = false);
			}

			details.$set(details_changes);
		},
		i(local) {
			if (current) return;
			transition_in(details.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(details.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(details, detaching);
		}
	};
}

function instance$x($$self, $$props, $$invalidate) {
	let localizedOptions;
	let selectedLabel;
	let { class: klass = undefined } = $$props;
	let { title = undefined } = $$props;
	let { label = undefined } = $$props;
	let { labelClass = undefined } = $$props;
	let { innerClass = undefined } = $$props;
	let { hideLabel = false } = $$props;
	let { icon = undefined } = $$props;
	let { name = undefined } = $$props;
	let { options = [] } = $$props;
	let { selectedIndex = -1 } = $$props;
	let { value = undefined } = $$props;
	let { optionLabelClass = undefined } = $$props;
	let { optionFilter = undefined } = $$props;
	let { optionMapper = undefined } = $$props;
	let { optionIconStyle = undefined } = $$props;
	let { optionLabelStyle = undefined } = $$props;
	let { locale = undefined } = $$props;
	let { onchange = noop$1 } = $$props;
	let { onload = noop$1 } = $$props;
	let { ondestroy = noop$1 } = $$props;

	const getUndefinedOptionLabel = options => {
		const option = options.find(option => option[0] === undefined);
		if (!option) return undefined;
		return option[1];
	};

	let dropdownVisible;

	const handleSelect = detail => {
		// triggers label update
		$$invalidate(18, selectedLabel = detail.value);

		// update value
		onchange(detail);

		// hide details
		$$invalidate(17, dropdownVisible = false);
	};

	const handleShowPanel = ({ e, panel }) => {
		if (e && e.key && (/up|down/i).test(e.key)) return panel.querySelector("input:not([disabled])").focus();
		panel.querySelector("fieldset").focus();
	};

	const handleKeydown = e => {
		// don't allow tabbing ([tab] is also blocked in normal <select>)
		if ((/tab/i).test(e.key)) e.preventDefault();
	};

	onMount(() => onload({ options }));
	onDestroy(() => ondestroy({ options }));

	function details_isActive_binding(value) {
		dropdownVisible = value;
		$$invalidate(17, dropdownVisible);
	}

	$$self.$$set = $$props => {
		if ("class" in $$props) $$invalidate(0, klass = $$props.class);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("label" in $$props) $$invalidate(2, label = $$props.label);
		if ("labelClass" in $$props) $$invalidate(3, labelClass = $$props.labelClass);
		if ("innerClass" in $$props) $$invalidate(4, innerClass = $$props.innerClass);
		if ("hideLabel" in $$props) $$invalidate(5, hideLabel = $$props.hideLabel);
		if ("icon" in $$props) $$invalidate(6, icon = $$props.icon);
		if ("name" in $$props) $$invalidate(7, name = $$props.name);
		if ("options" in $$props) $$invalidate(22, options = $$props.options);
		if ("selectedIndex" in $$props) $$invalidate(8, selectedIndex = $$props.selectedIndex);
		if ("value" in $$props) $$invalidate(9, value = $$props.value);
		if ("optionLabelClass" in $$props) $$invalidate(10, optionLabelClass = $$props.optionLabelClass);
		if ("optionFilter" in $$props) $$invalidate(11, optionFilter = $$props.optionFilter);
		if ("optionMapper" in $$props) $$invalidate(12, optionMapper = $$props.optionMapper);
		if ("optionIconStyle" in $$props) $$invalidate(13, optionIconStyle = $$props.optionIconStyle);
		if ("optionLabelStyle" in $$props) $$invalidate(14, optionLabelStyle = $$props.optionLabelStyle);
		if ("locale" in $$props) $$invalidate(15, locale = $$props.locale);
		if ("onchange" in $$props) $$invalidate(23, onchange = $$props.onchange);
		if ("onload" in $$props) $$invalidate(24, onload = $$props.onload);
		if ("ondestroy" in $$props) $$invalidate(25, ondestroy = $$props.ondestroy);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*locale, options*/ 4227072) {
			$$invalidate(16, localizedOptions = locale ? localizeOptions$1(options, locale) : options);
		}

		if ($$self.$$.dirty & /*localizedOptions, value*/ 66048) {
			$$invalidate(18, selectedLabel = localizedOptions.reduce(
				(prev, curr) => {
					if (prev) return prev;
					const item = Array.isArray(curr) ? curr : [curr, curr];
					const [optionValue, optionLabel] = item;
					if (isDeepEqual(optionValue, value)) return optionLabel;
				},
				undefined
			) || getUndefinedOptionLabel(localizedOptions));
		}
	};

	return [
		klass,
		title,
		label,
		labelClass,
		innerClass,
		hideLabel,
		icon,
		name,
		selectedIndex,
		value,
		optionLabelClass,
		optionFilter,
		optionMapper,
		optionIconStyle,
		optionLabelStyle,
		locale,
		localizedOptions,
		dropdownVisible,
		selectedLabel,
		handleSelect,
		handleShowPanel,
		handleKeydown,
		options,
		onchange,
		onload,
		ondestroy,
		details_isActive_binding
	];
}

class Dropdown extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$x, create_fragment$x, safe_not_equal, {
			class: 0,
			title: 1,
			label: 2,
			labelClass: 3,
			innerClass: 4,
			hideLabel: 5,
			icon: 6,
			name: 7,
			options: 22,
			selectedIndex: 8,
			value: 9,
			optionLabelClass: 10,
			optionFilter: 11,
			optionMapper: 12,
			optionIconStyle: 13,
			optionLabelStyle: 14,
			locale: 15,
			onchange: 23,
			onload: 24,
			ondestroy: 25
		});
	}
}

var numberRoundTo = (value, fraction) => {
    fraction = 1 / fraction;
    return Math.round(value * fraction) / fraction;
};

var toFraction = (value, min, max) => (value - min) / (max - min);

/* src/core/ui/components/Slider.svelte generated by Svelte v3.37.0 */

function create_default_slot_1$5(ctx) {
	let path;

	return {
		c() {
			path = svg_element("path");
			attr(path, "d", "M8 12 h8 M12 8 v8");
		},
		m(target, anchor) {
			insert(target, path, anchor);
		},
		d(detaching) {
			if (detaching) detach(path);
		}
	};
}

// (358:8) <Icon>
function create_default_slot$d(ctx) {
	let path;

	return {
		c() {
			path = svg_element("path");
			attr(path, "d", "M9 12 h6");
		},
		m(target, anchor) {
			insert(target, path, anchor);
		},
		d(detaching) {
			if (detaching) detach(path);
		}
	};
}

function create_fragment$w(ctx) {
	let div4;
	let div3;
	let input_1;
	let t0;
	let div0;
	let t1;
	let div2;
	let div1;
	let t2;
	let button0;
	let icon0;
	let t3;
	let button1;
	let icon1;
	let div4_class_value;
	let current;
	let mounted;
	let dispose;

	icon0 = new Icon({
			props: {
				$$slots: { default: [create_default_slot_1$5] },
				$$scope: { ctx }
			}
		});

	icon1 = new Icon({
			props: {
				$$slots: { default: [create_default_slot$d] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div4 = element("div");
			div3 = element("div");
			input_1 = element("input");
			t0 = space();
			div0 = element("div");
			t1 = space();
			div2 = element("div");
			div1 = element("div");
			t2 = space();
			button0 = element("button");
			create_component(icon0.$$.fragment);
			t3 = space();
			button1 = element("button");
			create_component(icon1.$$.fragment);
			attr(input_1, "type", "range");
			attr(input_1, "id", /*id*/ ctx[3]);
			attr(input_1, "min", /*min*/ ctx[0]);
			attr(input_1, "max", /*max*/ ctx[1]);
			attr(input_1, "step", /*step*/ ctx[2]);
			input_1.value = /*numberValue*/ ctx[8];
			attr(div0, "class", "PinturaSliderTrack");
			attr(div0, "style", /*trackStyle*/ ctx[4]);
			attr(div1, "class", "PinturaSliderKnob");
			attr(div1, "style", /*knobStyle*/ ctx[5]);
			attr(div2, "class", "PinturaSliderKnobController");
			attr(div2, "style", /*knobControllerStyle*/ ctx[10]);
			attr(div3, "class", "PinturaSliderControl");
			attr(button0, "type", "button");
			attr(button0, "aria-label", "Increase");
			attr(button1, "type", "button");
			attr(button1, "aria-label", "Decrease");
			attr(div4, "class", div4_class_value = arrayJoin(["PinturaSlider", /*klass*/ ctx[7]]));
			attr(div4, "data-direction", /*direction*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div3);
			append(div3, input_1);
			/*input_1_binding*/ ctx[22](input_1);
			append(div3, t0);
			append(div3, div0);
			append(div3, t1);
			append(div3, div2);
			append(div2, div1);
			append(div4, t2);
			append(div4, button0);
			mount_component(icon0, button0, null);
			append(div4, t3);
			append(div4, button1);
			mount_component(icon1, button1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input_1, "pointerdown", /*handlePointerDown*/ ctx[13]),
					listen(input_1, "input", /*handleInput*/ ctx[11]),
					listen(input_1, "nudge", /*handleNudge*/ ctx[12]),
					action_destroyer(nudgeable.call(null, input_1)),
					listen(button0, "pointerdown", /*handleUpdaterDown*/ ctx[14](1)),
					listen(button1, "pointerdown", /*handleUpdaterDown*/ ctx[14](-1))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (!current || dirty[0] & /*id*/ 8) {
				attr(input_1, "id", /*id*/ ctx[3]);
			}

			if (!current || dirty[0] & /*min*/ 1) {
				attr(input_1, "min", /*min*/ ctx[0]);
			}

			if (!current || dirty[0] & /*max*/ 2) {
				attr(input_1, "max", /*max*/ ctx[1]);
			}

			if (!current || dirty[0] & /*step*/ 4) {
				attr(input_1, "step", /*step*/ ctx[2]);
			}

			if (!current || dirty[0] & /*numberValue*/ 256) {
				input_1.value = /*numberValue*/ ctx[8];
			}

			if (!current || dirty[0] & /*trackStyle*/ 16) {
				attr(div0, "style", /*trackStyle*/ ctx[4]);
			}

			if (!current || dirty[0] & /*knobStyle*/ 32) {
				attr(div1, "style", /*knobStyle*/ ctx[5]);
			}

			if (!current || dirty[0] & /*knobControllerStyle*/ 1024) {
				attr(div2, "style", /*knobControllerStyle*/ ctx[10]);
			}

			const icon0_changes = {};

			if (dirty[1] & /*$$scope*/ 512) {
				icon0_changes.$$scope = { dirty, ctx };
			}

			icon0.$set(icon0_changes);
			const icon1_changes = {};

			if (dirty[1] & /*$$scope*/ 512) {
				icon1_changes.$$scope = { dirty, ctx };
			}

			icon1.$set(icon1_changes);

			if (!current || dirty[0] & /*klass*/ 128 && div4_class_value !== (div4_class_value = arrayJoin(["PinturaSlider", /*klass*/ ctx[7]]))) {
				attr(div4, "class", div4_class_value);
			}

			if (!current || dirty[0] & /*direction*/ 64) {
				attr(div4, "data-direction", /*direction*/ ctx[6]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(icon0.$$.fragment, local);
			transition_in(icon1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div4);
			/*input_1_binding*/ ctx[22](null);
			destroy_component(icon0);
			destroy_component(icon1);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$w($$self, $$props, $$invalidate) {
	let numberValue;
	let range;
	let position;
	let axis;
	let dimension;
	let offsetSizeProp;
	let offsetAxisProp;
	let pageAxisProp;
	let knobControllerStyle;
	let { min = 0 } = $$props;
	let { max = 100 } = $$props;
	let { step = 1 } = $$props;
	let { id = undefined } = $$props;
	let { value = 0 } = $$props;
	let { trackStyle = undefined } = $$props;
	let { knobStyle = undefined } = $$props;
	let { onchange = undefined } = $$props;
	let { direction = "x" } = $$props;
	let { getValue = passthrough } = $$props;
	let { setValue = passthrough } = $$props;
	let { class: klass = undefined } = $$props;
	let input;
	let inputSize;
	let inputOffset;
	let pageOffset;
	let valuePrev;
	const formatValue = value => setValue(numberRoundTo(clamp(value, min, max), step));

	const setValueByOffset = (offset, size) => {
		$$invalidate(15, value = formatValue(min + offset / size * range));
		if (value === valuePrev) return;
		valuePrev = value;
		onchange(value);
	};

	const handleInput = e => {
		// already handled by pointer events
		if (inputSize) return;

		$$invalidate(15, value = setValue(parseFloat(e.target.value)));
		if (value === valuePrev) return;
		valuePrev = value;
		onchange(value);
	};

	const handleNudge = e => {
		const size = input[offsetSizeProp];
		const offset = numberValue / range * size;
		setValueByOffset(offset + e.detail[direction], size);
	};

	const handlePointerDown = e => {
		e.stopPropagation();
		inputSize = input[offsetSizeProp];
		inputOffset = e[offsetAxisProp];
		pageOffset = e[pageAxisProp];
		setValueByOffset(inputOffset, inputSize);
		document.documentElement.addEventListener("pointermove", handlePointerMove);
		document.documentElement.addEventListener("pointerup", handlePointerUp);
	};

	const handlePointerMove = e => {
		const d = e[pageAxisProp] - pageOffset;
		setValueByOffset(inputOffset + d, inputSize);
	};

	const handlePointerUp = e => {
		inputSize = undefined;
		document.documentElement.removeEventListener("pointermove", handlePointerMove);
		document.documentElement.removeEventListener("pointerup", handlePointerUp);
		onchange(value);
	};

	const update = () => {
		$$invalidate(15, value = formatValue(numberValue + updateDir * step));
		onchange(value);
	};

	let updateTimer;
	let updateDir = 1;
	let didUpdate = false;

	const handleUpdaterDown = dir => e => {
		updateDir = dir;
		didUpdate = false;

		updateTimer = setInterval(
			() => {
				didUpdate = true;
				update();
			},
			100
		);

		document.addEventListener("pointercancel", handleUpdaterUp);
		document.addEventListener("pointerup", handleUpdaterUp);
	};

	const handleUpdaterUp = e => {
		clearTimeout(updateTimer);
		if (!didUpdate) update();
		document.removeEventListener("pointerup", handleUpdaterUp);
	};

	function input_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			input = $$value;
			$$invalidate(9, input);
		});
	}

	$$self.$$set = $$props => {
		if ("min" in $$props) $$invalidate(0, min = $$props.min);
		if ("max" in $$props) $$invalidate(1, max = $$props.max);
		if ("step" in $$props) $$invalidate(2, step = $$props.step);
		if ("id" in $$props) $$invalidate(3, id = $$props.id);
		if ("value" in $$props) $$invalidate(15, value = $$props.value);
		if ("trackStyle" in $$props) $$invalidate(4, trackStyle = $$props.trackStyle);
		if ("knobStyle" in $$props) $$invalidate(5, knobStyle = $$props.knobStyle);
		if ("onchange" in $$props) $$invalidate(16, onchange = $$props.onchange);
		if ("direction" in $$props) $$invalidate(6, direction = $$props.direction);
		if ("getValue" in $$props) $$invalidate(17, getValue = $$props.getValue);
		if ("setValue" in $$props) $$invalidate(18, setValue = $$props.setValue);
		if ("class" in $$props) $$invalidate(7, klass = $$props.class);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value, getValue*/ 163840) {
			$$invalidate(8, numberValue = value !== undefined ? getValue(value) : 0);
		}

		if ($$self.$$.dirty[0] & /*max, min*/ 3) {
			range = max - min;
		}

		if ($$self.$$.dirty[0] & /*numberValue, min, max*/ 259) {
			$$invalidate(19, position = toFraction(numberValue, min, max) * 100);
		}

		if ($$self.$$.dirty[0] & /*direction*/ 64) {
			$$invalidate(20, axis = direction.toUpperCase());
		}

		if ($$self.$$.dirty[0] & /*direction*/ 64) {
			$$invalidate(21, dimension = direction === "x" ? "Width" : "Height");
		}

		if ($$self.$$.dirty[0] & /*dimension*/ 2097152) {
			offsetSizeProp = `offset${dimension}`;
		}

		if ($$self.$$.dirty[0] & /*axis*/ 1048576) {
			offsetAxisProp = `offset${axis}`;
		}

		if ($$self.$$.dirty[0] & /*axis*/ 1048576) {
			pageAxisProp = `page${axis}`;
		}

		if ($$self.$$.dirty[0] & /*axis, position*/ 1572864) {
			$$invalidate(10, knobControllerStyle = `transform: translate${axis}(${position}%)`);
		}
	};

	return [
		min,
		max,
		step,
		id,
		trackStyle,
		knobStyle,
		direction,
		klass,
		numberValue,
		input,
		knobControllerStyle,
		handleInput,
		handleNudge,
		handlePointerDown,
		handleUpdaterDown,
		value,
		onchange,
		getValue,
		setValue,
		position,
		axis,
		dimension,
		input_1_binding
	];
}

class Slider extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$w,
			create_fragment$w,
			safe_not_equal,
			{
				min: 0,
				max: 1,
				step: 2,
				id: 3,
				value: 15,
				trackStyle: 4,
				knobStyle: 5,
				onchange: 16,
				direction: 6,
				getValue: 17,
				setValue: 18,
				class: 7
			},
			[-1, -1]
		);
	}
}

/* src/core/ui/components/ToggleSlider.svelte generated by Svelte v3.37.0 */

function create_if_block$9(ctx) {
	let icon_1;
	let current;

	icon_1 = new Icon({
			props: {
				class: "PinturaButtonIcon",
				$$slots: { default: [create_default_slot$c] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(icon_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icon_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const icon_1_changes = {};

			if (dirty & /*$$scope, icon*/ 262148) {
				icon_1_changes.$$scope = { dirty, ctx };
			}

			icon_1.$set(icon_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon_1, detaching);
		}
	};
}

// (47:8) <Icon class="PinturaButtonIcon">
function create_default_slot$c(ctx) {
	let g;

	return {
		c() {
			g = svg_element("g");
		},
		m(target, anchor) {
			insert(target, g, anchor);
			g.innerHTML = /*icon*/ ctx[2];
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 4) g.innerHTML = /*icon*/ ctx[2];		},
		d(detaching) {
			if (detaching) detach(g);
		}
	};
}

// (45:4) 
function create_label_slot$1(ctx) {
	let span1;
	let t0;
	let span0;
	let t1;
	let span0_class_value;
	let span1_title_value;
	let span1_class_value;
	let current;
	let if_block = /*icon*/ ctx[2] && create_if_block$9(ctx);

	return {
		c() {
			span1 = element("span");
			if (if_block) if_block.c();
			t0 = space();
			span0 = element("span");
			t1 = text$1(/*currentLabel*/ ctx[8]);

			attr(span0, "class", span0_class_value = arrayJoin([
				"PinturaButtonLabel",
				/*labelClass*/ ctx[3],
				/*hideLabel*/ ctx[5] && "implicit"
			]));

			attr(span1, "slot", "label");
			attr(span1, "title", span1_title_value = localize(/*title*/ ctx[1], /*locale*/ ctx[6]));
			attr(span1, "class", span1_class_value = arrayJoin(["PinturaButtonInner", /*innerClass*/ ctx[4]]));
		},
		m(target, anchor) {
			insert(target, span1, anchor);
			if (if_block) if_block.m(span1, null);
			append(span1, t0);
			append(span1, span0);
			append(span0, t1);
			current = true;
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*icon*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$9(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(span1, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*currentLabel*/ 256) set_data(t1, /*currentLabel*/ ctx[8]);

			if (!current || dirty & /*labelClass, hideLabel*/ 40 && span0_class_value !== (span0_class_value = arrayJoin([
				"PinturaButtonLabel",
				/*labelClass*/ ctx[3],
				/*hideLabel*/ ctx[5] && "implicit"
			]))) {
				attr(span0, "class", span0_class_value);
			}

			if (!current || dirty & /*title, locale*/ 66 && span1_title_value !== (span1_title_value = localize(/*title*/ ctx[1], /*locale*/ ctx[6]))) {
				attr(span1, "title", span1_title_value);
			}

			if (!current || dirty & /*innerClass*/ 16 && span1_class_value !== (span1_class_value = arrayJoin(["PinturaButtonInner", /*innerClass*/ ctx[4]]))) {
				attr(span1, "class", span1_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span1);
			if (if_block) if_block.d();
		}
	};
}

// (52:4) 
function create_details_slot$1(ctx) {
	let div;
	let slider;
	let current;
	let mounted;
	let dispose;

	const slider_spread_levels = [
		/*$$restProps*/ ctx[11],
		{ value: /*value*/ ctx[7] },
		{ onchange: /*handleChangeValue*/ ctx[10] }
	];

	let slider_props = {};

	for (let i = 0; i < slider_spread_levels.length; i += 1) {
		slider_props = assign(slider_props, slider_spread_levels[i]);
	}

	slider = new Slider({ props: slider_props });

	return {
		c() {
			div = element("div");
			create_component(slider.$$.fragment);
			attr(div, "slot", "details");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(slider, div, null);
			current = true;

			if (!mounted) {
				dispose = listen(div, "keydown", /*handleKeydown*/ ctx[9]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			const slider_changes = (dirty & /*$$restProps, value, handleChangeValue*/ 3200)
			? get_spread_update(slider_spread_levels, [
					dirty & /*$$restProps*/ 2048 && get_spread_object(/*$$restProps*/ ctx[11]),
					dirty & /*value*/ 128 && { value: /*value*/ ctx[7] },
					dirty & /*handleChangeValue*/ 1024 && { onchange: /*handleChangeValue*/ ctx[10] }
				])
			: {};

			slider.$set(slider_changes);
		},
		i(local) {
			if (current) return;
			transition_in(slider.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(slider.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(slider);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$v(ctx) {
	let details;
	let current;

	details = new Details({
			props: {
				panelClass: "PinturaSliderPanel",
				buttonClass: arrayJoin([
					"PinturaSliderButton",
					/*klass*/ ctx[0],
					/*hideLabel*/ ctx[5] && "PinturaSliderIconOnly"
				]),
				$$slots: {
					details: [create_details_slot$1],
					label: [create_label_slot$1]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(details.$$.fragment);
		},
		m(target, anchor) {
			mount_component(details, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const details_changes = {};

			if (dirty & /*klass, hideLabel*/ 33) details_changes.buttonClass = arrayJoin([
				"PinturaSliderButton",
				/*klass*/ ctx[0],
				/*hideLabel*/ ctx[5] && "PinturaSliderIconOnly"
			]);

			if (dirty & /*$$scope, $$restProps, value, title, locale, innerClass, labelClass, hideLabel, currentLabel, icon*/ 264702) {
				details_changes.$$scope = { dirty, ctx };
			}

			details.$set(details_changes);
		},
		i(local) {
			if (current) return;
			transition_in(details.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(details.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(details, detaching);
		}
	};
}

function instance$v($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","title","label","icon","labelClass","innerClass","hideLabel","locale","value","onchange"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { class: klass = undefined } = $$props;
	let { title = undefined } = $$props;
	let { label = value => Math.round(value) } = $$props;
	let { icon = undefined } = $$props;
	let { labelClass = undefined } = $$props;
	let { innerClass = undefined } = $$props;
	let { hideLabel = false } = $$props;
	let { locale = undefined } = $$props;
	let { value = undefined } = $$props;
	let { onchange = noop$1 } = $$props;
	const { min, max, getValue = passthrough } = $$restProps;

	const handleKeydown = e => {
		// don't allow tabbing ([tab] is also blocked in normal <select>)
		if ((/tab/i).test(e.key)) e.preventDefault();
	};

	const getLabel = value => isFunction$1(label)
	? label(getValue(value), min, max)
	: label;

	let currentLabel = getLabel(value);

	const handleChangeValue = value => {
		$$invalidate(8, currentLabel = getLabel(value));
		onchange(value);
	};

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(0, klass = $$new_props.class);
		if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
		if ("label" in $$new_props) $$invalidate(12, label = $$new_props.label);
		if ("icon" in $$new_props) $$invalidate(2, icon = $$new_props.icon);
		if ("labelClass" in $$new_props) $$invalidate(3, labelClass = $$new_props.labelClass);
		if ("innerClass" in $$new_props) $$invalidate(4, innerClass = $$new_props.innerClass);
		if ("hideLabel" in $$new_props) $$invalidate(5, hideLabel = $$new_props.hideLabel);
		if ("locale" in $$new_props) $$invalidate(6, locale = $$new_props.locale);
		if ("value" in $$new_props) $$invalidate(7, value = $$new_props.value);
		if ("onchange" in $$new_props) $$invalidate(13, onchange = $$new_props.onchange);
	};

	return [
		klass,
		title,
		icon,
		labelClass,
		innerClass,
		hideLabel,
		locale,
		value,
		currentLabel,
		handleKeydown,
		handleChangeValue,
		$$restProps,
		label,
		onchange
	];
}

class ToggleSlider extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$v, create_fragment$v, safe_not_equal, {
			class: 0,
			title: 1,
			label: 12,
			icon: 2,
			labelClass: 3,
			innerClass: 4,
			hideLabel: 5,
			locale: 6,
			value: 7,
			onchange: 13
		});
	}
}

/* src/core/ui/components/DynamicComponentTree.svelte generated by Svelte v3.37.0 */

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i][0];
	child_ctx[8] = list[i][1];
	child_ctx[9] = list[i][2];
	child_ctx[0] = list[i][3] !== undefined ? list[i][3] : [];
	return child_ctx;
}

// (55:4) {:else}
function create_else_block$3(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*props*/ ctx[9]];
	var switch_value = /*ComponentMap*/ ctx[1][/*node*/ ctx[7]] || /*node*/ ctx[7];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props());
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty$1();
		},
		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = (dirty & /*children*/ 1)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[9])])
			: {};

			if (switch_value !== (switch_value = /*ComponentMap*/ ctx[1][/*node*/ ctx[7]] || /*node*/ ctx[7])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (45:4) {#if !isComponent(node)}
function create_if_block$8(ctx) {
	let tag;
	let current;

	tag = new Tag({
			props: {
				name: /*node*/ ctx[7],
				attributes: /*getElementAttributes*/ ctx[2](/*props*/ ctx[9]),
				$$slots: { default: [create_default_slot$b] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(tag.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tag, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const tag_changes = {};
			if (dirty & /*children*/ 1) tag_changes.name = /*node*/ ctx[7];
			if (dirty & /*children*/ 1) tag_changes.attributes = /*getElementAttributes*/ ctx[2](/*props*/ ctx[9]);

			if (dirty & /*$$scope, children*/ 4097) {
				tag_changes.$$scope = { dirty, ctx };
			}

			tag.$set(tag_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tag.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tag.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tag, detaching);
		}
	};
}

// (51:34) 
function create_if_block_3$5(ctx) {
	let html_tag;
	let raw_value = /*props*/ ctx[9].innerHTML + "";
	let html_anchor;

	return {
		c() {
			html_anchor = empty$1();
			html_tag = new HtmlTag(html_anchor);
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*children*/ 1 && raw_value !== (raw_value = /*props*/ ctx[9].innerHTML + "")) html_tag.p(raw_value);
		},
		i: noop$2,
		o: noop$2,
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (49:36) 
function create_if_block_2$7(ctx) {
	let t_value = /*props*/ ctx[9].textContent + "";
	let t;

	return {
		c() {
			t = text$1(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*children*/ 1 && t_value !== (t_value = /*props*/ ctx[9].textContent + "")) set_data(t, t_value);
		},
		i: noop$2,
		o: noop$2,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (47:8) {#if children.length}
function create_if_block_1$8(ctx) {
	let dynamiccomponenttree;
	let current;

	dynamiccomponenttree = new DynamicComponentTree_1({
			props: {
				items: /*children*/ ctx[0],
				discardEmptyItems: true
			}
		});

	return {
		c() {
			create_component(dynamiccomponenttree.$$.fragment);
		},
		m(target, anchor) {
			mount_component(dynamiccomponenttree, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const dynamiccomponenttree_changes = {};
			if (dirty & /*children*/ 1) dynamiccomponenttree_changes.items = /*children*/ ctx[0];
			dynamiccomponenttree.$set(dynamiccomponenttree_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dynamiccomponenttree.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dynamiccomponenttree.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(dynamiccomponenttree, detaching);
		}
	};
}

// (46:8) <Tag name={node} attributes={getElementAttributes(props)}>
function create_default_slot$b(ctx) {
	let current_block_type_index;
	let if_block;
	let t;
	let current;
	const if_block_creators = [create_if_block_1$8, create_if_block_2$7, create_if_block_3$5];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*children*/ ctx[0].length) return 0;
		if (/*props*/ ctx[9].textContent) return 1;
		if (/*props*/ ctx[9].innerHTML) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, t, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(t);
		}
	};
}

// (44:0) {#each children as [node, key, props, children = []] (key) }
function create_each_block$6(key_1, ctx) {
	let first;
	let show_if;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$8, create_else_block$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty & /*children*/ 1) show_if = !!!/*isComponent*/ ctx[3](/*node*/ ctx[7]);
		if (show_if) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		key: key_1,
		first: null,
		c() {
			first = empty$1();
			if_block.c();
			if_block_anchor = empty$1();
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$u(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value = /*children*/ ctx[0];
	const get_key = ctx => /*key*/ ctx[8];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$6(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$6(key, child_ctx));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty$1();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*children, getElementAttributes, isComponent, ComponentMap*/ 15) {
				each_value = /*children*/ ctx[0];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$6, each_1_anchor, get_each_context$6);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach(each_1_anchor);
		}
	};
}

function instance$u($$self, $$props, $$invalidate) {
	let children;
	let { items } = $$props;
	let { discardEmptyItems = true } = $$props;
	const ComponentMap = { Button, Dropdown, "Slider": ToggleSlider };

	const getElementAttributes = (props = {}) => {
		const { textContent, innerHTML, ...attributes } = props;
		return attributes;
	};

	const isComponent = node => !isString(node) || !!ComponentMap[node];

	const shouldRenderItem = item => {
		// don't render falsy items
		if (!item) return false;

		// get relevant props
		const [node, ,props, children = []] = item;

		// if item is component, we always render it
		if (isComponent(node)) return true;

		// item is tag, we have to check if it has content
		return children.some(shouldRenderItem) || props.textContent || props.innerHTML;
	};

	$$self.$$set = $$props => {
		if ("items" in $$props) $$invalidate(4, items = $$props.items);
		if ("discardEmptyItems" in $$props) $$invalidate(5, discardEmptyItems = $$props.discardEmptyItems);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*items, discardEmptyItems*/ 48) {
			$$invalidate(0, children = (items && discardEmptyItems
			? items.filter(shouldRenderItem)
			: items) || []);
		}
	};

	return [
		children,
		ComponentMap,
		getElementAttributes,
		isComponent,
		items,
		discardEmptyItems
	];
}

class DynamicComponentTree_1 extends SvelteComponent {
	constructor(options) {
		super();
		init$3(this, options, instance$u, create_fragment$u, safe_not_equal, { items: 4, discardEmptyItems: 5 });
	}
}

const ImageStoreProps = [
    'file',
    'size',
    'loadState',
    'processState',
    'cropAspectRatio',
    'cropLimitToImage',
    'crop',
    'cropMinSize',
    'cropMaxSize',
    'cropRange',
    'cropOrigin',
    'cropRectAspectRatio',
    'rotation',
    'rotationRange',
    'targetSize',
    'flipX',
    'flipY',
    'perspectiveX',
    'perspectiveY',
    'perspective',
    'colorMatrix',
    'convolutionMatrix',
    'gamma',
    'vignette',
    'noise',
    'decoration',
    'annotation',
    'frame',
    'backgroundColor',
    'state',
];
const proxy = function (get, set, update) {
    let subscribers = [];
    return {
        set,
        update,
        publish: (value) => {
            subscribers.forEach((cb) => cb(value));
        },
        subscribe: (cb) => {
            subscribers.push(cb);
            get(cb);
            return () => {
                subscribers = subscribers.filter((item) => item !== cb);
            };
        },
    };
};
var createImageProxy = () => {
    let unsubs;
    let image;
    const proxyStores = ImageStoreProps.reduce((prev, curr) => {
        prev[curr] = proxy(
        // getter
        (cb) => {
            // subscribe
            if (!image)
                return cb();
            const unsub = image.stores[curr].subscribe(cb);
            unsub();
        }, 
        // setter
        (value) => {
            // set value on actual store if is defined
            if (!image)
                return;
            image.stores[curr].set(value);
        }, 
        // updater
        (cb) => {
            if (!image)
                return;
            image.stores[curr].update(cb);
        });
        return prev;
    }, {});
    const update = (newImage) => {
        image = newImage;
        if (unsubs) {
            // remove subscribers
            unsubs.forEach((unsub) => unsub());
            unsubs = undefined;
        }
        if (!newImage) {
            // need to reset load state
            proxyStores['file'].publish(undefined);
            proxyStores['loadState'].publish(undefined);
            return;
        }
        unsubs = ImageStoreProps.map((prop) => newImage.stores[prop].subscribe((value) => {
            proxyStores[prop].publish(value);
        }));
    };
    return {
        update,
        stores: proxyStores,
    };
};

var createPingRouter = (route, cancel = true) => (e) => {
    if (e.type !== 'ping')
        return;
    if (cancel)
        e.stopPropagation();
    route(e.detail.type, e.detail.data);
};

var isTextarea = (element) => /textarea/i.test(element.nodeName);

var isTextInput = (node) => /date|email|number|search|text|url/.test(node.type);

var isTextField = (node) => isTextarea(node) || isTextInput(node);

var toKebabCase = (str, abbr) => {
    return (abbr ? stringReplace(str, abbr) : str)
        .replace(/([a-z])([A-Z])/g, '$1-$2')
        .replace(/\s+/g, '-')
        .toLowerCase();
};

let result$5 = null;
var supportsPointerEvents = () => {
    if (result$5 === null) {
        result$5 = isBrowser() && 'onpointerdown' in window$1;
    }
    return result$5;
};

var matchMedia$1 = (query, cb) => {
    const mql = matchMedia(query);
    mql.addListener(cb);
    cb(mql);
    return {
        get matches() { return mql.matches; },
        destroy: () => mql.removeListener(cb)
    };
};

var mediaQueryStore = (query, formatValue = passthrough) => {
    const { subscribe, set } = writable(undefined);
    const mm = matchMedia$1(query, ({ matches }) => set(formatValue(matches)));
    return {
        subscribe,
        unsubscribe: mm.destroy
    };
};

var canPreventNavSwipe = () => {
    // if not iOS we can't prevent swipe because it probably isn't a thing
    if (!isIOS())
        return false;
    // extract version number
    const matches = navigator.userAgent.match(/OS (\d+)_(\d+)_?(\d+)?/i) || [];
    const [, major, minor] = matches.map((v) => parseInt(v, 10) || 0);
    // is atleast version 13.4+
    return major > 13 || (major === 13 && minor >= 4);
};

var calculateImageTransforms = (stageRect, rootRect, imageSize, cropRect, imageSelectionRect, imageScale, imagePerspectiveX, imagePerspectiveY, imageRotation, imageFlipX, imageFlipY) => {
    if (!stageRect || !rootRect || !imageSize || !cropRect || !imageScale)
        return undefined;
    const viewRect = rectNormalizeOffset(rectClone(rootRect));
    const viewCenter = rectCenter(viewRect);
    const stageCenter = rectCenter(stageRect);
    const imageRect = rectCreateFromSize(imageSize);
    const imageCenter = rectCenter(imageRect);
    const imagePerspective = vectorCreate(imagePerspectiveX, imagePerspectiveY);
    // get base crop rect so we can correctly apply transforms
    const cropRectBase = getBaseCropRect(imageSize, cropRect, imageRotation);
    const cropRectBaseCenter = rectCenter(cropRectBase);
    const imageTranslation = vectorSubtract(vectorClone(imageCenter), cropRectBaseCenter);
    // calculate stage center offset from view center
    const imageOffset = vectorSubtract(vectorClone(stageCenter), viewCenter);
    // correct for stage offset
    imageTranslation.x += imageOffset.x;
    imageTranslation.y += imageOffset.y;
    // set origin of translation (so rotates around center of selection)
    const imageOrigin = vectorInvert(vectorClone(imageTranslation));
    // correct for stage offset
    imageOrigin.x += imageOffset.x;
    imageOrigin.y += imageOffset.y;
    // correct for image selection offset relative to view
    const imageSelectionCenter = rectCenter(rectTranslate(rectClone(imageSelectionRect), stageRect));
    const imageSelectionOffset = vectorSubtract(imageSelectionCenter, stageCenter);
    vectorAdd(imageTranslation, imageSelectionOffset);
    return {
        // offset: imageOffset,
        origin: imageOrigin,
        translation: imageTranslation,
        rotation: {
            x: imageFlipY ? Math.PI : 0,
            y: imageFlipX ? Math.PI : 0,
            z: imageRotation,
        },
        perspective: imagePerspective,
        scale: imageScale,
    };
};

// @ts-ignore
var historyCreate = (getState, setState) => {
    // set up pub/sub for history object
    const { sub, pub } = pubsub();
    // current history state
    //let baseState;//
    const entries = [];
    const index = writable(0);
    const subs = [];
    const updateSubs = () => subs.forEach((cb) => cb({ index: get_store_value(index), length: entries.length }));
    const history = {
        get index() {
            return get_store_value(index);
        },
        set index(i) {
            // validate new index
            i = Number.isInteger(i) ? i : 0;
            i = clamp(i, 0, entries.length - 1);
            // remember
            index.set(i);
            setState(entries[history.index]); // || baseState);
            // update subs
            updateSubs();
        },
        get state() {
            return entries[entries.length - 1]; // || baseState;
        },
        length() {
            return entries.length;
        },
        undo() {
            const newIndex = history.index--;
            pub('undo', newIndex);
            return newIndex;
        },
        redo() {
            const newIndex = history.index++;
            pub('redo', history.index);
            return newIndex;
        },
        revert() {
            entries.length = 1; // retain first state
            history.index = 0;
            pub('revert');
        },
        write(state) {
            // write history entry
            if (state) {
                setState({
                    ...getState(),
                    ...state,
                });
            }
            const newState = getState();
            const lastState = entries[entries.length - 1];
            // don't update if new state isn't different
            if (JSON.stringify(newState) === JSON.stringify(lastState))
                return;
            // reset length to current index
            entries.length = history.index + 1;
            // add new entry
            entries.push(newState);
            // move pointer to last added index
            index.set(entries.length - 1);
            updateSubs();
        },
        set(state = {}) {
            // set clears all entries
            entries.length = 0;
            history.index = 0;
            // set new entries
            const newStateEntries = !Array.isArray(state) ? [state] : state;
            // if (!Array.isArray(state)) {
            // add new entries
            entries.push(...newStateEntries);
            // move pointer to last added index
            history.index = entries.length - 1;
        },
        get() {
            return [...entries];
        },
        subscribe(cb) {
            subs.push(cb);
            cb({ index: history.index, length: entries.length });
            return () => subs.splice(subs.indexOf(cb), 1);
        },
        on: sub,
    };
    return history;
};

var isChrome = () => isBrowser() && !!window$1['chrome'];

var imageBitmapToImageData = async (imageBitmap) => canvasToImageData(await imageDataToCanvas(imageBitmap));

var blobToImageBitmap = (file, ImageOrienter, canvasMemoryLimit) => new Promise(async (resolve, reject) => {
    // get orientation of image, should return 1 for normal orientation
    const orientation = await ImageOrienter.read(file);
    // helper method to apply orientation fix if needed
    const toImageData = (file) => blobToImageData(file, canvasMemoryLimit)
        .then((imageData) => ImageOrienter.apply(imageData, orientation))
        .then(resolve)
        .catch(reject);
    // cannot create image bitmaps in worker
    if (!canCreateImageBitmap() || isSVGFile(file))
        return toImageData(file);
    // create image bitmap in thread
    let imageBitmap;
    try {
        imageBitmap = await thread((file, done) => createImageBitmap(file)
            .then((bitmap) => done(null, bitmap))
            .catch(done), [file]);
    }
    catch (err) {
        // fails silently on purpose, we'll try to turn the blob into image data in the main thread
        // console.error(err);
    }
    // no bitmap returned, something went wrong in `createImageBitmap` logic
    if (!imageBitmap || !imageBitmap.width)
        return toImageData(file);
    // if the browser can't orient images, we need to correct the orientation now
    if (!(await canOrientImages()))
        return resolve(ImageOrienter.apply(imageBitmap, orientation));
    // need to convert so oriented image can be used as WebGL texture
    // converting ImageBitmap to <canvas> (and then optionally to image data) fixes a Chrome render bug where the
    // ImageBitmap when used in WebGL doesn't render in the correct orientation
    // https://bugs.chromium.org/p/chromium/issues/detail?id=1082451&q=orientation%20imagebitmap&can=2
    if (isChrome() && orientation > 1)
        return resolve(await imageBitmapToImageData(imageBitmap));
    // yay we got our bitmap
    resolve(imageBitmap);
});

var imageDataContain = (imageData, size) => new Promise(async (resolve) => {
    if (imageData.width < size.width && imageData.height < size.height)
        return resolve(imageData);
    const scalar = Math.min(size.width / imageData.width, size.height / imageData.height);
    // scale
    const targetWidth = scalar * imageData.width;
    const targetHeight = scalar * imageData.height;
    const canvas = h$1('canvas', {
        width: targetWidth,
        height: targetHeight,
    });
    const ctx = canvas.getContext('2d');
    const data = isImageData(imageData)
        ? (await imageDataToCanvas(imageData))
        : imageData;
    ctx.drawImage(data, 0, 0, targetWidth, targetHeight);
    resolve(canvasToImageData(canvas));
});

let limit = null;
var getWebGLTextureSizeLimit = () => {
    if (limit !== null)
        return limit;
    const canvas = h$1('canvas');
    const gl = getWebGLContext(canvas);
    limit = gl ? gl.getParameter(gl.MAX_TEXTURE_SIZE) : undefined;
    releaseCanvas(canvas);
    return limit;
};

var hexToRGB = (str) => {
    const [, q, w, e] = str.split('');
    str = str.length === 4 ? `#${q}${q}${w}${w}${e}${e}` : str;
    const [, r, g, b] = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(str);
    return [r, g, b].map((v) => parseInt(v, 16) / 255);
};

var colorStringToColorArray = (color) => {
    color = color.trim();
    // if rgba(128, 128, 128, .5)
    if (/^rgba/.test(color)) {
        return color
            .substr(5)
            .split(',')
            .map(parseFloat)
            .map((v, i) => v / (i === 3 ? 1 : 255));
    }
    // if rgb(128, 128, 128)
    if (/^rgb/.test(color)) {
        return color
            .substr(4)
            .split(',')
            .map(parseFloat)
            .map((v) => v / 255);
    }
    // if #777
    if (/^#/.test(color)) {
        return hexToRGB(color);
    }
    // is possibly 255, 0, 0
    if (/[0-9]{1,3}\s?,\s?[0-9]{1,3}\s?,\s?[0-9]{1,3}/.test(color)) {
        return color
            .split(',')
            .map((v) => parseInt(v, 10))
            .map((v) => v / 255);
    }
};

let result$4 = null;
var supportsWebGL = () => {
    if (result$4 === null) {
        const canvas = h$1('canvas');
        result$4 = !!getWebGLContext(canvas);
        releaseCanvas(canvas);
    }
    return result$4;
};

var isBitmap = (file) => /^image/.test(file.type) && !/svg/.test(file.type);

// @ts-ignore
const COLOR_MATRIX_IDENTITY = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
const SPRING_PROPS = { precision: 0.0001 };
const SPRING_PROPS_FRACTION = { precision: SPRING_PROPS.precision * 0.01 };
var createImage = (data, size, options = {}) => {
    const { resize: resizeInitial = 1, opacity: opacityInitial = 0 } = options;
    const stores = {
        // interface
        opacity: [spring$2(opacityInitial, { ...SPRING_PROPS, stiffness: 0.1 }), passthrough],
        resize: [spring$2(resizeInitial, { ...SPRING_PROPS, stiffness: 0.1 }), passthrough],
        // transforms
        translation: [spring$2(undefined, SPRING_PROPS), passthrough],
        rotation: [spring$2(undefined, SPRING_PROPS_FRACTION), passthrough],
        origin: [spring$2(undefined, SPRING_PROPS), passthrough],
        scale: [spring$2(undefined, SPRING_PROPS_FRACTION), passthrough],
        gamma: [spring$2(undefined, SPRING_PROPS_FRACTION), (v) => v || 1],
        vignette: [spring$2(undefined, SPRING_PROPS_FRACTION), (v) => v || 0],
        colorMatrix: [
            spring$2([...COLOR_MATRIX_IDENTITY], SPRING_PROPS),
            (v) => v || [...COLOR_MATRIX_IDENTITY],
        ],
        convolutionMatrix: [writable(undefined), (v) => (v && v.clarity) || undefined],
        backgroundColor: [spring$2(undefined, SPRING_PROPS), passthrough],
    };
    // shortcut to quickly get all stores from the stores object
    const storeEntries = Object.entries(stores).map(([key, value]) => [key, value[0]]);
    const storeArray = storeEntries.map(([, store]) => store);
    // create quick accessors to store value setter functions, best to do ones on creation instead of on each update
    const storeSetters = Object.entries(stores).reduce((prev, [key, value]) => {
        const [store, getValue] = value;
        prev[key] = (value, opts) => store.set(getValue(value), opts);
        return prev;
    }, {});
    // holds current derived state so can be easily read from from the outside
    let stateCache;
    //
    const state = derived(storeArray, (storeValues) => {
        // get new state
        stateCache = storeValues.reduce((calculatedState, value, index) => {
            const key = storeEntries[index][0];
            calculatedState[key] = value;
            return calculatedState;
        }, {});
        // set base image props
        stateCache.data = data;
        stateCache.size = size;
        // apply resize modifier (is at index 1 of storeValues)
        stateCache.scale *= storeValues[1];
        return stateCache;
    });
    state.get = () => stateCache;
    state.set = (props, animate) => {
        const opts = { hard: !animate };
        Object.entries(props).forEach(([key, value]) => {
            if (!storeSetters[key])
                return;
            storeSetters[key](value, opts);
        });
    };
    return state;
};

var storeList = () => {
    const stores = [];
    const subscribers = [];
    const state = [];
    const storeDidUpdate = (store, value) => {
        const index = stores.indexOf(store);
        if (index < 0)
            return;
        state[index] = value;
        triggerUpdate();
    };
    const triggerUpdate = () => {
        subscribers.forEach((fn) => fn(state));
    };
    const addStore = (store) => {
        store.unsub = store.subscribe((value) => storeDidUpdate(store, value));
        triggerUpdate();
    };
    const unshift = (store) => {
        stores.unshift(store);
        addStore(store);
    };
    const push = (store) => {
        stores.push(store);
        addStore(store);
    };
    const clear = () => {
        stores.forEach((store) => store.unsub());
        stores.length = 0;
        state.length = 0;
    };
    const remove = (store) => {
        store.unsub();
        const index = stores.indexOf(store);
        stores.splice(index, 1);
        state.splice(index, 1);
    };
    const subscribe = (fn) => {
        subscribers.push(fn);
        return () => {
            subscribers.splice(subscribers.indexOf(fn), 1);
        };
    };
    const forEach = (fn) => stores.forEach(fn);
    const filter = (fn) => stores.filter(fn);
    const get = (index) => stores[index];
    return {
        get length() {
            return stores.length;
        },
        clear,
        unshift,
        get,
        push,
        remove,
        forEach,
        filter,
        subscribe,
    };
};

var isDarkColor = (color) => {
    return color[0] < 0.25 && color[1] < 0.25 && color[2] < 0.25;
};

var smoothstep = (min, max, value, ease = (x) => x * x * (3 - 2 * x)) => ease(Math.max(0, Math.min(1, (value - min) / (max - min))));

/* src/core/ui/index.svelte generated by Svelte v3.37.0 */

const { window: window_1 } = globals;

function create_if_block_1$7(ctx) {
	let t;
	let if_block1_anchor;
	let current;
	let if_block0 = /*isStatusVisible*/ ctx[25] && create_if_block_6$1(ctx);
	let if_block1 = /*$imagePreview*/ ctx[22] && !/*isSupportsError*/ ctx[23] && create_if_block_2$6(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty$1();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*isStatusVisible*/ ctx[25]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*isStatusVisible*/ 33554432) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_6$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*$imagePreview*/ ctx[22] && !/*isSupportsError*/ ctx[23]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*$imagePreview, isSupportsError*/ 12582912) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2$6(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (2200:2) {#if isStatusVisible}
function create_if_block_6$1(ctx) {
	let div;
	let p;
	let current_block_type_index;
	let if_block;
	let div_style_value;
	let current;
	const if_block_creators = [create_if_block_7, create_if_block_8];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isSupportsError*/ ctx[23]) return 0;
		if (/*statusState*/ ctx[12]) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			div = element("div");
			p = element("p");
			if (if_block) if_block.c();
			attr(p, "style", /*statusTransform*/ ctx[36]);
			attr(div, "class", "PinturaStatus");
			attr(div, "style", div_style_value = `opacity: ${/*$statusOpacity*/ ctx[24]}`);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, p);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(p, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(p, null);
				} else {
					if_block = null;
				}
			}

			if (!current || dirty[1] & /*statusTransform*/ 32) {
				attr(p, "style", /*statusTransform*/ ctx[36]);
			}

			if (!current || dirty[0] & /*$statusOpacity*/ 16777216 && div_style_value !== (div_style_value = `opacity: ${/*$statusOpacity*/ ctx[24]}`)) {
				attr(div, "style", div_style_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}
		}
	};
}

// (2212:25) 
function create_if_block_8(ctx) {
	let statusmessage;
	let t;
	let if_block_anchor;
	let current;

	statusmessage = new StatusMessage({
			props: {
				text: /*statusState*/ ctx[12].text || "",
				onmeasure: /*offsetAside*/ ctx[123]
			}
		});

	let if_block = /*statusState*/ ctx[12].aside && create_if_block_9(ctx);

	return {
		c() {
			create_component(statusmessage.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty$1();
		},
		m(target, anchor) {
			mount_component(statusmessage, target, anchor);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const statusmessage_changes = {};
			if (dirty[0] & /*statusState*/ 4096) statusmessage_changes.text = /*statusState*/ ctx[12].text || "";
			statusmessage.$set(statusmessage_changes);

			if (/*statusState*/ ctx[12].aside) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*statusState*/ 4096) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_9(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(statusmessage.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(statusmessage.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			destroy_component(statusmessage, detaching);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (2204:3) {#if isSupportsError}
function create_if_block_7(ctx) {
	let statusmessage;
	let t;
	let statusaside;
	let current;

	statusmessage = new StatusMessage({
			props: {
				text: /*isSupportsError*/ ctx[23],
				onmeasure: /*offsetAside*/ ctx[123]
			}
		});

	statusaside = new StatusAside({
			props: {
				class: "PinturaStatusIcon",
				offset: /*$asideOffset*/ ctx[42],
				opacity: /*$asideOpacity*/ ctx[43],
				$$slots: { default: [create_default_slot_4$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(statusmessage.$$.fragment);
			t = space();
			create_component(statusaside.$$.fragment);
		},
		m(target, anchor) {
			mount_component(statusmessage, target, anchor);
			insert(target, t, anchor);
			mount_component(statusaside, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const statusmessage_changes = {};
			if (dirty[0] & /*isSupportsError*/ 8388608) statusmessage_changes.text = /*isSupportsError*/ ctx[23];
			statusmessage.$set(statusmessage_changes);
			const statusaside_changes = {};
			if (dirty[1] & /*$asideOffset*/ 2048) statusaside_changes.offset = /*$asideOffset*/ ctx[42];
			if (dirty[1] & /*$asideOpacity*/ 4096) statusaside_changes.opacity = /*$asideOpacity*/ ctx[43];

			if (dirty[0] & /*locale*/ 4 | dirty[11] & /*$$scope*/ 16) {
				statusaside_changes.$$scope = { dirty, ctx };
			}

			statusaside.$set(statusaside_changes);
		},
		i(local) {
			if (current) return;
			transition_in(statusmessage.$$.fragment, local);
			transition_in(statusaside.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(statusmessage.$$.fragment, local);
			transition_out(statusaside.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(statusmessage, detaching);
			if (detaching) detach(t);
			destroy_component(statusaside, detaching);
		}
	};
}

// (2216:4) {#if statusState.aside }
function create_if_block_9(ctx) {
	let statusaside;
	let current;

	statusaside = new StatusAside({
			props: {
				class: "PinturaStatusButton",
				offset: /*$asideOffset*/ ctx[42],
				opacity: /*$asideOpacity*/ ctx[43],
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(statusaside.$$.fragment);
		},
		m(target, anchor) {
			mount_component(statusaside, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const statusaside_changes = {};
			if (dirty[1] & /*$asideOffset*/ 2048) statusaside_changes.offset = /*$asideOffset*/ ctx[42];
			if (dirty[1] & /*$asideOpacity*/ 4096) statusaside_changes.opacity = /*$asideOpacity*/ ctx[43];

			if (dirty[0] & /*statusState*/ 4096 | dirty[11] & /*$$scope*/ 16) {
				statusaside_changes.$$scope = { dirty, ctx };
			}

			statusaside.$set(statusaside_changes);
		},
		i(local) {
			if (current) return;
			transition_in(statusaside.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(statusaside.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(statusaside, detaching);
		}
	};
}

// (2219:5) {#if statusState.progressIndicator.visible}
function create_if_block_11(ctx) {
	let progressindicator;
	let current;

	progressindicator = new ProgressIndicator({
			props: {
				progress: /*statusState*/ ctx[12].progressIndicator.progress
			}
		});

	return {
		c() {
			create_component(progressindicator.$$.fragment);
		},
		m(target, anchor) {
			mount_component(progressindicator, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const progressindicator_changes = {};
			if (dirty[0] & /*statusState*/ 4096) progressindicator_changes.progress = /*statusState*/ ctx[12].progressIndicator.progress;
			progressindicator.$set(progressindicator_changes);
		},
		i(local) {
			if (current) return;
			transition_in(progressindicator.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(progressindicator.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(progressindicator, detaching);
		}
	};
}

// (2223:5) {#if statusState.closeButton && statusState.text}
function create_if_block_10(ctx) {
	let button;
	let current;
	const button_spread_levels = [/*statusState*/ ctx[12].closeButton, { hideLabel: true }];
	let button_props = {};

	for (let i = 0; i < button_spread_levels.length; i += 1) {
		button_props = assign(button_props, button_spread_levels[i]);
	}

	button = new Button({ props: button_props });

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = (dirty[0] & /*statusState*/ 4096)
			? get_spread_update(button_spread_levels, [
					get_spread_object(/*statusState*/ ctx[12].closeButton),
					button_spread_levels[1]
				])
			: {};

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (2217:4) <StatusAside class="PinturaStatusButton" offset={$asideOffset} opacity={$asideOpacity}>
function create_default_slot_6(ctx) {
	let t;
	let if_block1_anchor;
	let current;
	let if_block0 = /*statusState*/ ctx[12].progressIndicator.visible && create_if_block_11(ctx);
	let if_block1 = /*statusState*/ ctx[12].closeButton && /*statusState*/ ctx[12].text && create_if_block_10(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty$1();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*statusState*/ ctx[12].progressIndicator.visible) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*statusState*/ 4096) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_11(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*statusState*/ ctx[12].closeButton && /*statusState*/ ctx[12].text) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*statusState*/ 4096) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_10(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (2209:5) <Icon>
function create_default_slot_5(ctx) {
	let g;
	let raw_value = /*locale*/ ctx[2].iconSupportError + "";

	return {
		c() {
			g = svg_element("g");
		},
		m(target, anchor) {
			insert(target, g, anchor);
			g.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*locale*/ 4 && raw_value !== (raw_value = /*locale*/ ctx[2].iconSupportError + "")) g.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) detach(g);
		}
	};
}

// (2208:4) <StatusAside class="PinturaStatusIcon" offset={$asideOffset} opacity={$asideOpacity}>
function create_default_slot_4$1(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(icon.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const icon_changes = {};

			if (dirty[0] & /*locale*/ 4 | dirty[11] & /*$$scope*/ 16) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon, detaching);
		}
	};
}

// (2235:2) {#if $imagePreview && !isSupportsError}
function create_if_block_2$6(ctx) {
	let t0;
	let t1;
	let current_block_type_index;
	let if_block2;
	let t2;
	let canvas;
	let t3;
	let div;
	let current;
	let if_block0 = /*enableToolbar*/ ctx[6] && create_if_block_5$3(ctx);
	let if_block1 = /*shouldRenderTabs*/ ctx[16] && /*showUtils*/ ctx[14] && create_if_block_4$4(ctx);
	const if_block_creators = [create_if_block_3$4, create_else_block$2];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*shouldRenderTabs*/ ctx[16]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	canvas = new Canvas({
			props: {
				animate: /*$shouldAnimate*/ ctx[17],
				pixelRatio: /*$pixelRatio*/ ctx[46],
				backgroundColor: /*$rootBackgroundColor*/ ctx[47],
				maskRect: /*$imageSelectionRectPresentation*/ ctx[35],
				maskOpacity: /*imageCanvasState*/ ctx[34]
				? /*imageCanvasState*/ ctx[34].maskOpacity
				: 1,
				maskFrameOpacity: /*$utilSelectedStore*/ ctx[48] === "frame" && /*$stagePadded*/ ctx[49]
				? 0
				: 0.95,
				images: /*$activeImages*/ ctx[19],
				interfaceImages: /*$interfaceImages*/ ctx[50],
				loadImageData: /*imageSourceToImageData*/ ctx[8],
				willRender: /*func_2*/ ctx[261]
			}
		});

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if_block2.c();
			t2 = space();
			create_component(canvas.$$.fragment);
			t3 = space();
			div = element("div");
			attr(div, "class", "PinturaRootPortal");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, t2, anchor);
			mount_component(canvas, target, anchor);
			insert(target, t3, anchor);
			insert(target, div, anchor);
			/*div_binding*/ ctx[262](div);
			current = true;
		},
		p(ctx, dirty) {
			if (/*enableToolbar*/ ctx[6]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*enableToolbar*/ 64) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_5$3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*shouldRenderTabs*/ ctx[16] && /*showUtils*/ ctx[14]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*shouldRenderTabs, showUtils*/ 81920) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_4$4(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(t2.parentNode, t2);
			}

			const canvas_changes = {};
			if (dirty[0] & /*$shouldAnimate*/ 131072) canvas_changes.animate = /*$shouldAnimate*/ ctx[17];
			if (dirty[1] & /*$pixelRatio*/ 32768) canvas_changes.pixelRatio = /*$pixelRatio*/ ctx[46];
			if (dirty[1] & /*$rootBackgroundColor*/ 65536) canvas_changes.backgroundColor = /*$rootBackgroundColor*/ ctx[47];
			if (dirty[1] & /*$imageSelectionRectPresentation*/ 16) canvas_changes.maskRect = /*$imageSelectionRectPresentation*/ ctx[35];

			if (dirty[1] & /*imageCanvasState*/ 8) canvas_changes.maskOpacity = /*imageCanvasState*/ ctx[34]
			? /*imageCanvasState*/ ctx[34].maskOpacity
			: 1;

			if (dirty[1] & /*$utilSelectedStore, $stagePadded*/ 393216) canvas_changes.maskFrameOpacity = /*$utilSelectedStore*/ ctx[48] === "frame" && /*$stagePadded*/ ctx[49]
			? 0
			: 0.95;

			if (dirty[0] & /*$activeImages*/ 524288) canvas_changes.images = /*$activeImages*/ ctx[19];
			if (dirty[1] & /*$interfaceImages*/ 524288) canvas_changes.interfaceImages = /*$interfaceImages*/ ctx[50];
			if (dirty[0] & /*imageSourceToImageData*/ 256) canvas_changes.loadImageData = /*imageSourceToImageData*/ ctx[8];
			if (dirty[0] & /*willRenderCanvas*/ 32 | dirty[1] & /*$imageAnnotation, $imageDecoration, $imageFrame, $imageOverlay*/ 15728640) canvas_changes.willRender = /*func_2*/ ctx[261];
			canvas.$set(canvas_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(canvas.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(canvas.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t1);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(t2);
			destroy_component(canvas, detaching);
			if (detaching) detach(t3);
			if (detaching) detach(div);
			/*div_binding*/ ctx[262](null);
		}
	};
}

// (2237:3) {#if enableToolbar}
function create_if_block_5$3(ctx) {
	let div;
	let dynamiccomponenttree;
	let current;
	let mounted;
	let dispose;

	dynamiccomponenttree = new DynamicComponentTree_1({
			props: { items: /*toolbarItems*/ ctx[39] }
		});

	return {
		c() {
			div = element("div");
			create_component(dynamiccomponenttree.$$.fragment);
			attr(div, "class", "PinturaNav PinturaNavTools");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(dynamiccomponenttree, div, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "measure", /*measure_handler*/ ctx[246]),
					action_destroyer(measurable.call(null, div))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			const dynamiccomponenttree_changes = {};
			if (dirty[1] & /*toolbarItems*/ 256) dynamiccomponenttree_changes.items = /*toolbarItems*/ ctx[39];
			dynamiccomponenttree.$set(dynamiccomponenttree_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dynamiccomponenttree.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dynamiccomponenttree.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(dynamiccomponenttree);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (2243:3) {#if shouldRenderTabs && showUtils }
function create_if_block_4$4(ctx) {
	let div;
	let scrollable;
	let current;

	scrollable = new Scrollable({
			props: {
				elasticity: /*elasticityMultiplier*/ ctx[4] * scrollElasticity,
				scrollDirection: /*isLandscape*/ ctx[32] ? "y" : "x",
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(scrollable.$$.fragment);
			attr(div, "class", "PinturaNav PinturaNavMain");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(scrollable, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const scrollable_changes = {};
			if (dirty[0] & /*elasticityMultiplier*/ 16) scrollable_changes.elasticity = /*elasticityMultiplier*/ ctx[4] * scrollElasticity;
			if (dirty[1] & /*isLandscape*/ 2) scrollable_changes.scrollDirection = /*isLandscape*/ ctx[32] ? "y" : "x";

			if (dirty[0] & /*tabsConfig, tabs, utilSelected*/ 805568512 | dirty[11] & /*$$scope*/ 16) {
				scrollable_changes.$$scope = { dirty, ctx };
			}

			scrollable.$set(scrollable_changes);
		},
		i(local) {
			if (current) return;
			transition_in(scrollable.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(scrollable.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(scrollable);
		}
	};
}

// (2247:6) <Icon>
function create_default_slot_3$1(ctx) {
	let g;
	let raw_value = /*tab*/ ctx[344].icon + "";

	return {
		c() {
			g = svg_element("g");
		},
		m(target, anchor) {
			insert(target, g, anchor);
			g.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty[11] & /*tab*/ 8 && raw_value !== (raw_value = /*tab*/ ctx[344].icon + "")) g.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) detach(g);
		}
	};
}

// (2246:5) <TabList {...tabsConfig} {tabs} on:select={({ detail }) => utilSelected = detail} let:tab={tab}>
function create_default_slot_2$3(ctx) {
	let icon;
	let t0;
	let span;
	let t1_value = /*tab*/ ctx[344].label + "";
	let t1;
	let current;

	icon = new Icon({
			props: {
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(icon.$$.fragment);
			t0 = space();
			span = element("span");
			t1 = text$1(t1_value);
		},
		m(target, anchor) {
			mount_component(icon, target, anchor);
			insert(target, t0, anchor);
			insert(target, span, anchor);
			append(span, t1);
			current = true;
		},
		p(ctx, dirty) {
			const icon_changes = {};

			if (dirty[11] & /*$$scope, tab*/ 24) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
			if ((!current || dirty[11] & /*tab*/ 8) && t1_value !== (t1_value = /*tab*/ ctx[344].label + "")) set_data(t1, t1_value);
		},
		i(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon, detaching);
			if (detaching) detach(t0);
			if (detaching) detach(span);
		}
	};
}

// (2245:4) <Scrollable elasticity={elasticityMultiplier * scrollElasticity} scrollDirection={isLandscape ? 'y' : 'x'}>
function create_default_slot_1$4(ctx) {
	let tablist;
	let current;
	const tablist_spread_levels = [/*tabsConfig*/ ctx[28], { tabs: /*tabs*/ ctx[29] }];

	let tablist_props = {
		$$slots: {
			default: [
				create_default_slot_2$3,
				({ tab }) => ({ 344: tab }),
				({ tab }) => [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, tab ? 8 : 0]
			]
		},
		$$scope: { ctx }
	};

	for (let i = 0; i < tablist_spread_levels.length; i += 1) {
		tablist_props = assign(tablist_props, tablist_spread_levels[i]);
	}

	tablist = new TabList({ props: tablist_props });
	tablist.$on("select", /*select_handler*/ ctx[247]);

	return {
		c() {
			create_component(tablist.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tablist, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const tablist_changes = (dirty[0] & /*tabsConfig, tabs*/ 805306368)
			? get_spread_update(tablist_spread_levels, [
					dirty[0] & /*tabsConfig*/ 268435456 && get_spread_object(/*tabsConfig*/ ctx[28]),
					dirty[0] & /*tabs*/ 536870912 && { tabs: /*tabs*/ ctx[29] }
				])
			: {};

			if (dirty[11] & /*$$scope, tab*/ 24) {
				tablist_changes.$$scope = { dirty, ctx };
			}

			tablist.$set(tablist_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tablist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tablist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tablist, detaching);
		}
	};
}

// (2268:3) {:else}
function create_else_block$2(ctx) {
	let panel;
	let updating_component;
	let current;

	function panel_component_binding_1(value) {
		/*panel_component_binding_1*/ ctx[256](value);
	}

	let panel_props = {
		class: "PinturaMain",
		content: {
			.../*utilsMerged*/ ctx[20].find(/*func_1*/ ctx[255]),
			props: /*pluginOptions*/ ctx[7][/*utilSelected*/ ctx[18]]
		},
		locale: /*locale*/ ctx[2],
		isAnimated: /*$shouldAnimate*/ ctx[17],
		stores: /*utilStores*/ ctx[113]
	};

	if (/*pluginInterface*/ ctx[0][/*utilSelected*/ ctx[18]] !== void 0) {
		panel_props.component = /*pluginInterface*/ ctx[0][/*utilSelected*/ ctx[18]];
	}

	panel = new Panel({ props: panel_props });
	binding_callbacks.push(() => bind$1(panel, "component", panel_component_binding_1));
	panel.$on("measure", /*measure_handler_3*/ ctx[257]);
	panel.$on("show", /*show_handler_1*/ ctx[258]);
	panel.$on("hide", /*hide_handler_1*/ ctx[259]);
	panel.$on("fade", /*fade_handler_1*/ ctx[260]);

	return {
		c() {
			create_component(panel.$$.fragment);
		},
		m(target, anchor) {
			mount_component(panel, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const panel_changes = {};

			if (dirty[0] & /*utilsMerged, utilSelected, pluginOptions*/ 1310848) panel_changes.content = {
				.../*utilsMerged*/ ctx[20].find(/*func_1*/ ctx[255]),
				props: /*pluginOptions*/ ctx[7][/*utilSelected*/ ctx[18]]
			};

			if (dirty[0] & /*locale*/ 4) panel_changes.locale = /*locale*/ ctx[2];
			if (dirty[0] & /*$shouldAnimate*/ 131072) panel_changes.isAnimated = /*$shouldAnimate*/ ctx[17];

			if (!updating_component && dirty[0] & /*pluginInterface, utilSelected*/ 262145) {
				updating_component = true;
				panel_changes.component = /*pluginInterface*/ ctx[0][/*utilSelected*/ ctx[18]];
				add_flush_callback(() => updating_component = false);
			}

			panel.$set(panel_changes);
		},
		i(local) {
			if (current) return;
			transition_in(panel.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(panel.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(panel, detaching);
		}
	};
}

// (2254:3) {#if shouldRenderTabs}
function create_if_block_3$4(ctx) {
	let tabpanels;
	let current;

	const tabpanels_spread_levels = [
		{ class: "PinturaMain" },
		{ visible: /*utilsVisible*/ ctx[26] },
		/*tabsConfig*/ ctx[28],
		{ panels: /*panels*/ ctx[30] }
	];

	let tabpanels_props = {
		$$slots: {
			default: [
				create_default_slot$a,
				({ panel }) => ({ 343: panel }),
				({ panel }) => [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, panel ? 4 : 0]
			]
		},
		$$scope: { ctx }
	};

	for (let i = 0; i < tabpanels_spread_levels.length; i += 1) {
		tabpanels_props = assign(tabpanels_props, tabpanels_spread_levels[i]);
	}

	tabpanels = new TabPanels({ props: tabpanels_props });
	tabpanels.$on("measure", /*measure_handler_2*/ ctx[254]);

	return {
		c() {
			create_component(tabpanels.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tabpanels, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const tabpanels_changes = (dirty[0] & /*utilsVisible, tabsConfig, panels*/ 1409286144)
			? get_spread_update(tabpanels_spread_levels, [
					tabpanels_spread_levels[0],
					dirty[0] & /*utilsVisible*/ 67108864 && { visible: /*utilsVisible*/ ctx[26] },
					dirty[0] & /*tabsConfig*/ 268435456 && get_spread_object(/*tabsConfig*/ ctx[28]),
					dirty[0] & /*panels*/ 1073741824 && { panels: /*panels*/ ctx[30] }
				])
			: {};

			if (dirty[0] & /*utilsMerged, pluginOptions, locale, utilSelected, $shouldAnimate, pluginInterface, utilsVisible, utilsVisibleFraction*/ 70647941 | dirty[1] & /*$utilRect*/ 16384 | dirty[11] & /*$$scope, panel*/ 20) {
				tabpanels_changes.$$scope = { dirty, ctx };
			}

			tabpanels.$set(tabpanels_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tabpanels.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tabpanels.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tabpanels, detaching);
		}
	};
}

// (2255:3) <TabPanels class="PinturaMain" visible={utilsVisible} {...tabsConfig} {panels} let:panel on:measure={e => $tabRect = e.detail}>
function create_default_slot$a(ctx) {
	let panel;
	let updating_component;
	let current;

	function func(...args) {
		return /*func*/ ctx[248](/*panel*/ ctx[343], ...args);
	}

	function panel_component_binding(value) {
		/*panel_component_binding*/ ctx[249](value, /*panel*/ ctx[343]);
	}

	function show_handler() {
		return /*show_handler*/ ctx[251](/*panel*/ ctx[343]);
	}

	function hide_handler() {
		return /*hide_handler*/ ctx[252](/*panel*/ ctx[343]);
	}

	function fade_handler(...args) {
		return /*fade_handler*/ ctx[253](/*panel*/ ctx[343], ...args);
	}

	let panel_props = {
		content: {
			.../*utilsMerged*/ ctx[20].find(func),
			props: /*pluginOptions*/ ctx[7][/*panel*/ ctx[343]]
		},
		locale: /*locale*/ ctx[2],
		isActive: /*panel*/ ctx[343] === /*utilSelected*/ ctx[18],
		isAnimated: /*$shouldAnimate*/ ctx[17],
		stores: /*utilStores*/ ctx[113]
	};

	if (/*pluginInterface*/ ctx[0][/*panel*/ ctx[343]] !== void 0) {
		panel_props.component = /*pluginInterface*/ ctx[0][/*panel*/ ctx[343]];
	}

	panel = new Panel({ props: panel_props });
	binding_callbacks.push(() => bind$1(panel, "component", panel_component_binding));
	panel.$on("measure", /*measure_handler_1*/ ctx[250]);
	panel.$on("show", show_handler);
	panel.$on("hide", hide_handler);
	panel.$on("fade", fade_handler);

	return {
		c() {
			create_component(panel.$$.fragment);
		},
		m(target, anchor) {
			mount_component(panel, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const panel_changes = {};

			if (dirty[0] & /*utilsMerged, pluginOptions*/ 1048704 | dirty[11] & /*panel*/ 4) panel_changes.content = {
				.../*utilsMerged*/ ctx[20].find(func),
				props: /*pluginOptions*/ ctx[7][/*panel*/ ctx[343]]
			};

			if (dirty[0] & /*locale*/ 4) panel_changes.locale = /*locale*/ ctx[2];
			if (dirty[0] & /*utilSelected*/ 262144 | dirty[11] & /*panel*/ 4) panel_changes.isActive = /*panel*/ ctx[343] === /*utilSelected*/ ctx[18];
			if (dirty[0] & /*$shouldAnimate*/ 131072) panel_changes.isAnimated = /*$shouldAnimate*/ ctx[17];

			if (!updating_component && dirty[0] & /*pluginInterface*/ 1 | dirty[11] & /*panel*/ 4) {
				updating_component = true;
				panel_changes.component = /*pluginInterface*/ ctx[0][/*panel*/ ctx[343]];
				add_flush_callback(() => updating_component = false);
			}

			panel.$set(panel_changes);
		},
		i(local) {
			if (current) return;
			transition_in(panel.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(panel.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(panel, detaching);
		}
	};
}

// (2315:1) {#if $disabledTransition > 0}
function create_if_block$7(ctx) {
	let span;
	let span_style_value;

	return {
		c() {
			span = element("span");
			attr(span, "class", "PinturaEditorOverlay");
			attr(span, "style", span_style_value = `opacity:${/*$disabledTransition*/ ctx[55]}`);
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p(ctx, dirty) {
			if (dirty[1] & /*$disabledTransition*/ 16777216 && span_style_value !== (span_style_value = `opacity:${/*$disabledTransition*/ ctx[55]}`)) {
				attr(span, "style", span_style_value);
			}
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

function create_fragment$t(ctx) {
	let div;
	let t;
	let current;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowresize*/ ctx[245]);
	let if_block0 = /*canRender*/ ctx[40] && create_if_block_1$7(ctx);
	let if_block1 = /*$disabledTransition*/ ctx[55] > 0 && create_if_block$7(ctx);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr(div, "id", /*id*/ ctx[3]);
			attr(div, "class", /*className*/ ctx[31]);
			attr(div, "data-env", /*envStr*/ ctx[33]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t);
			if (if_block1) if_block1.m(div, null);
			/*div_binding_1*/ ctx[263](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window_1, "keydown", /*handleKeydown*/ ctx[125]),
					listen(window_1, "keyup", /*handleKeyup*/ ctx[126]),
					listen(window_1, "blur", /*handleWindowBlur*/ ctx[127]),
					listen(window_1, "paste", /*handlePaste*/ ctx[130]),
					listen(window_1, "resize", /*onwindowresize*/ ctx[245]),
					listen(div, "ping", function () {
						if (is_function(/*routePing*/ ctx[41])) /*routePing*/ ctx[41].apply(this, arguments);
					}),
					listen(div, "contextmenu", /*handleContextMenu*/ ctx[128]),
					listen(
						div,
						"touchstart",
						function () {
							if (is_function(/*handleTouchStart*/ ctx[37])) /*handleTouchStart*/ ctx[37].apply(this, arguments);
						},
						{ passive: false }
					),
					listen(div, "touchmove", function () {
						if (is_function(/*handleTouchMove*/ ctx[38])) /*handleTouchMove*/ ctx[38].apply(this, arguments);
					}),
					listen(div, "transitionend", /*handleTransitionEnd*/ ctx[114]),
					listen(div, "dropfiles", /*handleDropFiles*/ ctx[129]),
					listen(div, "measure", /*measure_handler_4*/ ctx[264]),
					action_destroyer(measurable.call(null, div, { observeViewRect: true })),
					action_destroyer(focusvisible.call(null, div)),
					action_destroyer(dropable.call(null, div))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*canRender*/ ctx[40]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*canRender*/ 512) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$7(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*$disabledTransition*/ ctx[55] > 0) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$7(ctx);
					if_block1.c();
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || dirty[0] & /*id*/ 8) {
				attr(div, "id", /*id*/ ctx[3]);
			}

			if (!current || dirty[1] & /*className*/ 1) {
				attr(div, "class", /*className*/ ctx[31]);
			}

			if (!current || dirty[1] & /*envStr*/ 4) {
				attr(div, "data-env", /*envStr*/ ctx[33]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			/*div_binding_1*/ ctx[263](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

const imageCropRectElasticity = 5;

// updating crop selection / the intended selection rect, combined with actual selection rect, used to render elasticity visualisation
const imageSelectionRectElasticity = 1;

const STAGE_OVERLAY_ID = "stage-overlay";
const maxOpacity = 0.85;
const scrollElasticity = 10;
const rangeInputElasticity = 5;

function instance$t($$self, $$props, $$invalidate) {
	let isOverlayModeEnabled;
	let showUtils;
	let maxImageDataSize;
	let preprocessShape;
	let imageTargetSizeCurrent;
	let overlayTop;
	let overlayBottom;
	let overlayLeft;
	let overlayRight;
	let gradientOverlays;
	let canAnimate;
	let acceptsAnimations;
	let canUndo;
	let canRedo;
	let utilsFiltered;
	let utilsAvailable;
	let utilsDefined;
	let utilsMerged;
	let utilSelected;
	let utilTools;
	let utilsVisibleFraction;
	let tabsConfig;
	let tabs;
	let panels;
	let shouldRenderTabs;
	let className;
	let horizontalSpace;
	let hasLimitedSpace;
	let verticalSpace;
	let isModal;
	let isCenteredHorizontally;
	let isCenteredVertically;
	let isCentered;
	let isNarrow;
	let orientation;
	let isLandscape;
	let isCompact;
	let hasSwipeNavigation;
	let shouldRenderUtilTools;
	let rootElementComputedStyle;
	let envStr;
	let imageCanvasState;
	let hasProps;
	let missingFeatures;
	let isSupportsError;
	let isStartLoadingImageSource;
	let isImageLoadError;
	let isWaitingForImage;
	let imageLoadProgress;
	let isLoadingImageData;
	let isCreatingImagePreview;
	let isProcessingImage;
	let imageLoadShowProgressIndicator;
	let imageLoadStatusLabel;
	let imageProcessStatusLabel;
	let imageProcessProgress;
	let imageProcessShowProgressIndicator;
	let isImageProcessingError;
	let isCustomStatus;
	let isStatusActive;
	let isStatusVisible;
	let hasAside;
	let statusIndent;
	let statusTransform;
	let handleTouchStart;
	let handleTouchMove;
	let toolbarItems;
	let hasClientRect;
	let canRender;
	let routePing;
	let $images;
	let $shapePreprocessor;
	let $clientRect;
	let $imageCropAspectRatio;
	let $rootRect;
	let $imageLoadState;
	let $imageCropRect;
	let $imageCropRectIntent;
	let $isInteracting;
	let $imageCropRectSnapshot;
	let $previewShouldUpscale;
	let $imageSelectionRect;
	let $shouldAnimate;
	let $imageSelectionRectIntent;
	let $stageRect;
	let $imageOutputSize;
	let $stageScalar;
	let $imageSize;
	let $presentationScalar;
	let $imageSelectionRectSnapshot;
	let $overlayInset;
	let $imageVisualBounds;
	let $overlaySize;
	let $overlayTopOpacity;
	let $overlayBottomOpacity;
	let $overlayLeftOpacity;
	let $overlayRightOpacity;
	let $imageOverlayMarkup;
	let $imageFile;
	let $activeImages;
	let $imagePreviewSource;
	let $prefersReducedMotion;
	let $imageState;
	let $tabRect;

	let $history,
		$$unsubscribe_history = noop$2,
		$$subscribe_history = () => ($$unsubscribe_history(), $$unsubscribe_history = subscribe(history, $$value => $$invalidate(195, $history = $$value)), history);

	let $imageProcessingPreparing;
	let $env;
	let $pointerAccuracy;
	let $pointerHoverable;
	let $imageTransforms;
	let $imagePreviewModifiers;
	let $imagePreview;
	let $imageProps;
	let $imageSelectionRectPresentation;
	let $imageVisualLoadComplete;
	let $imageProcessState;
	let $statusOpacity;
	let $statusWidth;
	let $asideWidth;
	let $statusOffset;
	let $pressedKeysStore;
	let $rootForegroundColor;
	let $rootLineColor;
	let $isInteractingFraction;
	let $asideOffset;
	let $asideOpacity;
	let $toolRect;
	let $utilRect;
	let $pixelRatio;
	let $rootBackgroundColor;
	let $utilSelectedStore;
	let $stagePadded;
	let $interfaceImages;
	let $imageAnnotation;
	let $imageDecoration;
	let $imageFrame;
	let $imageOverlay;
	let $disabledTransition;
	component_subscribe($$self, prefersReducedMotion, $$value => $$invalidate(193, $prefersReducedMotion = $$value));
	$$self.$$.on_destroy.push(() => $$unsubscribe_history());
	const eventProxy = pubsub();
	const dispatch = createEventDispatcher();

	//
	// View Props
	//
	let { class: klass = undefined } = $$props;

	let { layout: layoutMode = undefined } = $$props;
	let { stores } = $$props;
	let { locale = undefined } = $$props;
	let { id = undefined } = $$props;
	let { util = undefined } = $$props;
	let { utils = undefined } = $$props; // which utils are active (list of ids), or is derived from plugins automatically
	let { animations = "auto" } = $$props;
	let { disabled = false } = $$props;
	let { status = undefined } = $$props;
	let { previewUpscale = false } = $$props;
	let { elasticityMultiplier = 10 } = $$props;
	let { willRevert = () => Promise.resolve(true) } = $$props;
	let { willProcessImage = () => Promise.resolve(true) } = $$props;
	let { willRenderCanvas = passthrough } = $$props;
	let { willRenderToolbar = passthrough } = $$props;
	let { willSetHistoryInitialState = passthrough } = $$props;
	let { enableButtonExport = true } = $$props;
	let { enableButtonRevert = true } = $$props;
	let { enableNavigateHistory = true } = $$props;
	let { enableToolbar = true } = $$props;
	let { enableUtils = true } = $$props;
	let { enableButtonClose = false } = $$props;
	let { enableDropImage = false } = $$props;
	let { enablePasteImage = false } = $$props;
	let { previewImageDataMaxSize = undefined } = $$props;
	let { layoutDirectionPreference = "auto" } = $$props;
	let { imagePreviewSrc = undefined } = $$props;
	let { imageOrienter = { read: () => 1, apply: v => v } } = $$props;
	let { pluginComponents = undefined } = $$props;
	let { pluginOptions = {} } = $$props;
	const sub = eventProxy.sub;
	const pluginInterface = {};
	let { root } = $$props;
	let registeredPluginsComponents = [];

	// editor disabled spring for animating in and out disabled state
	const disabledTransition = spring$2();

	component_subscribe($$self, disabledTransition, value => $$invalidate(55, $disabledTransition = value));

	// this method is used to read image resources (preview image / shape images)
	const glMaxTextureSize = getWebGLTextureSizeLimit() || 1024;

	const maxTextureSize = sizeCreate(glMaxTextureSize, glMaxTextureSize);
	const canvasMemoryLimit = isIOS() ? 4096 * 4096 : Infinity;

	let { imageSourceToImageData = src => isString(src)
	? // it's a url src
		fetch(src).then(res => {
			if (res.status !== 200) throw `${res.status} (${res.statusText})`;
			return res.blob();
		}).then(blob => blobToImageBitmap(blob, imageOrienter, canvasMemoryLimit)).then(imageData => imageDataContain(imageData, maxImageDataSize))
	: isElement(src)
		? // assume src is a <canvas>
			new Promise(resolve => resolve(canvasToImageData(src)))
		: // assume src is a File or Blob
			blobToImageBitmap(src, imageOrienter, canvasMemoryLimit).then(imageData => imageDataContain(imageData, maxImageDataSize)) } = $$props;

	const imageProxy = createImageProxy();
	const { file: imageFile, size: imageSize, loadState: imageLoadState, processState: imageProcessState, cropAspectRatio: imageCropAspectRatio, cropLimitToImage: imageCropLimitToImage, crop: imageCropRect, cropMinSize: imageCropMinSize, cropMaxSize: imageCropMaxSize, cropRange: imageCropRange, cropOrigin: imageCropRectOrigin, cropRectAspectRatio: imageCropRectAspectRatio, rotation: imageRotation, rotationRange: imageRotationRange, targetSize: imageOutputSize, flipX: imageFlipX, flipY: imageFlipY, backgroundColor: imageBackgroundColor, colorMatrix: imageColorMatrix, convolutionMatrix: imageConvolutionMatrix, gamma: imageGamma, vignette: imageVignette, noise: imageNoise, decoration: imageDecoration, annotation: imageAnnotation, frame: imageFrame, state: imageState } = imageProxy.stores;
	component_subscribe($$self, imageFile, value => $$invalidate(189, $imageFile = value));
	component_subscribe($$self, imageSize, value => $$invalidate(278, $imageSize = value));
	component_subscribe($$self, imageLoadState, value => $$invalidate(169, $imageLoadState = value));
	component_subscribe($$self, imageProcessState, value => $$invalidate(230, $imageProcessState = value));
	component_subscribe($$self, imageCropAspectRatio, value => $$invalidate(271, $imageCropAspectRatio = value));
	component_subscribe($$self, imageCropRect, value => $$invalidate(170, $imageCropRect = value));
	component_subscribe($$self, imageOutputSize, value => $$invalidate(174, $imageOutputSize = value));
	component_subscribe($$self, imageDecoration, value => $$invalidate(52, $imageDecoration = value));
	component_subscribe($$self, imageAnnotation, value => $$invalidate(51, $imageAnnotation = value));
	component_subscribe($$self, imageFrame, value => $$invalidate(53, $imageFrame = value));
	component_subscribe($$self, imageState, value => $$invalidate(281, $imageState = value));
	const { images, shapePreprocessor } = stores;
	component_subscribe($$self, images, value => $$invalidate(166, $images = value));
	component_subscribe($$self, shapePreprocessor, value => $$invalidate(167, $shapePreprocessor = value));

	// let the world know about state changes
	imageState.subscribe(state => eventProxy.pub("update", state));

	// this will hold the currently selected util
	const utilSelectedStore = writable();

	component_subscribe($$self, utilSelectedStore, value => $$invalidate(48, $utilSelectedStore = value));

	//
	// handles the view rect size, makes sure it is offset from the top
	//
	// root element reference used to read styles
	const rootBackgroundColor = writable([0, 0, 0]);

	component_subscribe($$self, rootBackgroundColor, value => $$invalidate(47, $rootBackgroundColor = value));
	const rootForegroundColor = writable([1, 1, 1]);
	component_subscribe($$self, rootForegroundColor, value => $$invalidate(283, $rootForegroundColor = value));
	const rootLineColor = spring$2();
	component_subscribe($$self, rootLineColor, value => $$invalidate(284, $rootLineColor = value));

	// client rect is the editor rect excluding scroll offset
	const clientRect = writable();

	component_subscribe($$self, clientRect, value => $$invalidate(15, $clientRect = value));

	// root rect is the editor rect including scroll offset
	const rootRect = writable();

	component_subscribe($$self, rootRect, value => $$invalidate(168, $rootRect = value));

	// when in overlay mode force aspect ratio to aspect ratio of editor root
	const syncRootAspectRatio = () => {
		// get current aspect ratio and get next aspect ratio, compare, if different, reset
		const currentAspectRatio = $imageCropAspectRatio;

		const nextAspectRatio = rectAspectRatio($rootRect);
		if (currentAspectRatio && currentAspectRatio === nextAspectRatio) return;

		// set aspect ratio
		imageCropAspectRatio.set(rectAspectRatio($rootRect));

		// need to set history 0 point to this state
		setInitialHistoryState();
	};

	const tabRect = writable(rectCreateEmpty());
	component_subscribe($$self, tabRect, value => $$invalidate(27, $tabRect = value));
	const toolRect = writable(rectCreateEmpty());
	component_subscribe($$self, toolRect, value => $$invalidate(44, $toolRect = value));
	const utilRect = writable(); // is undefined because we wait till util is set before defining stage rect
	component_subscribe($$self, utilRect, value => $$invalidate(45, $utilRect = value));

	//
	// environment
	//
	const pointerAccuracy = mediaQueryStore("(pointer: fine)", matches => matches ? "pointer-fine" : "pointer-coarse");

	component_subscribe($$self, pointerAccuracy, value => $$invalidate(215, $pointerAccuracy = value));
	const pointerHoverable = mediaQueryStore("(hover: hover)", matches => matches ? "pointer-hover" : "pointer-no-hover");
	component_subscribe($$self, pointerHoverable, value => $$invalidate(216, $pointerHoverable = value));

	//
	// app API
	//
	const isInteracting = writable(false);

	component_subscribe($$self, isInteracting, value => $$invalidate(171, $isInteracting = value));

	const isInteractingFraction = readable(undefined, set => {
		const animator = spring$2(0);

		const updater = value => {
			animator.set(value ? 1 : 0);
		};

		const subs = [isInteracting.subscribe(updater), animator.subscribe(set)];

		// destroy subs
		return () => subs.forEach(unsub => unsub());
	});

	component_subscribe($$self, isInteractingFraction, value => $$invalidate(285, $isInteractingFraction = value));
	const previewShouldUpscale = writable(previewUpscale);
	component_subscribe($$self, previewShouldUpscale, value => $$invalidate(274, $previewShouldUpscale = value));
	const imageCropRectSnapshot = writable();
	component_subscribe($$self, imageCropRectSnapshot, value => $$invalidate(273, $imageCropRectSnapshot = value));
	const imageCropRectIntent = writable(); // should always be set before setting `imageCropRect`
	component_subscribe($$self, imageCropRectIntent, value => $$invalidate(272, $imageCropRectIntent = value));

	const imageCropRectPresentation = readable(undefined, set => {
		const animator = spring$2(undefined, { precision: 0.0001 });

		const update = () => {
			if (!$imageCropRect) return;
			const instantUpdate = $imageCropRectIntent === undefined || $isInteracting;
			const elasticRect = elastifyRects($imageCropRect, $imageCropRectIntent, imageCropRectElasticity * elasticityMultiplier);
			animator.set(elasticRect, { hard: instantUpdate });
		};

		const subs = [
			// need to update presentation rect when crop rect is updated
			imageCropRect.subscribe(update),
			// update parent store
			animator.subscribe(set)
		];

		return () => subs.forEach(unsub => unsub());
	});

	const imageSelectionRect = writable();
	component_subscribe($$self, imageSelectionRect, value => $$invalidate(275, $imageSelectionRect = value));
	const imageSelectionRectSnapshot = writable();
	component_subscribe($$self, imageSelectionRectSnapshot, value => $$invalidate(280, $imageSelectionRectSnapshot = value));
	const imageSelectionRectIntent = writable(undefined); // should always be set before setting `imageSelectionRect`
	component_subscribe($$self, imageSelectionRectIntent, value => $$invalidate(276, $imageSelectionRectIntent = value));
	let prevFramePadding = { left: 0, right: 0, top: 0, bottom: 0 };

	const framePadding = derived([imageFrame, imageSelectionRect], ([$imageFrame, $imageSelectionRect], set) => {
		if (!$imageSelectionRect) set(prevFramePadding);

		// set frame padding
		let newPadding = getStagePadding($imageSelectionRect, $imageFrame);

		// exif if no value changes
		if (fixPrecision(prevFramePadding.top, 4) === fixPrecision(newPadding.top, 4) && fixPrecision(prevFramePadding.bottom, 4) === fixPrecision(newPadding.bottom, 4) && fixPrecision(prevFramePadding.right, 4) === fixPrecision(newPadding.right, 4) && fixPrecision(prevFramePadding.left, 4) === fixPrecision(newPadding.left, 4)) return;

		prevFramePadding = newPadding;
		set(newPadding);
	});

	const framePadded = derived([framePadding], ([$framePadding], set) => {
		set(Object.values($framePadding).some(value => value > 0));
	});

	let prevStagePadding = { left: 0, right: 0, top: 0, bottom: 0 };

	const stagePadding = derived([utilSelectedStore, imageFrame, imageSelectionRect], ([$utilSelectedStore, $imageFrame, $imageSelectionRect], set) => {
		if (!$imageSelectionRect) set(prevStagePadding);

		// TODO: configure in plugin
		let newPadding;

		if ($utilSelectedStore === "frame") {
			newPadding = getStagePadding($imageSelectionRect, $imageFrame);
		} else {
			newPadding = { left: 0, right: 0, top: 0, bottom: 0 };
		}

		// exif if no value changes
		if (fixPrecision(prevStagePadding.top, 4) === fixPrecision(newPadding.top, 4) && fixPrecision(prevStagePadding.bottom, 4) === fixPrecision(newPadding.bottom, 4) && fixPrecision(prevStagePadding.right, 4) === fixPrecision(newPadding.right, 4) && fixPrecision(prevStagePadding.left, 4) === fixPrecision(newPadding.left, 4)) return;

		prevStagePadding = newPadding;
		set(newPadding);
	});

	const stagePadded = derived([stagePadding], ([$stagePadding], set) => {
		set(Object.values($stagePadding).some(value => value > 0));
	});

	component_subscribe($$self, stagePadded, value => $$invalidate(49, $stagePadded = value));

	const stageRect = derived([utilRect, tabRect, toolRect, stagePadding], ([$utilRect, $tabRect, $toolRect, $stagePadding], set) => {
		if (!$utilRect) return set(undefined);
		let utilOffsetY = 0;

		// if only one util active, we don't have util tabs, so add additional offset
		if (utilsFiltered.length === 1 && !isOverlayModeEnabled) {
			utilOffsetY = $toolRect.y + $toolRect.height;
		}

		set(rectCreate($utilRect.x + $tabRect.x + $stagePadding.top, $utilRect.y + $tabRect.y + utilOffsetY + $stagePadding.top, $utilRect.width - ($stagePadding.left + $stagePadding.right), $utilRect.height - ($stagePadding.top + $stagePadding.bottom)));
	});

	component_subscribe($$self, stageRect, value => $$invalidate(173, $stageRect = value));

	const stageScalar = derived([stageRect, imageCropRect], ([$stageRect, $imageCropRect], set) => {
		const isManipulatingImageCropRect = !!($imageCropRectSnapshot || $imageCropRectIntent);

		// update stage scalar, the crop output size relative to the stage, if image fits it's 1
		if (!$stageRect || !$imageCropRect || isManipulatingImageCropRect) return;

		// calculate scale factor needed to fit crop rect to stage
		const scalar = Math.min($stageRect.width / $imageCropRect.width, $stageRect.height / $imageCropRect.height);

		// always scaled down to fit stage, if is allowed to upscale, zoom to fit stage
		const scale = $previewShouldUpscale ? scalar : Math.min(1, scalar);

		set(scale);
	});

	component_subscribe($$self, stageScalar, value => $$invalidate(277, $stageScalar = value));

	//
	// Image selection
	//
	const getStagePadding = (presentationRect, imageFrame) => {
		if (!imageFrame || !presentationRect) return { top: 0, right: 0, bottom: 0, left: 0 };
		const shapes = shapesFromCompositShape(imageFrame, presentationRect, preprocessShape);
		const bounds = shapesBounds(shapes, presentationRect);

		return {
			top: Math.abs(bounds.top),
			right: Math.abs(bounds.right),
			bottom: Math.abs(bounds.bottom),
			left: Math.abs(bounds.left)
		};
	};

	const imageSelectionRectPresentation = readable(undefined, set => {
		const animator = spring$2(undefined, { precision: 0.0001 });

		const updater = () => {
			if (!$imageSelectionRect) return;
			const instantUpdate = $isInteracting || !$shouldAnimate;
			const elasticRect = elastifyRects($imageSelectionRect, $imageSelectionRectIntent, imageSelectionRectElasticity * elasticityMultiplier);

			// prevent negative size (can happen because of elastics)
			if (elasticRect.width < 0) {
				elasticRect.width = 0;
				elasticRect.x = $imageSelectionRect.x;
			}

			if (elasticRect.height < 0) {
				elasticRect.height = 0;
				elasticRect.y = $imageSelectionRect.y;
			}

			// translate elastic rect x,y by stage rect x,y
			rectTranslate(elasticRect, $stageRect);

			// adjust size if needed
			// TODO: MAKE THIS CONTROLLABLE FROM PLUGIN
			if ($imageCropRect) {
				if (utilSelected === "resize") {
					const visualSize = $imageOutputSize || $imageCropRect;
					rectScale(elasticRect, visualSize.width / $imageSelectionRect.width || visualSize.height / $imageSelectionRect.height);
				}
			}

			animator.set(elasticRect, { hard: instantUpdate });
		};

		const subs = [
			// need to update selection rect when stage is resized
			stageRect.subscribe(updater),
			// listen for selection rect changes (as is assigned rect will always trigger, even if assigned same rect, this is needed to also update when intent changes)
			imageSelectionRect.subscribe(updater),
			// if output size changes need to update presentation
			imageOutputSize.subscribe(updater),
			// need to update if frame exceeds bounds
			imageFrame.subscribe(updater),
			// update parent store
			animator.subscribe(set)
		];

		// destroy subs
		return () => subs.forEach(unsub => unsub());
	});

	component_subscribe($$self, imageSelectionRectPresentation, value => $$invalidate(35, $imageSelectionRectPresentation = value));

	// when scaling the stage we need to recenter the image selection
	let stageRectPrev;

	stageRect.subscribe(rect => {
		if (!rect || !$imageCropRect) return;
		if (isOverlayModeEnabled && stageRectPrev && rectEqual(stageRectPrev, rect)) return;

		// remember
		stageRectPrev = rect;

		const imageCropRectFitsStage = $imageCropRect.width <= rect.width && $imageCropRect.height <= rect.height;

		const centeredImageSelectionRect = // if we have a crop rect and it fits the stage, center it
		imageCropRectFitsStage
		? // center the crop rectangle to the stage
			rectCenterRect(rect, rectMultiply(rectClone($imageCropRect), $stageScalar || 1))
		: // render a rectangle based on the fixed crop aspect ratio, or the aspect ratio of the current crop rectangle, or as a last resort the input image
			rectContainRect(rect, rectAspectRatio($imageCropRect || $imageSize));

		imageSelectionRect.set(centeredImageSelectionRect);
	});

	// if we've taken a snapshot of the selection, also take a snapshot of the crop rect and the presentationScalar
	// - cropRect so we can adjust it based on the adjustments to the imageSelectionRect
	// - presentationScalar so we can use the snapshot for the calculation of the cropRect scale relative to the original imageSelectionRect (if we use the live $presentationScalar small rounding errors of the scalar result in weird glitches)
	let presentationScalarSnapshot;

	imageSelectionRectSnapshot.subscribe(rect => {
		if (!rect) {
			presentationScalarSnapshot = undefined;
			set_store_value(imageCropRectSnapshot, $imageCropRectSnapshot = undefined, $imageCropRectSnapshot);
			return;
		}

		presentationScalarSnapshot = $presentationScalar;
		const cropRectClone = rectClone($imageCropRect);
		imageCropRectSnapshot.set(cropRectClone);
	});

	// if image selection rect is being manipulated, and imageSelectionRectSnapshot has been defined, we also need to update the crop rect
	imageSelectionRect.subscribe(rect => {
		// only sync crop rect with image selection rect when no longer manipulating
		if (!rect || !$imageSelectionRectSnapshot) return;

		const offset = rectSubtract(rectClone(rect), $imageSelectionRectSnapshot);
		rectDivide(offset, presentationScalarSnapshot);
		const crop = rectAdd(rectClone($imageCropRectSnapshot), offset);
		imageCropRect.set(crop);
	});

	imageCropRect.subscribe(rect => {
		// don't update image selection rect while we're intertacting with the view, this prevents feedback loop from cropRect model updates
		if ($isInteracting || $imageSelectionRectSnapshot || $imageCropRectIntent) return;

		// if no rect, we can't do anything
		// if no selection rect yet, we wait for a selection rect to be loaded
		if (!rect || !$imageSelectionRect) return;

		// only if crop aspect ratio differs from image selection aspect ratio we update image selection rectangle
		const imageSelectionRectAspectRatio = rectAspectRatio($imageSelectionRect);

		const cropRectAspectRatio = rectAspectRatio(rect);
		if (fixPrecision(imageSelectionRectAspectRatio, 6) === fixPrecision(cropRectAspectRatio, 6)) return;

		// TEMP DUPLICATE OF STAGESCALAR DERIVED STORE TO FIX ZOOM OUT AFTER WHEEL ISSUE
		// reproduce -> crop view => resize selection rect vertically, tap recenter, zoom out with scroll wheel
		const scalar = Math.min($stageRect.width / $imageCropRect.width, $stageRect.height / $imageCropRect.height);

		// const scale = $previewShouldUpscale ? scalar : Math.min(1, scalar);
		const size = sizeCreate(rect.width * scalar, rect.height * scalar);

		const tx = ($imageSelectionRect.width - size.width) * 0.5;
		const ty = ($imageSelectionRect.height - size.height) * 0.5;
		const selectionRect = rectCreate($imageSelectionRect.x + tx, $imageSelectionRect.y + ty, size.width, size.height);
		imageSelectionRect.set(selectionRect);
	});

	const imageScalar = derived([stageScalar, imageCropRect, imageSelectionRect], ([$stageScalar, $imageCropRect, $imageSelectionRect], set) => {
		// update the image scalar, the image zoom calculated by the image selection and the actual crop coordinates
		if (!$stageScalar || !$imageCropRect || !$imageSelectionRect) return;

		const selectionScaledWidth = $imageSelectionRect.width / $imageCropRect.width;
		const selectionScaledHeight = $imageSelectionRect.height / $imageCropRect.height;

		// need to correct for scale of stage
		let scalar = Math.max(selectionScaledWidth, selectionScaledHeight) / $stageScalar;

		set(scalar);
	});

	const presentationScalar = derived([stageScalar, imageScalar], ([$stageScalar, $imageScalar], set) => {
		// can't scale presentation if no image scalar defined
		if (!$imageScalar) return;

		const scalar = $stageScalar * $imageScalar;
		set(scalar);
	});

	component_subscribe($$self, presentationScalar, value => $$invalidate(279, $presentationScalar = value));

	// const imagePresentationScale = writable(1);
	// const imagePresentationPan = writable(vectorCreateEmpty());
	//
	// UI Elements
	//
	// image outline
	const imageOutlineOpacity = spring$2(0.075, {
		stiffness: 0.03,
		damping: 0.4,
		precision: 0.001
	});

	const imageVisualBounds = derived([imageSelectionRectPresentation, framePadding], ([$rect, $padding], set) => {
		if (!$rect) return;
		let { x, y, width, height } = $rect;
		let { left, right, top, bottom } = $padding;

		if (utilSelected === "resize") {
			const visualSize = $imageOutputSize || $imageCropRect;
			const scalar = visualSize.width / $imageSelectionRect.width || visualSize.height / $imageSelectionRect.height;
			left *= scalar;
			right *= scalar;
			top *= scalar;
			bottom *= scalar;
		}

		set({
			x: x - left,
			y: y - right,
			width: width + left + right,
			height: height + top + bottom
		});
	});

	component_subscribe($$self, imageVisualBounds, value => $$invalidate(177, $imageVisualBounds = value));

	const imageOutline = derived(
		[
			rootLineColor,
			imageOutlineOpacity,
			imageSelectionRectPresentation,
			imageFrame,
			framePadded,
			framePadding
		],
		([
				$rootLineColor,
				$colorOpacity,
				$rect,
				$imageFrame,
				$framePadded,
				$framePadding
			], set) => {
			if (!$rect || isOverlayModeEnabled) return set([]);
			let { x, y, width, height } = $rect;
			x += 0.5;
			y += 0.5;
			width -= 0.5;
			height -= 0.5;
			const shapes = [];

			if ($framePadded) {
				if ($colorOpacity > 0.1) {
					// image outline
					shapes.push({
						x,
						y,
						width: width - 0.5,
						height: height - 0.5,
						strokeWidth: 1,
						strokeColor: $rootLineColor,
						opacity: $colorOpacity
					});
				}

				let { left, right, top, bottom } = $framePadding;

				if (utilSelected === "resize") {
					const visualSize = $imageOutputSize || $imageCropRect;
					const scalar = visualSize.width / $imageSelectionRect.width || visualSize.height / $imageSelectionRect.height;
					left *= scalar;
					right *= scalar;
					top *= scalar;
					bottom *= scalar;
				}

				set([
					...shapes,
					// frame outline
					{
						x: x - left,
						y: y - right,
						width: width + left + right,
						height: height + top + bottom,
						strokeWidth: 1,
						strokeColor: $rootLineColor,
						opacity: 0.05
					}
				]);

				return;
			}

			// draw shadow behind frame if is dark outline on dark frame or bright outline on bright frame
			const isDarkLine = isDarkColor($rootLineColor);

			const isDarkFrame = $imageFrame && $imageFrame.frameColor && isDarkColor($imageFrame.frameColor);

			if (isDarkLine && isDarkFrame || !isDarkLine && !isDarkLine) {
				const shadeColor = isDarkLine ? [1, 1, 1, 0.3] : [0, 0, 0, 0.075];

				shapes.push({
					x,
					y,
					width,
					height,
					strokeWidth: 3.5,
					strokeColor: shadeColor,
					opacity: $colorOpacity
				});
			}

			set([
				...shapes,
				// outline
				{
					x,
					y,
					width,
					height,
					strokeWidth: 1,
					strokeColor: $rootLineColor,
					opacity: $colorOpacity
				}
			]);
		}
	);

	// custom markup rendered on top of image
	const imageOverlayMarkup = writable([]);

	component_subscribe($$self, imageOverlayMarkup, value => $$invalidate(188, $imageOverlayMarkup = value));

	// the resulting overlay markup
	const imageOverlay = derived([imageOutline, imageOverlayMarkup], ([$imageOutline, $imageOverlayMarkup], set) => {
		set([...$imageOutline, ...$imageOverlayMarkup]);
	});

	component_subscribe($$self, imageOverlay, value => $$invalidate(54, $imageOverlay = value));

	//
	// Stage overlay
	//
	// create canvas gradient for use as menu backdrop
	const getOverlayGradient = (width, height, color) => {
		const ctx = document.createElement("canvas").getContext("2d");
		ctx.canvas.width = Math.max(1, width);
		ctx.canvas.height = Math.max(1, height);
		const gradient = ctx.createLinearGradient(0, 0, width, height);

		[
			[0, 0],
			[0.013, 0.081],
			[0.049, 0.155],
			[0.104, 0.225],
			[0.175, 0.29],
			[0.259, 0.353],
			[0.352, 0.412],
			[0.45, 0.471],
			[0.55, 0.529],
			[0.648, 0.588],
			[0.741, 0.647],
			[0.825, 0.71],
			[0.896, 0.775],
			[0.951, 0.845],
			[0.987, 0.919],
			[1, 1]
		].forEach(([o, s]) => gradient.addColorStop(s, `rgba(${color[0] * 255}, ${color[1] * 255}, ${color[2] * 255}, ${o})`));

		ctx.fillStyle = gradient;
		ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		return ctx.canvas;
	};

	const calculateImageTargetSize = (outputSize, cropRect) => {
		let { width, height } = outputSize;
		const aspectRatio = rectAspectRatio(cropRect);
		if (width && height) return outputSize;

		if (width && !height) {
			height = width / aspectRatio;
		}

		if (height && !width) {
			width = height * aspectRatio;
		}

		if (!width && !height) {
			width = cropRect.width;
			height = cropRect.height;
		}

		return sizeApply(sizeCreate(width, height), Math.round);
	};

	const overlayInset = spring$2(40);
	component_subscribe($$self, overlayInset, value => $$invalidate(176, $overlayInset = value));
	const overlaySize = spring$2(70);
	component_subscribe($$self, overlaySize, value => $$invalidate(179, $overlaySize = value));
	const overlayLeftOpacity = spring$2(0);
	component_subscribe($$self, overlayLeftOpacity, value => $$invalidate(184, $overlayLeftOpacity = value));
	const overlayRightOpacity = spring$2(0);
	component_subscribe($$self, overlayRightOpacity, value => $$invalidate(186, $overlayRightOpacity = value));
	const overlayTopOpacity = spring$2(0);
	component_subscribe($$self, overlayTopOpacity, value => $$invalidate(180, $overlayTopOpacity = value));
	const overlayBottomOpacity = spring$2(0);
	component_subscribe($$self, overlayBottomOpacity, value => $$invalidate(182, $overlayBottomOpacity = value));

	// make sure canvas only redraws if background color changes
	let gradientOverlayHorizontal;

	let gradientOverlayVertical;

	rootBackgroundColor.subscribe(color => {
		if (!color) return;
		$$invalidate(160, gradientOverlayHorizontal = getOverlayGradient(16, 0, color));
		$$invalidate(161, gradientOverlayVertical = getOverlayGradient(0, 16, color));
	});

	// }
	//
	// Loading the preview
	//
	const imageVisualLoadComplete = writable(false);

	component_subscribe($$self, imageVisualLoadComplete, value => $$invalidate(227, $imageVisualLoadComplete = value));
	const imagePreviewSource = writable();
	component_subscribe($$self, imagePreviewSource, value => $$invalidate(190, $imagePreviewSource = value));
	let imagePreviewLoaderCancelToken;

	const createImagePreviewLoader = (src, token) => new Promise((resolve, reject) => {
			// try not to show preview loader if updating active images array
			const minPreviewLoaderDuration = $activeImages && $activeImages.length ? 0 : 250;

			let cancelled = false;
			let timer;
			token.cancel = () => cancelled = true;
			const now = Date.now();

			imageSourceToImageData(src).then(imageData => {
				const dist = Date.now() - now;
				clearTimeout(timer);

				timer = setTimeout(
					() => {
						if (cancelled) return;
						resolve(imageData);
					},
					Math.max(0, minPreviewLoaderDuration - dist)
				);
			}).catch(reject);
		});

	const imagePreview = derived([imageVisualLoadComplete, imagePreviewSource], ([$imageVisualLoadComplete, $imagePreviewSource], set) => {
		// cancel existing loader
		if (imagePreviewLoaderCancelToken) {
			imagePreviewLoaderCancelToken.cancel();
			$$invalidate(162, imagePreviewLoaderCancelToken = undefined);
		}

		// no data, reset preview data
		if (!$imageVisualLoadComplete || !$imagePreviewSource) return set(undefined);

		// load preview
		$$invalidate(162, imagePreviewLoaderCancelToken = { cancel: noop$1 });

		createImagePreviewLoader($imagePreviewSource, imagePreviewLoaderCancelToken).then(set).catch(err => set_store_value(imageLoadState, $imageLoadState.error = err, $imageLoadState)).finally(() => $$invalidate(162, imagePreviewLoaderCancelToken = undefined));
	});

	component_subscribe($$self, imagePreview, value => $$invalidate(22, $imagePreview = value));

	//
	// Calculates the image transforms and effects necessary for the preview
	//
	const imagePreviewModifiers = writable({});

	component_subscribe($$self, imagePreviewModifiers, value => $$invalidate(218, $imagePreviewModifiers = value));
	const interfaceImages = writable([]);
	component_subscribe($$self, interfaceImages, value => $$invalidate(50, $interfaceImages = value));

	// reset image UI previews when new file is loaded
	const resetPreviews = () => interfaceImages.set([]);

	const imageTransforms = derived(
		[
			stageRect,
			rootRect,
			imageSize,
			imageCropRectPresentation,
			imageSelectionRect,
			presentationScalar,
			imageRotation,
			imageFlipX,
			imageFlipY,
			imageOutputSize
		],
		([
				$stageRect,
				$rootRect,
				$imageSize,
				$imageCropRectPresentation,
				$imageSelectionRect,
				$presentationScalar,
				$imageRotation,
				$imageFlipX,
				$imageFlipY,
				$imageOutputSize
			], set) => {
			if (!$stageRect) return;

			// TODO: MAKE THIS CONTROLLABLE FROM PLUGIN
			if (utilSelected === "resize") {
				const visualSize = $imageOutputSize || $imageCropRectPresentation;
				$presentationScalar = visualSize.width / $imageCropRectPresentation.width || visualSize.height / $imageCropRectPresentation.height;
			}

			const transforms = calculateImageTransforms($stageRect, $rootRect, $imageSize, $imageCropRectPresentation, $imageSelectionRect, $presentationScalar, 0, 0, $imageRotation, $imageFlipX, $imageFlipY);
			set(transforms);
		}
	);

	component_subscribe($$self, imageTransforms, value => $$invalidate(217, $imageTransforms = value));

	const imageEffects = derived(
		[
			imageColorMatrix,
			imageConvolutionMatrix,
			imageGamma,
			imageVignette,
			imageNoise
		],
		([$colorMatrix, $convolutionMatrix, $gamma, $vignette, $noise], set) => {
			const colorMatrices = $colorMatrix && Object.keys($colorMatrix).map(name => $colorMatrix[name]).filter(Boolean);

			const effects = {
				gamma: $gamma || undefined,
				vignette: $vignette || undefined,
				noise: $noise || undefined,
				convolutionMatrix: $convolutionMatrix || undefined,
				colorMatrix: colorMatrices && colorMatrices.length && getColorMatrixFromColorMatrices(colorMatrices)
			};

			set(effects);
		}
	);

	//
	// current environment variables
	//
	let windowWidth;

	let windowHeight;
	const shouldPreventSwipe = canPreventNavSwipe();
	const env = writable({});
	component_subscribe($$self, env, value => $$invalidate(214, $env = value));
	const initialPixelRatio = getDevicePixelRatio();

	const pixelRatio = readable(initialPixelRatio, set => {
		const handleResolutionChange = () => set(getDevicePixelRatio());
		const resolutionObserver = matchMedia(`(resolution: ${initialPixelRatio}dppx)`);
		resolutionObserver.addListener(handleResolutionChange);
		return () => resolutionObserver.removeListener(handleResolutionChange);
	});

	component_subscribe($$self, pixelRatio, value => $$invalidate(46, $pixelRatio = value));

	//
	// Animations based on prefers-reduced-motion, automatically checks if user prefers reduced animations
	//
	const shouldAnimate = writable();

	component_subscribe($$self, shouldAnimate, value => $$invalidate(17, $shouldAnimate = value));

	const history = historyCreate(
		() => {
			// $imageState is always a clone of the current state
			return $imageState;
		},
		state => {
			// set new state from history, $imageState will store a clone of the received state
			set_store_value(imageState, $imageState = state, $imageState);

			// trigger recenter of image selection rect
			tabRect.set($tabRect);
		}
	);

	$$subscribe_history();

	const setInitialHistoryState = () => {
		// set history state
		const baseRect = { x: 0, y: 0, ...$imageSize };

		const baseCropRect = rectContainRect(baseRect, $imageState.cropAspectRatio);

		const baseEditorState = willSetHistoryInitialState(
			{
				// the base state is the image state but the `rotation` and `crop` are reset
				...$imageState,
				// should be read from imageInitialProps?
				rotation: 0,
				crop: baseCropRect
			},
			$imageState
		);

		// this will be the base state
		const editorInitialHistoryState = [baseEditorState];

		// only add additional entry if base state and current state are different
		if (JSON.stringify(baseEditorState) !== JSON.stringify($imageState)) {
			editorInitialHistoryState.push({ ...$imageState });
		}

		// loading done, set this as base state
		history.set(editorInitialHistoryState);
	};

	imageLoadState.subscribe(state => {
		// not ready yet
		if (!state || !state.complete) return;

		// set initial state after image load has completed
		setInitialHistoryState();
	});

	const revert = () => willRevert().then(shouldReset => shouldReset && history.revert());

	//
	// Visual processing of the image
	//
	const imageProcessingPreparing = writable(false);

	component_subscribe($$self, imageProcessingPreparing, value => $$invalidate(197, $imageProcessingPreparing = value));

	const handleExport = () => {
		// this will trigger status overlay fade in
		set_store_value(imageProcessingPreparing, $imageProcessingPreparing = true, $imageProcessingPreparing);

		willProcessImage().then(shouldProcess => {
			// nope, restore hide processing overlay and back to editing
			if (!shouldProcess) {
				set_store_value(imageProcessingPreparing, $imageProcessingPreparing = false, $imageProcessingPreparing);
				return;
			}

			// wait for status to be done fading in, then requests image writing
			let unsub;

			unsub = statusOpacity.subscribe(value => {
				if (value !== 1) return;

				// stop listening for
				unsub && unsub();

				// request write image
				dispatch("processImage");
			});
		});
	};

	imageProcessState.subscribe(state => {
		if (!state) return;
		set_store_value(imageProcessingPreparing, $imageProcessingPreparing = true, $imageProcessingPreparing);
		const { complete, abort } = state;
		if (complete || abort) set_store_value(imageProcessingPreparing, $imageProcessingPreparing = false, $imageProcessingPreparing);
	});

	//
	// Configure the available views
	//
	const utilStores = {
		// model stores
		...stores,
		// image
		imageFile,
		imageSize,
		imageBackgroundColor,
		imageCropAspectRatio,
		imageCropMinSize,
		imageCropMaxSize,
		imageCropLimitToImage,
		imageCropRect,
		imageCropRectOrigin,
		imageCropRectSnapshot,
		imageCropRectAspectRatio,
		imageCropRange,
		imageRotation,
		imageRotationRange,
		imageFlipX,
		imageFlipY,
		imageOutputSize,
		// effects
		imageColorMatrix,
		imageConvolutionMatrix,
		imageGamma,
		imageVignette,
		imageNoise,
		// markup
		imageDecoration,
		imageAnnotation,
		imageFrame,
		// image preview for utils that need access to pixel data
		imagePreview,
		// top left position of image preview
		imageTransforms,
		// allows utils to control how the preview is presented (for example more opacity for mask)
		imagePreviewModifiers,
		// history state and update
		history,
		// static env info
		animation: shouldAnimate,
		pixelRatio,
		elasticityMultiplier,
		scrollElasticity,
		rangeInputElasticity,
		// dynamic env info
		pointerAccuracy,
		pointerHoverable,
		env,
		rootRect,
		stageRect,
		stageScalar,
		framePadded,
		utilRect,
		presentationScalar,
		rootBackgroundColor,
		rootForegroundColor,
		rootLineColor,
		imageOutlineOpacity,
		// interaction
		// imagePresentationPan,
		// imagePresentationScale,
		// (write) add guides to ui (for example is used by markup util to add lines for shape manipulator)
		imageOverlayMarkup,
		// (write) interface images to render
		interfaceImages,
		// (write) set to true to disable animations
		isInteracting,
		// (read) goes from 0 to 1 while interacting
		isInteractingFraction,
		// (write) the current intended crop rect
		imageCropRectIntent,
		// (read) the current presented crop rect
		imageCropRectPresentation,
		// (write) the current limited size of the image selection rect
		imageSelectionRect,
		// (write) the inteded rectangle by the user
		imageSelectionRectIntent,
		// (read) the current presentation of the image selection rect, includes elasticity etc.
		imageSelectionRectPresentation,
		// (read) a snapshot of the image selection rectangle, use to store the rectangle before modification so alterations to the rectangle can be applied to the snapshot
		imageSelectionRectSnapshot,
		// scalar of image in view
		imageScalar
	};

	// don't expose image store
	delete utilStores.image;

	const utilsUniqueId = `util-${getUniqueId()}`;
	let utilsVisible = [];

	// env
	let iOS = isIOS();

	const getOrientation = (rect, layoutPreference) => {
		if (!$rootRect) return "landscape";
		if (layoutPreference === "auto") return rect.width > rect.height ? "landscape" : "portrait";
		if (layoutPreference === "horizontal") return rect.width < 500 ? "portrait" : "landscape";
		if (layoutPreference === "vertical") return rect.height < 400 ? "landscape" : "portrait";
	};

	const getColorPropertyValue = name => {
		const colorString = rootElementComputedStyle.getPropertyValue(name);
		return colorStringToColorArray(colorString);
	};

	const syncColor = (property, store) => {
		const colorArray = getColorPropertyValue(property);

		// hide transparent color
		if (!colorArray || colorArray[3] === 0) return;

		// limit to opaque colors
		colorArray.length = 3;

		// update store
		store.set(colorArray);
	};

	const syncColors = () => {
		syncColor("color", rootForegroundColor);
		syncColor("background-color", rootBackgroundColor);
		syncColor("outline-color", rootLineColor);
	};

	const handleTransitionEnd = ({ target, propertyName }) => {
		if (target !== root || !(/background|outline/).test(propertyName)) return;
		syncColors();
	};

	const imageProps = derived([imageTransforms, imageEffects, imageBackgroundColor], ([$imageTransforms, $imageEffects, backgroundColor]) => {
		return $imageTransforms && {
			...$imageTransforms,
			...$imageEffects,
			backgroundColor
		};
	});

	component_subscribe($$self, imageProps, value => $$invalidate(220, $imageProps = value));
	const activeImages = storeList();
	component_subscribe($$self, activeImages, value => $$invalidate(19, $activeImages = value));

	const addImagePreview = () => {
		// if is first image scale up slightly on entrance
		const imageIntro = activeImages.length ? undefined : { resize: 1.05 };

		// create the new image
		const image = createImage($imagePreview, $imageSize, imageIntro);

		// new image on top
		activeImages.unshift(image);

		// update images
		updateImagePreviews($imageProps);
	};

	const updateImagePreviews = currentImageProps => {
		activeImages.forEach((image, index) => {
			const opacity = index === 0 ? 1 : 0;
			const resize = 1;
			image.set({ ...currentImageProps, opacity, resize }, $shouldAnimate);
		});
	};

	// test if some shapes have left/top/bottom/right offsets, if so, convert to crop space
	// updates original shape (which at this point is a flattened shape (clone))
	const positionDecorationShape = (shape, canvasState) => shapeComputeDisplay(shape, {
		x: $imageSelectionRectPresentation.x / canvasState.scale,
		y: $imageSelectionRectPresentation.y / canvasState.scale,
		width: $imageSelectionRectPresentation.width / canvasState.scale,
		height: $imageSelectionRectPresentation.height / canvasState.scale
	});

	// decoration is drawn relative to view space, so we need to translate relative to crop presentation rect
	const transformDecorationShape = (shape, canvasState) => {
		shapeComputeTransform(shape, $imageSelectionRectPresentation, canvasState.scale, canvasState.size);
		return shape;
	};

	const flattenShapes = shapes => {
		const flattenedShapes = [];
		shapes.forEach(shape => flattenedShapes.push(flattenShape(shape)));
		return flattenedShapes.filter(Boolean);
	};

	const flattenShape = shape => {
		// at this point shape is a copy of the original shape
		if (shapeIsLine(shape)) {
			shape.points = [vectorCreate(shape.x1, shape.y1), vectorCreate(shape.x2, shape.y2)];
		} else if (shapeIsTriangle(shape)) {
			shape.points = [
				vectorCreate(shape.x1, shape.y1),
				vectorCreate(shape.x2, shape.y2),
				vectorCreate(shape.x3, shape.y3)
			];
		} else // is empty text
		if (shapeIsTextEmpty(shape)) {
			// make sure shape is still visible
			if (shapeIsTextLine(shape)) {
				shape.width = 5;

				shape.height = isFunction$1(shape.lineHeight)
				? shape.lineHeight(shape.fontSize)
				: shape.lineHeight;
			}

			// set to empty text style
			shape.strokeWidth = 1;

			shape.strokeColor = [1, 1, 1, 0.5];
			shape.backgroundColor = [0, 0, 0, 0.1];
		} else if (shapeIsText(shape)) {
			shape.fontFamily = shape.fontFamily || "sans-serif";
			shape.fontSize = shape.fontSize || 16;
		}

		return shape;
	};

	const statusOpacity = tweened(undefined, { duration: 500 });
	component_subscribe($$self, statusOpacity, value => $$invalidate(24, $statusOpacity = value));
	let loadTimer;
	let statusState;

	const asideOffset = spring$2(undefined, {
		stiffness: 0.1,
		damping: 0.7,
		precision: 0.25
	});

	component_subscribe($$self, asideOffset, value => $$invalidate(42, $asideOffset = value));
	const asideOpacity = spring$2(0, { stiffness: 0.1, precision: 0.05 });
	component_subscribe($$self, asideOpacity, value => $$invalidate(43, $asideOpacity = value));

	const asideWidth = spring$2(0, {
		stiffness: 0.02,
		damping: 0.5,
		precision: 0.25
	});

	component_subscribe($$self, asideWidth, value => $$invalidate(242, $asideWidth = value));

	const statusWidth = spring$2(undefined, {
		stiffness: 0.02,
		damping: 0.5,
		precision: 0.25
	});

	component_subscribe($$self, statusWidth, value => $$invalidate(240, $statusWidth = value));

	const statusOffset = spring$2(undefined, {
		stiffness: 0.02,
		damping: 0.5,
		precision: 0.25
	});

	component_subscribe($$self, statusOffset, value => $$invalidate(243, $statusOffset = value));
	let asideWidthUpdateTimer;

	const offsetAside = e => {
		// if error occured, snap in possition
		const hard = !!(statusState && statusState.closeButton);

		// where to render the progress indicator or close button
		statusWidth.set(e.detail.width, { hard });

		// offsets text so it's better centered to the viewport
		statusOffset.set(Math.round(-e.detail.width * 0.5), { hard });
	};

	const handleCloseImageLoadError = () => {
		dispatch("abortLoadImage");
	};

	const handleCloseImageProcessError = () => {
		dispatch("abortProcessImage");
		set_store_value(imageProcessingPreparing, $imageProcessingPreparing = false, $imageProcessingPreparing);
	};

	// context for children to know if a key is down
	const pressedKeysStore = writable([]);

	component_subscribe($$self, pressedKeysStore, value => $$invalidate(282, $pressedKeysStore = value));
	setContext("keysPressed", pressedKeysStore);

	const handleKeydown = e => {
		const { keyCode, composed, ctrlKey, shiftKey } = e;

		// prevent tabbing through fields if editor is disabled
		if (keyCode === 9 && disabled) {
			e.preventDefault();
			return;
		}

		// undo/redo
		if (keyCode === 90 && (composed || ctrlKey)) {
			if (shiftKey && composed) {
				// redo on macos
				history.redo();
			} else {
				// undo
				history.undo();
			}

			return;
		} else if (keyCode === 89 && ctrlKey) {
			// redo on windows
			history.redo();

			return;
		}

		// ignore IME popup keycode, fixes keycode 229 sticking around, as it's not triggered in keyup "If an Input Method Editor is processing key input and the event is keydown, return 229."
		// https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
		if (keyCode === 229) return;

		// add to set
		const keySet = new Set([...$pressedKeysStore, keyCode]);

		pressedKeysStore.set(Array.from(keySet));
	};

	const handleKeyup = ({ keyCode }) => {
		pressedKeysStore.set($pressedKeysStore.filter(pressedKey => pressedKey !== keyCode));
	};

	// so no keys get stuck when user cmd-tabs out of the window, or when dev-tools open by key-press
	const handleWindowBlur = () => {
		pressedKeysStore.set([]);
	};

	// block context menu on everything but text input fields
	const handleContextMenu = e => {
		if (isTextField(e.target)) return;
		e.preventDefault();
	};

	// handle files being dropped on the editor
	const handleUserFile = file => {
		// no file received, isn't an image file, is not a URL
		if (// no file received
		!file || // if it's a file object it should be a bitmap
		isBinary(file) && !isBitmap(file) || // if it's not a file object it should be a URL
		!isBinary(file) && !(/^http/).test(file)) return;

		// request load image
		dispatch("loadImage", file);
	};

	const handleDropFiles = e => {
		// not allowed to drop
		if (!enableDropImage) return;

		handleUserFile(e.detail.resources[0]);
	};

	const handlePaste = e => {
		// not allowed to paste
		if (!enablePasteImage) return;

		// calculate percentage of editor that is in view
		const xPercentage = clamp((windowWidth - Math.abs($rootRect.x)) / $rootRect.width, 0, 1);

		const yPercentage = clamp((windowHeight - Math.abs($rootRect.y)) / $rootRect.height, 0, 1);

		// editor needs to be in view
		if (xPercentage < 0.75 && yPercentage < 0.75) return;

		// request load image
		handleUserFile((e.clipboardData || window$1.clipboardData).files[0]);
	};

	// canvas drawing
	const getStageState = () => ({
		// add foreground color
		foregroundColor: [...$rootForegroundColor],
		// add line color
		lineColor: [...$rootLineColor],
		// add information on which util is active
		utilVisibility: { ...utilsVisibleFraction },
		// used to fade in elements when interacting
		isInteracting: $isInteracting,
		isInteractingFraction: $isInteractingFraction,
		// add the root rectangle so will render can use width/height of root element
		rootRect: rectClone($rootRect),
		// add the stage rectangle so will render knows where stage starts and ends
		stageRect: rectClone($stageRect),
		// preview selection rect
		selectionRect: rectClone($imageSelectionRectPresentation)
	});

	const createCanvasState = (canvasState, annotationShapes, decorationShapes, interfaceShapes, frameShapes) => ({
		annotationShapes: flattenShapes(annotationShapes.filter(shapeIsVisible).map(shapeDeepCopy).map(shape => shapeComputeDisplay(shape, $imageSize)).map(preprocessShape).flat()),
		decorationShapes: flattenShapes(decorationShapes.filter(shapeIsVisible).map(shapeDeepCopy).map(shape => positionDecorationShape(shape, canvasState)).map(preprocessShape).flat().map(shape => transformDecorationShape(shape, canvasState))),
		interfaceShapes: flattenShapes(interfaceShapes.filter(shapeIsVisible)),
		frameShapes: flattenShapes(frameShapes.map(shapeDeepCopy).map(shape => positionDecorationShape(shape, canvasState)).map(preprocessShape).flat().map(shape => transformDecorationShape(shape, canvasState)))
	});

	// setup root portal for detail panel dropdown
	let rootPortal;

	const rootPortalStore = writable();
	setContext("rootPortal", rootPortalStore);

	// setup root rect store for global access
	setContext("rootRect", rootRect);

	function onwindowresize() {
		$$invalidate(10, windowWidth = window_1.innerWidth);
		$$invalidate(11, windowHeight = window_1.innerHeight);
	}

	const measure_handler = e => set_store_value(toolRect, $toolRect = e.detail, $toolRect);
	const select_handler = ({ detail }) => $$invalidate(18, utilSelected = detail);
	const func = (panel, util) => util.id === panel;

	function panel_component_binding(value, panel) {
		if ($$self.$$.not_equal(pluginInterface[panel], value)) {
			pluginInterface[panel] = value;
			(($$invalidate(0, pluginInterface), $$invalidate(7, pluginOptions)), $$invalidate(157, pluginComponents));
		}
	}

	const measure_handler_1 = e => set_store_value(utilRect, $utilRect = e.detail, $utilRect);
	const show_handler = panel => $$invalidate(26, utilsVisible = utilsVisible.concat(panel));
	const hide_handler = panel => $$invalidate(26, utilsVisible = utilsVisible.filter(util => util !== panel));
	const fade_handler = (panel, { detail }) => $$invalidate(21, utilsVisibleFraction[panel] = detail, utilsVisibleFraction);
	const measure_handler_2 = e => set_store_value(tabRect, $tabRect = e.detail, $tabRect);
	const func_1 = util => util.id === utilSelected;

	function panel_component_binding_1(value) {
		if ($$self.$$.not_equal(pluginInterface[utilSelected], value)) {
			pluginInterface[utilSelected] = value;
			(($$invalidate(0, pluginInterface), $$invalidate(7, pluginOptions)), $$invalidate(157, pluginComponents));
		}
	}

	const measure_handler_3 = e => set_store_value(utilRect, $utilRect = e.detail, $utilRect);
	const show_handler_1 = () => $$invalidate(26, utilsVisible = utilsVisible.concat(utilSelected));
	const hide_handler_1 = () => $$invalidate(26, utilsVisible = utilsVisible.filter(util => util !== utilSelected));
	const fade_handler_1 = ({ detail }) => $$invalidate(21, utilsVisibleFraction[utilSelected] = detail, utilsVisibleFraction);

	const func_2 = canvasState => {
		// current draw state
		const drawState = { ...canvasState, ...getStageState() };

		// allow dev to add custom overlay to `imageOverlay`
		const { annotationShapes, decorationShapes, interfaceShapes, frameShapes } = willRenderCanvas(
			{
				annotationShapes: $imageAnnotation,
				decorationShapes: $imageDecoration,
				frameShapes: [$imageFrame],
				interfaceShapes: $imageOverlay
			},
			drawState
		);

		// need to map shapes
		return createCanvasState(drawState, annotationShapes, decorationShapes, interfaceShapes, frameShapes);
	};

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			rootPortal = $$value;
			$$invalidate(13, rootPortal);
		});
	}

	function div_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			root = $$value;
			$$invalidate(1, root);
		});
	}

	const measure_handler_4 = e => set_store_value(clientRect, $clientRect = e.detail, $clientRect);

	$$self.$$set = $$props => {
		if ("class" in $$props) $$invalidate(134, klass = $$props.class);
		if ("layout" in $$props) $$invalidate(135, layoutMode = $$props.layout);
		if ("stores" in $$props) $$invalidate(136, stores = $$props.stores);
		if ("locale" in $$props) $$invalidate(2, locale = $$props.locale);
		if ("id" in $$props) $$invalidate(3, id = $$props.id);
		if ("util" in $$props) $$invalidate(137, util = $$props.util);
		if ("utils" in $$props) $$invalidate(138, utils = $$props.utils);
		if ("animations" in $$props) $$invalidate(139, animations = $$props.animations);
		if ("disabled" in $$props) $$invalidate(140, disabled = $$props.disabled);
		if ("status" in $$props) $$invalidate(133, status = $$props.status);
		if ("previewUpscale" in $$props) $$invalidate(141, previewUpscale = $$props.previewUpscale);
		if ("elasticityMultiplier" in $$props) $$invalidate(4, elasticityMultiplier = $$props.elasticityMultiplier);
		if ("willRevert" in $$props) $$invalidate(142, willRevert = $$props.willRevert);
		if ("willProcessImage" in $$props) $$invalidate(143, willProcessImage = $$props.willProcessImage);
		if ("willRenderCanvas" in $$props) $$invalidate(5, willRenderCanvas = $$props.willRenderCanvas);
		if ("willRenderToolbar" in $$props) $$invalidate(144, willRenderToolbar = $$props.willRenderToolbar);
		if ("willSetHistoryInitialState" in $$props) $$invalidate(145, willSetHistoryInitialState = $$props.willSetHistoryInitialState);
		if ("enableButtonExport" in $$props) $$invalidate(146, enableButtonExport = $$props.enableButtonExport);
		if ("enableButtonRevert" in $$props) $$invalidate(147, enableButtonRevert = $$props.enableButtonRevert);
		if ("enableNavigateHistory" in $$props) $$invalidate(148, enableNavigateHistory = $$props.enableNavigateHistory);
		if ("enableToolbar" in $$props) $$invalidate(6, enableToolbar = $$props.enableToolbar);
		if ("enableUtils" in $$props) $$invalidate(149, enableUtils = $$props.enableUtils);
		if ("enableButtonClose" in $$props) $$invalidate(150, enableButtonClose = $$props.enableButtonClose);
		if ("enableDropImage" in $$props) $$invalidate(151, enableDropImage = $$props.enableDropImage);
		if ("enablePasteImage" in $$props) $$invalidate(152, enablePasteImage = $$props.enablePasteImage);
		if ("previewImageDataMaxSize" in $$props) $$invalidate(153, previewImageDataMaxSize = $$props.previewImageDataMaxSize);
		if ("layoutDirectionPreference" in $$props) $$invalidate(154, layoutDirectionPreference = $$props.layoutDirectionPreference);
		if ("imagePreviewSrc" in $$props) $$invalidate(155, imagePreviewSrc = $$props.imagePreviewSrc);
		if ("imageOrienter" in $$props) $$invalidate(156, imageOrienter = $$props.imageOrienter);
		if ("pluginComponents" in $$props) $$invalidate(157, pluginComponents = $$props.pluginComponents);
		if ("pluginOptions" in $$props) $$invalidate(7, pluginOptions = $$props.pluginOptions);
		if ("root" in $$props) $$invalidate(1, root = $$props.root);
		if ("imageSourceToImageData" in $$props) $$invalidate(8, imageSourceToImageData = $$props.imageSourceToImageData);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[4] & /*layoutMode*/ 2048) {
			$$invalidate(165, isOverlayModeEnabled = layoutMode === "overlay");
		}

		if ($$self.$$.dirty[4] & /*enableUtils*/ 33554432 | $$self.$$.dirty[5] & /*isOverlayModeEnabled*/ 1024) {
			$$invalidate(14, showUtils = enableUtils && !isOverlayModeEnabled);
		}

		if ($$self.$$.dirty[0] & /*pluginOptions, pluginInterface*/ 129) {
			// map plugin options to plugin interface
			if (pluginOptions) {
				// for every plugin in plugin options
				Object.entries(pluginOptions).forEach(([name, plugin]) => {
					// for every prop defined for this plugin
					Object.entries(plugin).forEach(([prop, value]) => {
						// set value to interface
						if (!pluginInterface[name]) return;

						// set prop value
						$$invalidate(0, pluginInterface[name][prop] = value, pluginInterface);
					});
				});
			}
		}

		if ($$self.$$.dirty[0] & /*pluginInterface*/ 1 | $$self.$$.dirty[5] & /*pluginComponents*/ 4) {
			{
				let changed = false;

				pluginComponents.forEach(([key]) => {
					if (pluginInterface[key]) return;
					$$invalidate(0, pluginInterface[key] = {}, pluginInterface);
					changed = true;
				});

				if (changed) {
					$$invalidate(159, registeredPluginsComponents = [...pluginComponents]);
				}
			}
		}

		if ($$self.$$.dirty[4] & /*disabled*/ 65536) {
			disabledTransition.set(disabled ? 1 : 0);
		}

		if ($$self.$$.dirty[4] & /*previewImageDataMaxSize*/ 536870912) {
			maxImageDataSize = previewImageDataMaxSize
			? sizeMin(previewImageDataMaxSize, maxTextureSize)
			: maxTextureSize;
		}

		if ($$self.$$.dirty[5] & /*$images*/ 2048) {
			imageProxy.update($images[0]);
		}

		if ($$self.$$.dirty[5] & /*$shapePreprocessor*/ 4096) {
			preprocessShape = $shapePreprocessor
			? shape => $shapePreprocessor(shape, { isPreview: true })
			: passthrough;
		}

		if ($$self.$$.dirty[0] & /*$clientRect*/ 32768) {
			$clientRect && rootRect.set(rectCreate($clientRect.x, $clientRect.y, $clientRect.width, $clientRect.height));
		}

		if ($$self.$$.dirty[5] & /*$rootRect, isOverlayModeEnabled, $imageLoadState*/ 25600) {
			$rootRect && isOverlayModeEnabled && ($imageLoadState && $imageLoadState.complete) && syncRootAspectRatio();
		}

		if ($$self.$$.dirty[0] & /*locale*/ 4 | $$self.$$.dirty[4] & /*utils*/ 16384 | $$self.$$.dirty[5] & /*registeredPluginsComponents*/ 16) {
			$$invalidate(172, utilsFiltered = locale && registeredPluginsComponents.length
			? utils || registeredPluginsComponents.map(([id]) => id)
			: []);
		}

		if ($$self.$$.dirty[5] & /*utilsFiltered*/ 131072) {
			$$invalidate(16, shouldRenderTabs = utilsFiltered.length > 1);
		}

		if ($$self.$$.dirty[0] & /*shouldRenderTabs*/ 65536) {
			if (!shouldRenderTabs) tabRect.set(rectCreateEmpty());
		}

		if ($$self.$$.dirty[0] & /*enableToolbar*/ 64) {
			if (!enableToolbar) toolRect.set(rectCreateEmpty());
		}

		if ($$self.$$.dirty[4] & /*previewUpscale*/ 131072 | $$self.$$.dirty[5] & /*isOverlayModeEnabled*/ 1024) {
			previewShouldUpscale.set(previewUpscale || isOverlayModeEnabled);
		}

		if ($$self.$$.dirty[5] & /*registeredPluginsComponents, utilsFiltered*/ 131088) {
			$$invalidate(198, utilsAvailable = registeredPluginsComponents.filter(([id]) => utilsFiltered.includes(id)));
		}

		if ($$self.$$.dirty[6] & /*utilsAvailable*/ 4096) {
			$$invalidate(199, utilsDefined = utilsAvailable.length);
		}

		if ($$self.$$.dirty[4] & /*util*/ 8192 | $$self.$$.dirty[5] & /*utilsFiltered*/ 131072 | $$self.$$.dirty[6] & /*utilsDefined*/ 8192) {
			$$invalidate(18, utilSelected = util && typeof util === "string" && utilsFiltered.includes(util)
			? util
			: utilsDefined > 0 ? utilsFiltered[0] : undefined);
		}

		if ($$self.$$.dirty[0] & /*utilSelected*/ 262144) {
			utilSelected && imageOutlineOpacity.set(0.075);
		}

		if ($$self.$$.dirty[0] & /*utilSelected*/ 262144) {
			overlayInset.set(utilSelected === "resize" ? 40 : 30);
		}

		if ($$self.$$.dirty[0] & /*utilSelected*/ 262144) {
			overlaySize.set(utilSelected === "resize" ? 140 : 70);
		}

		if ($$self.$$.dirty[5] & /*$imageCropRect, $imageOutputSize*/ 557056) {
			$$invalidate(175, imageTargetSizeCurrent = $imageCropRect && calculateImageTargetSize($imageOutputSize || {}, $imageCropRect));
		}

		if ($$self.$$.dirty[5] & /*imageTargetSizeCurrent, $stageRect, $overlayInset, $imageVisualBounds*/ 7602176) {
			imageTargetSizeCurrent && $stageRect && overlayTopOpacity.set(smoothstep($stageRect.y, $stageRect.y - $overlayInset, $imageVisualBounds.y));
		}

		if ($$self.$$.dirty[5] & /*imageTargetSizeCurrent, $stageRect, $overlayInset, $imageVisualBounds*/ 7602176) {
			imageTargetSizeCurrent && $stageRect && overlayRightOpacity.set(smoothstep($stageRect.x + $stageRect.width, $stageRect.x + $stageRect.width + $overlayInset, $imageVisualBounds.x + $imageVisualBounds.width));
		}

		if ($$self.$$.dirty[5] & /*imageTargetSizeCurrent, $stageRect, $overlayInset, $imageVisualBounds*/ 7602176) {
			imageTargetSizeCurrent && $stageRect && overlayBottomOpacity.set(smoothstep($stageRect.y + $stageRect.height, $stageRect.y + $stageRect.height + $overlayInset, $imageVisualBounds.y + $imageVisualBounds.height));
		}

		if ($$self.$$.dirty[5] & /*imageTargetSizeCurrent, $stageRect, $overlayInset, $imageVisualBounds*/ 7602176) {
			imageTargetSizeCurrent && $stageRect && overlayLeftOpacity.set(smoothstep($stageRect.x, $stageRect.x - $overlayInset, $imageVisualBounds.x));
		}

		if ($$self.$$.dirty[5] & /*$rootRect, $overlaySize, $overlayTopOpacity, gradientOverlayVertical*/ 50339904) {
			$$invalidate(178, overlayTop = $rootRect && {
				id: STAGE_OVERLAY_ID,
				x: 0,
				y: 0,
				width: $rootRect.width,
				height: $overlaySize,
				rotation: Math.PI,
				opacity: maxOpacity * $overlayTopOpacity,
				backgroundImage: gradientOverlayVertical
			});
		}

		if ($$self.$$.dirty[5] & /*$rootRect, $overlaySize, $overlayBottomOpacity, gradientOverlayVertical*/ 151003200) {
			$$invalidate(181, overlayBottom = $rootRect && {
				id: STAGE_OVERLAY_ID,
				x: 0,
				y: $rootRect.height - $overlaySize,
				width: $rootRect.width,
				height: $overlaySize,
				opacity: maxOpacity * $overlayBottomOpacity,
				backgroundImage: gradientOverlayVertical
			});
		}

		if ($$self.$$.dirty[5] & /*$rootRect, $overlaySize, $overlayLeftOpacity, gradientOverlayHorizontal*/ 553656352) {
			$$invalidate(183, overlayLeft = $rootRect && {
				id: STAGE_OVERLAY_ID,
				x: 0,
				y: 0,
				height: $rootRect.height,
				width: $overlaySize,
				rotation: Math.PI,
				opacity: maxOpacity * $overlayLeftOpacity,
				backgroundImage: gradientOverlayHorizontal
			});
		}

		if ($$self.$$.dirty[5] & /*$rootRect, $overlaySize, gradientOverlayHorizontal*/ 16785440 | $$self.$$.dirty[6] & /*$overlayRightOpacity*/ 1) {
			$$invalidate(185, overlayRight = $rootRect && {
				id: STAGE_OVERLAY_ID,
				x: $rootRect.width - $overlaySize,
				y: 0,
				height: $rootRect.height,
				width: $overlaySize,
				opacity: maxOpacity * $overlayRightOpacity,
				backgroundImage: gradientOverlayHorizontal
			});
		}

		if ($$self.$$.dirty[5] & /*overlayTop, overlayRight, overlayBottom, overlayLeft*/ 1417674752) {
			$$invalidate(187, gradientOverlays = [overlayTop, overlayRight, overlayBottom, overlayLeft].filter(Boolean));
		}

		if ($$self.$$.dirty[6] & /*gradientOverlays, $imageOverlayMarkup*/ 6) {
			// if overlay top changes
			if (gradientOverlays && $imageOverlayMarkup) {
				// remove existing resize overlays
				const overlayMarkup = $imageOverlayMarkup.filter(markup => markup.id !== STAGE_OVERLAY_ID);

				// if ($isActiveFraction > 0) {
				set_store_value(imageOverlayMarkup, $imageOverlayMarkup = [...overlayMarkup, ...gradientOverlays], $imageOverlayMarkup);
			} // }
			// else {
			//     $imageOverlayMarkup = overlayMarkup;
		}

		if ($$self.$$.dirty[5] & /*imagePreviewSrc*/ 1 | $$self.$$.dirty[6] & /*$imageFile*/ 8) {
			imagePreviewSource.set(imagePreviewSrc
			? imagePreviewSrc
			: $imageFile || undefined);
		}

		if ($$self.$$.dirty[6] & /*$imagePreviewSource*/ 16) {
			if ($imagePreviewSource) resetPreviews();
		}

		if ($$self.$$.dirty[5] & /*$isInteracting*/ 65536) {
			$$invalidate(191, canAnimate = !$isInteracting && !isSoftwareRendering());
		}

		if ($$self.$$.dirty[6] & /*$prefersReducedMotion*/ 128) {
			$$invalidate(192, acceptsAnimations = !$prefersReducedMotion);
		}

		if ($$self.$$.dirty[4] & /*animations*/ 32768 | $$self.$$.dirty[6] & /*canAnimate, acceptsAnimations*/ 96) {
			set_store_value(
				shouldAnimate,
				$shouldAnimate = animations === "always"
				? canAnimate
				: animations === "never"
					? false
					: canAnimate && acceptsAnimations,
				$shouldAnimate
			);
		}

		if ($$self.$$.dirty[6] & /*$history*/ 512) {
			$$invalidate(194, canUndo = $history.index > 0); //-1;
		}

		if ($$self.$$.dirty[6] & /*$history*/ 512) {
			$$invalidate(196, canRedo = $history.index < $history.length - 1);
		}

		if ($$self.$$.dirty[0] & /*locale*/ 4 | $$self.$$.dirty[5] & /*utilsFiltered*/ 131072 | $$self.$$.dirty[6] & /*utilsAvailable*/ 4096) {
			$$invalidate(20, utilsMerged = utilsFiltered.map(utilId => {
				const util = utilsAvailable.find(([id]) => utilId === id); // [id, view]
				if (!util) return;

				return {
					id: utilId,
					view: util[1],
					tabIcon: locale[`${utilId}Icon`],
					tabLabel: locale[`${utilId}Label`]
				};
			}).filter(Boolean) || []);
		}

		if ($$self.$$.dirty[0] & /*utilSelected*/ 262144) {
			utilSelectedStore.set(utilSelected);
		}

		if ($$self.$$.dirty[0] & /*utilSelected, pluginInterface*/ 262145) {
			$$invalidate(200, utilTools = utilSelected && pluginInterface[utilSelected].tools || []);
		}

		if ($$self.$$.dirty[0] & /*utilsMerged, utilsVisibleFraction*/ 3145728) {
			$$invalidate(21, utilsVisibleFraction = utilsMerged.reduce(
				(prev, curr) => {
					prev[curr.id] = utilsVisibleFraction && utilsVisibleFraction[curr.id] || 0;
					return prev;
				},
				{}
			));
		}

		if ($$self.$$.dirty[0] & /*utilSelected*/ 262144) {
			$$invalidate(28, tabsConfig = {
				name: utilsUniqueId,
				selected: utilSelected
			});
		}

		if ($$self.$$.dirty[0] & /*utilsMerged*/ 1048576) {
			$$invalidate(29, tabs = utilsMerged.map(util => ({
				id: util.id,
				icon: util.tabIcon,
				label: util.tabLabel
			})));
		}

		if ($$self.$$.dirty[0] & /*utilsMerged*/ 1048576) {
			$$invalidate(30, panels = utilsMerged.map(util => util.id));
		}

		if ($$self.$$.dirty[4] & /*klass*/ 1024) {
			$$invalidate(31, className = arrayJoin(["PinturaRoot", "PinturaRootComponent", klass]));
		}

		if ($$self.$$.dirty[5] & /*$rootRect*/ 8192) {
			$$invalidate(201, horizontalSpace = $rootRect && ($rootRect.width > 1000
			? "wide"
			: $rootRect.width < 600 ? "narrow" : undefined));
		}

		if ($$self.$$.dirty[5] & /*$rootRect*/ 8192) {
			$$invalidate(202, hasLimitedSpace = $rootRect && ($rootRect.width <= 320 || $rootRect.height <= 460));
		}

		if ($$self.$$.dirty[5] & /*$rootRect*/ 8192) {
			$$invalidate(203, verticalSpace = $rootRect && ($rootRect.height > 1000
			? "tall"
			: $rootRect.height < 600 ? "short" : undefined));
		}

		if ($$self.$$.dirty[0] & /*root*/ 2) {
			$$invalidate(204, isModal = root && root.parentNode && root.parentNode.classList.contains("PinturaModal"));
		}

		if ($$self.$$.dirty[0] & /*windowWidth*/ 1024 | $$self.$$.dirty[5] & /*$rootRect*/ 8192 | $$self.$$.dirty[6] & /*isModal*/ 262144) {
			$$invalidate(205, isCenteredHorizontally = isModal && $rootRect && windowWidth > $rootRect.width);
		}

		if ($$self.$$.dirty[0] & /*windowHeight*/ 2048 | $$self.$$.dirty[5] & /*$rootRect*/ 8192 | $$self.$$.dirty[6] & /*isModal*/ 262144) {
			$$invalidate(206, isCenteredVertically = isModal && $rootRect && windowHeight > $rootRect.height);
		}

		if ($$self.$$.dirty[6] & /*isCenteredHorizontally, isCenteredVertically*/ 1572864) {
			$$invalidate(207, isCentered = isCenteredHorizontally && isCenteredVertically);
		}

		if ($$self.$$.dirty[6] & /*horizontalSpace*/ 32768) {
			$$invalidate(208, isNarrow = horizontalSpace === "narrow");
		}

		if ($$self.$$.dirty[4] & /*layoutDirectionPreference*/ 1073741824 | $$self.$$.dirty[5] & /*$rootRect*/ 8192) {
			$$invalidate(209, orientation = getOrientation($rootRect, layoutDirectionPreference));
		}

		if ($$self.$$.dirty[6] & /*orientation*/ 8388608) {
			$$invalidate(32, isLandscape = orientation === "landscape");
		}

		if ($$self.$$.dirty[6] & /*isNarrow, verticalSpace*/ 4325376) {
			$$invalidate(210, isCompact = isNarrow || verticalSpace === "short");
		}

		if ($$self.$$.dirty[0] & /*windowWidth*/ 1024 | $$self.$$.dirty[5] & /*$rootRect*/ 8192) {
			$$invalidate(211, hasSwipeNavigation = iOS && ($rootRect && windowWidth === $rootRect.width) && !shouldPreventSwipe);
		}

		if ($$self.$$.dirty[5] & /*isOverlayModeEnabled*/ 1024 | $$self.$$.dirty[6] & /*utilTools, verticalSpace*/ 147456) {
			$$invalidate(212, shouldRenderUtilTools = utilTools.length && (verticalSpace === "short" || isOverlayModeEnabled));
		}

		if ($$self.$$.dirty[0] & /*root*/ 2) {
			// will update when root element is available (computed style is live, so is updated when the style is updated)
			$$invalidate(213, rootElementComputedStyle = root && getComputedStyle(root));
		}

		if ($$self.$$.dirty[6] & /*rootElementComputedStyle*/ 134217728) {
			// sync for first time
			if (rootElementComputedStyle) syncColors();
		}

		if ($$self.$$.dirty[0] & /*$shouldAnimate, enableToolbar, shouldRenderTabs, showUtils*/ 213056 | $$self.$$.dirty[4] & /*layoutMode, disabled*/ 67584 | $$self.$$.dirty[6] & /*$env, orientation, horizontalSpace, verticalSpace, isModal, isCentered, isCenteredHorizontally, isCenteredVertically, $pointerAccuracy, $pointerHoverable, isCompact, hasSwipeNavigation, hasLimitedSpace*/ 1941929984) {
			env.set({
				...$env,
				layoutMode,
				orientation,
				horizontalSpace,
				verticalSpace,
				isModal,
				isDisabled: disabled,
				isCentered,
				isCenteredHorizontally,
				isCenteredVertically,
				isAnimated: $shouldAnimate,
				pointerAccuracy: $pointerAccuracy,
				pointerHoverable: $pointerHoverable,
				isCompact,
				hasSwipeNavigation,
				hasLimitedSpace,
				hasToolbar: enableToolbar,
				hasNavigation: shouldRenderTabs && showUtils,
				isIOS: iOS
			});
		}

		if ($$self.$$.dirty[6] & /*$env*/ 268435456) {
			$$invalidate(33, envStr = Object.entries($env).map(([key, value]) => {
				// is true boolean prop, use key
				if ((/^is|has/).test(key)) {
					return value ? toKebabCase(key) : undefined;
				}

				// use value
				return value;
			}).filter(Boolean).join(" "));
		}

		if ($$self.$$.dirty[7] & /*$imageTransforms, $imagePreviewModifiers*/ 3) {
			$$invalidate(34, imageCanvasState = $imageTransforms && Object.entries($imagePreviewModifiers).filter(([,value]) => value != null).reduce(
				(prev, [,value]) => {
					prev = { ...prev, ...value };
					return prev;
				},
				{}
			));
		}

		if ($$self.$$.dirty[5] & /*$imageLoadState*/ 16384) {
			//
			// loading status
			//
			$$invalidate(219, isStartLoadingImageSource = $imageLoadState && $imageLoadState.task === "any-to-file");
		}

		if ($$self.$$.dirty[7] & /*isStartLoadingImageSource*/ 4) {
			// reset active images when loading a new image source
			if (isStartLoadingImageSource && activeImages) activeImages.clear();
		}

		if ($$self.$$.dirty[7] & /*$imageProps*/ 8) {
			// if image props are ready 
			$$invalidate(221, hasProps = !!$imageProps && !!$imageProps.translation);
		}

		if ($$self.$$.dirty[0] & /*$imagePreview*/ 4194304 | $$self.$$.dirty[7] & /*hasProps*/ 16) {
			// if image preview changes, push it on the stack
			hasProps && $imagePreview && addImagePreview();
		}

		if ($$self.$$.dirty[7] & /*hasProps, $imageProps*/ 24) {
			// update images when image props change
			hasProps && updateImagePreviews($imageProps);
		}

		if ($$self.$$.dirty[0] & /*$activeImages*/ 524288) {
			// clean active images array, removes 'inactive' images when their opacity is 0
			if ($activeImages && $activeImages.length > 1) {
				let imagesToRemove = [];

				activeImages.forEach((image, index) => {
					if (index === 0) return;
					if (image.get().opacity <= 0) imagesToRemove.push(image);
				});

				imagesToRemove.forEach(image => activeImages.remove(image));
			}
		}

		if ($$self.$$.dirty[0] & /*locale*/ 4 | $$self.$$.dirty[7] & /*missingFeatures*/ 32) {
			$$invalidate(23, isSupportsError = locale && missingFeatures.length && locale.labelSupportError(missingFeatures));
		}

		if ($$self.$$.dirty[5] & /*$imageLoadState*/ 16384) {
			$$invalidate(223, isImageLoadError = $imageLoadState && !!$imageLoadState.error);
		}

		if ($$self.$$.dirty[5] & /*$imageLoadState*/ 16384) {
			$$invalidate(224, isWaitingForImage = !$imageLoadState || !$imageLoadState.complete && $imageLoadState.task === undefined);
		}

		if ($$self.$$.dirty[5] & /*$imageLoadState*/ 16384) {
			$$invalidate(225, imageLoadProgress = $imageLoadState && ($imageLoadState.taskLengthComputable
			? $imageLoadState.taskProgress
			: Infinity));
		}

		if ($$self.$$.dirty[7] & /*isStartLoadingImageSource*/ 4) {
			if (isStartLoadingImageSource) set_store_value(imageVisualLoadComplete, $imageVisualLoadComplete = false, $imageVisualLoadComplete);
		}

		if ($$self.$$.dirty[5] & /*$imageLoadState, loadTimer*/ 16640) {
			if ($imageLoadState && $imageLoadState.complete) {
				const minLoaderDuration = 500;

				// TODO: derive visual load complete from interface rest state instead of arbitrary timer
				clearTimeout(loadTimer);

				$$invalidate(163, loadTimer = setTimeout(
					() => {
						set_store_value(imageVisualLoadComplete, $imageVisualLoadComplete = true, $imageVisualLoadComplete);
					},
					minLoaderDuration
				));
			}
		}

		if ($$self.$$.dirty[5] & /*$imageLoadState*/ 16384 | $$self.$$.dirty[7] & /*isImageLoadError, isWaitingForImage, $imageVisualLoadComplete*/ 1216) {
			$$invalidate(226, isLoadingImageData = $imageLoadState && !isImageLoadError && !isWaitingForImage && !$imageVisualLoadComplete);
		}

		if ($$self.$$.dirty[0] & /*$imagePreview*/ 4194304 | $$self.$$.dirty[5] & /*imagePreviewLoaderCancelToken*/ 128 | $$self.$$.dirty[6] & /*$imagePreviewSource*/ 16) {
			// is creating a preview while an image source is set and the preview isn't ready or when a cancel token is found
			$$invalidate(228, isCreatingImagePreview = !!$imagePreviewSource && (!$imagePreview || !!imagePreviewLoaderCancelToken));
		}

		if ($$self.$$.dirty[6] & /*$imageProcessingPreparing*/ 2048 | $$self.$$.dirty[7] & /*$imageProcessState*/ 8192) {
			//
			// processing status
			//
			$$invalidate(229, isProcessingImage = $imageProcessingPreparing || $imageProcessState && $imageProcessState.progress !== undefined && !$imageProcessState.complete);
		}

		if ($$self.$$.dirty[5] & /*$imageLoadState*/ 16384 | $$self.$$.dirty[7] & /*isWaitingForImage*/ 128) {
			$$invalidate(231, imageLoadShowProgressIndicator = $imageLoadState && !($imageLoadState.error || isWaitingForImage));
		}

		if ($$self.$$.dirty[0] & /*locale*/ 4 | $$self.$$.dirty[5] & /*$imageLoadState*/ 16384) {
			$$invalidate(232, imageLoadStatusLabel = locale && (!$imageLoadState
			? locale.statusLabelLoadImage($imageLoadState)
			: !$imageLoadState.complete || $imageLoadState.error
				? stringReplace(locale.statusLabelLoadImage($imageLoadState), $imageLoadState.error && $imageLoadState.error.metadata, "{", "}")
				: locale.statusLabelLoadImage({
						progress: Infinity,
						task: "blob-to-bitmap"
					})));
		}

		if ($$self.$$.dirty[0] & /*locale*/ 4 | $$self.$$.dirty[7] & /*$imageProcessState*/ 8192) {
			$$invalidate(233, imageProcessStatusLabel = $imageProcessState && locale && locale.statusLabelProcessImage($imageProcessState));
		}

		if ($$self.$$.dirty[7] & /*$imageProcessState*/ 8192) {
			$$invalidate(234, imageProcessProgress = $imageProcessState && ($imageProcessState.taskLengthComputable
			? $imageProcessState.taskProgress
			: Infinity));
		}

		if ($$self.$$.dirty[7] & /*$imageProcessState*/ 8192) {
			$$invalidate(235, imageProcessShowProgressIndicator = $imageProcessState && !$imageProcessState.error);
		}

		if ($$self.$$.dirty[7] & /*$imageProcessState*/ 8192) {
			$$invalidate(236, isImageProcessingError = $imageProcessState && $imageProcessState.error);
		}

		if ($$self.$$.dirty[0] & /*locale*/ 4 | $$self.$$.dirty[4] & /*status*/ 512 | $$self.$$.dirty[7] & /*isWaitingForImage, isImageLoadError, isLoadingImageData, isCreatingImagePreview, imageLoadStatusLabel, imageLoadShowProgressIndicator, imageLoadProgress, isProcessingImage, imageProcessStatusLabel, isImageProcessingError, imageProcessShowProgressIndicator, imageProcessProgress*/ 1039296) {
			if (status) {
				let label;
				let progress;
				let showProgress;
				let isError;
				let errorCallback;
				if (isString(status)) label = status;

				if (isNumber$1(status)) progress = status; else if (Array.isArray(status)) {
					[label, progress, errorCallback] = status;
					if (progress === false) isError = true;
					if (isNumber$1(progress)) showProgress = true;
				}

				$$invalidate(12, statusState = (label || progress) && {
					text: label,
					aside: isError || showProgress,
					progressIndicator: { visible: showProgress, progress },
					closeButton: isError && {
						label: locale.statusLabelButtonClose,
						icon: locale.statusIconButtonClose,
						onclick: errorCallback || (() => $$invalidate(133, status = undefined))
					}
				});
			} else if (locale && isWaitingForImage || isImageLoadError || isLoadingImageData || isCreatingImagePreview) {
				$$invalidate(12, statusState = {
					text: imageLoadStatusLabel,
					aside: isImageLoadError || imageLoadShowProgressIndicator,
					progressIndicator: {
						visible: imageLoadShowProgressIndicator,
						progress: imageLoadProgress
					},
					closeButton: isImageLoadError && {
						label: locale.statusLabelButtonClose,
						icon: locale.statusIconButtonClose,
						onclick: handleCloseImageLoadError
					}
				});
			} else if (locale && isProcessingImage && imageProcessStatusLabel) {
				$$invalidate(12, statusState = {
					text: imageProcessStatusLabel,
					aside: isImageProcessingError || imageProcessShowProgressIndicator,
					progressIndicator: {
						visible: imageProcessShowProgressIndicator,
						progress: imageProcessProgress
					},
					closeButton: isImageProcessingError && {
						label: locale.statusLabelButtonClose,
						icon: locale.statusIconButtonClose,
						onclick: handleCloseImageProcessError
					}
				});
			} else {
				$$invalidate(12, statusState = undefined);
			}
		}

		if ($$self.$$.dirty[4] & /*status*/ 512) {
			$$invalidate(237, isCustomStatus = status !== undefined);
		}

		if ($$self.$$.dirty[0] & /*isSupportsError*/ 8388608 | $$self.$$.dirty[7] & /*isWaitingForImage, isImageLoadError, isLoadingImageData, isCreatingImagePreview, isProcessingImage, isCustomStatus*/ 1055424) {
			$$invalidate(238, isStatusActive = isSupportsError || isWaitingForImage || isImageLoadError || isLoadingImageData || isCreatingImagePreview || isProcessingImage || isCustomStatus);
		}

		if ($$self.$$.dirty[7] & /*isStatusActive*/ 2097152) {
			set_store_value(statusOpacity, $statusOpacity = isStatusActive ? 1 : 0, $statusOpacity);
		}

		if ($$self.$$.dirty[0] & /*$statusOpacity*/ 16777216) {
			$$invalidate(25, isStatusVisible = $statusOpacity > 0);
		}

		if ($$self.$$.dirty[0] & /*statusState*/ 4096) {
			$$invalidate(239, hasAside = !!(statusState && statusState.aside));
		}

		if ($$self.$$.dirty[0] & /*isStatusVisible, statusState*/ 33558528 | $$self.$$.dirty[5] & /*asideWidthUpdateTimer*/ 512 | $$self.$$.dirty[7] & /*hasAside, $statusWidth*/ 12582912) {
			if (isStatusVisible && statusState) {
				clearTimeout(asideWidthUpdateTimer);

				// has aside
				if (hasAside) {
					// if error occured, snap in possition
					const hard = !!statusState.error;

					asideOpacity.set(1);

					// update offset of aside
					asideOffset.set($statusWidth, { hard });

					// update width of aside, this pushes message to left so it stays centered
					$$invalidate(164, asideWidthUpdateTimer = setTimeout(
						() => {
							asideWidth.set(16);
						},
						1
					));
				} else {
					asideOpacity.set(0);

					$$invalidate(164, asideWidthUpdateTimer = setTimeout(
						() => {
							asideWidth.set(0);
						},
						1
					));
				}
			}
		}

		if ($$self.$$.dirty[0] & /*isStatusVisible*/ 33554432) {
			if (!isStatusVisible) {
				statusOffset.set(undefined, { hard: true });
				asideOffset.set(undefined, { hard: true });
				asideWidth.set(0, { hard: true });
			}
		}

		if ($$self.$$.dirty[7] & /*$asideWidth*/ 33554432) {
			$$invalidate(241, statusIndent = $asideWidth * 0.5);
		}

		if ($$self.$$.dirty[7] & /*$statusOffset, statusIndent*/ 83886080) {
			$$invalidate(36, statusTransform = `transform: translateX(${$statusOffset - statusIndent}px)`);
		}

		if ($$self.$$.dirty[0] & /*windowWidth*/ 1024) {
			// prevents swipe to navigate back on iOS >= 13.4+
			$$invalidate(37, handleTouchStart = shouldPreventSwipe && (e => {
				// get touch or event itself (fixes issue with chrome dev tools)
				const event = e.touches ? e.touches[0] : e;

				// if is not an attempt to swipe back or forward
				if (event.pageX > 10 && event.pageX < windowWidth - 10) return;

				// stop the navigation attempt
				e.preventDefault();
			}));
		}

		if ($$self.$$.dirty[0] & /*locale*/ 4 | $$self.$$.dirty[4] & /*willRenderToolbar, enableButtonClose, enableButtonRevert, enableNavigateHistory, enableButtonExport*/ 97517568 | $$self.$$.dirty[6] & /*canUndo, canRedo, shouldRenderUtilTools, utilTools, isNarrow, $env*/ 339756288) {
			// dynamic IO menu
			$$invalidate(39, toolbarItems = locale && willRenderToolbar(
				[
					[
						"div",
						"alpha",
						{ class: "PinturaNavGroup" },
						[
							[
								"div",
								"alpha-set",
								{ class: "PinturaNavSet" },
								[
									// button close
									enableButtonClose && [
										"Button",
										"close",
										{
											label: locale.labelClose,
											icon: locale.iconButtonClose,
											onclick: () => dispatch("close"),
											hideLabel: true
										}
									],
									// button revert
									enableButtonRevert && [
										"Button",
										"revert",
										{
											label: locale.labelButtonRevert,
											icon: locale.iconButtonRevert,
											disabled: !canUndo,
											onclick: revert,
											hideLabel: true
										}
									]
								]
							]
						]
					],
					[
						"div",
						"beta",
						{
							class: "PinturaNavGroup PinturaNavGroupFloat"
						},
						[
							enableNavigateHistory && [
								"div",
								"history",
								{ class: "PinturaNavSet" },
								[
									[
										"Button",
										"undo",
										{
											label: locale.labelButtonUndo,
											icon: locale.iconButtonUndo,
											disabled: !canUndo,
											onclick: history.undo,
											hideLabel: true
										}
									],
									[
										"Button",
										"redo",
										{
											label: locale.labelButtonRedo,
											icon: locale.iconButtonRedo,
											disabled: !canRedo,
											onclick: history.redo,
											hideLabel: true
										}
									]
								]
							],
							shouldRenderUtilTools && [
								"div",
								"plugin-tools",
								{ class: "PinturaNavSet" },
								utilTools.filter(Boolean).map(// in
								([component, key, props]) => // out
								[component, key, { ...props, hideLabel: true }])
							]
						]
					],
					[
						"div",
						"gamma",
						{ class: "PinturaNavGroup" },
						[
							enableButtonExport && [
								"Button",
								"export",
								{
									label: locale.labelButtonExport,
									icon: isNarrow && locale.iconButtonExport,
									class: "PinturaButtonExport",
									onclick: handleExport,
									hideLabel: isNarrow
								}
							]
						]
					]
				],
				{ ...$env }
			));
		}

		if ($$self.$$.dirty[0] & /*$clientRect*/ 32768) {
			$$invalidate(244, hasClientRect = $clientRect && $clientRect.width > 0 && $clientRect.height > 0);
		}

		if ($$self.$$.dirty[0] & /*locale*/ 4 | $$self.$$.dirty[6] & /*utilsDefined*/ 8192 | $$self.$$.dirty[7] & /*hasClientRect*/ 134217728) {
			$$invalidate(40, canRender = hasClientRect && locale && utilsDefined);
		}

		if ($$self.$$.dirty[0] & /*rootPortal*/ 8192) {
			rootPortal && rootPortalStore.set(rootPortal);
		}
	};

	$$invalidate(222, missingFeatures = [!supportsWebGL() && "WebGL"].filter(Boolean));

	// prevent scrolling of page on older (<=12) iOS devices
	$$invalidate(38, handleTouchMove = !supportsPointerEvents() && (e => e.preventDefault()));

	// used to route ping events
	$$invalidate(41, routePing = createPingRouter(eventProxy.pub));

	return [
		pluginInterface,
		root,
		locale,
		id,
		elasticityMultiplier,
		willRenderCanvas,
		enableToolbar,
		pluginOptions,
		imageSourceToImageData,
		history,
		windowWidth,
		windowHeight,
		statusState,
		rootPortal,
		showUtils,
		$clientRect,
		shouldRenderTabs,
		$shouldAnimate,
		utilSelected,
		$activeImages,
		utilsMerged,
		utilsVisibleFraction,
		$imagePreview,
		isSupportsError,
		$statusOpacity,
		isStatusVisible,
		utilsVisible,
		$tabRect,
		tabsConfig,
		tabs,
		panels,
		className,
		isLandscape,
		envStr,
		imageCanvasState,
		$imageSelectionRectPresentation,
		statusTransform,
		handleTouchStart,
		handleTouchMove,
		toolbarItems,
		canRender,
		routePing,
		$asideOffset,
		$asideOpacity,
		$toolRect,
		$utilRect,
		$pixelRatio,
		$rootBackgroundColor,
		$utilSelectedStore,
		$stagePadded,
		$interfaceImages,
		$imageAnnotation,
		$imageDecoration,
		$imageFrame,
		$imageOverlay,
		$disabledTransition,
		disabledTransition,
		imageFile,
		imageSize,
		imageLoadState,
		imageProcessState,
		imageCropAspectRatio,
		imageCropRect,
		imageOutputSize,
		imageDecoration,
		imageAnnotation,
		imageFrame,
		imageState,
		images,
		shapePreprocessor,
		utilSelectedStore,
		rootBackgroundColor,
		rootForegroundColor,
		rootLineColor,
		clientRect,
		rootRect,
		tabRect,
		toolRect,
		utilRect,
		pointerAccuracy,
		pointerHoverable,
		isInteracting,
		isInteractingFraction,
		previewShouldUpscale,
		imageCropRectSnapshot,
		imageCropRectIntent,
		imageSelectionRect,
		imageSelectionRectSnapshot,
		imageSelectionRectIntent,
		stagePadded,
		stageRect,
		stageScalar,
		imageSelectionRectPresentation,
		presentationScalar,
		imageVisualBounds,
		imageOverlayMarkup,
		imageOverlay,
		overlayInset,
		overlaySize,
		overlayLeftOpacity,
		overlayRightOpacity,
		overlayTopOpacity,
		overlayBottomOpacity,
		imageVisualLoadComplete,
		imagePreviewSource,
		imagePreview,
		imagePreviewModifiers,
		interfaceImages,
		imageTransforms,
		env,
		pixelRatio,
		shouldAnimate,
		imageProcessingPreparing,
		utilStores,
		handleTransitionEnd,
		imageProps,
		activeImages,
		statusOpacity,
		asideOffset,
		asideOpacity,
		asideWidth,
		statusWidth,
		statusOffset,
		offsetAside,
		pressedKeysStore,
		handleKeydown,
		handleKeyup,
		handleWindowBlur,
		handleContextMenu,
		handleDropFiles,
		handlePaste,
		getStageState,
		createCanvasState,
		status,
		klass,
		layoutMode,
		stores,
		util,
		utils,
		animations,
		disabled,
		previewUpscale,
		willRevert,
		willProcessImage,
		willRenderToolbar,
		willSetHistoryInitialState,
		enableButtonExport,
		enableButtonRevert,
		enableNavigateHistory,
		enableUtils,
		enableButtonClose,
		enableDropImage,
		enablePasteImage,
		previewImageDataMaxSize,
		layoutDirectionPreference,
		imagePreviewSrc,
		imageOrienter,
		pluginComponents,
		sub,
		registeredPluginsComponents,
		gradientOverlayHorizontal,
		gradientOverlayVertical,
		imagePreviewLoaderCancelToken,
		loadTimer,
		asideWidthUpdateTimer,
		isOverlayModeEnabled,
		$images,
		$shapePreprocessor,
		$rootRect,
		$imageLoadState,
		$imageCropRect,
		$isInteracting,
		utilsFiltered,
		$stageRect,
		$imageOutputSize,
		imageTargetSizeCurrent,
		$overlayInset,
		$imageVisualBounds,
		overlayTop,
		$overlaySize,
		$overlayTopOpacity,
		overlayBottom,
		$overlayBottomOpacity,
		overlayLeft,
		$overlayLeftOpacity,
		overlayRight,
		$overlayRightOpacity,
		gradientOverlays,
		$imageOverlayMarkup,
		$imageFile,
		$imagePreviewSource,
		canAnimate,
		acceptsAnimations,
		$prefersReducedMotion,
		canUndo,
		$history,
		canRedo,
		$imageProcessingPreparing,
		utilsAvailable,
		utilsDefined,
		utilTools,
		horizontalSpace,
		hasLimitedSpace,
		verticalSpace,
		isModal,
		isCenteredHorizontally,
		isCenteredVertically,
		isCentered,
		isNarrow,
		orientation,
		isCompact,
		hasSwipeNavigation,
		shouldRenderUtilTools,
		rootElementComputedStyle,
		$env,
		$pointerAccuracy,
		$pointerHoverable,
		$imageTransforms,
		$imagePreviewModifiers,
		isStartLoadingImageSource,
		$imageProps,
		hasProps,
		missingFeatures,
		isImageLoadError,
		isWaitingForImage,
		imageLoadProgress,
		isLoadingImageData,
		$imageVisualLoadComplete,
		isCreatingImagePreview,
		isProcessingImage,
		$imageProcessState,
		imageLoadShowProgressIndicator,
		imageLoadStatusLabel,
		imageProcessStatusLabel,
		imageProcessProgress,
		imageProcessShowProgressIndicator,
		isImageProcessingError,
		isCustomStatus,
		isStatusActive,
		hasAside,
		$statusWidth,
		statusIndent,
		$asideWidth,
		$statusOffset,
		hasClientRect,
		onwindowresize,
		measure_handler,
		select_handler,
		func,
		panel_component_binding,
		measure_handler_1,
		show_handler,
		hide_handler,
		fade_handler,
		measure_handler_2,
		func_1,
		panel_component_binding_1,
		measure_handler_3,
		show_handler_1,
		hide_handler_1,
		fade_handler_1,
		func_2,
		div_binding,
		div_binding_1,
		measure_handler_4
	];
}

class Ui extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$t,
			create_fragment$t,
			safe_not_equal,
			{
				class: 134,
				layout: 135,
				stores: 136,
				locale: 2,
				id: 3,
				util: 137,
				utils: 138,
				animations: 139,
				disabled: 140,
				status: 133,
				previewUpscale: 141,
				elasticityMultiplier: 4,
				willRevert: 142,
				willProcessImage: 143,
				willRenderCanvas: 5,
				willRenderToolbar: 144,
				willSetHistoryInitialState: 145,
				enableButtonExport: 146,
				enableButtonRevert: 147,
				enableNavigateHistory: 148,
				enableToolbar: 6,
				enableUtils: 149,
				enableButtonClose: 150,
				enableDropImage: 151,
				enablePasteImage: 152,
				previewImageDataMaxSize: 153,
				layoutDirectionPreference: 154,
				imagePreviewSrc: 155,
				imageOrienter: 156,
				pluginComponents: 157,
				pluginOptions: 7,
				sub: 158,
				pluginInterface: 0,
				root: 1,
				imageSourceToImageData: 8,
				history: 9
			},
			[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
		);
	}

	get class() {
		return this.$$.ctx[134];
	}

	set class(klass) {
		this.$set({ class: klass });
		flush();
	}

	get layout() {
		return this.$$.ctx[135];
	}

	set layout(layoutMode) {
		this.$set({ layout: layoutMode });
		flush();
	}

	get stores() {
		return this.$$.ctx[136];
	}

	set stores(stores) {
		this.$set({ stores });
		flush();
	}

	get locale() {
		return this.$$.ctx[2];
	}

	set locale(locale) {
		this.$set({ locale });
		flush();
	}

	get id() {
		return this.$$.ctx[3];
	}

	set id(id) {
		this.$set({ id });
		flush();
	}

	get util() {
		return this.$$.ctx[137];
	}

	set util(util) {
		this.$set({ util });
		flush();
	}

	get utils() {
		return this.$$.ctx[138];
	}

	set utils(utils) {
		this.$set({ utils });
		flush();
	}

	get animations() {
		return this.$$.ctx[139];
	}

	set animations(animations) {
		this.$set({ animations });
		flush();
	}

	get disabled() {
		return this.$$.ctx[140];
	}

	set disabled(disabled) {
		this.$set({ disabled });
		flush();
	}

	get status() {
		return this.$$.ctx[133];
	}

	set status(status) {
		this.$set({ status });
		flush();
	}

	get previewUpscale() {
		return this.$$.ctx[141];
	}

	set previewUpscale(previewUpscale) {
		this.$set({ previewUpscale });
		flush();
	}

	get elasticityMultiplier() {
		return this.$$.ctx[4];
	}

	set elasticityMultiplier(elasticityMultiplier) {
		this.$set({ elasticityMultiplier });
		flush();
	}

	get willRevert() {
		return this.$$.ctx[142];
	}

	set willRevert(willRevert) {
		this.$set({ willRevert });
		flush();
	}

	get willProcessImage() {
		return this.$$.ctx[143];
	}

	set willProcessImage(willProcessImage) {
		this.$set({ willProcessImage });
		flush();
	}

	get willRenderCanvas() {
		return this.$$.ctx[5];
	}

	set willRenderCanvas(willRenderCanvas) {
		this.$set({ willRenderCanvas });
		flush();
	}

	get willRenderToolbar() {
		return this.$$.ctx[144];
	}

	set willRenderToolbar(willRenderToolbar) {
		this.$set({ willRenderToolbar });
		flush();
	}

	get willSetHistoryInitialState() {
		return this.$$.ctx[145];
	}

	set willSetHistoryInitialState(willSetHistoryInitialState) {
		this.$set({ willSetHistoryInitialState });
		flush();
	}

	get enableButtonExport() {
		return this.$$.ctx[146];
	}

	set enableButtonExport(enableButtonExport) {
		this.$set({ enableButtonExport });
		flush();
	}

	get enableButtonRevert() {
		return this.$$.ctx[147];
	}

	set enableButtonRevert(enableButtonRevert) {
		this.$set({ enableButtonRevert });
		flush();
	}

	get enableNavigateHistory() {
		return this.$$.ctx[148];
	}

	set enableNavigateHistory(enableNavigateHistory) {
		this.$set({ enableNavigateHistory });
		flush();
	}

	get enableToolbar() {
		return this.$$.ctx[6];
	}

	set enableToolbar(enableToolbar) {
		this.$set({ enableToolbar });
		flush();
	}

	get enableUtils() {
		return this.$$.ctx[149];
	}

	set enableUtils(enableUtils) {
		this.$set({ enableUtils });
		flush();
	}

	get enableButtonClose() {
		return this.$$.ctx[150];
	}

	set enableButtonClose(enableButtonClose) {
		this.$set({ enableButtonClose });
		flush();
	}

	get enableDropImage() {
		return this.$$.ctx[151];
	}

	set enableDropImage(enableDropImage) {
		this.$set({ enableDropImage });
		flush();
	}

	get enablePasteImage() {
		return this.$$.ctx[152];
	}

	set enablePasteImage(enablePasteImage) {
		this.$set({ enablePasteImage });
		flush();
	}

	get previewImageDataMaxSize() {
		return this.$$.ctx[153];
	}

	set previewImageDataMaxSize(previewImageDataMaxSize) {
		this.$set({ previewImageDataMaxSize });
		flush();
	}

	get layoutDirectionPreference() {
		return this.$$.ctx[154];
	}

	set layoutDirectionPreference(layoutDirectionPreference) {
		this.$set({ layoutDirectionPreference });
		flush();
	}

	get imagePreviewSrc() {
		return this.$$.ctx[155];
	}

	set imagePreviewSrc(imagePreviewSrc) {
		this.$set({ imagePreviewSrc });
		flush();
	}

	get imageOrienter() {
		return this.$$.ctx[156];
	}

	set imageOrienter(imageOrienter) {
		this.$set({ imageOrienter });
		flush();
	}

	get pluginComponents() {
		return this.$$.ctx[157];
	}

	set pluginComponents(pluginComponents) {
		this.$set({ pluginComponents });
		flush();
	}

	get pluginOptions() {
		return this.$$.ctx[7];
	}

	set pluginOptions(pluginOptions) {
		this.$set({ pluginOptions });
		flush();
	}

	get sub() {
		return this.$$.ctx[158];
	}

	get pluginInterface() {
		return this.$$.ctx[0];
	}

	get root() {
		return this.$$.ctx[1];
	}

	set root(root) {
		this.$set({ root });
		flush();
	}

	get imageSourceToImageData() {
		return this.$$.ctx[8];
	}

	set imageSourceToImageData(imageSourceToImageData) {
		this.$set({ imageSourceToImageData });
		flush();
	}

	get history() {
		return this.$$.ctx[9];
	}
}

// which props to filter out of exported props
const utilPrivateProps = ['klass', 'stores', 'isVisible', 'isActive', 'isActiveFraction', 'locale'];
const viewPrivateProps = [
    // methods
    'history',
    // props
    'klass',
    'stores',
    'navButtons',
    'pluginComponents',
    'pluginInterface',
    'pluginOptions',
    'sub',
    'imagePreviewSrc',
];
// view options array
let editorProps;
const pluginProps = new Set([]);
const propPluginRef = {};
// loops over plugins and registers all available options so we can define getters/setters
const pluginComponents = new Map();
const setEditorViewPlugins = (...args) => {
    args.filter((plugin) => !!plugin.util).forEach((plugin) => {
        const [id, Component] = plugin.util;
        if (pluginComponents.has(id))
            return;
        pluginComponents.set(id, Component);
        getComponentExportedProps(Component)
            .filter((prop) => !utilPrivateProps.includes(prop))
            .forEach((prop) => {
            pluginProps.add(prop);
            if (propPluginRef[prop]) {
                propPluginRef[prop].push(id);
                return;
            }
            propPluginRef[prop] = [id];
        });
    });
};
const attachEditorView = (target, stores) => {
    const accessors = {};
    // creates the editor component instance
    const editor = new Ui({
        target,
        props: {
            stores,
            pluginComponents: Array.from(pluginComponents),
        },
    });
    // destroys the editor component instance
    let isDestroyed = false;
    const destroy = () => {
        if (isDestroyed)
            return;
        if (isBrowser())
            window$1.removeEventListener('pagehide', destroy);
        if (!editor)
            return;
        isDestroyed = true;
        editor.$destroy();
    };
    // set up accessors for editor props
    if (!editorProps)
        editorProps = new Set(getComponentExportedProps(Ui).filter((prop) => !viewPrivateProps.includes(prop)));
    editorProps.forEach((prop) => {
        Object.defineProperty(accessors, prop, {
            get: () => editor[prop],
            set: (value) => (editor[prop] = value),
        });
    });
    // set up accessors for plugin props
    pluginProps.forEach((prop) => {
        const plugins = propPluginRef[prop];
        const plugin = plugins[0]; // will always get value from first plugin, when plugins share a property the value will be in sync when set
        Object.defineProperty(accessors, prop, {
            get: () => editor.pluginInterface[plugin][prop],
            set: (value) => {
                const opts = plugins.reduce((prev, plugin) => {
                    prev[plugin] = {
                        ...editor.pluginOptions[plugin],
                        [prop]: value,
                    };
                    return prev;
                }, {});
                editor.pluginOptions = {
                    ...editor.pluginOptions,
                    ...opts,
                };
            },
        });
    });
    // add `element` root query
    Object.defineProperty(accessors, 'element', {
        get: () => editor.root,
        set: () => undefined,
    });
    // history shortcut
    const history = editor.history;
    defineMethods(accessors, {
        on: (event, cb) => {
            // exit if editor was destroyed, will return stub function so unsubs can be called without issues
            if (isDestroyed)
                return () => { };
            // catch history events and route to history object
            if (/undo|redo|revert/.test(event))
                return history.on(event, cb);
            // gather unsub methods
            const unsubs = [
                editor.sub(event, cb),
                editor.$on(event, (e) => cb(e instanceof CustomEvent && !e.detail ? undefined : e)),
            ].filter(Boolean);
            // set up unsubscribe group
            return () => unsubs.forEach((unsub) => unsub());
        },
        updateImagePreview: (src) => {
            editor.imagePreviewSrc = src;
        },
        close: () => !isDestroyed && editor.pub('close'),
        destroy,
    });
    Object.defineProperty(accessors, 'history', {
        get: () => ({
            undo: () => history.undo(),
            redo: () => history.redo(),
            revert: () => history.revert(),
            get: () => history.get(),
            set: (entries) => history.set(entries),
            write: (state) => history.write(state),
            get length() {
                return history.length();
            },
            get index() {
                return history.index;
            },
        }),
    });
    // clean up on window unload
    if (isBrowser())
        window$1.addEventListener('pagehide', destroy);
    return accessors;
};

var editorEvents = [
    // core editor events that should be re-dispatched
    ...editorEventsToBubble,
    // ui editor events
    'undo',
    'redo',
    'update',
    'revert',
    'destroy',
    'show',
    'hide',
    'close',
    'selectshape',
    'updateshape',
    'addshape',
    'removeshape',
];

const dispatchElementEvent = (target, event, detail) => target.dispatchEvent(new CustomEvent(event, { detail, bubbles: true, cancelable: true }));
var dispatchEditorEvents = (editor, handler, options = {}) => {
    const { prefix = 'pintura:' } = options;
    return editorEvents.map((event) => editor.on(event, (value) => isElement(handler)
        ? dispatchElementEvent(handler, `${prefix}${event}`, value)
        : handler(event, value)));
};

var toPercentageNumber = (v) => Math.round(v * 100);

const brightness = {
    base: 0,
    min: -0.25,
    max: 0.25,
    getLabel: (value) => toPercentageNumber(value / 0.25),
    getStore: ({ imageColorMatrix }) => imageColorMatrix,
    getValue: (store) => {
        if (!store.brightness)
            return;
        return store.brightness[4];
    },
    setValue: (store, v) => store.update((matrices) => ({
        // clone existing matrices
        ...matrices,
        // prettier-ignore
        brightness: [
            1, 0, 0, 0, v,
            0, 1, 0, 0, v,
            0, 0, 1, 0, v,
            0, 0, 0, 1, 0
        ],
    })),
};
const contrast = {
    base: 1,
    min: 0.5,
    max: 1.5,
    getLabel: (value) => toPercentageNumber(-1 + (value - 0.5) * 2),
    getStore: ({ imageColorMatrix }) => imageColorMatrix,
    getValue: (store) => {
        if (!store.contrast)
            return;
        return store.contrast[0];
    },
    setValue: (store, v) => store.update((matrices) => ({
        // clone existing matrices
        ...matrices,
        // prettier-ignore
        contrast: [
            v, 0, 0, 0, .5 * (1 - v),
            0, v, 0, 0, .5 * (1 - v),
            0, 0, v, 0, .5 * (1 - v),
            0, 0, 0, 1, 0
        ],
    })),
};
const saturation = {
    base: 1,
    min: 0,
    max: 2,
    getLabel: (value) => toPercentageNumber(value - 1),
    getStore: ({ imageColorMatrix }) => imageColorMatrix,
    getValue: (store) => {
        if (!store.saturation)
            return;
        return (store.saturation[0] - 0.213) / 0.787;
    },
    setValue: (store, v) => store.update((matrices) => ({
        ...matrices,
        // prettier-ignore
        saturation: [
            .213 + .787 * v, .715 - .715 * v, .072 - .072 * v, 0, 0,
            .213 - .213 * v, .715 + .285 * v, .072 - .072 * v, 0, 0,
            .213 - .213 * v, .715 - .715 * v, .072 + .928 * v, 0, 0,
            0, 0, 0, 1, 0
        ],
    })),
};
const exposure = {
    base: 1,
    min: 0.5,
    max: 1.5,
    getLabel: (value) => toPercentageNumber(-1 + (value - 0.5) * 2),
    getStore: ({ imageColorMatrix }) => imageColorMatrix,
    getValue: (store) => {
        if (!store.exposure)
            return;
        return store.exposure[0];
    },
    setValue: (store, v) => store.update((matrices) => ({
        ...matrices,
        // prettier-ignore
        exposure: [
            v, 0, 0, 0, 0,
            0, v, 0, 0, 0,
            0, 0, v, 0, 0,
            0, 0, 0, 1, 0
        ],
    })),
};
const gamma = {
    base: 1,
    min: 0.15,
    max: 4,
    getLabel: (value) => {
        if (value < 1) {
            return toPercentageNumber((value - 0.15) / 0.85 - 1);
        }
        return toPercentageNumber((value - 1) / 3);
    },
    getStore: ({ imageGamma }) => imageGamma,
};
const vignette = {
    base: 0,
    min: -1,
    max: 1,
    getStore: ({ imageVignette }) => imageVignette,
};
const clarity = {
    base: 0,
    min: -1,
    max: 1,
    getStore: ({ imageConvolutionMatrix }) => imageConvolutionMatrix,
    getValue: (store) => {
        if (!store.clarity)
            return;
        if (store.clarity[0] === 0) {
            return store.clarity[1] / -1;
        }
        else {
            return store.clarity[1] / -2;
        }
    },
    setValue: (store, v) => {
        store.update((matrices) => ({
            ...matrices,
            // prettier-ignore
            clarity: v >= 0
                ? [0, -1 * v, 0,
                    -1 * v, 1 + 4 * v, -1 * v,
                    0, -1 * v, 0
                ]
                : [-1 * v, -2 * v, -1 * v,
                    -2 * v, 1 + -3 * v, -2 * v,
                    -1 * v, -2 * v, -1 * v
                ],
        }));
    },
};
const temperature = {
    base: 0,
    min: -1,
    max: 1,
    getStore: ({ imageColorMatrix }) => imageColorMatrix,
    getValue: (store) => {
        if (!store.temperature)
            return;
        const v = store.temperature[0];
        if (v >= 1) {
            return (v - 1) / 0.1;
        }
        return (1 - v) / -0.15;
    },
    setValue: (store, v) => store.update((matrices) => ({
        ...matrices,
        // prettier-ignore
        temperature: v > 0 ? [
            1 + (v * .1), 0, 0, 0, 0,
            0, 1, 0, 0, 0,
            0, 0, 1 + (-v * .1), 0, 0,
            0, 0, 0, 1, 0
        ] : [
            1 + (v * .15), 0, 0, 0, 0,
            0, 1 + (v * .05), 0, 0, 0,
            0, 0, 1 + (-v * .15), 0, 0,
            0, 0, 0, 1, 0
        ],
    })),
};
const finetuneControlConfigurationDefault = {
    gamma,
    brightness,
    contrast,
    saturation,
    exposure,
    temperature,
    clarity,
    vignette,
};
const finetuneOptionsDefault = [
    ['brightness', (locale) => locale.finetuneLabelBrightness],
    ['contrast', (locale) => locale.finetuneLabelContrast],
    ['saturation', (locale) => locale.finetuneLabelSaturation],
    ['exposure', (locale) => locale.finetuneLabelExposure],
    ['temperature', (locale) => locale.finetuneLabelTemperature],
    ['gamma', (locale) => locale.finetuneLabelGamma],
    !isSoftwareRendering() && ['clarity', (locale) => locale.finetuneLabelClarity],
    ['vignette', (locale) => locale.finetuneLabelVignette],
].filter(Boolean);
var _plugin_finetune_defaults = {
    finetuneControlConfiguration: finetuneControlConfigurationDefault,
    finetuneOptions: finetuneOptionsDefault,
};
/*
TODO: fix inverse fn in getValue
export const hue = {
    base: 0,
    min: 0,
    max: Math.PI,
    getStore: ({ imageColorMatrix }) => imageColorMatrix,
    getValue: (store) => {
        if (!store.hue) return;

        const v = store.hue[1];

        const o = -(Math.acos((0.715 - v) / Math.sqrt(2) / 0.715) - Math.PI / 4);

        return o;
    },
    setValue: (store, v: number) => {
        store.update((matrices) => {
            // const value = v * (Math.PI);

            const cos = Math.cos(v);
            const sin = Math.sin(v);

            const a00 = 0.213 + cos * 0.787 - sin * 0.213;
            const a01 = 0.715 - cos * 0.715 - sin * 0.715;
            const a02 = 0.072 - cos * 0.072 + sin * 0.928;
            const a10 = 0.213 - cos * 0.213 + sin * 0.143;
            const a11 = 0.715 + cos * 0.285 + sin * 0.14;
            const a12 = 0.072 - cos * 0.072 - sin * 0.283;
            const a20 = 0.213 - cos * 0.213 - sin * 0.787;
            const a21 = 0.715 - cos * 0.715 + sin * 0.715;
            const a22 = 0.072 + cos * 0.928 + sin * 0.072;

            return {
                ...matrices,

                // prettier-ignore
                hue: [
                    a00, a01, a02, 0, 0,
                    a10, a11, a12, 0, 0,
                    a20, a21, a22, 0, 0,
                      0,   0,   0, 1, 0,
                ]
            };
        });
    },
};
*/

const pastel = () => 
// prettier-ignore
[
    0.75, 0.25, 0.25, 0, 0,
    0.25, 0.75, 0.25, 0, 0,
    0.25, 0.25, 0.75, 0, 0,
    0, 0, 0, 1, 0
];
const chrome$2 = () => 
// prettier-ignore
[
    1.398, -0.316, 0.065, -0.273, 0.201,
    -0.051, 1.278, -0.080, -0.273, 0.201,
    -0.051, 0.119, 1.151, -0.290, 0.215,
    0, 0, 0, 1, 0
];
const fade = () => 
// prettier-ignore
[
    1.073, -0.015, 0.092, -0.115, -0.017,
    0.107, 0.859, 0.184, -0.115, -0.017,
    0.015, 0.077, 1.104, -0.115, -0.017,
    0, 0, 0, 1, 0
];
const warm = () => 
// prettier-ignore
[
    1.06, 0, 0, 0, 0,
    0, 1.01, 0, 0, 0,
    0, 0, 0.93, 0, 0,
    0, 0, 0, 1, 0,
];
const cold = () => 
// prettier-ignore
[
    1.1, 0, 0, 0, -.1,
    0, 1.1, 0, 0, -.1,
    0, 0, 1.2, 0, -.1,
    0, 0, 0, 1, 0,
];
const monoDefault = () => 
// prettier-ignore
[
    0.212, 0.715, 0.114, 0, 0,
    0.212, 0.715, 0.114, 0, 0,
    0.212, 0.715, 0.114, 0, 0,
    0, 0, 0, 1, 0
];
const monoNoir = () => 
// prettier-ignore
[
    0.15, 1.3, -0.25, 0.1, -0.2,
    0.15, 1.3, -0.25, 0.1, -0.2,
    0.15, 1.3, -0.25, 0.1, -0.2,
    0, 0, 0, 1, 0
];
const monoWash = () => 
// prettier-ignore
[
    0.163, 0.518, 0.084, -0.010, 0.208,
    0.163, 0.529, 0.082, -0.020, 0.210,
    0.171, 0.529, 0.084, 0.000, 0.214,
    0.000, 0.000, 0.000, 1.000, 0.000,
];
const monoStark = () => 
// prettier-ignore
[
    0.338, 0.991, 0.117, 0.093, -0.196,
    0.302, 1.049, 0.096, 0.078, -0.196,
    0.286, 1.016, 0.146, 0.101, -0.196,
    0.000, 0.000, 0.000, 1.000, 0.000,
];
const sepiaDefault = () => 
// prettier-ignore
[
    0.393, 0.768, 0.188, 0, 0,
    0.349, 0.685, 0.167, 0, 0,
    0.272, 0.533, 0.130, 0, 0,
    0, 0, 0, 1, 0,
];
const sepiaBlues = () => 
// prettier-ignore
[
    0.289, 0.620, 0.185, 0.000, 0.077,
    0.257, 0.566, 0.163, 0.000, 0.115,
    0.200, 0.430, 0.128, 0.000, 0.188,
    0.000, 0.000, 0.000, 1.000, 0.000,
];
const sepiaRust = () => 
// prettier-ignore
[
    0.269, 0.764, 0.172, 0.050, 0.100,
    0.239, 0.527, 0.152, 0.000, 0.176,
    0.186, 0.400, 0.119, 0.000, 0.159,
    0.000, 0.000, 0.000, 1.000, 0.000,
];
const sepiaColor = () => 
// prettier-ignore
[
    0.547, 0.764, 0.134, 0.000, -0.147,
    0.281, 0.925, 0.120, 0.000, -0.135,
    0.225, 0.558, 0.330, 0.000, -0.113,
    0.000, 0.000, 0.000, 1.000, 0.000,
];
//
// default filter set
//
const filterFunctionsDefault = {
    chrome: chrome$2,
    fade,
    pastel,
    cold,
    warm,
    monoDefault,
    monoWash,
    monoNoir,
    monoStark,
    sepiaDefault,
    sepiaRust,
    sepiaBlues,
    sepiaColor,
};
const filterOptionsDefault = [
    ['Default', [[undefined, (locale) => locale.labelDefault]]],
    [
        'Classic',
        [
            ['chrome', (locale) => locale.filterLabelChrome],
            ['fade', (locale) => locale.filterLabelFade],
            ['cold', (locale) => locale.filterLabelCold],
            ['warm', (locale) => locale.filterLabelWarm],
            ['pastel', (locale) => locale.filterLabelPastel],
        ],
    ],
    [
        'Monochrome',
        [
            ['monoDefault', (locale) => locale.filterLabelMonoDefault],
            ['monoNoir', (locale) => locale.filterLabelMonoNoir],
            ['monoStark', (locale) => locale.filterLabelMonoStark],
            ['monoWash', (locale) => locale.filterLabelMonoWash],
        ],
    ],
    [
        'Sepia',
        [
            ['sepiaDefault', (locale) => locale.filterLabelSepiaDefault],
            ['sepiaRust', (locale) => locale.filterLabelSepiaRust],
            ['sepiaBlues', (locale) => locale.filterLabelSepiaBlues],
            ['sepiaColor', (locale) => locale.filterLabelSepiaColor],
        ],
    ],
];
var _plugin_filter_defaults = {
    filterFunctions: filterFunctionsDefault,
    filterOptions: filterOptionsDefault,
};

const solidSharp = {
    shape: {
        frameStyle: 'solid',
        frameSize: '2.5%',
    },
    thumb: '<rect stroke-width="5" x="0" y="0" width="100%" height="100%"/>',
};
const solidRound = {
    shape: {
        frameStyle: 'solid',
        frameSize: '2.5%',
        frameRound: true,
    },
    thumb: '<rect stroke-width="5" x="0" y="0" width="100%" height="100%" rx="12%"/>',
};
const lineSingle = {
    shape: {
        frameStyle: 'line',
        frameInset: '2.5%',
        frameSize: '.3125%',
        frameRadius: 0,
    },
    thumb: '<div style="top:.5em;left:.5em;right:.5em;bottom:.5em;box-shadow:inset 0 0 0 1px currentColor"></div>',
};
const lineMultiple = {
    shape: {
        frameStyle: 'line',
        frameAmount: 2,
        frameInset: '2.5%',
        frameSize: '.3125%',
        frameOffset: '1.25%',
        frameRadius: 0,
    },
    thumb: '<div style="top:.75em;left:.75em;right:.75em;bottom:.75em; outline: 3px double"></div>',
};
const edgeSeparate = {
    shape: {
        frameStyle: 'edge',
        frameInset: '2.5%',
        frameOffset: '5%',
        frameSize: '.3125%',
    },
    thumb: '<div style="top:.75em;left:.5em;bottom:.75em;border-left:1px solid"></div><div style="top:.75em;right:.5em;bottom:.75em;border-right:1px solid"></div><div style="top:.5em;left:.75em;right:.75em;border-top:1px solid"></div><div style="bottom:.5em;left:.75em;right:.75em;border-bottom:1px solid"></div>',
};
const edgeCross = {
    shape: {
        frameStyle: 'edge',
        frameInset: '2.5%',
        frameSize: '.3125%',
    },
    thumb: '<div style="top:-.5em;left:.5em;right:.5em;bottom:-.5em; box-shadow: inset 0 0 0 1px currentColor"></div><div style="top:.5em;left:-.5em;right:-.5em;bottom:.5em;box-shadow:inset 0 0 0 1px currentColor"></div>',
};
const edgeOverlap = {
    shape: {
        frameStyle: 'edge',
        frameOffset: '1.5%',
        frameSize: '.3125%',
    },
    thumb: '<div style="top:.3125em;left:.5em;bottom:.3125em;border-left:1px solid"></div><div style="top:.3125em;right:.5em;bottom:.3125em;border-right:1px solid"></div><div style="top:.5em;left:.3125em;right:.3125em;border-top:1px solid"></div><div style="bottom:.5em;left:.3125em;right:.3125em;border-bottom:1px solid"></div>',
};
const hook = {
    shape: {
        frameStyle: 'hook',
        frameInset: '2.5%',
        frameSize: '.3125%',
        frameLength: '5%',
    },
    thumb: '<div style="top:.5em;left:.5em;width:.75em;height:.75em; border-left: 1px solid;border-top: 1px solid;"></div><div style="top:.5em;right:.5em;width:.75em;height:.75em; border-right: 1px solid;border-top: 1px solid;"></div><div style="bottom:.5em;left:.5em;width:.75em;height:.75em; border-left: 1px solid;border-bottom: 1px solid;"></div><div style="bottom:.5em;right:.5em;width:.75em;height:.75em; border-right: 1px solid;border-bottom: 1px solid;"></div>',
};
const polaroid = {
    shape: {
        frameStyle: 'polaroid',
    },
    thumb: '<rect stroke-width="20%" x="-5%" y="-5%" width="110%" height="96%"/>',
};
const frameStylesDefault = {
    solidSharp,
    solidRound,
    lineSingle,
    lineMultiple,
    edgeSeparate,
    edgeCross,
    edgeOverlap,
    hook,
    polaroid,
};
const frameOptionsDefault = [
    [undefined, (locale) => locale.labelNone],
    ['solidSharp', (locale) => locale.frameLabelMatSharp],
    ['solidRound', (locale) => locale.frameLabelMatRound],
    ['lineSingle', (locale) => locale.frameLabelLineSingle],
    ['lineMultiple', (locale) => locale.frameLabelLineMultiple],
    ['edgeCross', (locale) => locale.frameLabelEdgeCross],
    ['edgeSeparate', (locale) => locale.frameLabelEdgeSeparate],
    ['edgeOverlap', (locale) => locale.frameLabelEdgeOverlap],
    ['hook', (locale) => locale.frameLabelCornerHooks],
    ['polaroid', (locale) => locale.frameLabelPolaroid],
];
var _plugin_frame_defaults = {
    frameStyles: frameStylesDefault,
    frameOptions: frameOptionsDefault,
};

var RGBToHSV = (r, g, b) => {
    let v = Math.max(r, g, b), n = v - Math.min(r, g, b);
    let h = n && (v == r ? (g - b) / n : v == g ? 2 + (b - r) / n : 4 + (r - g) / n);
    return [(60 * (h < 0 ? h + 6 : h)) / 360, v && n / v, v];
};

var HSVToRGB = (h, s, v) => {
    let r, g, b;
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0:
            (r = v), (g = t), (b = p);
            break;
        case 1:
            (r = q), (g = v), (b = p);
            break;
        case 2:
            (r = p), (g = v), (b = t);
            break;
        case 3:
            (r = p), (g = q), (b = v);
            break;
        case 4:
            (r = t), (g = p), (b = v);
            break;
        case 5:
            (r = v), (g = p), (b = q);
            break;
    }
    return [r, g, b];
};

/* src/core/ui/components/ColorPreview.svelte generated by Svelte v3.37.0 */

function create_fragment$s(ctx) {
	let div;
	let span;
	let div_style_value;

	return {
		c() {
			div = element("div");
			span = element("span");
			attr(div, "class", "PinturaColorPreview");
			attr(div, "title", /*title*/ ctx[0]);
			attr(div, "style", div_style_value = `--color:${/*colorValue*/ ctx[1]}`);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span);
		},
		p(ctx, [dirty]) {
			if (dirty & /*title*/ 1) {
				attr(div, "title", /*title*/ ctx[0]);
			}

			if (dirty & /*colorValue*/ 2 && div_style_value !== (div_style_value = `--color:${/*colorValue*/ ctx[1]}`)) {
				attr(div, "style", div_style_value);
			}
		},
		i: noop$2,
		o: noop$2,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$s($$self, $$props, $$invalidate) {
	let colorValue;
	let { color = undefined } = $$props;
	let { title = undefined } = $$props;

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*color*/ 4) {
			$$invalidate(1, colorValue = color ? colorArrayToRGBA(color) : "transparent");
		}
	};

	return [title, colorValue, color];
}

class ColorPreview extends SvelteComponent {
	constructor(options) {
		super();
		init$3(this, options, instance$s, create_fragment$s, safe_not_equal, { color: 2, title: 0 });
	}
}

/* src/core/ui/components/ColorPicker.svelte generated by Svelte v3.37.0 */

function create_if_block_4$3(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(/*label*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*label*/ 1) set_data(t, /*label*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (317:4) 
function create_label_slot(ctx) {
	let span;
	let colorpreview;
	let t;
	let current;

	colorpreview = new ColorPreview({
			props: {
				color: /*value*/ ctx[4],
				title: localize(/*title*/ ctx[8], /*locale*/ ctx[10])
			}
		});

	let if_block = !/*hidePresetLabel*/ ctx[9] && create_if_block_4$3(ctx);

	return {
		c() {
			span = element("span");
			create_component(colorpreview.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			attr(span, "slot", "label");
			attr(span, "class", "PinturaButtonLabel");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			mount_component(colorpreview, span, null);
			append(span, t);
			if (if_block) if_block.m(span, null);
			current = true;
		},
		p(ctx, dirty) {
			const colorpreview_changes = {};
			if (dirty[0] & /*value*/ 16) colorpreview_changes.color = /*value*/ ctx[4];
			if (dirty[0] & /*title, locale*/ 1280) colorpreview_changes.title = localize(/*title*/ ctx[8], /*locale*/ ctx[10]);
			colorpreview.$set(colorpreview_changes);

			if (!/*hidePresetLabel*/ ctx[9]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_4$3(ctx);
					if_block.c();
					if_block.m(span, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(colorpreview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(colorpreview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			destroy_component(colorpreview);
			if (if_block) if_block.d();
		}
	};
}

// (329:8) {#if enablePicker}
function create_if_block_2$5(ctx) {
	let div3;
	let div2;
	let div1;
	let div0;
	let div0_style_value;
	let div1_style_value;
	let div2_style_value;
	let t0;
	let slider;
	let t1;
	let current;
	let mounted;
	let dispose;

	slider = new Slider({
			props: {
				class: "PinturaHuePicker",
				knobStyle: `background-color:${/*valueAsRGBAFullySaturated*/ ctx[19]}`,
				onchange: /*updateHue*/ ctx[24],
				value: /*hue*/ ctx[14],
				min: 0,
				max: 1,
				step: 0.01
			}
		});

	let if_block = /*enableOpacity*/ ctx[11] && create_if_block_3$3(ctx);

	return {
		c() {
			div3 = element("div");
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			t0 = space();
			create_component(slider.$$.fragment);
			t1 = space();
			if (if_block) if_block.c();
			attr(div0, "role", "button");
			attr(div0, "aria-label", "Saturation slider");
			attr(div0, "class", "PinturaPickerKnob");
			attr(div0, "tabindex", "0");
			attr(div0, "style", div0_style_value = `background-color:${/*valueAsRGBAFullyOpaque*/ ctx[18]};`);
			attr(div1, "class", "PinturaPickerKnobController");
			attr(div1, "style", div1_style_value = `transform:translate(${/*sx*/ ctx[21]}%,${/*sy*/ ctx[22]}%)`);
			attr(div2, "class", "PinturaSaturationPicker");
			attr(div2, "style", div2_style_value = `background-color: ${/*valueAsRGBAFullySaturated*/ ctx[19]}`);
			attr(div3, "class", "PinturaPicker");
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div2);
			append(div2, div1);
			append(div1, div0);
			/*div2_binding*/ ctx[31](div2);
			append(div3, t0);
			mount_component(slider, div3, null);
			append(div3, t1);
			if (if_block) if_block.m(div3, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "nudge", /*handleNudge*/ ctx[27]),
					action_destroyer(nudgeable.call(null, div0)),
					listen(div2, "pointerdown", /*handlePointerDown*/ ctx[26])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (!current || dirty[0] & /*valueAsRGBAFullyOpaque*/ 262144 && div0_style_value !== (div0_style_value = `background-color:${/*valueAsRGBAFullyOpaque*/ ctx[18]};`)) {
				attr(div0, "style", div0_style_value);
			}

			if (!current || dirty[0] & /*sx, sy*/ 6291456 && div1_style_value !== (div1_style_value = `transform:translate(${/*sx*/ ctx[21]}%,${/*sy*/ ctx[22]}%)`)) {
				attr(div1, "style", div1_style_value);
			}

			if (!current || dirty[0] & /*valueAsRGBAFullySaturated*/ 524288 && div2_style_value !== (div2_style_value = `background-color: ${/*valueAsRGBAFullySaturated*/ ctx[19]}`)) {
				attr(div2, "style", div2_style_value);
			}

			const slider_changes = {};
			if (dirty[0] & /*valueAsRGBAFullySaturated*/ 524288) slider_changes.knobStyle = `background-color:${/*valueAsRGBAFullySaturated*/ ctx[19]}`;
			if (dirty[0] & /*hue*/ 16384) slider_changes.value = /*hue*/ ctx[14];
			slider.$set(slider_changes);

			if (/*enableOpacity*/ ctx[11]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*enableOpacity*/ 2048) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_3$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div3, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(slider.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(slider.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div3);
			/*div2_binding*/ ctx[31](null);
			destroy_component(slider);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (350:12) {#if enableOpacity}
function create_if_block_3$3(ctx) {
	let slider;
	let current;

	slider = new Slider({
			props: {
				class: "PinturaOpacityPicker",
				knobStyle: `background-color: ${/*valueAsRGBA*/ ctx[16]}`,
				trackStyle: `background-image: linear-gradient(to right, ${/*valueAsRGBAFullyTransparent*/ ctx[17]}, ${/*valueAsRGBAFullyOpaque*/ ctx[18]})`,
				onchange: /*updateOpacity*/ ctx[25],
				value: /*opacity*/ ctx[15],
				min: 0,
				max: 1,
				step: 0.01
			}
		});

	return {
		c() {
			create_component(slider.$$.fragment);
		},
		m(target, anchor) {
			mount_component(slider, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const slider_changes = {};
			if (dirty[0] & /*valueAsRGBA*/ 65536) slider_changes.knobStyle = `background-color: ${/*valueAsRGBA*/ ctx[16]}`;
			if (dirty[0] & /*valueAsRGBAFullyTransparent, valueAsRGBAFullyOpaque*/ 393216) slider_changes.trackStyle = `background-image: linear-gradient(to right, ${/*valueAsRGBAFullyTransparent*/ ctx[17]}, ${/*valueAsRGBAFullyOpaque*/ ctx[18]})`;
			if (dirty[0] & /*opacity*/ 32768) slider_changes.value = /*opacity*/ ctx[15];
			slider.$set(slider_changes);
		},
		i(local) {
			if (current) return;
			transition_in(slider.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(slider.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(slider, detaching);
		}
	};
}

// (363:8) {#if enablePresets}
function create_if_block$6(ctx) {
	let radiogroup;
	let current;

	radiogroup = new RadioGroup({
			props: {
				label: "Presets",
				class: arrayJoin([
					"PinturaColorPresets",
					/*hidePresetLabel*/ ctx[9]
					? "PinturaColorPresetsGrid"
					: "PinturaColorPresetsList"
				]),
				hideLabel: false,
				name: /*name*/ ctx[1],
				value: /*value*/ ctx[4],
				optionGroupClass: "PinturaDropdownOptionGroup",
				optionClass: "PinturaDropdownOption",
				options: /*options*/ ctx[2].map(/*func*/ ctx[32]),
				selectedIndex: /*selectedIndex*/ ctx[3],
				optionMapper: /*optionMapper*/ ctx[7],
				optionLabelClass: /*optionLabelClass*/ ctx[6],
				onchange: /*func_1*/ ctx[33],
				$$slots: {
					option: [
						create_option_slot$3,
						({ option }) => ({ 44: option }),
						({ option }) => [0, option ? 8192 : 0]
					],
					group: [
						create_group_slot,
						({ option }) => ({ 44: option }),
						({ option }) => [0, option ? 8192 : 0]
					]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(radiogroup.$$.fragment);
		},
		m(target, anchor) {
			mount_component(radiogroup, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const radiogroup_changes = {};

			if (dirty[0] & /*hidePresetLabel*/ 512) radiogroup_changes.class = arrayJoin([
				"PinturaColorPresets",
				/*hidePresetLabel*/ ctx[9]
				? "PinturaColorPresetsGrid"
				: "PinturaColorPresetsList"
			]);

			if (dirty[0] & /*name*/ 2) radiogroup_changes.name = /*name*/ ctx[1];
			if (dirty[0] & /*value*/ 16) radiogroup_changes.value = /*value*/ ctx[4];
			if (dirty[0] & /*options, locale*/ 1028) radiogroup_changes.options = /*options*/ ctx[2].map(/*func*/ ctx[32]);
			if (dirty[0] & /*selectedIndex*/ 8) radiogroup_changes.selectedIndex = /*selectedIndex*/ ctx[3];
			if (dirty[0] & /*optionMapper*/ 128) radiogroup_changes.optionMapper = /*optionMapper*/ ctx[7];
			if (dirty[0] & /*optionLabelClass*/ 64) radiogroup_changes.optionLabelClass = /*optionLabelClass*/ ctx[6];

			if (dirty[0] & /*hidePresetLabel*/ 512 | dirty[1] & /*$$scope, option*/ 24576) {
				radiogroup_changes.$$scope = { dirty, ctx };
			}

			radiogroup.$set(radiogroup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(radiogroup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(radiogroup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(radiogroup, detaching);
		}
	};
}

// (378:12) 
function create_group_slot(ctx) {
	let span;
	let t_value = /*option*/ ctx[44].label + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(t_value);
			attr(span, "slot", "group");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty[1] & /*option*/ 8192 && t_value !== (t_value = /*option*/ ctx[44].label + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (383:16) {#if !hidePresetLabel}
function create_if_block_1$6(ctx) {
	let span;
	let t_value = /*option*/ ctx[44].label + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(t_value);
			attr(span, "class", "PinturaButtonLabel");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty[1] & /*option*/ 8192 && t_value !== (t_value = /*option*/ ctx[44].label + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (381:12) 
function create_option_slot$3(ctx) {
	let span;
	let colorpreview;
	let t;
	let current;

	colorpreview = new ColorPreview({
			props: {
				title: /*option*/ ctx[44].label,
				color: /*option*/ ctx[44].value
			}
		});

	let if_block = !/*hidePresetLabel*/ ctx[9] && create_if_block_1$6(ctx);

	return {
		c() {
			span = element("span");
			create_component(colorpreview.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			attr(span, "slot", "option");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			mount_component(colorpreview, span, null);
			append(span, t);
			if (if_block) if_block.m(span, null);
			current = true;
		},
		p(ctx, dirty) {
			const colorpreview_changes = {};
			if (dirty[1] & /*option*/ 8192) colorpreview_changes.title = /*option*/ ctx[44].label;
			if (dirty[1] & /*option*/ 8192) colorpreview_changes.color = /*option*/ ctx[44].value;
			colorpreview.$set(colorpreview_changes);

			if (!/*hidePresetLabel*/ ctx[9]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$6(ctx);
					if_block.c();
					if_block.m(span, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(colorpreview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(colorpreview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			destroy_component(colorpreview);
			if (if_block) if_block.d();
		}
	};
}

// (326:4) 
function create_details_slot(ctx) {
	let div;
	let t;
	let current;
	let if_block0 = /*enablePicker*/ ctx[13] && create_if_block_2$5(ctx);
	let if_block1 = /*enablePresets*/ ctx[12] && create_if_block$6(ctx);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr(div, "slot", "details");
			attr(div, "class", "PinturaColorPickerPanel");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*enablePicker*/ ctx[13]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*enablePicker*/ 8192) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$5(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*enablePresets*/ ctx[12]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*enablePresets*/ 4096) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$6(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

function create_fragment$r(ctx) {
	let details;
	let current;

	details = new Details({
			props: {
				buttonClass: arrayJoin(["PinturaColorPickerButton", /*buttonClass*/ ctx[5]]),
				$$slots: {
					details: [create_details_slot],
					label: [create_label_slot]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(details.$$.fragment);
		},
		m(target, anchor) {
			mount_component(details, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const details_changes = {};
			if (dirty[0] & /*buttonClass*/ 32) details_changes.buttonClass = arrayJoin(["PinturaColorPickerButton", /*buttonClass*/ ctx[5]]);

			if (dirty[0] & /*hidePresetLabel, name, value, options, locale, selectedIndex, optionMapper, optionLabelClass, enablePresets, valueAsRGBA, valueAsRGBAFullyTransparent, valueAsRGBAFullyOpaque, opacity, enableOpacity, valueAsRGBAFullySaturated, hue, input, sx, sy, enablePicker, label, title*/ 8388575 | dirty[1] & /*$$scope*/ 16384) {
				details_changes.$$scope = { dirty, ctx };
			}

			details.$set(details_changes);
		},
		i(local) {
			if (current) return;
			transition_in(details.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(details.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(details, detaching);
		}
	};
}

function instance$r($$self, $$props, $$invalidate) {
	let sx;
	let sy;
	let { label = undefined } = $$props;
	let { name = undefined } = $$props;
	let { options = [] } = $$props;
	let { selectedIndex = -1 } = $$props;
	let { value = undefined } = $$props;
	let { buttonClass = undefined } = $$props;
	let { optionLabelClass = undefined } = $$props;
	let { optionMapper = undefined } = $$props;
	let { onchange = undefined } = $$props;
	let { title = undefined } = $$props;
	let { hidePresetLabel = true } = $$props;
	let { locale = undefined } = $$props;
	let { enableOpacity = true } = $$props;
	let { enablePresets = true } = $$props;
	let { enablePicker = true } = $$props;

	// inputs
	let hue;

	let saturation;
	let brightness;
	let opacity;

	// shortcuts
	let valueAsRGB;

	let valueAsRGBA;
	let valueAsRGBAFullyTransparent;
	let valueAsRGBAFullyOpaque;
	let valueAsRGBAFullySaturated;

	const updateProps = (color, syncControls) => {
		valueAsRGB = [color[0], color[1], color[2]];

		if (syncControls) {
			let valueAsHSV = RGBToHSV(...valueAsRGB);
			$$invalidate(14, hue = valueAsHSV[0]);
			$$invalidate(29, saturation = valueAsHSV[1]);
			$$invalidate(30, brightness = valueAsHSV[2]);
			$$invalidate(15, opacity = isNumber$1(color[3]) ? color[3] : 1);
		}

		$$invalidate(16, valueAsRGBA = colorArrayToRGBA(color));
		$$invalidate(17, valueAsRGBAFullyTransparent = colorArrayToRGBA([...valueAsRGB, 0]));
		$$invalidate(18, valueAsRGBAFullyOpaque = colorArrayToRGBA([...valueAsRGB, 1]));
		$$invalidate(19, valueAsRGBAFullySaturated = colorArrayToRGBA(HSVToRGB(hue, 1, 1)));
	};

	value && updateProps(value, true);

	const update = () => {
		const rgb = HSVToRGB(hue, saturation, brightness);
		const rgba = [...rgb, opacity];
		updateProps(rgba);
		onchange(rgba);
	};

	const updateColorArray = arr => {
		const rgba = arr.length === 3 ? [...arr, 1] : arr;
		updateProps(rgba, true);
		onchange(rgba);
	};

	const updateHue = h => {
		$$invalidate(14, hue = h);
		if (opacity === 0) $$invalidate(15, opacity = 1);
		update();
	};

	const updateSaturationAndBrightness = (s, b) => {
		$$invalidate(29, saturation = s);
		$$invalidate(30, brightness = b);
		if (opacity === 0) $$invalidate(15, opacity = 1);
		update();
	};

	const updateOpacity = o => {
		$$invalidate(15, opacity = o);
		update();
	};

	const setValueByOffset = (offset, inputSize) => {
		const x = clamp(offset.x / inputSize.width, 0, 1);
		const y = clamp(offset.y / inputSize.height, 0, 1);
		updateSaturationAndBrightness(x, 1 - y);
	};

	let input;
	let inputSize;
	let inputOffset;
	let inputPageOffset;

	const handlePointerDown = e => {
		e.stopPropagation();
		inputSize = sizeCreate(input.offsetWidth, input.offsetHeight);
		inputOffset = vectorCreateFromPointerEventOffset(e);
		inputPageOffset = vectorCreateFromPointerEvent(e);
		setValueByOffset(inputOffset, inputSize);
		document.documentElement.addEventListener("pointermove", handlePointerMove);
		document.documentElement.addEventListener("pointerup", handlePointerUp);
	};

	const handlePointerMove = e => {
		const d = vectorSubtract(vectorCreateFromPointerEvent(e), inputPageOffset);
		setValueByOffset(vectorAdd(vectorClone(inputOffset), d), inputSize);
	};

	const handlePointerUp = e => {
		inputSize = undefined;
		document.documentElement.removeEventListener("pointermove", handlePointerMove);
		document.documentElement.removeEventListener("pointerup", handlePointerUp);
	};

	const handleNudge = e => {
		inputSize = sizeCreate(input.offsetWidth, input.offsetHeight);
		const x = sx / 100 * inputSize.width;
		const y = sy / 100 * inputSize.height;
		setValueByOffset({ x: x + e.detail.x, y: y + e.detail.y }, inputSize);
	};

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			input = $$value;
			$$invalidate(20, input);
		});
	}

	const func = ([color, label]) => [color, isFunction$1(label) ? label(locale) : label];
	const func_1 = detail => updateColorArray(detail.value);

	$$self.$$set = $$props => {
		if ("label" in $$props) $$invalidate(0, label = $$props.label);
		if ("name" in $$props) $$invalidate(1, name = $$props.name);
		if ("options" in $$props) $$invalidate(2, options = $$props.options);
		if ("selectedIndex" in $$props) $$invalidate(3, selectedIndex = $$props.selectedIndex);
		if ("value" in $$props) $$invalidate(4, value = $$props.value);
		if ("buttonClass" in $$props) $$invalidate(5, buttonClass = $$props.buttonClass);
		if ("optionLabelClass" in $$props) $$invalidate(6, optionLabelClass = $$props.optionLabelClass);
		if ("optionMapper" in $$props) $$invalidate(7, optionMapper = $$props.optionMapper);
		if ("onchange" in $$props) $$invalidate(28, onchange = $$props.onchange);
		if ("title" in $$props) $$invalidate(8, title = $$props.title);
		if ("hidePresetLabel" in $$props) $$invalidate(9, hidePresetLabel = $$props.hidePresetLabel);
		if ("locale" in $$props) $$invalidate(10, locale = $$props.locale);
		if ("enableOpacity" in $$props) $$invalidate(11, enableOpacity = $$props.enableOpacity);
		if ("enablePresets" in $$props) $$invalidate(12, enablePresets = $$props.enablePresets);
		if ("enablePicker" in $$props) $$invalidate(13, enablePicker = $$props.enablePicker);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*saturation*/ 536870912) {
			$$invalidate(21, sx = saturation * 100);
		}

		if ($$self.$$.dirty[0] & /*brightness*/ 1073741824) {
			$$invalidate(22, sy = 100 - brightness * 100);
		}
	};

	return [
		label,
		name,
		options,
		selectedIndex,
		value,
		buttonClass,
		optionLabelClass,
		optionMapper,
		title,
		hidePresetLabel,
		locale,
		enableOpacity,
		enablePresets,
		enablePicker,
		hue,
		opacity,
		valueAsRGBA,
		valueAsRGBAFullyTransparent,
		valueAsRGBAFullyOpaque,
		valueAsRGBAFullySaturated,
		input,
		sx,
		sy,
		updateColorArray,
		updateHue,
		updateOpacity,
		handlePointerDown,
		handleNudge,
		onchange,
		saturation,
		brightness,
		div2_binding,
		func,
		func_1
	];
}

class ColorPicker extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$r,
			create_fragment$r,
			safe_not_equal,
			{
				label: 0,
				name: 1,
				options: 2,
				selectedIndex: 3,
				value: 4,
				buttonClass: 5,
				optionLabelClass: 6,
				optionMapper: 7,
				onchange: 28,
				title: 8,
				hidePresetLabel: 9,
				locale: 10,
				enableOpacity: 11,
				enablePresets: 12,
				enablePicker: 13
			},
			[-1, -1]
		);
	}
}

var upperCaseFirstLetter = (str) => str.charAt(0).toUpperCase() + str.slice(1);

let result$2 = null;
var canCheckFontAvailability = () => {
    if (result$2 === null) {
        if (!isBrowser())
            result$2 = false;
        else {
            try {
                // if browser can detect font as non existend then it supports font checking (only chrome)
                // @ts-ignore
                result$2 = document.fonts.check('16px TestNonExistingFont') === false;
            }
            catch (err) {
                // if throws assume can't check
                result$2 = false;
            }
        }
    }
    return result$2;
};

// @ts-ignore
const toLocaleFn = (key, localePrefix) => (locale) => locale[localePrefix ? `${localePrefix}${upperCaseFirstLetter(key)}` : key];
const createLocaleMapper = (options, localePrefix) => (key) => [
    options[key],
    toLocaleFn(key, localePrefix),
];
const toolColorDefault = [1, 0.2549, 0.2118];
const toolStrokeColorDefault = [1, 1, 1, 0];
//#region tools
const toolShapeDefaults = {
    path: () => ({
        points: [],
        disableErase: false,
    }),
    eraser: () => ({
        eraseRadius: 0,
    }),
    line: () => ({
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        disableErase: false,
    }),
    rectangle: () => ({
        x: 0,
        y: 0,
        width: 0,
        height: 0,
    }),
    ellipse: () => ({
        x: 0,
        y: 0,
        rx: 0,
        ry: 0,
    }),
    text: () => ({
        x: 0,
        y: 0,
        text: 'Text',
    }),
};
const createToolStyle = (type, shape = {}, options = { position: 'relative' }) => {
    if (!toolShapeDefaults[type])
        return;
    const shapeDef = {
        ...toolShapeDefaults[type](),
        ...shape,
    };
    return [shapeDef, options];
};
const createToolStyles = (tools) => ({
    sharpie: createToolStyle('path', {
        strokeWidth: '0.5%',
        strokeColor: [...toolColorDefault],
    }),
    eraser: createToolStyle('eraser'),
    line: createToolStyle('line', {
        strokeColor: [...toolColorDefault],
        strokeWidth: '0.5%',
    }),
    arrow: createToolStyle('line', {
        lineStart: 'none',
        lineEnd: 'arrow-solid',
        strokeColor: [...toolColorDefault],
        strokeWidth: '0.5%',
    }),
    rectangle: createToolStyle('rectangle', {
        strokeColor: [...toolStrokeColorDefault],
        backgroundColor: [...toolColorDefault],
    }),
    ellipse: createToolStyle('ellipse', {
        strokeColor: [...toolStrokeColorDefault],
        backgroundColor: [...toolColorDefault],
    }),
    text: createToolStyle('text', {
        color: [...toolColorDefault],
        fontSize: '2%',
    }),
    ...tools,
});
//#endregion
//#region toolbar
const createToolbarItem = (tool, label, props) => [
    tool,
    label || toLocaleFn(tool, 'shapeLabelTool'),
    {
        icon: toLocaleFn(tool, 'shapeIconTool'),
        ...props,
    },
];
const createToolbar = (tools = ['sharpie', 'eraser', 'line', 'arrow', 'rectangle', 'ellipse', 'text', 'preset']) => tools
    .map((tool) => {
    // default tool definition, assume locale in
    if (isString(tool))
        return createToolbarItem(tool);
    // tool def with propery
    if (Array.isArray(tool)) {
        // state update of tool with key in locale object
        if (isObject$1(tool[1]))
            return createToolbarItem(tool[0], undefined, tool[1]);
        // should be string, string
        return createToolbarItem(tool[0], tool[1], tool[2]);
    }
})
    .filter(Boolean);
//#endregion
//#region style option defaults
const createDefaultColorOptions = () => ({
    transparent: [1, 1, 1, 0],
    white: [1, 1, 1],
    silver: [0.8667, 0.8667, 0.8667],
    gray: [0.6667, 0.6667, 0.6667],
    black: [0, 0, 0],
    navy: [0, 0.1216, 0.2471],
    blue: [0, 0.4549, 0.851],
    aqua: [0.498, 0.8588, 1],
    teal: [0.2235, 0.8, 0.8],
    olive: [0.2392, 0.6, 0.4392],
    green: [0.1804, 0.8, 0.251],
    yellow: [1, 0.8627, 0],
    orange: [1, 0.5216, 0.1059],
    red: [1, 0.2549, 0.2118],
    maroon: [0.5216, 0.0784, 0.2941],
    fuchsia: [0.9412, 0.0706, 0.7451],
    purple: [0.6941, 0.051, 0.7882],
});
const createDefaultFontScaleOptions = () => ({
    extraSmall: '2%',
    small: '4%',
    mediumSmall: '8%',
    medium: '10%',
    mediumLarge: '15%',
    large: '20%',
    extraLarge: '25%',
});
const createDefaultStrokeScaleOptions = () => ({
    extraSmall: '0.25%',
    small: '0.5%',
    mediumSmall: '1%',
    medium: '1.75%',
    mediumLarge: '2.5%',
    large: '3.5%',
    extraLarge: '5%',
});
const createDefaultLineEndStyleOptions = () => [
    'bar',
    'arrow',
    'arrowSolid',
    'circle',
    'circleSolid',
    'square',
    'squareSolid',
];
const createDefaultFontFamilyOptions = () => [
    [`Helvetica, Arial, Verdana, 'Droid Sans', sans-serif`, 'Sans Serif'],
    [`'Arial Black', 'Avenir-Black', 'Arial Bold'`, 'Black'],
    [`'Arial Narrow', 'Futura-CondensedMedium'`, 'Narrow'],
    [`'Trebuchet MS'`, 'Humanist'],
    [`Georgia, 'Avenir-Black', 'Times New Roman', 'Droid Serif', serif`, 'Serif'],
    [`Palatino`, 'Old-Style'],
    [`'Times New Roman', 'TimesNewRomanPSMT'`, 'Transitional'],
    [`Menlo, Monaco, 'Lucida Console', monospace`, 'Monospaced'],
    [`'Courier New', monospace`, 'Slab Serif'],
];
const createDefaultTextAlignOptions = () => ['left', 'center', 'right'];
const createDefaultFontStyleOptions = () => [
    ['normal', 'bold'],
    ['italic', 'normal'],
    ['italic', 'bold'],
];
//#endregion
//#region style options
const createColorOptions = (colors) => Object.keys(colors).map(createLocaleMapper(colors, 'shapeTitleColor'));
const createFontScaleOptions = (scales) => Object.keys(scales).map(createLocaleMapper(scales, 'labelSize'));
const createStrokeScaleOptions = (scales) => Object.keys(scales).map(createLocaleMapper(scales, 'labelSize'));
const createFontFamilyOptions = (fonts) => [...fonts];
const createFontStyleOptions = (styles) => styles.map((style) => [
    style,
    (locale) => locale[`shapeLabelFontStyle${style
        .filter((v) => v !== 'normal')
        .map(upperCaseFirstLetter)
        .join('')}`],
]);
const createLineEndStyleOptions = (styles) => styles.map((style) => [
    toKebabCase(style),
    (locale) => locale[`shapeTitleLineDecoration${upperCaseFirstLetter(style)}`],
    { icon: (locale) => locale[`shapeIconLineDecoration${upperCaseFirstLetter(style)}`] },
]);
const createTextAlignOptions = (options) => options.map((align) => [
    align,
    (locale) => locale[`shapeTitleTextAlign${upperCaseFirstLetter(align)}`],
    {
        hideLabel: true,
        icon: (locale) => locale[`shapeIconTextAlign${upperCaseFirstLetter(align)}`],
    },
]);
const createControlOptions = (items, options) => {
    const { defaultKey, defaultOptions } = options || {};
    let arr = [];
    if (defaultKey)
        arr[0] = [undefined, (locale) => locale[defaultKey], { ...defaultOptions }];
    return [...arr, ...items];
};
//#endregion
//#region shape style controls
const someFontsAvailableInStack = (stack) => stack
    .split(',')
    .map((name) => name.trim())
    .some((name) => {
    // @ts-ignore
    return document.fonts.check(`16px ${name}`);
});
const createColorControl = (items) => [
    ColorPicker,
    {
        title: (locale) => locale.labelColor,
        options: createControlOptions(items),
    },
];
const createSliderControl = (options = {}) => [
    ToggleSlider,
    {
        ...options,
    },
];
const createFontFamilyControl = (fontFamilies) => [
    Dropdown,
    {
        title: (locale) => locale.shapeTitleFontFamily,
        onload: ({ options = [] }) => {
            // can't check for font availability so don't
            if (!canCheckFontAvailability())
                return;
            options
                // map to font stack (option value)
                .map(([stack]) => stack)
                // filter out undefined
                .filter(Boolean)
                // filter out fonts that are available
                .filter((stack) => !someFontsAvailableInStack(stack))
                // remaining fonts should have dom elements for future check
                .forEach((stack) => {
                // get as id
                const testId = `PinturaFontTest-${stack
                    .replace(/[^a-zA-Z0-9]+/g, '')
                    .toLowerCase()}`;
                // already added this tester
                if (document.getElementById(testId))
                    return;
                // add font tester
                document.body.appendChild(h$1('span', {
                    textContent: ' ',
                    id: testId,
                    style: `font-family:${stack};font-size:0;color:transparent;`,
                }));
            });
        },
        ondestroy: () => {
            // can't check for font availability so no need to clean up
            if (!canCheckFontAvailability())
                return;
            // clean up testers
            const testers = document.querySelectorAll('.PinturaFontTest');
            testers.forEach((tester) => tester.remove());
        },
        optionLabelStyle: (value) => `font-family: ${value}`,
        options: createControlOptions(fontFamilies, { defaultKey: 'labelDefault' }),
        optionFilter: (fontFamilyOption) => {
            // don't filter if not in browser context
            if (!canCheckFontAvailability())
                return true;
            // get font stack
            const [stack] = fontFamilyOption;
            // allow if undefined
            if (!stack)
                return true;
            // filter out fonts that aren't available
            const res = someFontsAvailableInStack(stack);
            return res;
        },
    },
];
const createBackgroundColorControl = (items) => [
    ColorPicker,
    {
        title: (locale) => locale.shapeTitleBackgroundColor,
        options: createControlOptions(items),
    },
];
const createStrokeColorControl = (items, options = {}) => [
    ColorPicker,
    {
        title: (locale) => locale.shapeTitleStrokeColor,
        options: createControlOptions(items),
        buttonClass: 'PinturaColorPickerButtonStroke',
        onchange: (value, shape) => {
            // get shape strokeWidth as number
            const strokeWidth = shape.strokeWidth;
            const strokeWidthParsed = isNumber$1(strokeWidth) || isString(strokeWidth) ? parseFloat(strokeWidth) : 0;
            // already has outline
            if (strokeWidthParsed > 0)
                return;
            // set outline to first stroke width
            shape.strokeWidth = (options && options.defaultStrokeWidth) || '0.5%';
        },
    },
];
const createStrokeWidthControl = (items) => [
    Dropdown,
    {
        title: (locale) => locale.shapeTitleStrokeWidth,
        options: (shape) => {
            if (hasProp(shape, 'backgroundColor'))
                return createControlOptions(items, {
                    defaultKey: 'shapeLabelStrokeNone',
                });
            return createControlOptions(items);
        },
    },
];
const createLineControl = (items, titleKey, optionIconStyle) => [
    Dropdown,
    {
        title: (locale) => locale[titleKey],
        options: createControlOptions(items, {
            defaultKey: 'labelNone',
            defaultOptions: {
                icon: `<g stroke="currentColor" stroke-linecap="round" stroke-width=".125em"><path d="M5,12 H14"/></g>`,
            },
        }),
        optionIconStyle,
    },
];
const createLineStartStyleControl = (items) => createLineControl(items, 'shapeTitleLineStart', `transform: scaleX(-1)`);
const createLineEndStyleControl = (items) => createLineControl(items, 'shapeTitleLineEnd');
const createFontColorControl = (items) => [
    ColorPicker,
    {
        title: (locale) => locale.shapeTitleTextColor,
        options: createControlOptions(items),
    },
];
const createFontStyleControl = (items) => [
    Dropdown,
    {
        title: (locale) => locale.shapeTitleFontStyle,
        optionLabelStyle: (value) => value && `font-style:${value[0]};font-weight:${value[1]}`,
        options: createControlOptions(items, {
            defaultKey: 'shapeLabelFontStyleNormal',
        }),
    },
];
const createFontSizeControl = (items) => [
    Dropdown,
    {
        title: (locale) => locale.shapeTitleFontSize,
        options: createControlOptions(items, { defaultKey: 'labelDefault' }),
    },
];
const createTextAlignControl = (items) => [
    RadioGroup,
    {
        title: (locale) => locale.shapeTitleTextAlign,
        options: createControlOptions(items),
    },
];
const createShapeStyleControls = (options = {}) => {
    const { colorOptions = createColorOptions(createDefaultColorOptions()), strokeWidthOptions = createStrokeScaleOptions(createDefaultStrokeScaleOptions()), lineEndStyleOptions = createLineEndStyleOptions(createDefaultLineEndStyleOptions()), fontFamilyOptions = createFontFamilyOptions(createDefaultFontFamilyOptions()), fontStyleOptions = createFontStyleOptions(createDefaultFontStyleOptions()), fontSizeOptions = createFontScaleOptions(createDefaultFontScaleOptions()), textAlignOptions = createTextAlignOptions(createDefaultTextAlignOptions()), } = options;
    return {
        // generic
        defaultColor: colorOptions && createColorControl(colorOptions),
        defaultNumber: createSliderControl(),
        defaultPercentage: createSliderControl({
            getValue: (value) => parseFloat(value),
            setValue: (value) => `${value}%`,
            step: 0.05,
            label: (value, min, max) => `${Math.round((value / max) * 100)}%`,
            labelClass: 'PinturaPercentageLabel',
        }),
        // shape background
        backgroundColor: colorOptions && createBackgroundColorControl(colorOptions),
        // line/outline
        strokeColor: colorOptions && createStrokeColorControl(colorOptions),
        strokeWidth: strokeWidthOptions && createStrokeWidthControl(strokeWidthOptions),
        // line
        lineStart: lineEndStyleOptions && createLineStartStyleControl(lineEndStyleOptions),
        lineEnd: lineEndStyleOptions && createLineEndStyleControl(lineEndStyleOptions),
        // text
        color: colorOptions && createFontColorControl(colorOptions),
        fontFamily: fontFamilyOptions && createFontFamilyControl(fontFamilyOptions),
        fontStyle_fontWeight: fontStyleOptions && createFontStyleControl(fontStyleOptions),
        fontSize: fontSizeOptions && createFontSizeControl(fontSizeOptions),
        textAlign: textAlignOptions && createTextAlignControl(textAlignOptions),
        // lineHeight: lineHeightOptions && createLineHeightControl(lineHeightOptions),
        // generic options
        frameColor: ['defaultColor'],
        frameSize: [
            'defaultPercentage',
            {
                min: 0.2,
                max: 10,
                title: (locale) => locale.labelSize,
            },
        ],
        frameInset: [
            'defaultPercentage',
            { min: 0.5, max: 10, title: (locale) => locale.labelInset },
        ],
        frameOffset: [
            'defaultPercentage',
            { min: 0.5, max: 10, title: (locale) => locale.labelOffset },
        ],
        frameRadius: [
            'defaultPercentage',
            { min: 0.5, max: 10, title: (locale) => locale.labelRadius },
        ],
        frameAmount: [
            'defaultNumber',
            { min: 1, max: 5, step: 1, title: (locale) => locale.labelAmount },
        ],
    };
};
//#endregion

/* src/core/ui/components/Measure.svelte generated by Svelte v3.37.0 */

function create_fragment$q(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", /*klass*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "measure", /*handleResize*/ ctx[1]),
					action_destroyer(measurable.call(null, div))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			if (!current || dirty & /*klass*/ 1) {
				attr(div, "class", /*klass*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$q($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const dispatch = createEventDispatcher();
	let { class: klass = null } = $$props;
	const handleResize = ({ detail }) => dispatch("measure", detail);

	$$self.$$set = $$props => {
		if ("class" in $$props) $$invalidate(0, klass = $$props.class);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [klass, handleResize, $$scope, slots];
}

class Measure extends SvelteComponent {
	constructor(options) {
		super();
		init$3(this, options, instance$q, create_fragment$q, safe_not_equal, { class: 0 });
	}
}

/* src/core/ui/components/Util.svelte generated by Svelte v3.37.0 */
const get_footer_slot_changes = dirty => ({});
const get_footer_slot_context = ctx => ({});
const get_main_slot_changes = dirty => ({});
const get_main_slot_context = ctx => ({});
const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});

// (261:0) {#if hasHeader}
function create_if_block_2$4(ctx) {
	let div;
	let current;
	const header_slot_template = /*#slots*/ ctx[4].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[3], get_header_slot_context);

	return {
		c() {
			div = element("div");
			if (header_slot) header_slot.c();
			attr(div, "class", "PinturaUtilHeader");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[3], dirty, get_header_slot_changes, get_header_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (268:22) <Measure class="PinturaStage" on:measure/>
function fallback_block(ctx) {
	let measure;
	let current;
	measure = new Measure({ props: { class: "PinturaStage" } });
	measure.$on("measure", /*measure_handler*/ ctx[5]);

	return {
		c() {
			create_component(measure.$$.fragment);
		},
		m(target, anchor) {
			mount_component(measure, target, anchor);
			current = true;
		},
		p: noop$2,
		i(local) {
			if (current) return;
			transition_in(measure.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(measure.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(measure, detaching);
		}
	};
}

// (271:0) {#if hasFooter}
function create_if_block_1$5(ctx) {
	let div;
	let current;
	const footer_slot_template = /*#slots*/ ctx[4].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[3], get_footer_slot_context);

	return {
		c() {
			div = element("div");
			if (footer_slot) footer_slot.c();
			attr(div, "class", "PinturaUtilFooter");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (footer_slot) {
				if (footer_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[3], dirty, get_footer_slot_changes, get_footer_slot_context);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};
}

function create_fragment$p(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let if_block2_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[1] && create_if_block_2$4(ctx);
	const main_slot_template = /*#slots*/ ctx[4].main;
	const main_slot = create_slot(main_slot_template, ctx, /*$$scope*/ ctx[3], get_main_slot_context);
	const main_slot_or_fallback = main_slot || fallback_block(ctx);
	let if_block1 = /*hasFooter*/ ctx[2] && create_if_block_1$5(ctx);
	let if_block2 = false ;

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (main_slot_or_fallback) main_slot_or_fallback.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if_block2_anchor = empty$1();
			attr(div, "class", "PinturaUtilMain");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, div, anchor);

			if (main_slot_or_fallback) {
				main_slot_or_fallback.m(div, null);
			}

			/*div_binding*/ ctx[6](div);
			insert(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t2, anchor);
			insert(target, if_block2_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*hasHeader*/ ctx[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*hasHeader*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (main_slot) {
				if (main_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(main_slot, main_slot_template, ctx, /*$$scope*/ ctx[3], dirty, get_main_slot_changes, get_main_slot_context);
				}
			}

			if (/*hasFooter*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*hasFooter*/ 4) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$5(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t2.parentNode, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(main_slot_or_fallback, local);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(main_slot_or_fallback, local);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(div);
			if (main_slot_or_fallback) main_slot_or_fallback.d(detaching);
			/*div_binding*/ ctx[6](null);
			if (detaching) detach(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t2);
			if (detaching) detach(if_block2_anchor);
		}
	};
}

function instance$p($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { hasHeader = !!$$props.$$slots.header } = $$props;
	let { hasFooter = !!$$props.$$slots.footer } = $$props;
	let { root = undefined } = $$props;

	function measure_handler(event) {
		bubble($$self, event);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			root = $$value;
			$$invalidate(0, root);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("hasHeader" in $$new_props) $$invalidate(1, hasHeader = $$new_props.hasHeader);
		if ("hasFooter" in $$new_props) $$invalidate(2, hasFooter = $$new_props.hasFooter);
		if ("root" in $$new_props) $$invalidate(0, root = $$new_props.root);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$props = exclude_internal_props($$props);
	return [root, hasHeader, hasFooter, $$scope, slots, measure_handler, div_binding];
}

class Util extends SvelteComponent {
	constructor(options) {
		super();
		init$3(this, options, instance$p, create_fragment$p, safe_not_equal, { hasHeader: 1, hasFooter: 2, root: 0 });
	}
}

/* src/core/ui/components/RangeInput.svelte generated by Svelte v3.37.0 */

function create_if_block$5(ctx) {
	let div;
	let div_style_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", "PinturaRangeInputMeter");
			attr(div, "style", div_style_value = `transform: translateX(${/*$position*/ ctx[9].x - /*svgPadding*/ ctx[10].x}px) translateY(${/*$position*/ ctx[9].y - /*svgPadding*/ ctx[10].y}px)`);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			div.innerHTML = /*svg*/ ctx[7];
		},
		p(ctx, dirty) {
			if (dirty[0] & /*svg*/ 128) div.innerHTML = /*svg*/ ctx[7];
			if (dirty[0] & /*$position*/ 512 && div_style_value !== (div_style_value = `transform: translateX(${/*$position*/ ctx[9].x - /*svgPadding*/ ctx[10].x}px) translateY(${/*$position*/ ctx[9].y - /*svgPadding*/ ctx[10].y}px)`)) {
				attr(div, "style", div_style_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$o(ctx) {
	let div1;
	let span;
	let t0;
	let t1;
	let button;
	let t2;
	let button_disabled_value;
	let t3;
	let div0;
	let nudgeable_action;
	let mounted;
	let dispose;
	let if_block = /*$position*/ ctx[9] && create_if_block$5(ctx);

	return {
		c() {
			div1 = element("div");
			span = element("span");
			t0 = text$1(/*valueLabel*/ ctx[4]);
			t1 = space();
			button = element("button");
			t2 = text$1(/*labelReset*/ ctx[1]);
			t3 = space();
			div0 = element("div");
			if (if_block) if_block.c();
			attr(span, "class", "PinturaRangeInputValue");
			attr(button, "class", "PinturaRangeInputReset");
			attr(button, "type", "button");
			button.disabled = button_disabled_value = /*value*/ ctx[0] === /*base*/ ctx[3];
			attr(div0, "class", "PinturaRangeInputInner");
			attr(div0, "style", /*rangeMask*/ ctx[8]);
			attr(div0, "data-value-limited", /*isLimited*/ ctx[6]);
			attr(div1, "class", "PinturaRangeInput");
			attr(div1, "tabindex", "0");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, span);
			append(span, t0);
			append(div1, t1);
			append(div1, button);
			append(button, t2);
			append(div1, t3);
			append(div1, div0);
			if (if_block) if_block.m(div0, null);

			if (!mounted) {
				dispose = [
					listen(button, "click", /*handleReset*/ ctx[15]),
					listen(div0, "interactionstart", /*handleDragStart*/ ctx[11]),
					listen(div0, "interactionupdate", /*handleDragMove*/ ctx[13]),
					listen(div0, "interactionend", /*handleDragEnd*/ ctx[14]),
					listen(div0, "interactionrelease", /*handleDragRelease*/ ctx[12]),
					action_destroyer(interactable.call(null, div0, { inertia: true })),
					listen(div0, "measure", /*measure_handler*/ ctx[32]),
					action_destroyer(measurable.call(null, div0)),
					listen(div1, "wheel", /*handleWheel*/ ctx[17], { passive: false }),
					listen(div1, "nudge", /*handleNudge*/ ctx[18]),
					action_destroyer(nudgeable_action = nudgeable.call(null, div1, /*direction*/ ctx[2] = "horizontal"))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*valueLabel*/ 16) set_data(t0, /*valueLabel*/ ctx[4]);
			if (dirty[0] & /*labelReset*/ 2) set_data(t2, /*labelReset*/ ctx[1]);

			if (dirty[0] & /*value, base*/ 9 && button_disabled_value !== (button_disabled_value = /*value*/ ctx[0] === /*base*/ ctx[3])) {
				button.disabled = button_disabled_value;
			}

			if (/*$position*/ ctx[9]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					if_block.m(div0, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*rangeMask*/ 256) {
				attr(div0, "style", /*rangeMask*/ ctx[8]);
			}

			if (dirty[0] & /*isLimited*/ 64) {
				attr(div0, "data-value-limited", /*isLimited*/ ctx[6]);
			}

			if (nudgeable_action && is_function(nudgeable_action.update) && dirty[0] & /*direction*/ 4) nudgeable_action.update.call(null, /*direction*/ ctx[2] = "horizontal");
		},
		i: noop$2,
		o: noop$2,
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

const radiusBig = 2; // 2
const radiusSmall = 0.75; // .75
const indicatorSpacing = 10;
const indicatorInterval = 5;
const indicatorCount = 40; // must be even

function instance$o($$self, $$props, $$invalidate) {
	let range;
	let valueMinLimited;
	let valueMaxLimited;
	let barSize;
	let baseFraction;
	let isLimited;
	let rangeMask;
	let $position;
	let { labelReset = "Reset" } = $$props;
	let { direction = "x" } = $$props;
	let { min = 0 } = $$props;
	let { max = 1 } = $$props;
	let { base = min } = $$props;
	let { value = 0 } = $$props;
	let { valueLabel = 0 } = $$props;
	let { valueMin = undefined } = $$props;
	let { valueMax = undefined } = $$props;
	let { oninputstart = noop$1 } = $$props;
	let { oninputmove = noop$1 } = $$props;
	let { oninputend = noop$1 } = $$props;
	let { elasticity = 0 } = $$props;
	const round = (number, increment, offset) => Math.ceil((number - offset) / increment) * increment + offset;
	let size;
	let svg;
	let svgSize;
	const svgPadding = { x: 2, y: 0 };
	const createPathCircle = (cx, cy, r) => `M ${cx - r} ${cy} a ${r} ${r} 0 1 0 0 -1`;

	function getMask(limitedMin, limitedMax) {
		const step = 1 / indicatorCount;
		const from = toFraction(limitedMin, min, max);
		const to = toFraction(limitedMax, min, max);
		const fromSnapped = fixPrecision(round(from, step, 0) - step * 0.5);
		const toSnapped = fixPrecision(round(to, step, 0) - step * 0.5);
		return `--range-mask-from:${fromSnapped * 100}%;--range-mask-to:${toSnapped * 100}%`;
	}

	//
	// Dragging related
	//
	let interactionOrigin = undefined;

	let interactionReleased = false;
	let interactionRange;
	let interactionOptions = { snap: false, elastic: false };

	const handleDragStart = () => {
		interactionReleased = false;
		interactionOrigin = get_store_value(position);

		interactionRange = [
			valueToPosition(valueMin != null ? valueMin : min, direction),
			valueToPosition(valueMax != null ? valueMax : max, direction)
		];

		oninputstart();
	};

	const handleDragRelease = () => {
		interactionReleased = true;
	};

	const handleDragMove = ({ detail }) => {
		interactionOptions.snap = !interactionReleased;
		interactionOptions.elastic = !interactionReleased;
		translatePosition(interactionOrigin, detail.translation, interactionOptions);
	};

	const handleDragEnd = ({ detail }) => {
		interactionOptions.snap = false;
		interactionOptions.elastic = false;
		const valueAtPosition = translatePosition(interactionOrigin, detail.translation, interactionOptions);
		interactionOrigin = undefined;
		interactionRange = undefined;

		// if is near base position, set to base
		if (Math.abs(valueAtPosition - base) < 0.01) return oninputend(base);

		oninputend(valueAtPosition);
	};

	const translatePosition = (origin, translation, options) => {
		const target = origin[direction] + translation[direction];
		const targetLimited = clamp(target, interactionRange[1][direction], interactionRange[0][direction]);

		const targetElastic = elasticity
		? targetLimited + elastify(target - targetLimited, elasticity)
		: targetLimited;

		const targetVisual = options.elastic ? targetElastic : targetLimited;

		// set position
		const targetValid = vectorCreate(0, 0);

		targetValid[direction] = targetVisual;
		position.set(targetValid, { hard: options.snap });
		return clamp(positionToValue(targetValid, direction), min, max);
	};

	const handleReset = () => {
		$$invalidate(0, value = clamp(base, valueMinLimited, valueMaxLimited));
		oninputstart();
		oninputend(value);
	};

	//
	// Meter position and value updates
	//
	const position = spring$2();

	component_subscribe($$self, position, value => $$invalidate(9, $position = value));

	const valueToPosition = (value, axis) => {
		const offset = (size[axis] - barSize[axis]) * 0.5;
		const fraction = toFraction(value, min, max);
		const v = fraction * barSize[axis] - barSize[axis] * 0.5;
		const pos = offset - v;

		return {
			x: axis === "x" ? pos : 0,
			y: axis === "y" ? pos : 0
		};
	};

	const positionToValue = (position, axis) => {
		const dist = position[axis] - size[axis] * 0.5;
		const fraction = -(dist / barSize[axis]);
		return min + fraction * range;
	};

	position.subscribe(currentPosition => {
		// if not positioned yet or is not interacting we're not interested in this event
		if (!currentPosition || !interactionOrigin) return;

		oninputmove(clamp(positionToValue(currentPosition, direction), min, max));
	});

	const updatePosition = value => {
		const interactionRange = [
			valueToPosition(valueMin != null ? valueMin : min, direction),
			valueToPosition(valueMax != null ? valueMax : max, direction)
		];

		const target = {
			x: direction === "x" ? $position.x + value : 0,
			y: direction === "y" ? $position.y + value : 0
		};

		const targetLimited = clamp(target[direction], interactionRange[1][direction], interactionRange[0][direction]);
		const positionTarget = { ...$position, [direction]: targetLimited };
		set_store_value(position, $position = positionTarget, $position);
		const result = clamp(positionToValue(positionTarget, direction), min, max);
		oninputstart();
		oninputmove(result);
		oninputend(result);
	};

	const handleWheel = e => {
		// don't run default actions, prevent other actions from running
		e.preventDefault();

		e.stopPropagation();

		// apply wheel delta to offset
		const step = 8;

		const delta = getWheelDelta(e) * step;
		updatePosition(delta);
	};

	const handleNudge = ({ detail }) => {
		updatePosition(detail[direction] * 8);
	};

	const measure_handler = e => $$invalidate(5, size = vectorCreateFromSize(e.detail));

	$$self.$$set = $$props => {
		if ("labelReset" in $$props) $$invalidate(1, labelReset = $$props.labelReset);
		if ("direction" in $$props) $$invalidate(2, direction = $$props.direction);
		if ("min" in $$props) $$invalidate(19, min = $$props.min);
		if ("max" in $$props) $$invalidate(20, max = $$props.max);
		if ("base" in $$props) $$invalidate(3, base = $$props.base);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("valueLabel" in $$props) $$invalidate(4, valueLabel = $$props.valueLabel);
		if ("valueMin" in $$props) $$invalidate(21, valueMin = $$props.valueMin);
		if ("valueMax" in $$props) $$invalidate(22, valueMax = $$props.valueMax);
		if ("oninputstart" in $$props) $$invalidate(23, oninputstart = $$props.oninputstart);
		if ("oninputmove" in $$props) $$invalidate(24, oninputmove = $$props.oninputmove);
		if ("oninputend" in $$props) $$invalidate(25, oninputend = $$props.oninputend);
		if ("elasticity" in $$props) $$invalidate(26, elasticity = $$props.elasticity);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*max, min*/ 1572864) {
			//
			// derived
			//
			$$invalidate(28, range = max - min);
		}

		if ($$self.$$.dirty[0] & /*valueMin, min*/ 2621440) {
			$$invalidate(29, valueMinLimited = valueMin != null ? Math.max(valueMin, min) : min);
		}

		if ($$self.$$.dirty[0] & /*valueMax, max*/ 5242880) {
			$$invalidate(30, valueMaxLimited = valueMax != null ? Math.min(valueMax, max) : max);
		}

		if ($$self.$$.dirty[0] & /*base, min, max*/ 1572872) {
			$$invalidate(31, baseFraction = toFraction(base, min, max));
		}

		if ($$self.$$.dirty[0] & /*size*/ 32 | $$self.$$.dirty[1] & /*baseFraction*/ 1) {
			if (size) {
				const centerY = size.y * 0.5;
				let indicatorCenter = indicatorCount * baseFraction;
				let d = "";
				let svgWidth;
				let svgHeight = size.y;
				let centerShape = "";

				for (let i = 0; i <= indicatorCount; i++) {
					const x = svgPadding.x + i * indicatorSpacing;
					const y = centerY;
					const r = i % indicatorInterval === 0 ? radiusBig : radiusSmall;
					d += createPathCircle(x, y, r) + " ";
					svgWidth = x + svgPadding.x;

					if (i === indicatorCenter) {
						centerShape = `<path d="M${x} ${y - 4} l2 3 l-2 -1 l-2 1 z"/>`;
					}
				}

				$$invalidate(7, svg = `<svg width="${svgWidth}" height="${svgHeight}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${svgWidth} ${svgHeight}" aria-hidden="true" focusable="false">
        ${centerShape}
        <rect rx="4" ry="4" y="${centerY - 4}"" height="8"/>
        <path fill-rule="evenodd" d="${d.trim()}"/></svg>`);

				$$invalidate(27, svgSize = {
					x: svgWidth - svgPadding.x * 2,
					y: svgHeight
				});
			}
		}

		if ($$self.$$.dirty[0] & /*size, svgSize*/ 134217760) {
			barSize = size && svgSize;
		}

		if ($$self.$$.dirty[0] & /*valueMinLimited, min, valueMaxLimited, max*/ 1612185600) {
			$$invalidate(6, isLimited = valueMinLimited !== min || valueMaxLimited !== max);
		}

		if ($$self.$$.dirty[0] & /*isLimited, valueMinLimited, valueMaxLimited*/ 1610612800) {
			$$invalidate(8, rangeMask = isLimited
			? getMask(valueMinLimited, valueMaxLimited)
			: "");
		}

		if ($$self.$$.dirty[0] & /*range, size, value, direction*/ 268435493) {
			// if has size (range is in here so the position is updated if the range is changed)
			if (range && size && size.x && size.y) {
				position.set(valueToPosition(value, direction));
			}
		}
	};

	return [
		value,
		labelReset,
		direction,
		base,
		valueLabel,
		size,
		isLimited,
		svg,
		rangeMask,
		$position,
		svgPadding,
		handleDragStart,
		handleDragRelease,
		handleDragMove,
		handleDragEnd,
		handleReset,
		position,
		handleWheel,
		handleNudge,
		min,
		max,
		valueMin,
		valueMax,
		oninputstart,
		oninputmove,
		oninputend,
		elasticity,
		svgSize,
		range,
		valueMinLimited,
		valueMaxLimited,
		baseFraction,
		measure_handler
	];
}

class RangeInput extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$o,
			create_fragment$o,
			safe_not_equal,
			{
				labelReset: 1,
				direction: 2,
				min: 19,
				max: 20,
				base: 3,
				value: 0,
				valueLabel: 4,
				valueMin: 21,
				valueMax: 22,
				oninputstart: 23,
				oninputmove: 24,
				oninputend: 25,
				elasticity: 26
			},
			[-1, -1]
		);
	}
}

/* src/core/ui/components/Toolbar.svelte generated by Svelte v3.37.0 */

function create_fragment$n(ctx) {
	let div1;
	let div0;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr(div0, "class", "PinturaToolbarInner");
			attr(div1, "class", "PinturaToolbar");
			attr(div1, "data-layout", /*layout*/ ctx[1]);
			attr(div1, "data-overflow", /*overflow*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "measure", /*handleChildResizeEvent*/ ctx[3]),
					action_destroyer(measurable.call(null, div0)),
					listen(div1, "measure", /*handleParentResizeEvent*/ ctx[2]),
					action_destroyer(measurable.call(null, div1))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			if (!current || dirty & /*layout*/ 2) {
				attr(div1, "data-layout", /*layout*/ ctx[1]);
			}

			if (!current || dirty & /*overflow*/ 1) {
				attr(div1, "data-overflow", /*overflow*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$n($$self, $$props, $$invalidate) {
	let layout;
	let { $$slots: slots = {}, $$scope } = $$props;
	let childWidth = 0;
	let childMaxWidth = 0;
	let parentWidth = 0;
	let overflow;

	const testOverflow = () => {
		$$invalidate(0, overflow = layout === "compact" && childWidth > parentWidth
		? "overflow"
		: undefined);
	};

	const handleParentResizeEvent = ({ detail }) => {
		const { width } = detail;
		$$invalidate(5, parentWidth = width);
		testOverflow();
	};

	const handleChildResizeEvent = ({ detail }) => {
		const { width } = detail;

		if (width > childMaxWidth) {
			$$invalidate(4, childMaxWidth = width);
		}

		childWidth = width;
		if (!overflow) testOverflow();
	};

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*childMaxWidth, parentWidth*/ 48) {
			$$invalidate(1, layout = childMaxWidth > parentWidth ? "compact" : "default");
		}
	};

	return [
		overflow,
		layout,
		handleParentResizeEvent,
		handleChildResizeEvent,
		childMaxWidth,
		parentWidth,
		$$scope,
		slots
	];
}

class Toolbar extends SvelteComponent {
	constructor(options) {
		super();
		init$3(this, options, instance$n, create_fragment$n, safe_not_equal, {});
	}
}

// enum Direction {
//     Top = 't',
//     Right = 'r',
//     Bottom = 'b',
//     Left = 'l',
//     TopLeft = 'tl',
//     TopRight = 'tr',
//     BottomRight = 'br',
//     BottomLeft = 'bl',
// }
// export const { Top, Right, Bottom, Left, TopLeft, TopRight, BottomRight, BottomLeft } = Direction;
// export default Direction;
const Direction = {
    Top: 't',
    Right: 'r',
    Bottom: 'b',
    Left: 'l',
    TopLeft: 'tl',
    TopRight: 'tr',
    BottomRight: 'br',
    BottomLeft: 'bl',
};
const { Top, Right, Bottom, Left, TopLeft, TopRight, BottomRight, BottomLeft } = Direction;

var DirectionRectMap = {
    [Top]: (rect) => ({ x: rect.x, y: rect.y }),
    [TopRight]: (rect) => ({ x: rect.x + rect.width, y: rect.y }),
    [Right]: (rect) => ({ x: rect.x + rect.width, y: rect.y }),
    [BottomRight]: (rect) => ({ x: rect.x + rect.width, y: rect.y + rect.height }),
    [Bottom]: (rect) => ({ x: rect.x, y: rect.y + rect.height }),
    [BottomLeft]: (rect) => ({ x: rect.x, y: rect.y + rect.height }),
    [Left]: (rect) => ({ x: rect.x, y: rect.y }),
    [TopLeft]: (rect) => ({ x: rect.x, y: rect.y }),
};

/* src/core/ui/components/RectManipulator.svelte generated by Svelte v3.37.0 */

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i].key;
	child_ctx[13] = list[i].translate;
	child_ctx[14] = list[i].scale;
	child_ctx[15] = list[i].type;
	child_ctx[16] = list[i].opacity;
	return child_ctx;
}

// (226:0) {#each mappedDirections as { key, translate, scale, type, opacity }
function create_each_block$5(key_1, ctx) {
	let div;
	let div_aria_label_value;
	let div_tabindex_value;
	let div_data_direction_value;
	let div_data_shape_value;
	let div_style_value;
	let mounted;
	let dispose;

	return {
		key: key_1,
		first: null,
		c() {
			div = element("div");
			attr(div, "role", "button");
			attr(div, "aria-label", div_aria_label_value = `Drag ${/*type*/ ctx[15]} ${/*key*/ ctx[12]}`);
			attr(div, "tabindex", div_tabindex_value = /*type*/ ctx[15] === "edge" ? -1 : 0);
			attr(div, "class", "PinturaRectManipulator");
			attr(div, "data-direction", div_data_direction_value = /*key*/ ctx[12]);

			attr(div, "data-shape", div_data_shape_value = `${/*type*/ ctx[15] === "edge"
			? "edge"
			: `${/*style*/ ctx[0]}`}`);

			attr(div, "style", div_style_value = `transform: translate3d(${/*translate*/ ctx[13].x}px, ${/*translate*/ ctx[13].y}px, 0) scale(${/*scale*/ ctx[14].x}, ${/*scale*/ ctx[14].y}); opacity: ${/*opacity*/ ctx[16]}`);
			this.first = div;
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (!mounted) {
				dispose = [
					listen(div, "nudge", function () {
						if (is_function(/*nudge*/ ctx[5](/*key*/ ctx[12]))) /*nudge*/ ctx[5](/*key*/ ctx[12]).apply(this, arguments);
					}),
					action_destroyer(nudgeable.call(null, div)),
					listen(div, "interactionstart", function () {
						if (is_function(/*route*/ ctx[4]("resizestart", /*key*/ ctx[12]))) /*route*/ ctx[4]("resizestart", /*key*/ ctx[12]).apply(this, arguments);
					}),
					listen(div, "interactionupdate", function () {
						if (is_function(/*route*/ ctx[4]("resizemove", /*key*/ ctx[12]))) /*route*/ ctx[4]("resizemove", /*key*/ ctx[12]).apply(this, arguments);
					}),
					listen(div, "interactionend", function () {
						if (is_function(/*route*/ ctx[4]("resizeend", /*key*/ ctx[12]))) /*route*/ ctx[4]("resizeend", /*key*/ ctx[12]).apply(this, arguments);
					}),
					action_destroyer(interactable.call(null, div))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*mappedDirections*/ 2 && div_aria_label_value !== (div_aria_label_value = `Drag ${/*type*/ ctx[15]} ${/*key*/ ctx[12]}`)) {
				attr(div, "aria-label", div_aria_label_value);
			}

			if (dirty & /*mappedDirections*/ 2 && div_tabindex_value !== (div_tabindex_value = /*type*/ ctx[15] === "edge" ? -1 : 0)) {
				attr(div, "tabindex", div_tabindex_value);
			}

			if (dirty & /*mappedDirections*/ 2 && div_data_direction_value !== (div_data_direction_value = /*key*/ ctx[12])) {
				attr(div, "data-direction", div_data_direction_value);
			}

			if (dirty & /*mappedDirections, style*/ 3 && div_data_shape_value !== (div_data_shape_value = `${/*type*/ ctx[15] === "edge"
			? "edge"
			: `${/*style*/ ctx[0]}`}`)) {
				attr(div, "data-shape", div_data_shape_value);
			}

			if (dirty & /*mappedDirections*/ 2 && div_style_value !== (div_style_value = `transform: translate3d(${/*translate*/ ctx[13].x}px, ${/*translate*/ ctx[13].y}px, 0) scale(${/*scale*/ ctx[14].x}, ${/*scale*/ ctx[14].y}); opacity: ${/*opacity*/ ctx[16]}`)) {
				attr(div, "style", div_style_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$m(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let each_value = /*mappedDirections*/ ctx[1];
	const get_key = ctx => /*key*/ ctx[12];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$5(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty$1();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*mappedDirections, style, nudge, route*/ 51) {
				each_value = /*mappedDirections*/ ctx[1];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$5, each_1_anchor, get_each_context$5);
			}
		},
		i: noop$2,
		o: noop$2,
		d(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach(each_1_anchor);
		}
	};
}

function instance$m($$self, $$props, $$invalidate) {
	let mappedDirections;
	let $selectionScale;
	let $selectionOpacity;
	let { rect = null } = $$props;
	let { visible = false } = $$props;
	let { style = undefined } = $$props;

	// is `undefined` to prevent bounce when first rendering view
	const selectionScale = spring$2(undefined, {
		precision: 0.0001,
		stiffness: 0.2,
		damping: 0.4
	});

	component_subscribe($$self, selectionScale, value => $$invalidate(8, $selectionScale = value));
	const selectionOpacity = spring$2(0, { precision: 0.001 });
	component_subscribe($$self, selectionOpacity, value => $$invalidate(9, $selectionOpacity = value));

	//
	// dragging
	//
	let currentDirection;

	const dispatch = createEventDispatcher();

	const route = (type, direction) => ({ detail }) => {
		// don't handle other interactions while manipulating on axis
		if (currentDirection && direction !== currentDirection) return;

		// ignore move and end events if no direction has been set
		if (type !== "resizestart" && currentDirection === undefined) return;

		// set new direction
		if (type === "resizestart") currentDirection = direction;

		// release direction
		if (type === "resizeend") currentDirection = undefined;

		dispatch(type, {
			direction,
			translation: detail && detail.translation
		});
	};

	const nudge = direction => ({ detail }) => {
		dispatch(`resizestart`, { direction, translation: { x: 0, y: 0 } });
		dispatch(`resizemove`, { direction, translation: detail });
		dispatch(`resizeend`, { direction, translation: { x: 0, y: 0 } });
	};

	$$self.$$set = $$props => {
		if ("rect" in $$props) $$invalidate(6, rect = $$props.rect);
		if ("visible" in $$props) $$invalidate(7, visible = $$props.visible);
		if ("style" in $$props) $$invalidate(0, style = $$props.style);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*visible*/ 128) {
			selectionScale.set(visible ? 1 : 0.5);
		}

		if ($$self.$$.dirty & /*visible*/ 128) {
			selectionOpacity.set(visible ? 1 : 0);
		}

		if ($$self.$$.dirty & /*rect, $selectionScale, $selectionOpacity*/ 832) {
			//
			// rendering
			//
			$$invalidate(1, mappedDirections = Object.keys(Direction).map((key, i) => {
				// get direction enum
				const direction = Direction[key];

				// get position from direction
				const position = DirectionRectMap[direction](rect);

				// corner or edge
				const type = direction.length === 1 ? "edge" : "corner";

				const isCorner = type === "corner";

				return {
					key: direction,
					type,
					scale: {
						x: (/^(t|b)$/).test(direction)
						? rect.width
						: isCorner ? clamp($selectionScale, 0.5, 1.25) : 1,
						y: (/^(r|l)$/).test(direction)
						? rect.height
						: isCorner ? clamp($selectionScale, 0.5, 1.25) : 1
					},
					translate: { x: position.x, y: position.y },
					opacity: $selectionOpacity
				};
			}));
		}
	};

	return [
		style,
		mappedDirections,
		selectionScale,
		selectionOpacity,
		route,
		nudge,
		rect,
		visible,
		$selectionScale,
		$selectionOpacity
	];
}

class RectManipulator extends SvelteComponent {
	constructor(options) {
		super();
		init$3(this, options, instance$m, create_fragment$m, safe_not_equal, { rect: 6, visible: 7, style: 0 });
	}
}

var gesturable = (element) => {
    function dispatch(type, detail) {
        element.dispatchEvent(new CustomEvent(type, { detail }));
    }
    const handleGestureStart = (e) => {
        e.preventDefault();
        element.addEventListener('gesturechange', handleGestureChange);
        element.addEventListener('gestureend', handleGestureEnd);
        dispatch('gesturedown');
    };
    const handleGestureChange = (e) => {
        e.preventDefault();
        dispatch('gestureupdate', e.scale);
    };
    const handleGestureEnd = (e) => {
        dispatch('gestureup', e.scale);
        e.preventDefault();
        clean();
    };
    const clean = () => {
        element.removeEventListener('gesturechange', handleGestureChange);
        element.removeEventListener('gestureend', handleGestureEnd);
    };
    element.addEventListener('gesturestart', handleGestureStart);
    return {
        destroy: () => {
            clean();
            element.removeEventListener('gesturestart', handleGestureStart);
        },
    };
};

var getEventPositionInViewport = (e) => vectorCreate(e.clientX, e.clientY);

var getEventPositionInStage = (e, viewOffset, stageOffset) => {
    const positionInViewport = getEventPositionInViewport(e);
    return vectorSubtract(vectorSubtract(positionInViewport, viewOffset), stageOffset);
};

var DirectionInversionTable = {
    [Top]: Bottom,
    [Right]: Left,
    [Bottom]: Top,
    [Left]: Right,
    [TopLeft]: BottomRight,
    [TopRight]: BottomLeft,
    [BottomRight]: TopLeft,
    [BottomLeft]: TopRight,
};

var DirectionCoordinateTable = {
    [Top]: [0.5, 0],
    [Right]: [1, 0.5],
    [Bottom]: [0.5, 1],
    [Left]: [0, 0.5],
    [TopLeft]: [0, 0],
    [TopRight]: [1, 0],
    [BottomRight]: [1, 1],
    [BottomLeft]: [0, 1],
};

var getTranslationInfo = (target) => {
    const translateToRight = target === Right || target === TopRight || target === BottomRight;
    const translateToLeft = target === Left || target === BottomLeft || target === TopLeft;
    const translateToTop = target === Top || target === TopRight || target === TopLeft;
    const translateToBottom = target === Bottom || target === BottomRight || target === BottomLeft;
    const translateHorizontally = target === Left || target === Right;
    const translateVertically = target === Top || target === Bottom;
    const translateAxis = translateHorizontally || translateVertically;
    return [
        translateToRight,
        translateToLeft,
        translateToTop,
        translateToBottom,
        translateHorizontally,
        translateVertically,
        translateAxis,
    ];
};

var limitRectDirectionTranslation = (rect, transform, bounds, options = {}) => {
    // the transforms to apply
    const { target, translate } = transform;
    // the transform requirements
    const { aspectRatio, minSize, maxSize } = options;
    // get anchor coordinates and x,y position we need this for relative scaling of the view rectangle
    const anchor = DirectionInversionTable[target];
    const anchorDirectionCoordinates = DirectionCoordinateTable[anchor];
    const anchorPosition = vectorAdd(vectorCreate(rect.x, rect.y), vectorCreate(anchorDirectionCoordinates[0] * rect.width, anchorDirectionCoordinates[1] * rect.height));
    // get coordinate of direction
    const targetDirectionCoordinates = DirectionCoordinateTable[target];
    const targetPosition = vectorAdd(rectClone(rect), vectorCreate(targetDirectionCoordinates[0] * rect.width, targetDirectionCoordinates[1] * rect.height));
    // bools to determine which direction the interaction is moving in
    const [translateToRight, translateToLeft, translateToTop, translateToBottom, translateHorizontally, translateVertically, translateAxis,] = getTranslationInfo(target);
    let tx = translate.x;
    let ty = translate.y;
    if (translateHorizontally)
        ty = 0;
    else if (translateVertically)
        tx = 0;
    const interactionBounds = getInteractionBounds(anchorPosition, target, bounds, {
        aspectRatio,
        minSize,
        maxSize,
    });
    // current bounds
    let [t, r, b, l] = rectToBounds(rect);
    // update view bounds with anchor based on translation direction (one side is always locked)
    if (translateToRight)
        l = anchorPosition.x;
    else if (translateToLeft)
        r = anchorPosition.x;
    if (translateToBottom)
        t = anchorPosition.y;
    else if (translateToTop)
        b = anchorPosition.y;
    // update view bounds with interaction limits
    if (translateToRight) {
        const innerR = interactionBounds.inner.x + interactionBounds.inner.width;
        const outerR = interactionBounds.outer.x + interactionBounds.outer.width;
        r = clamp(targetPosition.x + tx, innerR, outerR);
    }
    else if (translateToLeft) {
        const innerL = interactionBounds.outer.x;
        const outerL = interactionBounds.inner.x;
        l = clamp(targetPosition.x + tx, innerL, outerL);
    }
    if (translateToBottom) {
        const innerB = interactionBounds.inner.y + interactionBounds.inner.height;
        const outerB = interactionBounds.outer.y + interactionBounds.outer.height;
        b = clamp(targetPosition.y + ty, innerB, outerB);
    }
    else if (translateToTop) {
        const innerT = interactionBounds.outer.y;
        const outerT = interactionBounds.inner.y;
        t = clamp(targetPosition.y + ty, innerT, outerT);
    }
    // if aspect ratio is set we need to scale both axis
    if (aspectRatio) {
        // if translating over horizontal or vertical axis we need to update the other axis based on the aspect ratio as well
        if (translateAxis) {
            let dx = r - l;
            let dy = b - t;
            if (translateHorizontally) {
                dy = dx / aspectRatio;
                t = anchorPosition.y - dy * 0.5;
                b = anchorPosition.y + dy * 0.5;
            }
            else if (translateVertically) {
                dx = dy * aspectRatio;
                l = anchorPosition.x - dx * 0.5;
                r = anchorPosition.x + dx * 0.5;
            }
        }
        // we're translating one of the corners in both the x and y direction, need to make sure it conforms to aspect ratio
        else {
            const pointer = vectorCreate(targetPosition.x + tx - anchorPosition.x, targetPosition.y + ty - anchorPosition.y);
            // translations cannot be inverted, limited by anchor position
            if (target === TopRight) {
                pointer.x = Math.max(0, pointer.x);
                pointer.y = Math.min(0, pointer.y);
            }
            else if (target === BottomRight) {
                pointer.x = Math.max(0, pointer.x);
                pointer.y = Math.max(0, pointer.y);
            }
            else if (target === BottomLeft) {
                pointer.x = Math.min(0, pointer.x);
                pointer.y = Math.max(0, pointer.y);
            }
            else if (target === TopLeft) {
                pointer.x = Math.min(0, pointer.x);
                pointer.y = Math.min(0, pointer.y);
            }
            // calculate the translation pointer, then get its length, now create a new pointer based on the aspect ratio, and scale it based on the original (limited) length
            const pointerLength = vectorLength(pointer);
            const pointerLengthMin = vectorLength(vectorCreate(interactionBounds.inner.width, interactionBounds.inner.height));
            const pointerLengthMax = vectorLength(vectorCreate(interactionBounds.outer.width, interactionBounds.outer.height));
            const pointerLengthLimited = clamp(pointerLength, pointerLengthMin, pointerLengthMax);
            const pointerAspectRatio = vectorCreate(aspectRatio, 1);
            const pointerScaled = vectorMultiply(vectorNormalize(pointerAspectRatio), pointerLengthLimited);
            if (target === TopRight) {
                r = anchorPosition.x + pointerScaled.x;
                t = anchorPosition.y - pointerScaled.y;
            }
            else if (target === BottomRight) {
                r = anchorPosition.x + pointerScaled.x;
                b = anchorPosition.y + pointerScaled.y;
            }
            else if (target === BottomLeft) {
                l = anchorPosition.x - pointerScaled.x;
                b = anchorPosition.y + pointerScaled.y;
            }
            else if (target === TopLeft) {
                l = anchorPosition.x - pointerScaled.x;
                t = anchorPosition.y - pointerScaled.y;
            }
        }
    }
    return rectCreate(l, t, r - l, b - t);
};
const getInteractionBounds = (anchor, dir, bounds, options) => {
    const { aspectRatio, minSize, maxSize } = options;
    const translateToRight = dir === Right || dir === TopRight || dir === BottomRight;
    const translateToLeft = dir === Left || dir === BottomLeft || dir === TopLeft;
    const translateToTop = dir === Top || dir === TopRight || dir === TopLeft;
    const translateToBottom = dir === Bottom || dir === BottomRight || dir === BottomLeft;
    const translateHorizontally = dir === Left || dir === Right;
    const translateVertically = dir === Top || dir === Bottom;
    // limit bounds based on anchor and direction
    const limitedBounds = rectClone(bounds);
    if (translateToRight) {
        limitedBounds.x = anchor.x;
        limitedBounds.width -= anchor.x;
    }
    else if (translateToLeft) {
        limitedBounds.width = anchor.x;
    }
    if (translateToBottom) {
        limitedBounds.y = anchor.y;
        limitedBounds.height -= anchor.y;
    }
    else if (translateToTop) {
        limitedBounds.height = anchor.y;
    }
    // limit max size based on bounds
    const maxSizeLimitedToBounds = rectCreateFromDimensions(Math.min(limitedBounds.width, maxSize.width), Math.min(limitedBounds.height, maxSize.height));
    if (aspectRatio) {
        // limit height
        if (translateHorizontally) {
            const verticalSpace = Math.min(anchor.y, bounds.height - anchor.y);
            maxSizeLimitedToBounds.height = Math.min(verticalSpace * 2, maxSizeLimitedToBounds.height);
        }
        // limit width
        else if (translateVertically) {
            const horizontalSpace = Math.min(anchor.x, bounds.width - anchor.x);
            maxSizeLimitedToBounds.width = Math.min(horizontalSpace * 2, maxSizeLimitedToBounds.width);
        }
    }
    const maxSizeLimited = aspectRatio
        ? sizeCreateFromRect(rectContainRect(maxSizeLimitedToBounds, aspectRatio))
        : maxSizeLimitedToBounds;
    // limit min size
    const minSizeLimited = aspectRatio
        ? sizeCreateFromRect(rectCoverRect(rectCreateFromSize(minSize), aspectRatio))
        : minSize;
    let l, r, t, b;
    // set bounds
    if (translateToRight)
        l = anchor.x;
    else if (translateToLeft)
        r = anchor.x;
    if (translateToBottom)
        t = anchor.y;
    else if (translateToTop)
        b = anchor.y;
    // inner
    if (translateToRight) {
        r = l + minSizeLimited.width;
    }
    else if (translateToLeft) {
        l = r - minSizeLimited.width;
    }
    if (translateToBottom) {
        b = t + minSizeLimited.height;
    }
    else if (translateToTop) {
        t = b - minSizeLimited.height;
    }
    if (translateHorizontally) {
        t = anchor.y - minSizeLimited.height * 0.5;
        b = anchor.y + minSizeLimited.height * 0.5;
    }
    else if (translateVertically) {
        l = anchor.x - minSizeLimited.width * 0.5;
        r = anchor.x + minSizeLimited.width * 0.5;
    }
    const inner = rectCreateFromPoints(vectorCreate(l, t), vectorCreate(r, b));
    // outer
    if (translateToRight) {
        r = l + maxSizeLimited.width;
    }
    else if (translateToLeft) {
        l = r - maxSizeLimited.width;
    }
    if (translateToBottom) {
        b = t + maxSizeLimited.height;
    }
    else if (translateToTop) {
        t = b - maxSizeLimited.height;
    }
    if (translateHorizontally) {
        t = anchor.y - maxSizeLimited.height * 0.5;
        b = anchor.y + maxSizeLimited.height * 0.5;
    }
    else if (translateVertically) {
        l = anchor.x - maxSizeLimited.width * 0.5;
        r = anchor.x + maxSizeLimited.width * 0.5;
    }
    const outer = rectCreateFromPoints(vectorCreate(l, t), vectorCreate(r, b));
    return {
        inner,
        outer,
    };
};

var applyRectDirectionTranslation = (rect, transform, options = {}) => {
    // the transforms to apply
    const { target, translate } = transform;
    // the transform requirements
    const { aspectRatio } = options;
    // get anchor coordinates and x,y position we need this for relative scaling of the view rectangle
    const anchor = DirectionInversionTable[target];
    const anchorDirectionCoordinates = DirectionCoordinateTable[anchor];
    const anchorPosition = vectorAdd(rectClone(rect), vectorCreate(anchorDirectionCoordinates[0] * rect.width, anchorDirectionCoordinates[1] * rect.height));
    // get coordinate of direction
    const targetDirectionCoordinates = DirectionCoordinateTable[target];
    const targetPosition = vectorAdd(rectClone(rect), vectorCreate(targetDirectionCoordinates[0] * rect.width, targetDirectionCoordinates[1] * rect.height));
    // bools to determine which direction the interaction is moving in
    const [translateToRight, translateToLeft, translateToTop, translateToBottom, translateHorizontally, translateVertically, translateAxis,] = getTranslationInfo(target);
    let tx = translate.x;
    let ty = translate.y;
    if (translateHorizontally)
        ty = 0;
    else if (translateVertically)
        tx = 0;
    // current bounds
    let [t, r, b, l] = rectToBounds(rect);
    // update view bounds with anchor based on translation direction (one side is always locked)
    if (translateToRight)
        l = anchorPosition.x;
    else if (translateToLeft)
        r = anchorPosition.x;
    if (translateToBottom)
        t = anchorPosition.y;
    else if (translateToTop)
        b = anchorPosition.y;
    // update view bounds with interaction limits
    if (translateToRight) {
        r = targetPosition.x + tx;
    }
    else if (translateToLeft) {
        l = targetPosition.x + tx;
    }
    if (translateToBottom) {
        b = targetPosition.y + ty;
    }
    else if (translateToTop) {
        t = targetPosition.y + ty;
    }
    // if aspect ratio is set we need to scale both axis
    if (aspectRatio) {
        // if translating over horizontal or vertical axis we need to update the other axis based on the aspect ratio as well
        if (translateAxis) {
            let dx = r - l;
            let dy = b - t;
            if (translateHorizontally) {
                dy = dx / aspectRatio;
                t = anchorPosition.y - dy * 0.5;
                b = anchorPosition.y + dy * 0.5;
            }
            else if (translateVertically) {
                dx = dy * aspectRatio;
                l = anchorPosition.x - dx * 0.5;
                r = anchorPosition.x + dx * 0.5;
            }
        }
        // we're translating one of the corners in both the x and y direction, need to make sure it conforms to aspect ratio
        else {
            const pointer = vectorCreate(targetPosition.x + tx - anchorPosition.x, targetPosition.y + ty - anchorPosition.y);
            // translations cannot be inverted, limited by anchor position
            if (target === TopRight) {
                pointer.x = Math.max(0, pointer.x);
                pointer.y = Math.min(0, pointer.y);
            }
            else if (target === BottomRight) {
                pointer.x = Math.max(0, pointer.x);
                pointer.y = Math.max(0, pointer.y);
            }
            else if (target === BottomLeft) {
                pointer.x = Math.min(0, pointer.x);
                pointer.y = Math.max(0, pointer.y);
            }
            else if (target === TopLeft) {
                pointer.x = Math.min(0, pointer.x);
                pointer.y = Math.min(0, pointer.y);
            }
            // calculate the translation pointer, then get its length, now create a new pointer based on the aspect ratio, and scale it based on the original (limited) length
            const pointerLength = vectorLength(pointer);
            const pointerAspectRatio = vectorCreate(aspectRatio, 1);
            const pointerScaled = vectorMultiply(vectorNormalize(pointerAspectRatio), pointerLength);
            if (target === TopRight) {
                r = anchorPosition.x + pointerScaled.x;
                t = anchorPosition.y - pointerScaled.y;
            }
            else if (target === BottomRight) {
                r = anchorPosition.x + pointerScaled.x;
                b = anchorPosition.y + pointerScaled.y;
            }
            else if (target === BottomLeft) {
                l = anchorPosition.x - pointerScaled.x;
                b = anchorPosition.y + pointerScaled.y;
            }
            else if (target === TopLeft) {
                l = anchorPosition.x - pointerScaled.x;
                t = anchorPosition.y - pointerScaled.y;
            }
        }
    }
    return rectCreate(l, t, r - l, b - t);
};

var radToDeg = (rad) => rad * 180 / Math.PI;

/* src/core/ui/plugins/crop/components/ImageRotator.svelte generated by Svelte v3.37.0 */

function create_fragment$l(ctx) {
	let div;
	let rangeinput;
	let current;

	rangeinput = new RangeInput({
			props: {
				elasticity: /*elasticity*/ ctx[5],
				min: /*min*/ ctx[7],
				max: /*max*/ ctx[8],
				value: /*value*/ ctx[12],
				valueMin: /*valueMin*/ ctx[0],
				valueMax: /*valueMax*/ ctx[1],
				labelReset: /*labelReset*/ ctx[6],
				base: /*center*/ ctx[11],
				valueLabel: `${Math.round(radToDeg(/*value*/ ctx[12]))}°`,
				oninputstart: /*oninputstart*/ ctx[2],
				oninputmove: /*func*/ ctx[14],
				oninputend: /*func_1*/ ctx[15]
			}
		});

	return {
		c() {
			div = element("div");
			create_component(rangeinput.$$.fragment);
			attr(div, "class", "PinturaImageRotator");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(rangeinput, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const rangeinput_changes = {};
			if (dirty & /*elasticity*/ 32) rangeinput_changes.elasticity = /*elasticity*/ ctx[5];
			if (dirty & /*min*/ 128) rangeinput_changes.min = /*min*/ ctx[7];
			if (dirty & /*max*/ 256) rangeinput_changes.max = /*max*/ ctx[8];
			if (dirty & /*value*/ 4096) rangeinput_changes.value = /*value*/ ctx[12];
			if (dirty & /*valueMin*/ 1) rangeinput_changes.valueMin = /*valueMin*/ ctx[0];
			if (dirty & /*valueMax*/ 2) rangeinput_changes.valueMax = /*valueMax*/ ctx[1];
			if (dirty & /*labelReset*/ 64) rangeinput_changes.labelReset = /*labelReset*/ ctx[6];
			if (dirty & /*center*/ 2048) rangeinput_changes.base = /*center*/ ctx[11];
			if (dirty & /*value*/ 4096) rangeinput_changes.valueLabel = `${Math.round(radToDeg(/*value*/ ctx[12]))}°`;
			if (dirty & /*oninputstart*/ 4) rangeinput_changes.oninputstart = /*oninputstart*/ ctx[2];
			if (dirty & /*oninputmove, sign, turns*/ 1544) rangeinput_changes.oninputmove = /*func*/ ctx[14];
			if (dirty & /*oninputend, sign, turns*/ 1552) rangeinput_changes.oninputend = /*func_1*/ ctx[15];
			rangeinput.$set(rangeinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(rangeinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(rangeinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(rangeinput);
		}
	};
}

const MARGIN = 1e-9;

function instance$l($$self, $$props, $$invalidate) {
	let min;
	let max;
	let center;
	let sign;
	let turns;
	let value;
	const HALF_PI = Math.PI / 2;
	const QUARTER_PI = Math.PI / 4;
	let { rotation } = $$props;
	let { valueMin } = $$props;
	let { valueMax } = $$props;
	let { oninputstart = noop$1 } = $$props;
	let { oninputmove = noop$1 } = $$props;
	let { oninputend = noop$1 } = $$props;
	let { elasticity = 0 } = $$props;
	let { labelReset = undefined } = $$props;
	const func = value => oninputmove(sign * turns + value);
	const func_1 = value => oninputend(sign * turns + value);

	$$self.$$set = $$props => {
		if ("rotation" in $$props) $$invalidate(13, rotation = $$props.rotation);
		if ("valueMin" in $$props) $$invalidate(0, valueMin = $$props.valueMin);
		if ("valueMax" in $$props) $$invalidate(1, valueMax = $$props.valueMax);
		if ("oninputstart" in $$props) $$invalidate(2, oninputstart = $$props.oninputstart);
		if ("oninputmove" in $$props) $$invalidate(3, oninputmove = $$props.oninputmove);
		if ("oninputend" in $$props) $$invalidate(4, oninputend = $$props.oninputend);
		if ("elasticity" in $$props) $$invalidate(5, elasticity = $$props.elasticity);
		if ("labelReset" in $$props) $$invalidate(6, labelReset = $$props.labelReset);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*min, max*/ 384) {
			$$invalidate(11, center = min + (max - min) * 0.5);
		}

		if ($$self.$$.dirty & /*rotation*/ 8192) {
			$$invalidate(9, sign = Math.sign(rotation));
		}

		if ($$self.$$.dirty & /*rotation*/ 8192) {
			$$invalidate(10, turns = Math.round(Math.abs(rotation) / HALF_PI) * HALF_PI);
		}

		if ($$self.$$.dirty & /*rotation, sign, turns*/ 9728) {
			$$invalidate(12, value = rotation - sign * turns);
		}
	};

	$$invalidate(7, min = -QUARTER_PI + MARGIN);
	$$invalidate(8, max = QUARTER_PI - MARGIN);

	return [
		valueMin,
		valueMax,
		oninputstart,
		oninputmove,
		oninputend,
		elasticity,
		labelReset,
		min,
		max,
		sign,
		turns,
		center,
		value,
		rotation,
		func,
		func_1
	];
}

class ImageRotator extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$l, create_fragment$l, safe_not_equal, {
			rotation: 13,
			valueMin: 0,
			valueMax: 1,
			oninputstart: 2,
			oninputmove: 3,
			oninputend: 4,
			elasticity: 5,
			labelReset: 6
		});
	}
}

/* src/core/ui/plugins/crop/components/ImageInfo.svelte generated by Svelte v3.37.0 */

function create_fragment$k(ctx) {
	let div;
	let p;
	let t0;
	let t1;
	let t2;

	return {
		c() {
			div = element("div");
			p = element("p");
			t0 = text$1(/*width*/ ctx[0]);
			t1 = text$1(" × ");
			t2 = text$1(/*height*/ ctx[1]);
			attr(div, "class", "PinturaImageInfo");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, p);
			append(p, t0);
			append(p, t1);
			append(p, t2);
		},
		p(ctx, [dirty]) {
			if (dirty & /*width*/ 1) set_data(t0, /*width*/ ctx[0]);
			if (dirty & /*height*/ 2) set_data(t2, /*height*/ ctx[1]);
		},
		i: noop$2,
		o: noop$2,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$k($$self, $$props, $$invalidate) {
	let { width } = $$props;
	let { height } = $$props;

	$$self.$$set = $$props => {
		if ("width" in $$props) $$invalidate(0, width = $$props.width);
		if ("height" in $$props) $$invalidate(1, height = $$props.height);
	};

	return [width, height];
}

class ImageInfo extends SvelteComponent {
	constructor(options) {
		super();
		init$3(this, options, instance$k, create_fragment$k, safe_not_equal, { width: 0, height: 1 });
	}
}

var getSelectionPresetOptionIcon = (value, options = {}) => {
    const { width = 24, height = 24, bounds = 16, radius = 3 } = options;
    let aspectRatio = isArray(value) ? getAspectRatio(value[0], value[1]) : value;
    let aspectRatioDefined = !!aspectRatio;
    aspectRatio = aspectRatioDefined ? aspectRatio : 1;
    let x;
    let y;
    let w;
    let h;
    w = aspectRatio > 1 ? bounds : aspectRatio * bounds;
    h = w / aspectRatio;
    x = Math.round((width - w) * 0.5);
    y = Math.round((height - h) * 0.5);
    const fill = aspectRatioDefined ? 'currentColor' : 'none';
    const stroke = aspectRatioDefined ? 'none' : 'currentColor';
    const strokeWidth = width / 16;
    const strokeDashArray = [width / 12, width / 6].join(' ');
    return `<rect fill="${fill}" stroke="${stroke}" stroke-width="${strokeWidth}" stroke-dasharray="${strokeDashArray}" x="${x}" y="${y}" width="${w}" height="${h}" rx="${radius}"/>`;
};

/* src/core/ui/plugins/crop/index.svelte generated by Svelte v3.37.0 */

function create_default_slot_2$2(ctx) {
	let dynamiccomponenttree;
	let current;
	dynamiccomponenttree = new DynamicComponentTree_1({ props: { items: /*tools*/ ctx[0] } });

	return {
		c() {
			create_component(dynamiccomponenttree.$$.fragment);
		},
		m(target, anchor) {
			mount_component(dynamiccomponenttree, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const dynamiccomponenttree_changes = {};
			if (dirty[0] & /*tools*/ 1) dynamiccomponenttree_changes.items = /*tools*/ ctx[0];
			dynamiccomponenttree.$set(dynamiccomponenttree_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dynamiccomponenttree.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dynamiccomponenttree.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(dynamiccomponenttree, detaching);
		}
	};
}

// (1360:4) 
function create_header_slot(ctx) {
	let div;
	let toolbar;
	let current;

	toolbar = new Toolbar({
			props: {
				$$slots: { default: [create_default_slot_2$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(toolbar.$$.fragment);
			attr(div, "slot", "header");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(toolbar, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const toolbar_changes = {};

			if (dirty[0] & /*tools*/ 1 | dirty[6] & /*$$scope*/ 64) {
				toolbar_changes.$$scope = { dirty, ctx };
			}

			toolbar.$set(toolbar_changes);
		},
		i(local) {
			if (current) return;
			transition_in(toolbar.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(toolbar.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(toolbar);
		}
	};
}

// (1388:12) {#if shouldRenderImageSelection && shouldRenderImageSelectionRecenterButton}
function create_if_block_5$2(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				onclick: /*handleRecenterAction*/ ctx[80],
				label: /*locale*/ ctx[4].cropLabelButtonRecenter,
				icon: /*locale*/ ctx[4].cropIconButtonRecenter,
				class: "PinturaButtonCenter",
				disabled: !/*canCenter*/ ctx[10],
				hideLabel: true,
				style: `opacity: ${/*$recenterOpacity*/ ctx[27]}; transform: translate3d(${/*$recenterOffset*/ ctx[28].x}px, ${/*$recenterOffset*/ ctx[28].y}px, 0)`
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty[0] & /*locale*/ 16) button_changes.label = /*locale*/ ctx[4].cropLabelButtonRecenter;
			if (dirty[0] & /*locale*/ 16) button_changes.icon = /*locale*/ ctx[4].cropIconButtonRecenter;
			if (dirty[0] & /*canCenter*/ 1024) button_changes.disabled = !/*canCenter*/ ctx[10];
			if (dirty[0] & /*$recenterOpacity, $recenterOffset*/ 402653184) button_changes.style = `opacity: ${/*$recenterOpacity*/ ctx[27]}; transform: translate3d(${/*$recenterOffset*/ ctx[28].x}px, ${/*$recenterOffset*/ ctx[28].y}px, 0)`;
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (1399:12) {#if shouldRenderImageSelection}
function create_if_block_4$2(ctx) {
	let rectmanipulator;
	let current;

	rectmanipulator = new RectManipulator({
			props: {
				rect: /*imageSelectionRectOffset*/ ctx[11],
				visible: /*$isActive*/ ctx[9],
				style: /*cropImageSelectionCornerStyle*/ ctx[2]
			}
		});

	rectmanipulator.$on("resizestart", /*handleSelectionGrab*/ ctx[60]);
	rectmanipulator.$on("resizemove", /*handleSelectionDrag*/ ctx[61]);
	rectmanipulator.$on("resizeend", /*handleSelectionRelease*/ ctx[62]);

	return {
		c() {
			create_component(rectmanipulator.$$.fragment);
		},
		m(target, anchor) {
			mount_component(rectmanipulator, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const rectmanipulator_changes = {};
			if (dirty[0] & /*imageSelectionRectOffset*/ 2048) rectmanipulator_changes.rect = /*imageSelectionRectOffset*/ ctx[11];
			if (dirty[0] & /*$isActive*/ 512) rectmanipulator_changes.visible = /*$isActive*/ ctx[9];
			if (dirty[0] & /*cropImageSelectionCornerStyle*/ 4) rectmanipulator_changes.style = /*cropImageSelectionCornerStyle*/ ctx[2];
			rectmanipulator.$set(rectmanipulator_changes);
		},
		i(local) {
			if (current) return;
			transition_in(rectmanipulator.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(rectmanipulator.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(rectmanipulator, detaching);
		}
	};
}

// (1411:8) {#if shouldRenderInfoIndicator}
function create_if_block_3$2(ctx) {
	let imageinfo;
	let current;

	imageinfo = new ImageInfo({
			props: {
				width: Math.round(/*$imageCropRect*/ ctx[7].width),
				height: Math.round(/*$imageCropRect*/ ctx[7].height)
			}
		});

	return {
		c() {
			create_component(imageinfo.$$.fragment);
		},
		m(target, anchor) {
			mount_component(imageinfo, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const imageinfo_changes = {};
			if (dirty[0] & /*$imageCropRect*/ 128) imageinfo_changes.width = Math.round(/*$imageCropRect*/ ctx[7].width);
			if (dirty[0] & /*$imageCropRect*/ 128) imageinfo_changes.height = Math.round(/*$imageCropRect*/ ctx[7].height);
			imageinfo.$set(imageinfo_changes);
		},
		i(local) {
			if (current) return;
			transition_in(imageinfo.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(imageinfo.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(imageinfo, detaching);
		}
	};
}

// (1366:4) 
function create_main_slot$1(ctx) {
	let div1;
	let div0;
	let t0;
	let interactable_action;
	let t1;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*shouldRenderImageSelection*/ ctx[17] && /*shouldRenderImageSelectionRecenterButton*/ ctx[18] && create_if_block_5$2(ctx);
	let if_block1 = /*shouldRenderImageSelection*/ ctx[17] && create_if_block_4$2(ctx);
	let if_block2 = /*shouldRenderInfoIndicator*/ ctx[16] && create_if_block_3$2(ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			attr(div0, "class", "PinturaStage");
			attr(div1, "slot", "main");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			if (if_block0) if_block0.m(div0, null);
			append(div0, t0);
			if (if_block1) if_block1.m(div0, null);
			/*div0_binding*/ ctx[145](div0);
			append(div1, t1);
			if (if_block2) if_block2.m(div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "measure", /*measure_handler_1*/ ctx[143]),
					action_destroyer(measurable.call(null, div0)),
					listen(
						div0,
						"wheel",
						function () {
							if (is_function(/*cropEnableZoom*/ ctx[3] && /*handleWheel*/ ctx[79])) (/*cropEnableZoom*/ ctx[3] && /*handleWheel*/ ctx[79]).apply(this, arguments);
						},
						{ passive: false }
					),
					listen(div0, "interactionstart", /*handleImageDragStart*/ ctx[66]),
					listen(div0, "interactionupdate", /*handleImageDrag*/ ctx[67]),
					listen(div0, "interactionrelease", /*handleImageDragRelease*/ ctx[69]),
					listen(div0, "interactionend", /*handleImageDragEnd*/ ctx[68]),
					action_destroyer(interactable_action = interactable.call(null, div0, {
						drag: true,
						pinch: /*cropEnableZoom*/ ctx[3],
						inertia: true,
						matchTarget: true,
						getEventPosition: /*interactable_function*/ ctx[146]
					})),
					listen(div0, "gesturedown", /*handleGestureStart*/ ctx[76]),
					listen(div0, "gestureupdate", /*handleGestureUpdate*/ ctx[77]),
					listen(div0, "gestureup", /*handleGestureEnd*/ ctx[78]),
					action_destroyer(gesturable.call(null, div0))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*shouldRenderImageSelection*/ ctx[17] && /*shouldRenderImageSelectionRecenterButton*/ ctx[18]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*shouldRenderImageSelection, shouldRenderImageSelectionRecenterButton*/ 393216) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_5$2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div0, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*shouldRenderImageSelection*/ ctx[17]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*shouldRenderImageSelection*/ 131072) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_4$2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div0, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (interactable_action && is_function(interactable_action.update) && dirty[0] & /*cropEnableZoom, $rootRect*/ 32776) interactable_action.update.call(null, {
				drag: true,
				pinch: /*cropEnableZoom*/ ctx[3],
				inertia: true,
				matchTarget: true,
				getEventPosition: /*interactable_function*/ ctx[146]
			});

			if (/*shouldRenderInfoIndicator*/ ctx[16]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*shouldRenderInfoIndicator*/ 65536) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_3$2(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			/*div0_binding*/ ctx[145](null);
			if (if_block2) if_block2.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (1419:4) {#if shouldRenderFooter}
function create_if_block$4(ctx) {
	let tablist;
	let t;
	let tabpanels;
	let current;

	const tablist_spread_levels = [
		{ class: "PinturaControlList" },
		{ tabs: /*tabs*/ ctx[12] },
		/*tabsConfig*/ ctx[21]
	];

	let tablist_props = {
		$$slots: {
			default: [
				create_default_slot_1$3,
				({ tab }) => ({ 191: tab }),
				({ tab }) => [0, 0, 0, 0, 0, 0, tab ? 32 : 0]
			]
		},
		$$scope: { ctx }
	};

	for (let i = 0; i < tablist_spread_levels.length; i += 1) {
		tablist_props = assign(tablist_props, tablist_spread_levels[i]);
	}

	tablist = new TabList({ props: tablist_props });
	tablist.$on("select", /*select_handler*/ ctx[144]);

	const tabpanels_spread_levels = [
		{ class: "PinturaControlPanels" },
		{ panelClass: "PinturaControlPanel" },
		{ panels: /*panels*/ ctx[22] },
		/*tabsConfig*/ ctx[21]
	];

	let tabpanels_props = {
		$$slots: {
			default: [
				create_default_slot$9,
				({ panel }) => ({ 190: panel }),
				({ panel }) => [0, 0, 0, 0, 0, 0, panel ? 16 : 0]
			]
		},
		$$scope: { ctx }
	};

	for (let i = 0; i < tabpanels_spread_levels.length; i += 1) {
		tabpanels_props = assign(tabpanels_props, tabpanels_spread_levels[i]);
	}

	tabpanels = new TabPanels({ props: tabpanels_props });

	return {
		c() {
			create_component(tablist.$$.fragment);
			t = space();
			create_component(tabpanels.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tablist, target, anchor);
			insert(target, t, anchor);
			mount_component(tabpanels, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const tablist_changes = (dirty[0] & /*tabs, tabsConfig*/ 2101248)
			? get_spread_update(tablist_spread_levels, [
					tablist_spread_levels[0],
					dirty[0] & /*tabs*/ 4096 && { tabs: /*tabs*/ ctx[12] },
					dirty[0] & /*tabsConfig*/ 2097152 && get_spread_object(/*tabsConfig*/ ctx[21])
				])
			: {};

			if (dirty[6] & /*$$scope, tab*/ 96) {
				tablist_changes.$$scope = { dirty, ctx };
			}

			tablist.$set(tablist_changes);

			const tabpanels_changes = (dirty[0] & /*panels, tabsConfig*/ 6291456)
			? get_spread_update(tabpanels_spread_levels, [
					tabpanels_spread_levels[0],
					tabpanels_spread_levels[1],
					dirty[0] & /*panels*/ 4194304 && { panels: /*panels*/ ctx[22] },
					dirty[0] & /*tabsConfig*/ 2097152 && get_spread_object(/*tabsConfig*/ ctx[21])
				])
			: {};

			if (dirty[0] & /*$imageRotation, locale, $imageRotationRange, imageZoomLevelMin, $imageZoomLevelRange, $imageZoomLevel*/ 117457168 | dirty[6] & /*$$scope, panel*/ 80) {
				tabpanels_changes.$$scope = { dirty, ctx };
			}

			tabpanels.$set(tabpanels_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tablist.$$.fragment, local);
			transition_in(tabpanels.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tablist.$$.fragment, local);
			transition_out(tabpanels.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tablist, detaching);
			if (detaching) detach(t);
			destroy_component(tabpanels, detaching);
		}
	};
}

// (1421:8) <TabList class="PinturaControlList" {tabs} {...tabsConfig} on:select={({ detail }) => transformSelected = detail} let:tab={tab}>
function create_default_slot_1$3(ctx) {
	let span;
	let t_value = /*tab*/ ctx[191].label + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(t_value);
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty[6] & /*tab*/ 32 && t_value !== (t_value = /*tab*/ ctx[191].label + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (1436:56) 
function create_if_block_2$3(ctx) {
	let rangeinput;
	let current;

	rangeinput = new RangeInput({
			props: {
				elasticity: /*elasticityMultiplier*/ ctx[35] * /*rangeInputElasticity*/ ctx[36],
				base: imageZoomLevelBase,
				min: /*imageZoomLevelMin*/ ctx[14],
				max: imageZoomLevelMax,
				valueMin: /*$imageZoomLevelRange*/ ctx[25][0],
				valueMax: /*$imageZoomLevelRange*/ ctx[25][1],
				value: /*$imageZoomLevel*/ ctx[26],
				labelReset: /*locale*/ ctx[4].labelReset,
				valueLabel: `${Math.round(/*$imageZoomLevel*/ ctx[26] * 100)}%`,
				oninputstart: /*handleResizeStart*/ ctx[73],
				oninputmove: /*handleResizeMove*/ ctx[74],
				oninputend: /*handleResizeEnd*/ ctx[75]
			}
		});

	return {
		c() {
			create_component(rangeinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(rangeinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const rangeinput_changes = {};
			if (dirty[0] & /*imageZoomLevelMin*/ 16384) rangeinput_changes.min = /*imageZoomLevelMin*/ ctx[14];
			if (dirty[0] & /*$imageZoomLevelRange*/ 33554432) rangeinput_changes.valueMin = /*$imageZoomLevelRange*/ ctx[25][0];
			if (dirty[0] & /*$imageZoomLevelRange*/ 33554432) rangeinput_changes.valueMax = /*$imageZoomLevelRange*/ ctx[25][1];
			if (dirty[0] & /*$imageZoomLevel*/ 67108864) rangeinput_changes.value = /*$imageZoomLevel*/ ctx[26];
			if (dirty[0] & /*locale*/ 16) rangeinput_changes.labelReset = /*locale*/ ctx[4].labelReset;
			if (dirty[0] & /*$imageZoomLevel*/ 67108864) rangeinput_changes.valueLabel = `${Math.round(/*$imageZoomLevel*/ ctx[26] * 100)}%`;
			rangeinput.$set(rangeinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(rangeinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(rangeinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(rangeinput, detaching);
		}
	};
}

// (1426:12) {#if panel === cropUniqueId + '-rotation' }
function create_if_block_1$4(ctx) {
	let imagerotator;
	let current;

	imagerotator = new ImageRotator({
			props: {
				elasticity: /*elasticityMultiplier*/ ctx[35] * /*rangeInputElasticity*/ ctx[36],
				rotation: /*$imageRotation*/ ctx[8],
				labelReset: /*locale*/ ctx[4].labelReset,
				valueMin: /*$imageRotationRange*/ ctx[24][0],
				valueMax: /*$imageRotationRange*/ ctx[24][1],
				oninputstart: /*handleRotateStart*/ ctx[63],
				oninputmove: /*handleRotateMove*/ ctx[64],
				oninputend: /*handleRotateEnd*/ ctx[65]
			}
		});

	return {
		c() {
			create_component(imagerotator.$$.fragment);
		},
		m(target, anchor) {
			mount_component(imagerotator, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const imagerotator_changes = {};
			if (dirty[0] & /*$imageRotation*/ 256) imagerotator_changes.rotation = /*$imageRotation*/ ctx[8];
			if (dirty[0] & /*locale*/ 16) imagerotator_changes.labelReset = /*locale*/ ctx[4].labelReset;
			if (dirty[0] & /*$imageRotationRange*/ 16777216) imagerotator_changes.valueMin = /*$imageRotationRange*/ ctx[24][0];
			if (dirty[0] & /*$imageRotationRange*/ 16777216) imagerotator_changes.valueMax = /*$imageRotationRange*/ ctx[24][1];
			imagerotator.$set(imagerotator_changes);
		},
		i(local) {
			if (current) return;
			transition_in(imagerotator.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(imagerotator.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(imagerotator, detaching);
		}
	};
}

// (1425:8) <TabPanels class="PinturaControlPanels" panelClass="PinturaControlPanel" {panels} {...tabsConfig} let:panel>
function create_default_slot$9(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$4, create_if_block_2$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*panel*/ ctx[190] === /*cropUniqueId*/ ctx[85] + "-rotation") return 0;
		if (/*panel*/ ctx[190] === /*cropUniqueId*/ ctx[85] + "-zoom") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty$1();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

// (1418:4) 
function create_footer_slot$5(ctx) {
	let div;
	let current;
	let if_block = /*shouldRenderFooter*/ ctx[20] && create_if_block$4(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "slot", "footer");
			attr(div, "style", /*footerStyle*/ ctx[23]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*shouldRenderFooter*/ ctx[20]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*shouldRenderFooter*/ 1048576) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*footerStyle*/ 8388608) {
				attr(div, "style", /*footerStyle*/ ctx[23]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
		}
	};
}

function create_fragment$j(ctx) {
	let util;
	let updating_root;
	let current;

	function util_root_binding(value) {
		/*util_root_binding*/ ctx[147](value);
	}

	let util_props = {
		hasHeader: /*shouldRenderToolbar*/ ctx[19],
		$$slots: {
			footer: [create_footer_slot$5],
			main: [create_main_slot$1],
			header: [create_header_slot]
		},
		$$scope: { ctx }
	};

	if (/*root*/ ctx[13] !== void 0) {
		util_props.root = /*root*/ ctx[13];
	}

	util = new Util({ props: util_props });
	binding_callbacks.push(() => bind$1(util, "root", util_root_binding));
	util.$on("measure", /*measure_handler*/ ctx[148]);

	return {
		c() {
			create_component(util.$$.fragment);
		},
		m(target, anchor) {
			mount_component(util, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const util_changes = {};
			if (dirty[0] & /*shouldRenderToolbar*/ 524288) util_changes.hasHeader = /*shouldRenderToolbar*/ ctx[19];

			if (dirty[0] & /*footerStyle, panels, tabsConfig, $imageRotation, locale, $imageRotationRange, imageZoomLevelMin, $imageZoomLevelRange, $imageZoomLevel, tabs, transformSelected, shouldRenderFooter, $imageCropRect, shouldRenderInfoIndicator, stageRef, cropEnableZoom, $rootRect, imageSelectionRectOffset, $isActive, cropImageSelectionCornerStyle, shouldRenderImageSelection, canCenter, $recenterOpacity, $recenterOffset, shouldRenderImageSelectionRecenterButton, tools*/ 536338429 | dirty[6] & /*$$scope*/ 64) {
				util_changes.$$scope = { dirty, ctx };
			}

			if (!updating_root && dirty[0] & /*root*/ 8192) {
				updating_root = true;
				util_changes.root = /*root*/ ctx[13];
				add_flush_callback(() => updating_root = false);
			}

			util.$set(util_changes);
		},
		i(local) {
			if (current) return;
			transition_in(util.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(util.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(util, detaching);
		}
	};
}

const imageZoomLevelMax = 1;
const imageZoomLevelBase = 0;

function instance$j($$self, $$props, $$invalidate) {
	let imageZoomLevelMin;
	let imageSelectionOffset;
	let imageSelectionCenter;
	let imageSelectionCenteredRect;
	let isImageSelectionDisplayed;
	let isImageSelectionCentered;
	let isResizingSelection;
	let isMaxSelectionRect;
	let isOverlayMode;
	let canZoomToCenter;
	let canCenter;
	let shouldRenderInfoIndicator;
	let shouldRenderImageSelection;
	let shouldRenderImageSelectionRecenterButton;
	let imageSelectionRectOffset;
	let hasPlentyVerticalSpace;
	let shouldRenderPresetSelect;
	let shouldRenderToolbar;
	let couldRenderZoomInput;
	let shouldRenderZoomInput;
	let shouldRenderFooter;
	let tabsConfig;
	let tabs;
	let panels;
	let footerStyle;
	let $imageCropAspectRatio;
	let $imageCropRect;
	let $imageSize;
	let $imageRotation;
	let $imageFlipY;
	let $imageFlipX;
	let $selectedPresetIndex;
	let $imageOutputSize;
	let $imageCropMinSize;
	let $imageCropLimitToImage;
	let $env;

	let $isActive,
		$$unsubscribe_isActive = noop$2,
		$$subscribe_isActive = () => ($$unsubscribe_isActive(), $$unsubscribe_isActive = subscribe(isActive, $$value => $$invalidate(9, $isActive = $$value)), isActive);

	let $isInteracting;
	let $imageSelectionRectSnapshot;
	let $imageSelectionRect;
	let $presentationScalar;
	let $imageCropMaxSize;
	let $imageSelectionRectIntent;
	let $utilRect;
	let $imageCropRectOrigin;
	let $imageCropRectIntent;
	let $imageCropRange;
	let $rootRect;
	let $stageRect;
	let $imageCropRangeAspectRatio;
	let $imageSelectionRectPresentation;
	let $imageScalar;
	let $framePadded;
	let $imagePreviewModifiers;
	let $imageOverlayMarkup;
	let $imageSelectionGuides;
	let $animation;
	let $footerOffset;
	let $imageRotationRange;
	let $imageZoomLevelRange;
	let $imageZoomLevel;
	let $recenterOpacity;
	let $recenterOffset;
	$$self.$$.on_destroy.push(() => $$unsubscribe_isActive());
	const name = "crop";
	let { isActive } = $$props;
	$$subscribe_isActive();
	let { stores } = $$props;
	let { cropImageSelectionCornerStyle = "circle" } = $$props; // 'circle', 'hook', 'invisible'

	let { cropWillRenderImageSelectionGuides = (interaction, interactionFraction) => {
		const isRotating = interaction == "rotate";

		return {
			rows: isRotating ? 5 : 3,
			cols: isRotating ? 5 : 3,
			opacity: interactionFraction * 0.25
		};
	} } = $$props;

	let { cropAutoCenterImageSelectionTimeout = undefined } = $$props;
	let { cropEnableZoomMatchImageAspectRatio = true } = $$props;
	let { cropEnableRotateMatchImageAspectRatio = "never" } = $$props; // 'always' | 'custom' | 'never'
	let { cropEnableRotationInput = true } = $$props;
	let { cropEnableZoom = true } = $$props;
	let { cropEnableZoomInput = true } = $$props;
	let { cropEnableZoomAutoHide = true } = $$props;
	let { cropEnableImageSelection = true } = $$props;
	let { cropEnableInfoIndicator = false } = $$props;
	let { cropEnableZoomTowardsWheelPosition = true } = $$props;
	let { cropEnableLimitWheelInputToCropSelection = true } = $$props;
	let { cropEnableCenterImageSelection = true } = $$props;
	let { cropEnableButtonRotateLeft = true } = $$props;
	let { cropEnableButtonRotateRight = false } = $$props;
	let { cropEnableButtonFlipHorizontal = true } = $$props;
	let { cropEnableButtonFlipVertical = false } = $$props;
	let { cropSelectPresetOptions = undefined } = $$props;
	let { cropEnableSelectPreset = true } = $$props;
	let { cropEnableButtonToggleCropLimit = false } = $$props;
	let { cropWillRenderTools = passthrough } = $$props;
	let { locale = {} } = $$props;
	let { tools = [] } = $$props;

	// state
	let interaction = "idle";

	// helpers
	const isCustomCrop = () => $imageCropAspectRatio === undefined;

	const turnAspectRatio = aspectRatio => 1 / aspectRatio;

	const hasValidRotatedCropAspectRatio = () => {
		if ($imageCropAspectRatio === 1) return false;
		const rotatedImageCropAspectRatio = turnAspectRatio($imageCropAspectRatio);

		// no options available, forced crop aspect ratio
		if (!cropSelectPresetOptions) return false;

		// options available but no valid option in list
		if (!flattenOptions(cropSelectPresetOptions).find(([aspectRatio]) => aspectRatio === rotatedImageCropAspectRatio)) return false;

		return true;
	};

	const isCropMaxSize = (imageCropRect, imageSize, imageRotation) => isRotatedSideways(imageRotation)
	? imageSize.width === Math.round(imageCropRect.height) || imageSize.height === Math.round(imageCropRect.width)
	: imageSize.width === Math.round(imageCropRect.width) || imageSize.height === Math.round(imageCropRect.height);

	const isCropCentered = (imageCropRect, imageSize, imageRotation) => {
		const imageSizeRotated = sizeApply(sizeRotate(sizeClone(imageSize), imageRotation), v => Math.abs(Math.round(v)));
		const imageCenter = sizeCenter(imageSizeRotated);
		const cropCenter = rectCenter(imageCropRect);
		return vectorEqual(imageCenter, cropCenter);
	};

	const canMatchCropAspectRatioToRotation = () => (// is custom crop mode
	isCustomCrop() || // can match preset crop and preset is available
	cropEnableRotateMatchImageAspectRatio === "always" && hasValidRotatedCropAspectRatio()) && isCropCentered($imageCropRect, $imageSize, $imageRotation) && isCropMaxSize($imageCropRect, $imageSize, $imageRotation);

	const applyRotation = value => {
		if (cropEnableRotateMatchImageAspectRatio !== "never" && canMatchCropAspectRatioToRotation()) {
			set_store_value(imageRotation, $imageRotation += value, $imageRotation);
			const isRotated = isRotatedSideways($imageRotation);
			const w = isRotated ? $imageSize.height : $imageSize.width;
			const h = isRotated ? $imageSize.width : $imageSize.height;
			set_store_value(imageCropRect, $imageCropRect = rectCreate(0, 0, w, h), $imageCropRect);
			if (!isCustomCrop()) set_store_value(imageCropAspectRatio, $imageCropAspectRatio = getAspectRatio(w, h), $imageCropAspectRatio);
		} else {
			set_store_value(imageRotation, $imageRotation += value, $imageRotation);
		}
	};

	const { history, env, isInteracting, isInteractingFraction, rootRect, stageRect, utilRect, rootLineColor, animation, elasticityMultiplier, rangeInputElasticity, presentationScalar, // effect filtering
	imagePreviewModifiers, imageOutlineOpacity, // crop selection
	imageFlipX, imageFlipY, imageRotation, imageRotationRange, imageOutputSize, imageSelectionRect, imageSelectionRectSnapshot, imageSelectionRectIntent, imageSelectionRectPresentation, imageCropRectIntent, imageCropRectOrigin, imageCropRect, imageCropMinSize, imageCropMaxSize, imageCropRange, imageCropAspectRatio, imageCropRectAspectRatio, imageCropLimitToImage, imageSize, imageScalar, imageOverlayMarkup, framePadded } = stores; // the actual limited rectangle
	// used to calculate rectangle while dragging
	// can be used to set set intended rectangle
	// readonly

	component_subscribe($$self, env, value => $$invalidate(118, $env = value));
	component_subscribe($$self, isInteracting, value => $$invalidate(119, $isInteracting = value));
	component_subscribe($$self, rootRect, value => $$invalidate(15, $rootRect = value));
	component_subscribe($$self, stageRect, value => $$invalidate(124, $stageRect = value));
	component_subscribe($$self, utilRect, value => $$invalidate(123, $utilRect = value));
	component_subscribe($$self, animation, value => $$invalidate(141, $animation = value));
	component_subscribe($$self, presentationScalar, value => $$invalidate(122, $presentationScalar = value));
	component_subscribe($$self, imagePreviewModifiers, value => $$invalidate(136, $imagePreviewModifiers = value));
	component_subscribe($$self, imageFlipX, value => $$invalidate(112, $imageFlipX = value));
	component_subscribe($$self, imageFlipY, value => $$invalidate(111, $imageFlipY = value));
	component_subscribe($$self, imageRotation, value => $$invalidate(8, $imageRotation = value));
	component_subscribe($$self, imageRotationRange, value => $$invalidate(24, $imageRotationRange = value));
	component_subscribe($$self, imageOutputSize, value => $$invalidate(159, $imageOutputSize = value));
	component_subscribe($$self, imageSelectionRect, value => $$invalidate(121, $imageSelectionRect = value));
	component_subscribe($$self, imageSelectionRectSnapshot, value => $$invalidate(120, $imageSelectionRectSnapshot = value));
	component_subscribe($$self, imageSelectionRectIntent, value => $$invalidate(161, $imageSelectionRectIntent = value));
	component_subscribe($$self, imageSelectionRectPresentation, value => $$invalidate(127, $imageSelectionRectPresentation = value));
	component_subscribe($$self, imageCropRectIntent, value => $$invalidate(163, $imageCropRectIntent = value));
	component_subscribe($$self, imageCropRectOrigin, value => $$invalidate(162, $imageCropRectOrigin = value));
	component_subscribe($$self, imageCropRect, value => $$invalidate(7, $imageCropRect = value));
	component_subscribe($$self, imageCropMinSize, value => $$invalidate(116, $imageCropMinSize = value));
	component_subscribe($$self, imageCropMaxSize, value => $$invalidate(160, $imageCropMaxSize = value));
	component_subscribe($$self, imageCropRange, value => $$invalidate(164, $imageCropRange = value));
	component_subscribe($$self, imageCropAspectRatio, value => $$invalidate(158, $imageCropAspectRatio = value));
	component_subscribe($$self, imageCropLimitToImage, value => $$invalidate(117, $imageCropLimitToImage = value));
	component_subscribe($$self, imageSize, value => $$invalidate(110, $imageSize = value));
	component_subscribe($$self, imageScalar, value => $$invalidate(134, $imageScalar = value));
	component_subscribe($$self, imageOverlayMarkup, value => $$invalidate(166, $imageOverlayMarkup = value));
	component_subscribe($$self, framePadded, value => $$invalidate(135, $framePadded = value));

	//
	// resizing crop
	//
	let presentationScalarSnapshot;

	let imageSelectionRectMinSize;
	let imageSelectionRectMaxSize;

	const handleSelectionGrab = () => {
		interaction = "select";

		// now interacting
		set_store_value(isInteracting, $isInteracting = true, $isInteracting);

		// we remember the current view rect and crop rect, because that is the crop rect we use as a starting point to transform while dragging
		set_store_value(imageSelectionRectSnapshot, $imageSelectionRectSnapshot = rectClone($imageSelectionRect), $imageSelectionRectSnapshot);

		// remember current scalar so we can update min and max size correctly
		presentationScalarSnapshot = $presentationScalar;

		imageSelectionRectMinSize = sizeScale(sizeClone($imageCropMinSize), presentationScalarSnapshot);
		imageSelectionRectMaxSize = sizeScale(sizeClone($imageCropMaxSize), presentationScalarSnapshot);
	};

	const handleSelectionDrag = ({ detail }) => {
		const { boundsLimited, boundsIntent } = translateSelection(detail.direction, detail.translation);

		// update actual image selection rectangle
		set_store_value(imageSelectionRectIntent, $imageSelectionRectIntent = boundsIntent, $imageSelectionRectIntent); // intent needs to be updated first because has no listeners attached

		set_store_value(imageSelectionRect, $imageSelectionRect = boundsLimited, $imageSelectionRect);
	};

	const handleSelectionRelease = ({ detail }) => {
		const { boundsLimited } = translateSelection(detail.direction, detail.translation);

		// we're no longer interacting with the image selection, we need to set this here so the image selection presentation is animated when applying the new bounds below
		set_store_value(isInteracting, $isInteracting = false, $isInteracting);

		// no more intent as we're finalizing the selection, so before setting the final selection, we set this to undefined | intent needs to be updated first because has no listeners attached
		set_store_value(imageSelectionRectIntent, $imageSelectionRectIntent = undefined, $imageSelectionRectIntent);

		// confirm the limited rect if actually made a change
		if (vectorLength(detail.translation)) {
			set_store_value(imageSelectionRect, $imageSelectionRect = boundsLimited, $imageSelectionRect);
			history.write();
		}

		// need to set this to undefined after setting the final rect, the snapshot is used to calculate the crop rect transform
		set_store_value(imageSelectionRectSnapshot, $imageSelectionRectSnapshot = undefined, $imageSelectionRectSnapshot);

		// done interacting with selection
		interaction = undefined;
	};

	const translateSelection = (target, translate) => {
		// - selection may grow to max bounds (util bounds)
		// - the image preview(!) is scaled to fit the selection, actual image size is not affected
		// - we need to make sure the selection adheres to the aspect ratio of the min size
		const directionTranslation = { target, translate };

		let rectIntended = applyRectDirectionTranslation($imageSelectionRectSnapshot, directionTranslation, { aspectRatio: $imageCropAspectRatio });
		let cropAspectRatioLimited;

		// size in crop rect
		const cropSize = sizeCreateFromRect(rectDivide(rectClone(rectIntended), $presentationScalar));

		getImagePolygon($imageSize, $imageRotation);

		// if one of the edges is small and not both are smaller we need to correct
		if (cropSize.width < $imageCropMinSize.width || cropSize.height < $imageCropMinSize.height) {
			// if moving towards the center of the crop, it can't exceed bounds
			const translateUp = translate.y < 0;

			const translateRight = translate.x > 0;
			const translateLeft = translate.x < 0;
			const translateDown = translate.y > 0;
			const couldExceedBounds = target === "t" && translateUp || target === "r" && translateRight || target === "b" && translateDown || target === "l" && translateLeft || target === "tr" && (translateRight || translateUp) || target === "tl" && (translateLeft || translateUp) || target === "br" && (translateRight || translateDown) || target === "bl" && (translateLeft || translateDown);

			// need the aspect ratio of the crop to determine if it violates min size
			const cropAspectRatio = rectAspectRatio(cropSize);

			// find the maximum size for the current aspect ratio
			const cropSizeMax = getMaxSizeInRect($imageSize, $imageRotation, cropAspectRatio);

			if (couldExceedBounds && (cropSizeMax.width < $imageCropMinSize.width || cropSizeMax.height < $imageCropMinSize.height)) {
				if ($imageRotation !== 0) {
					const sign = Math.sign($imageRotation);
					const turns = Math.round(Math.abs($imageRotation) / HALF_PI) * HALF_PI;
					const value = $imageRotation - sign * turns;
					const imageIsRotated = turns / HALF_PI % 2 === 1;
					const imageWidth = imageIsRotated ? $imageSize.height : $imageSize.width;
					const imageHeight = imageIsRotated ? $imageSize.width : $imageSize.height;
					const r = Math.abs(value);
					const sin = Math.sin(r);
					const cos = Math.cos(r);

					if (cropSize.width < $imageCropMinSize.width) {
						// width doesn't fit, let's limit the width to the min size
						cropSize.width = $imageCropMinSize.width;

						// And now calculate the height
						//  - rotation = .15
						//  - image size = 384 x 288
						//  - crop size width = 200
						// height = 288 - (Math.sin(.15) * 200) / Math.cos(.15)
						const w = cos * cropSize.width + sin * cropSize.height;

						const h = sin * cropSize.width + cos * cropSize.height;
						const dx = imageWidth - w;
						const dy = imageHeight - h;

						if (dx < dy) {
							cropSize.height = (imageWidth - cos * cropSize.width) / sin;
						} else if (dy < dx) {
							cropSize.height = (imageHeight - sin * cropSize.width) / cos;
						}
					}

					if (cropSize.height < $imageCropMinSize.height) {
						// height doesn't fit, let's limit the height to the min size
						cropSize.height = $imageCropMinSize.height;

						// And now calculate the width
						//  - rotation = .15
						//  - image size = 384 x 288
						//  - crop size height = 200
						const w = cos * cropSize.width + sin * cropSize.height;

						const h = sin * cropSize.width + cos * cropSize.height;
						const dx = imageWidth - w;
						const dy = imageHeight - h;

						if (dx < dy) {
							// (384 - (Math.sin(.15) * 250)) / Math.cos(.15)
							cropSize.width = (imageWidth - sin * cropSize.height) / cos;
						} else if (dy < dx) {
							// (288 - (Math.cos(.15) * 250)) / Math.sin(.15)
							cropSize.width = (imageHeight - cos * cropSize.height) / sin;
						}
					}
				} else {
					if (cropSize.width < $imageCropMinSize.width) {
						cropSize.width = $imageCropMinSize.width;
						cropSize.height = $imageSize.height;
					}

					if (cropSize.height < $imageCropMinSize.height) {
						cropSize.height = $imageCropMinSize.height;
						cropSize.width = $imageSize.width;
					}
				}

				// we now have a corrected size, let's calculate the new aspect ratio and use that to limit the translation
				cropAspectRatioLimited = rectAspectRatio(cropSize);
			}
		}

		if (cropAspectRatioLimited) {
			rectIntended = applyRectDirectionTranslation($imageSelectionRectSnapshot, directionTranslation, {
				aspectRatio: cropAspectRatioLimited || $imageCropAspectRatio
			});
		}

		let rectLimited = limitRectDirectionTranslation($imageSelectionRectSnapshot, directionTranslation, $utilRect, {
			aspectRatio: $imageCropAspectRatio || cropAspectRatioLimited,
			minSize: imageSelectionRectMinSize,
			maxSize: imageSelectionRectMaxSize
		});

		return {
			boundsLimited: rectLimited,
			boundsIntent: rectIntended
		};
	};

	//
	// rotating
	//
	const handleRotateStart = () => {
		interaction = "rotate";

		// now interacting with view
		set_store_value(isInteracting, $isInteracting = true, $isInteracting);

		// we need to know the origin of the crop so we can "shrink" the image to fit the crop rect while rotating
		set_store_value(imageCropRectOrigin, $imageCropRectOrigin = rectClone($imageCropRect), $imageCropRectOrigin);
	};

	const handleRotateMove = value => {
		set_store_value(imageRotation, $imageRotation = value, $imageRotation); // will auto validate
	};

	const handleRotateEnd = value => {
		// we're done interacting
		set_store_value(isInteracting, $isInteracting = false, $isInteracting);

		// apply our final rotation value
		set_store_value(imageRotation, $imageRotation = value, $imageRotation);

		history.write();

		// done, so we no longer need to "shrink" the image
		set_store_value(imageCropRectOrigin, $imageCropRectOrigin = undefined, $imageCropRectOrigin);
	};

	//
	// moving
	//
	let interactionCropRect = undefined;

	let interactionCropRectForce = undefined;

	const handleImageDragStart = () => {
		interaction = "pan";
		interactionCropRectForce = undefined;
		set_store_value(isInteracting, $isInteracting = true, $isInteracting);
		interactionCropRect = rectClone($imageCropRect);
	};

	const handleImageDrag = ({ detail }) => manipulateImage(detail);

	const handleImageDragEnd = ({ detail }) => {
		// done interacting
		set_store_value(isInteracting, $isInteracting = false, $isInteracting);

		// apply translation to the crop rect only if did make changes
		if (vectorLength(detail.translation) > 0 || detail.scalar !== 0) {
			manipulateImage(detail);
			history.write();
		}

		// no intent (needs to be set before crop rect is updated)
		set_store_value(imageCropRectIntent, $imageCropRectIntent = undefined, $imageCropRectIntent);

		// now done
		interactionCropRect = undefined;
	};

	const handleImageDragRelease = ({ detail }) => {
		interactionCropRectForce = detail.translation;
		set_store_value(isInteracting, $isInteracting = false, $isInteracting);
	};

	const manipulateImage = ({ translation, scalar }) => {
		const imageSelectionRectZoomFactor = Math.min($imageSelectionRect.width / $imageCropRect.width, $imageSelectionRect.height / $imageCropRect.height);
		const scaledTranslation = vectorMultiply(vectorClone(translation), 1 / imageSelectionRectZoomFactor);

		// while we're interacting we apply changes to the original crop rectangle, after we apply a force
		let cropIntent;

		if (!interactionCropRectForce) {
			cropIntent = rectTranslate(rectClone(interactionCropRect), vectorInvert(vectorClone(scaledTranslation)));

			if (scalar !== undefined) {
				rectScale(cropIntent, 1 / scalar);
			} // rectScale(cropIntent, scalar);
		} else {
			// we apply the force to the existing crop rect so animation is not borked
			const forceTranslation = vectorSubtract(vectorClone(interactionCropRectForce), translation);

			interactionCropRectForce = translation;
			cropIntent = rectTranslate(rectClone($imageCropRect), forceTranslation);
		}

		// update crop rect
		set_store_value(imageCropRectIntent, $imageCropRectIntent = cropIntent, $imageCropRectIntent); // auto calculates an elastic effect if bounds exceeded (needs to be set before crop rect is updated)

		set_store_value(imageCropRect, $imageCropRect = cropIntent, $imageCropRect); // auto limits to bounds if needed
	};

	//
	// resizing with range input
	//
	const calculateZoomLevel = (imageSize, size, imageRotation) => {
		if (isRotatedSideways(imageRotation)) {
			return 1 - 1 / Math.min(imageSize.height / size.width, imageSize.width / size.height);
		}

		return 1 - 1 / Math.min(imageSize.width / size.width, imageSize.height / size.height);
	};

	const imageCropRangeAspectRatio = derived([imageCropRange, imageCropRect], ([$imageCropRange, $imageCropRect], set) => {
		if (!$imageCropRect) return;
		const [minSize, maxSize] = $imageCropRange;
		const aspectRatio = rectAspectRatio($imageCropRect);

		set([
			sizeCreateFromRect(rectApply(rectCoverRect(minSize, aspectRatio), fixPrecision)),
			sizeCreateFromRect(rectApply(rectContainRect(maxSize, aspectRatio), fixPrecision))
		]);
	});

	component_subscribe($$self, imageCropRangeAspectRatio, value => $$invalidate(165, $imageCropRangeAspectRatio = value));

	// this is the max value range that can be set (triggers white range indicator bar)
	const imageZoomLevelRange = derived(
		[
			imageSize,
			imageCropLimitToImage,
			imageCropMinSize,
			imageCropMaxSize,
			imageCropRange,
			imageRotation
		],
		([
				$imageSize,
				$imageCropLimitToImage,
				$imageCropMinSize,
				$imageCropMaxSize,
				$imageCropRange,
				$imageRotation
			], set) => {
			if (!$imageSize) return;
			const rangeMinSize = $imageCropRange[0];
			const rangeMaxSize = $imageCropRange[1];
			let minZoom;
			let maxZoom;

			// can't zoom out
			if ($imageCropLimitToImage) {
				minZoom = calculateZoomLevel($imageSize, rangeMaxSize, $imageRotation);
				maxZoom = Math.min(rangeMinSize.width / $imageCropMinSize.width, rangeMinSize.height / $imageCropMinSize.height);
			} else {
				maxZoom = 1;
				minZoom = -1;
			}

			const range = [fixPrecision(minZoom), fixPrecision(maxZoom)];
			set(range);
		}
	);

	component_subscribe($$self, imageZoomLevelRange, value => $$invalidate(25, $imageZoomLevelRange = value));

	const imageZoomLevel = derived([imageSize, imageCropRect, imageCropRange, imageRotation], ([$imageSize, $imageCropRect, $imageCropRange, $imageRotation], set) => {
		// need to check if this value is set, could be that it's empty while loading a new image
		if (!$imageSize || !$imageCropRect) return set(0);

		let z;
		const rangeMinSize = $imageCropRange[0];
		const rangeMaxSize = $imageCropRange[1];
		const currentCropWidth = $imageCropRect.width;
		const currentCropHeight = $imageCropRect.height;
		const currentCropAspectRatio = rectAspectRatio($imageCropRect);

		const imageRect = isRotatedSideways($imageRotation)
		? sizeCreate($imageSize.height, $imageSize.width)
		: $imageSize;

		const imageCropMaxRect = rectContainRect(imageRect, currentCropAspectRatio);

		if (currentCropWidth <= imageCropMaxRect.width || currentCropHeight <= imageCropMaxRect.height) {
			// zoomed in
			const w = imageCropMaxRect.width - rangeMinSize.width;

			const h = imageCropMaxRect.height - rangeMinSize.height;

			// cannot zoom in
			if (w === 0 || h === 0) {
				z = 1;
			} else {
				z = 1 - Math.min((currentCropWidth - rangeMinSize.width) / w, (currentCropHeight - rangeMinSize.height) / h);
			}
		} else {
			// zoomed out
			const w = rangeMaxSize.width - imageCropMaxRect.width;

			const h = rangeMaxSize.height - imageCropMaxRect.height;
			const r = rectContainRect({ width: w, height: h }, currentCropAspectRatio);
			z = -Math.min((currentCropWidth - imageCropMaxRect.width) / r.width, (currentCropHeight - imageCropMaxRect.height) / r.height);
		}

		set(z);
	});

	component_subscribe($$self, imageZoomLevel, value => $$invalidate(26, $imageZoomLevel = value));

	const snapshotCropRect = () => {
		interactionCropRect = rectClone($imageCropRect);
	};

	const resizeImage = zoom => {
		const aspectRatio = rectAspectRatio(interactionCropRect);
		let targetWidth;
		let targetHeight;
		let r;

		const imageRect = isRotatedSideways($imageRotation)
		? sizeCreate($imageSize.height, $imageSize.width)
		: $imageSize;

		const imageCropMaxRect = rectContainRect(imageRect, aspectRatio);

		if (zoom >= 0) {
			// zoom in
			const rangeWidth = imageCropMaxRect.width - $imageCropRange[0].width;

			const rangeHeight = imageCropMaxRect.height - $imageCropRange[0].height;
			targetWidth = imageCropMaxRect.width - rangeWidth * zoom;
			targetHeight = imageCropMaxRect.height - rangeHeight * zoom;
			r = rectCoverRect({ width: targetWidth, height: targetHeight }, aspectRatio);
		} else {
			// zoom out
			const rangeWidth = $imageCropRange[1].width - imageCropMaxRect.width;

			const rangeHeight = $imageCropRange[1].height - imageCropMaxRect.height;
			targetWidth = imageCropMaxRect.width + rangeWidth * -zoom;
			targetHeight = imageCropMaxRect.height + rangeHeight * -zoom;
			r = rectContainRect({ width: targetWidth, height: targetHeight }, aspectRatio);
		}

		targetWidth = r.width;
		targetHeight = r.height;
		const targetX = interactionCropRect.x + interactionCropRect.width * 0.5 - targetWidth * 0.5;
		const targetY = interactionCropRect.y + interactionCropRect.height * 0.5 - targetHeight * 0.5;

		set_store_value(
			imageCropRect,
			$imageCropRect = {
				x: targetX,
				y: targetY,
				width: targetWidth,
				height: targetHeight
			},
			$imageCropRect
		);
	};

	const handleResizeStart = () => {
		interaction = "zoom";

		// now interacting with view
		set_store_value(isInteracting, $isInteracting = true, $isInteracting);

		snapshotCropRect();
	};

	const handleResizeMove = value => {
		// value range from 0 (no zoom) to 1 (100% zoom, 1x1 pixel)
		resizeImage(value);
	};

	const handleResizeEnd = value => {
		resizeImage(value);
		history.write();

		// we're done interacting
		set_store_value(isInteracting, $isInteracting = false, $isInteracting);

		// now done
		interactionCropRect = undefined;
	};

	//
	// resizing with gesture (MacBook trackpad Safari)
	//
	let gestureOriginCropRect;

	const handleGestureStart = () => {
		interaction = "zoom";

		// don't handle gesture as we're already handling input with interactable
		if (interactionCropRect) return;

		gestureOriginCropRect = rectClone($imageCropRect);

		// now interacting
		set_store_value(isInteracting, $isInteracting = true, $isInteracting);
	};

	const handleGestureUpdate = ({ detail }) => {
		// don't handle gesture as we're already handling input with interactable
		if (!gestureOriginCropRect) return;

		handleScaleGesture(detail);
	};

	const handleScaleGesture = scale => {
		const cropIntent = rectScale(rectClone(gestureOriginCropRect), 1 / scale);
		set_store_value(imageCropRectIntent, $imageCropRectIntent = cropIntent, $imageCropRectIntent);
		set_store_value(imageCropRect, $imageCropRect = cropIntent, $imageCropRect);
	};

	const handleGestureEnd = ({ detail }) => {
		// don't handle gesture as we're already handling input with interactable
		if (!gestureOriginCropRect) return;

		// now interacting
		set_store_value(isInteracting, $isInteracting = false, $isInteracting);

		handleScaleGesture(detail);

		// no intent (needs to be set before crop rect is updated)
		set_store_value(imageCropRectIntent, $imageCropRectIntent = undefined, $imageCropRectIntent);

		gestureOriginCropRect = undefined;
		history.write();
	};

	//
	// resizing with wheel
	//
	let zoomHistoryTimeoutId;

	const handleWheel = e => {
		const stageWheelPosition = getEventPositionInStage(e, $rootRect, $stageRect);

		// only block input if wheel is used within image rectangle
		if (cropEnableLimitWheelInputToCropSelection && !rectContainsPoint($imageSelectionRect, stageWheelPosition)) return;

		interaction = "zoom";

		// now interacting
		set_store_value(isInteracting, $isInteracting = true, $isInteracting);

		// don't run default actions, prevent other actions from running
		e.preventDefault();

		e.stopPropagation();

		// convert wheel delta to scalar
		const delta = getWheelDelta(e);

		const scalar = 1 + delta / 100;

		// get current crop rect
		const currentCropRect = rectClone($imageCropRect);

		// if already zoomed in, block further zoom in instructions
		const isMinSize = Math.min($imageCropRect.width / $imageCropMinSize.width, $imageCropRect.height / $imageCropMinSize.height) === 1;

		// if is fully zoomed out and trying to zoom out more and crop shape is free, fit image aspect ratio
		if (cropEnableZoomMatchImageAspectRatio && $imageCropLimitToImage) {
			const isAtMaxCropSize = isCropMaxSize($imageCropRect, $imageSize, $imageRotation);

			if (isCustomCrop() && isAtMaxCropSize && delta > 0 && isImageSelectionCentered) {
				set_store_value(isInteracting, $isInteracting = false, $isInteracting);

				const newCropRect = isRotatedSideways($imageRotation)
				? rectCreateFromSize({
						height: $imageSize.width,
						width: $imageSize.height
					})
				: rectCreateFromSize($imageSize);

				// no change, exit
				if (rectEqual(currentCropRect, newCropRect)) return;

				// if we were previously zooming in we need to clear the timeout to prevent two history entries
				clearTimeout(zoomHistoryTimeoutId);

				// test if crop rect in history is same as new crop rect, this is possible when zooming in and out real quick
				if (rectEqual(history.state.crop, newCropRect)) return;

				// store new crop rect
				set_store_value(imageCropRect, $imageCropRect = newCropRect, $imageCropRect);

				history.write();
				return;
			}
		}

		// by default when zooming, zoom from center of crop rectangle
		let origin = rectCenter($imageCropRect);

		// when zooming in, zoom in on the part of the image below the mouse cursor
		if (cropEnableZoomTowardsWheelPosition && delta < 0 && !isMinSize) {
			const selectionOffset = vectorSubtract(vectorClone(stageWheelPosition), $imageSelectionRect);
			const imageSelectionScale = Math.min($imageSelectionRect.width / $imageCropRect.width, $imageSelectionRect.height / $imageCropRect.height);

			// if wheel is inside image selection rectangle (slightly expanded version), we zoom based on position in the rectangle, if not, we use the selection center
			const expandedImageSelection = rectScale(rectClone($imageSelectionRect), 1.1);

			origin = rectContainsPoint(expandedImageSelection, stageWheelPosition)
			? vectorAdd(rectClone($imageCropRect), vectorMultiply(selectionOffset, 1 / imageSelectionScale))
			: origin;
		}

		let newCropRect = rectScale(rectClone($imageCropRect), scalar, origin);

		// determin if is new crop rect exceeds min or max size, if so, limit
		if (!sizeContains($imageCropRangeAspectRatio[1], newCropRect)) {
			// exceeds max size, limit to max size and position at new crop rect center
			newCropRect = rectCreateWithCenter(rectCenter(newCropRect), $imageCropRangeAspectRatio[1]);
		}

		if (!sizeContains(newCropRect, $imageCropRangeAspectRatio[0])) {
			// exceeds min size, limit to min size and position at new crop rect center
			newCropRect = rectCreateWithCenter(rectCenter(newCropRect), $imageCropRangeAspectRatio[0]);
		}

		// no change, exit
		if (rectEqual(currentCropRect, newCropRect, fixPrecision)) {
			set_store_value(isInteracting, $isInteracting = false, $isInteracting);
			return;
		}

		// attempt to update the rectangle, we use fixPrecision so the width and height are nice integers when at max zoom (this makes sure the `isMinSize` variable is set to true at this point)
		set_store_value(imageCropRect, $imageCropRect = rectApply(newCropRect, v => fixPrecision(v, 5)), $imageCropRect);

		// done!
		set_store_value(isInteracting, $isInteracting = false, $isInteracting);

		// write history timer
		clearTimeout(zoomHistoryTimeoutId);

		zoomHistoryTimeoutId = setTimeout(
			() => {
				history.write();
			},
			500
		);
	};

	//
	// recenter
	//
	// the 'measure' event triggers the editor to center and scale up the crop
	const dispatch = createEventDispatcher();

	const handleRecenterAction = () => {
		dispatch("measure", rectClone($utilRect));
	};

	// auto recenter after timeout
	let cropAutoCenterImageSelectionTimeoutId;

	// animations
	const recenterOpacity = spring$2(0, { precision: 0.0001 });

	component_subscribe($$self, recenterOpacity, value => $$invalidate(27, $recenterOpacity = value));
	const recenterOffset = spring$2();
	component_subscribe($$self, recenterOffset, value => $$invalidate(28, $recenterOffset = value));

	//
	// crop selection presets
	//
	const selectedPresetIndex = derived([imageCropAspectRatio, imageOutputSize], ([$cropAspectRatio, $imageOutputSize], set) => {
		if (!cropSelectPresetOptions) return;
		const options = flattenOptions(cropSelectPresetOptions);

		const matchedOptionValue = [...options].// to value
		map(option => option[0]).// sort sizes first
		sort((a, b) => {
			if (isArray(a[0]) && !isArray(b[0])) return 1;
			return -1;
		}).// match value
		find(value => {
			if (isArray(value) && $imageOutputSize) {
				// size + aspect ratio
				const [width, height] = value;

				const outputSizeMatches = $imageOutputSize.width === width && $imageOutputSize.height === height;
				const aspectRatioMatches = $cropAspectRatio === getAspectRatio(width, height);
				return outputSizeMatches && aspectRatioMatches;
			}

			// aspect ratio
			return value === $cropAspectRatio;
		});

		const index = options.// to value
		map(option => option[0]).// find index of matching value
		findIndex(value => isArray(value)
		? arrayEqual(value, matchedOptionValue)
		: value === matchedOptionValue);

		set(index);
	});

	component_subscribe($$self, selectedPresetIndex, value => $$invalidate(114, $selectedPresetIndex = value));

	const getAspectRatioBySelectedIndex = selectedIndex => {
		if (!cropSelectPresetOptions || selectedIndex === -1) return;
		const selectedValue = flattenOptions(cropSelectPresetOptions)[selectedIndex][0];

		return !selectedValue
		? undefined
		: isArray(selectedValue)
			? getAspectRatio(selectedValue[0], selectedValue[1])
			: selectedValue;
	};

	//
	// crop guides
	//
	const imageSelectionGuides = derived([rootLineColor, imageSelectionRectPresentation, isInteractingFraction], ([$rootLineColor, $rect, $isInteractingFraction], set) => {
		const { rows, cols, opacity } = cropWillRenderImageSelectionGuides(interaction, $isInteractingFraction);
		if (!$rect || opacity <= 0) return set([]);
		const { x, y, width, height } = $rect;
		const w = width / cols;
		const h = height / rows;
		const shapes = [];

		// rows
		for (let r = 1; r <= rows - 1; r++) {
			const yo = y + h * r;

			shapes.push({
				id: `image-selection-guide-row-${r}`,
				points: [vectorCreate(x, yo), vectorCreate(x + width, yo)],
				opacity,
				strokeWidth: 1,
				strokeColor: $rootLineColor
			});
		}

		// cols
		for (let c = 1; c <= cols - 1; c++) {
			const xo = x + w * c;

			shapes.push({
				id: `image-selection-guide-col-${c}`,
				points: [vectorCreate(xo, y), vectorCreate(xo, y + height)],
				opacity,
				strokeWidth: 1,
				strokeColor: $rootLineColor
			});
		}

		set(shapes);
	});

	component_subscribe($$self, imageSelectionGuides, value => $$invalidate(137, $imageSelectionGuides = value));

	const syncGuides = () => {
		// remove existing guides
		const overlayMarkup = $imageOverlayMarkup.filter(markup => !(/^image\-selection\-guide/).test(markup.id));

		if ($isActive) {
			set_store_value(imageOverlayMarkup, $imageOverlayMarkup = [...overlayMarkup, ...$imageSelectionGuides], $imageOverlayMarkup);
		} else {
			set_store_value(imageOverlayMarkup, $imageOverlayMarkup = overlayMarkup, $imageOverlayMarkup);
		}
	};

	const cropUniqueId = `crop-${getUniqueId()}`;
	let transformInitial = cropEnableRotationInput ? "rotation" : "zoom";
	let transformToolInitial = cropUniqueId + "-" + transformInitial;
	let transformSelected = transformToolInitial;
	let root = undefined;

	// fixes rendering issue with stage being empty in overlay mode, this basically redispatches the measure event so the stage is correctly measured
	let stageRef;

	const footerOffset = spring$2($animation ? 20 : 0);
	component_subscribe($$self, footerOffset, value => $$invalidate(142, $footerOffset = value));

	function measure_handler_1(event) {
		bubble($$self, event);
	}

	const select_handler = ({ detail }) => $$invalidate(5, transformSelected = detail);

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			stageRef = $$value;
			$$invalidate(6, stageRef);
		});
	}

	const interactable_function = e => getEventPositionInViewport(e);

	function util_root_binding(value) {
		root = value;
		$$invalidate(13, root);
	}

	function measure_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("isActive" in $$props) $$subscribe_isActive($$invalidate(1, isActive = $$props.isActive));
		if ("stores" in $$props) $$invalidate(88, stores = $$props.stores);
		if ("cropImageSelectionCornerStyle" in $$props) $$invalidate(2, cropImageSelectionCornerStyle = $$props.cropImageSelectionCornerStyle);
		if ("cropWillRenderImageSelectionGuides" in $$props) $$invalidate(89, cropWillRenderImageSelectionGuides = $$props.cropWillRenderImageSelectionGuides);
		if ("cropAutoCenterImageSelectionTimeout" in $$props) $$invalidate(90, cropAutoCenterImageSelectionTimeout = $$props.cropAutoCenterImageSelectionTimeout);
		if ("cropEnableZoomMatchImageAspectRatio" in $$props) $$invalidate(91, cropEnableZoomMatchImageAspectRatio = $$props.cropEnableZoomMatchImageAspectRatio);
		if ("cropEnableRotateMatchImageAspectRatio" in $$props) $$invalidate(92, cropEnableRotateMatchImageAspectRatio = $$props.cropEnableRotateMatchImageAspectRatio);
		if ("cropEnableRotationInput" in $$props) $$invalidate(93, cropEnableRotationInput = $$props.cropEnableRotationInput);
		if ("cropEnableZoom" in $$props) $$invalidate(3, cropEnableZoom = $$props.cropEnableZoom);
		if ("cropEnableZoomInput" in $$props) $$invalidate(94, cropEnableZoomInput = $$props.cropEnableZoomInput);
		if ("cropEnableZoomAutoHide" in $$props) $$invalidate(95, cropEnableZoomAutoHide = $$props.cropEnableZoomAutoHide);
		if ("cropEnableImageSelection" in $$props) $$invalidate(96, cropEnableImageSelection = $$props.cropEnableImageSelection);
		if ("cropEnableInfoIndicator" in $$props) $$invalidate(97, cropEnableInfoIndicator = $$props.cropEnableInfoIndicator);
		if ("cropEnableZoomTowardsWheelPosition" in $$props) $$invalidate(98, cropEnableZoomTowardsWheelPosition = $$props.cropEnableZoomTowardsWheelPosition);
		if ("cropEnableLimitWheelInputToCropSelection" in $$props) $$invalidate(99, cropEnableLimitWheelInputToCropSelection = $$props.cropEnableLimitWheelInputToCropSelection);
		if ("cropEnableCenterImageSelection" in $$props) $$invalidate(100, cropEnableCenterImageSelection = $$props.cropEnableCenterImageSelection);
		if ("cropEnableButtonRotateLeft" in $$props) $$invalidate(101, cropEnableButtonRotateLeft = $$props.cropEnableButtonRotateLeft);
		if ("cropEnableButtonRotateRight" in $$props) $$invalidate(102, cropEnableButtonRotateRight = $$props.cropEnableButtonRotateRight);
		if ("cropEnableButtonFlipHorizontal" in $$props) $$invalidate(103, cropEnableButtonFlipHorizontal = $$props.cropEnableButtonFlipHorizontal);
		if ("cropEnableButtonFlipVertical" in $$props) $$invalidate(104, cropEnableButtonFlipVertical = $$props.cropEnableButtonFlipVertical);
		if ("cropSelectPresetOptions" in $$props) $$invalidate(105, cropSelectPresetOptions = $$props.cropSelectPresetOptions);
		if ("cropEnableSelectPreset" in $$props) $$invalidate(106, cropEnableSelectPreset = $$props.cropEnableSelectPreset);
		if ("cropEnableButtonToggleCropLimit" in $$props) $$invalidate(107, cropEnableButtonToggleCropLimit = $$props.cropEnableButtonToggleCropLimit);
		if ("cropWillRenderTools" in $$props) $$invalidate(108, cropWillRenderTools = $$props.cropWillRenderTools);
		if ("locale" in $$props) $$invalidate(4, locale = $$props.locale);
		if ("tools" in $$props) $$invalidate(0, tools = $$props.tools);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[3] & /*$env*/ 33554432) {
			$$invalidate(132, isOverlayMode = $env.layoutMode === "overlay");
		}

		if ($$self.$$.dirty[3] & /*cropEnableSelectPreset*/ 8192 | $$self.$$.dirty[4] & /*isOverlayMode*/ 256) {
			$$invalidate(113, shouldRenderPresetSelect = cropEnableSelectPreset && !isOverlayMode);
		}

		if ($$self.$$.dirty[3] & /*$utilRect, $imageSelectionRect*/ 1342177280) {
			// determine if we can center the crop, if we can, show the crop center button
			$$invalidate(128, imageSelectionCenteredRect = $utilRect && $imageSelectionRect && rectCenterRect($utilRect, $imageSelectionRect));
		}

		if ($$self.$$.dirty[3] & /*$imageSelectionRect*/ 268435456 | $$self.$$.dirty[4] & /*imageSelectionCenteredRect*/ 16) {
			$$invalidate(129, isImageSelectionDisplayed = !!($imageSelectionRect && imageSelectionCenteredRect));
		}

		if ($$self.$$.dirty[3] & /*$imageSelectionRect*/ 268435456 | $$self.$$.dirty[4] & /*isImageSelectionDisplayed, imageSelectionCenteredRect*/ 48) {
			$$invalidate(115, isImageSelectionCentered = isImageSelectionDisplayed && rectEqual($imageSelectionRect, imageSelectionCenteredRect, value => fixPrecision(value, 5)));
		}

		if ($$self.$$.dirty[0] & /*locale, $imageRotation*/ 272 | $$self.$$.dirty[3] & /*cropWillRenderTools, cropEnableButtonRotateLeft, cropEnableButtonRotateRight, cropEnableButtonFlipHorizontal, $imageFlipY, $imageFlipX, cropEnableButtonFlipVertical, shouldRenderPresetSelect, cropSelectPresetOptions, $selectedPresetIndex, isImageSelectionCentered, $imageSize, $imageCropMinSize, cropEnableButtonToggleCropLimit, $imageCropLimitToImage, $env*/ 67034880) {
			$$invalidate(0, tools = cropWillRenderTools(
				[
					cropEnableButtonRotateLeft && [
						"Button",
						"rotate-left",
						{
							label: locale.cropLabelButtonRotateLeft,
							labelClass: "PinturaToolbarContentWide",
							icon: locale.cropIconButtonRotateLeft,
							onclick: () => {
								applyRotation(-Math.PI / 2);
								history.write();
							}
						}
					],
					cropEnableButtonRotateRight && [
						"Button",
						"rotate-right",
						{
							label: locale.cropLabelButtonRotateRight,
							labelClass: "PinturaToolbarContentWide",
							icon: locale.cropIconButtonRotateRight,
							onclick: () => {
								applyRotation(Math.PI / 2);
								history.write();
							}
						}
					],
					cropEnableButtonFlipHorizontal && [
						"Button",
						"flip-horizontal",
						{
							label: locale.cropLabelButtonFlipHorizontal,
							labelClass: "PinturaToolbarContentWide",
							icon: locale.cropIconButtonFlipHorizontal,
							onclick: () => {
								if (isRotatedSideways($imageRotation)) {
									set_store_value(imageFlipY, $imageFlipY = !$imageFlipY, $imageFlipY);
								} else {
									set_store_value(imageFlipX, $imageFlipX = !$imageFlipX, $imageFlipX);
								}

								history.write();
							}
						}
					],
					cropEnableButtonFlipVertical && [
						"Button",
						"flip-vertical",
						{
							label: locale.cropLabelButtonFlipVertical,
							labelClass: "PinturaToolbarContentWide",
							icon: locale.cropIconButtonFlipVertical,
							onclick: () => {
								if (isRotatedSideways($imageRotation)) {
									set_store_value(imageFlipX, $imageFlipX = !$imageFlipX, $imageFlipX);
								} else {
									set_store_value(imageFlipY, $imageFlipY = !$imageFlipY, $imageFlipY);
								}

								history.write();
							}
						}
					],
					shouldRenderPresetSelect && cropSelectPresetOptions && [
						"Dropdown",
						"select-preset",
						{
							icon: localize(locale.cropIconSelectPreset, locale, getAspectRatioBySelectedIndex($selectedPresetIndex)),
							label: locale.cropLabelSelectPreset,
							labelClass: "PinturaToolbarContentWide",
							options: cropSelectPresetOptions,
							selectedIndex: $selectedPresetIndex,
							onchange: ({ value }) => {
								if (isArray(value)) {
									set_store_value(imageCropAspectRatio, $imageCropAspectRatio = getAspectRatio(value[0], value[1]), $imageCropAspectRatio);
									set_store_value(imageOutputSize, $imageOutputSize = sizeCreateFromArray(value), $imageOutputSize);
								} else {
									set_store_value(imageCropAspectRatio, $imageCropAspectRatio = value, $imageCropAspectRatio);
								}

								if (isImageSelectionCentered) {
									handleRecenterAction();
								}

								history.write();
							},
							optionMapper: option => {
								// if no aspect ratio found we enable the option by default
								let disabled = false;

								// get aspect ratio for this option
								const optionAspectRatio = isArray(option.value)
								? option.value[0] / option.value[1]
								: option.value;

								// can be undefined in which case we don't need to check anything
								if (optionAspectRatio) {
									const maxCropSize = getMaxSizeInRect($imageSize, $imageRotation, optionAspectRatio);
									disabled = maxCropSize.width < $imageCropMinSize.width || maxCropSize.height < $imageCropMinSize.height;
								}

								// add icon for this option
								option.icon = getSelectionPresetOptionIcon(option.value, { bounds: 14 });

								return { ...option, disabled };
							}
						}
					],
					cropEnableButtonToggleCropLimit && [
						"Dropdown",
						"select-crop-limit",
						{
							icon: localize(locale.cropIconCropBoundary, locale, $imageCropLimitToImage),
							label: locale.cropLabelCropBoundary,
							labelClass: "PinturaToolbarContentWide",
							onchange: ({ value }) => {
								set_store_value(imageCropLimitToImage, $imageCropLimitToImage = value, $imageCropLimitToImage);
								history.write();
							},
							options: [
								[
									true,
									locale.cropLabelCropBoundaryEdge,
									{
										icon: localize(locale.cropIconCropBoundary, locale, true)
									}
								],
								[
									false,
									locale.cropLabelCropBoundaryNone,
									{
										icon: localize(locale.cropIconCropBoundary, locale, false)
									}
								]
							]
						}
					]
				].filter(Boolean),
				$env,
				() => ({})
			).filter(Boolean));
		}

		if ($$self.$$.dirty[0] & /*$isActive*/ 512) {
			$isActive && imageOutlineOpacity.set(1);
		}

		if ($$self.$$.dirty[3] & /*$imageCropLimitToImage*/ 16777216) {
			$$invalidate(14, imageZoomLevelMin = $imageCropLimitToImage ? 0 : -1);
		}

		if ($$self.$$.dirty[3] & /*$utilRect*/ 1073741824 | $$self.$$.dirty[4] & /*$stageRect*/ 1) {
			$$invalidate(125, imageSelectionOffset = $utilRect && vectorCreate(-($stageRect.x - $utilRect.x), -($stageRect.y - $utilRect.y)));
		}

		if ($$self.$$.dirty[4] & /*$imageSelectionRectPresentation, imageSelectionOffset*/ 10) {
			// normalized crop bounds, we use these to limit the crop interactions to the view
			$$invalidate(126, imageSelectionCenter = $imageSelectionRectPresentation && vectorCreate(snapToPixel($imageSelectionRectPresentation.x + $imageSelectionRectPresentation.width * 0.5 + imageSelectionOffset.x), snapToPixel($imageSelectionRectPresentation.y + $imageSelectionRectPresentation.height * 0.5 + imageSelectionOffset.y)));
		}

		if ($$self.$$.dirty[3] & /*$imageSelectionRectSnapshot*/ 134217728) {
			$$invalidate(130, isResizingSelection = $imageSelectionRectSnapshot != null);
		}

		if ($$self.$$.dirty[3] & /*$utilRect*/ 1073741824 | $$self.$$.dirty[4] & /*imageSelectionCenteredRect*/ 16) {
			$$invalidate(131, isMaxSelectionRect = $utilRect && imageSelectionCenteredRect && (imageSelectionCenteredRect.height === $utilRect.height || imageSelectionCenteredRect.width === $utilRect.width));
		}

		if ($$self.$$.dirty[3] & /*$presentationScalar*/ 536870912 | $$self.$$.dirty[4] & /*isMaxSelectionRect, $imageScalar*/ 1152) {
			$$invalidate(133, canZoomToCenter = !isMaxSelectionRect && ($presentationScalar < 1 && $imageScalar < 1));
		}

		if ($$self.$$.dirty[3] & /*isImageSelectionCentered*/ 4194304 | $$self.$$.dirty[4] & /*isImageSelectionDisplayed, isResizingSelection, canZoomToCenter*/ 608) {
			$$invalidate(10, canCenter = isImageSelectionDisplayed && !isResizingSelection && (!isImageSelectionCentered || canZoomToCenter));
		}

		if ($$self.$$.dirty[0] & /*$imageCropRect*/ 128 | $$self.$$.dirty[3] & /*cropEnableInfoIndicator*/ 16 | $$self.$$.dirty[4] & /*isOverlayMode*/ 256) {
			$$invalidate(16, shouldRenderInfoIndicator = cropEnableInfoIndicator && !!$imageCropRect && !isOverlayMode);
		}

		if ($$self.$$.dirty[4] & /*$imageSelectionRectPresentation, imageSelectionOffset*/ 10) {
			$$invalidate(11, imageSelectionRectOffset = $imageSelectionRectPresentation && imageSelectionOffset && {
				x: $imageSelectionRectPresentation.x + imageSelectionOffset.x,
				y: $imageSelectionRectPresentation.y + imageSelectionOffset.y,
				width: $imageSelectionRectPresentation.width,
				height: $imageSelectionRectPresentation.height
			});
		}

		if ($$self.$$.dirty[0] & /*imageSelectionRectOffset*/ 2048 | $$self.$$.dirty[3] & /*cropEnableImageSelection*/ 8 | $$self.$$.dirty[4] & /*isOverlayMode*/ 256) {
			$$invalidate(17, shouldRenderImageSelection = cropEnableImageSelection && !!imageSelectionRectOffset && !isOverlayMode);
		}

		if ($$self.$$.dirty[2] & /*cropAutoCenterImageSelectionTimeout*/ 268435456 | $$self.$$.dirty[3] & /*cropEnableCenterImageSelection*/ 128 | $$self.$$.dirty[4] & /*imageSelectionCenter*/ 4) {
			$$invalidate(18, shouldRenderImageSelectionRecenterButton = cropEnableCenterImageSelection && !!imageSelectionCenter && !cropAutoCenterImageSelectionTimeout);
		}

		if ($$self.$$.dirty[0] & /*canCenter*/ 1024 | $$self.$$.dirty[2] & /*cropAutoCenterImageSelectionTimeout*/ 268435456 | $$self.$$.dirty[3] & /*$isInteracting, cropAutoCenterImageSelectionTimeoutId*/ 67174400) {
			if (canCenter && cropAutoCenterImageSelectionTimeout && !$isInteracting) {
				clearTimeout(cropAutoCenterImageSelectionTimeoutId);
				$$invalidate(109, cropAutoCenterImageSelectionTimeoutId = setTimeout(handleRecenterAction, cropAutoCenterImageSelectionTimeout));
			}
		}

		if ($$self.$$.dirty[3] & /*$isInteracting, cropAutoCenterImageSelectionTimeoutId*/ 67174400) {
			if ($isInteracting) clearTimeout(cropAutoCenterImageSelectionTimeoutId);
		}

		if ($$self.$$.dirty[0] & /*canCenter*/ 1024) {
			recenterOpacity.set(canCenter ? 1 : 0);
		}

		if ($$self.$$.dirty[4] & /*imageSelectionCenter*/ 4) {
			recenterOffset.set(imageSelectionCenter);
		}

		if ($$self.$$.dirty[0] & /*$isActive*/ 512 | $$self.$$.dirty[4] & /*$framePadded, $imagePreviewModifiers*/ 6144) {
			//
			// enable seeing the image outside of the crop area, and disable the vignette effect
			// 
			if ($isActive && !$framePadded) {
				set_store_value(
					imagePreviewModifiers,
					$imagePreviewModifiers["crop"] = {
						maskOpacity: 0.85,
						maskMarkupOpacity: 0.85
					},
					$imagePreviewModifiers
				);
			} else {
				delete $imagePreviewModifiers["crop"];
			}
		}

		if ($$self.$$.dirty[4] & /*$imageSelectionGuides*/ 8192) {
			// if overlay top changes
			$imageSelectionGuides && syncGuides();
		}

		if ($$self.$$.dirty[3] & /*$env*/ 33554432) {
			//
			// Transform tabs
			//
			$$invalidate(138, hasPlentyVerticalSpace = $env.verticalSpace !== "short");
		}

		if ($$self.$$.dirty[4] & /*hasPlentyVerticalSpace*/ 16384) {
			$$invalidate(19, shouldRenderToolbar = hasPlentyVerticalSpace);
		}

		if ($$self.$$.dirty[0] & /*cropEnableZoom*/ 8 | $$self.$$.dirty[3] & /*cropEnableZoomInput*/ 2) {
			$$invalidate(139, couldRenderZoomInput = cropEnableZoom && cropEnableZoomInput);
		}

		if ($$self.$$.dirty[3] & /*cropEnableZoomAutoHide*/ 4 | $$self.$$.dirty[4] & /*hasPlentyVerticalSpace, couldRenderZoomInput*/ 49152) {
			$$invalidate(140, shouldRenderZoomInput = cropEnableZoomAutoHide
			? hasPlentyVerticalSpace && couldRenderZoomInput
			: couldRenderZoomInput);
		}

		if ($$self.$$.dirty[3] & /*cropEnableRotationInput*/ 1 | $$self.$$.dirty[4] & /*shouldRenderZoomInput*/ 65536) {
			$$invalidate(20, shouldRenderFooter = cropEnableRotationInput || shouldRenderZoomInput);
		}

		if ($$self.$$.dirty[4] & /*shouldRenderZoomInput*/ 65536) {
			if (!shouldRenderZoomInput) {
				$$invalidate(5, transformSelected = transformToolInitial);
			}
		}

		if ($$self.$$.dirty[0] & /*transformSelected*/ 32) {
			$$invalidate(21, tabsConfig = {
				name: cropUniqueId,
				selected: transformSelected
			});
		}

		if ($$self.$$.dirty[0] & /*locale*/ 16 | $$self.$$.dirty[3] & /*cropEnableRotationInput*/ 1 | $$self.$$.dirty[4] & /*shouldRenderZoomInput*/ 65536) {
			$$invalidate(12, tabs = [
				cropEnableRotationInput && {
					id: cropUniqueId + "-rotation",
					label: locale.cropLabelTabRotation
				},
				shouldRenderZoomInput && {
					id: cropUniqueId + "-zoom",
					label: locale.cropLabelTabZoom
				}
			].filter(Boolean));
		}

		if ($$self.$$.dirty[0] & /*tabs*/ 4096) {
			$$invalidate(22, panels = tabs.map(tab => tab.id));
		}

		if ($$self.$$.dirty[0] & /*stageRef*/ 64 | $$self.$$.dirty[4] & /*isOverlayMode*/ 256) {
			if (stageRef && !stageRef.children.length && isOverlayMode) {
				stageRef.dispatchEvent(new CustomEvent("measure", { detail: stageRef.rect }));
			}
		}

		if ($$self.$$.dirty[0] & /*$isActive*/ 512 | $$self.$$.dirty[4] & /*$animation*/ 131072) {
			$animation && footerOffset.set($isActive ? 0 : 20);
		}

		if ($$self.$$.dirty[4] & /*$footerOffset*/ 262144) {
			$$invalidate(23, footerStyle = $footerOffset
			? `transform: translateY(${$footerOffset}px)`
			: undefined);
		}
	};

	return [
		tools,
		isActive,
		cropImageSelectionCornerStyle,
		cropEnableZoom,
		locale,
		transformSelected,
		stageRef,
		$imageCropRect,
		$imageRotation,
		$isActive,
		canCenter,
		imageSelectionRectOffset,
		tabs,
		root,
		imageZoomLevelMin,
		$rootRect,
		shouldRenderInfoIndicator,
		shouldRenderImageSelection,
		shouldRenderImageSelectionRecenterButton,
		shouldRenderToolbar,
		shouldRenderFooter,
		tabsConfig,
		panels,
		footerStyle,
		$imageRotationRange,
		$imageZoomLevelRange,
		$imageZoomLevel,
		$recenterOpacity,
		$recenterOffset,
		env,
		isInteracting,
		rootRect,
		stageRect,
		utilRect,
		animation,
		elasticityMultiplier,
		rangeInputElasticity,
		presentationScalar,
		imagePreviewModifiers,
		imageFlipX,
		imageFlipY,
		imageRotation,
		imageRotationRange,
		imageOutputSize,
		imageSelectionRect,
		imageSelectionRectSnapshot,
		imageSelectionRectIntent,
		imageSelectionRectPresentation,
		imageCropRectIntent,
		imageCropRectOrigin,
		imageCropRect,
		imageCropMinSize,
		imageCropMaxSize,
		imageCropRange,
		imageCropAspectRatio,
		imageCropLimitToImage,
		imageSize,
		imageScalar,
		imageOverlayMarkup,
		framePadded,
		handleSelectionGrab,
		handleSelectionDrag,
		handleSelectionRelease,
		handleRotateStart,
		handleRotateMove,
		handleRotateEnd,
		handleImageDragStart,
		handleImageDrag,
		handleImageDragEnd,
		handleImageDragRelease,
		imageCropRangeAspectRatio,
		imageZoomLevelRange,
		imageZoomLevel,
		handleResizeStart,
		handleResizeMove,
		handleResizeEnd,
		handleGestureStart,
		handleGestureUpdate,
		handleGestureEnd,
		handleWheel,
		handleRecenterAction,
		recenterOpacity,
		recenterOffset,
		selectedPresetIndex,
		imageSelectionGuides,
		cropUniqueId,
		footerOffset,
		name,
		stores,
		cropWillRenderImageSelectionGuides,
		cropAutoCenterImageSelectionTimeout,
		cropEnableZoomMatchImageAspectRatio,
		cropEnableRotateMatchImageAspectRatio,
		cropEnableRotationInput,
		cropEnableZoomInput,
		cropEnableZoomAutoHide,
		cropEnableImageSelection,
		cropEnableInfoIndicator,
		cropEnableZoomTowardsWheelPosition,
		cropEnableLimitWheelInputToCropSelection,
		cropEnableCenterImageSelection,
		cropEnableButtonRotateLeft,
		cropEnableButtonRotateRight,
		cropEnableButtonFlipHorizontal,
		cropEnableButtonFlipVertical,
		cropSelectPresetOptions,
		cropEnableSelectPreset,
		cropEnableButtonToggleCropLimit,
		cropWillRenderTools,
		cropAutoCenterImageSelectionTimeoutId,
		$imageSize,
		$imageFlipY,
		$imageFlipX,
		shouldRenderPresetSelect,
		$selectedPresetIndex,
		isImageSelectionCentered,
		$imageCropMinSize,
		$imageCropLimitToImage,
		$env,
		$isInteracting,
		$imageSelectionRectSnapshot,
		$imageSelectionRect,
		$presentationScalar,
		$utilRect,
		$stageRect,
		imageSelectionOffset,
		imageSelectionCenter,
		$imageSelectionRectPresentation,
		imageSelectionCenteredRect,
		isImageSelectionDisplayed,
		isResizingSelection,
		isMaxSelectionRect,
		isOverlayMode,
		canZoomToCenter,
		$imageScalar,
		$framePadded,
		$imagePreviewModifiers,
		$imageSelectionGuides,
		hasPlentyVerticalSpace,
		couldRenderZoomInput,
		shouldRenderZoomInput,
		$animation,
		$footerOffset,
		measure_handler_1,
		select_handler,
		div0_binding,
		interactable_function,
		util_root_binding,
		measure_handler
	];
}

class Crop extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$j,
			create_fragment$j,
			safe_not_equal,
			{
				name: 87,
				isActive: 1,
				stores: 88,
				cropImageSelectionCornerStyle: 2,
				cropWillRenderImageSelectionGuides: 89,
				cropAutoCenterImageSelectionTimeout: 90,
				cropEnableZoomMatchImageAspectRatio: 91,
				cropEnableRotateMatchImageAspectRatio: 92,
				cropEnableRotationInput: 93,
				cropEnableZoom: 3,
				cropEnableZoomInput: 94,
				cropEnableZoomAutoHide: 95,
				cropEnableImageSelection: 96,
				cropEnableInfoIndicator: 97,
				cropEnableZoomTowardsWheelPosition: 98,
				cropEnableLimitWheelInputToCropSelection: 99,
				cropEnableCenterImageSelection: 100,
				cropEnableButtonRotateLeft: 101,
				cropEnableButtonRotateRight: 102,
				cropEnableButtonFlipHorizontal: 103,
				cropEnableButtonFlipVertical: 104,
				cropSelectPresetOptions: 105,
				cropEnableSelectPreset: 106,
				cropEnableButtonToggleCropLimit: 107,
				cropWillRenderTools: 108,
				locale: 4,
				tools: 0
			},
			[-1, -1, -1, -1, -1, -1, -1]
		);
	}

	get name() {
		return this.$$.ctx[87];
	}

	get isActive() {
		return this.$$.ctx[1];
	}

	set isActive(isActive) {
		this.$set({ isActive });
		flush();
	}

	get stores() {
		return this.$$.ctx[88];
	}

	set stores(stores) {
		this.$set({ stores });
		flush();
	}

	get cropImageSelectionCornerStyle() {
		return this.$$.ctx[2];
	}

	set cropImageSelectionCornerStyle(cropImageSelectionCornerStyle) {
		this.$set({ cropImageSelectionCornerStyle });
		flush();
	}

	get cropWillRenderImageSelectionGuides() {
		return this.$$.ctx[89];
	}

	set cropWillRenderImageSelectionGuides(cropWillRenderImageSelectionGuides) {
		this.$set({ cropWillRenderImageSelectionGuides });
		flush();
	}

	get cropAutoCenterImageSelectionTimeout() {
		return this.$$.ctx[90];
	}

	set cropAutoCenterImageSelectionTimeout(cropAutoCenterImageSelectionTimeout) {
		this.$set({ cropAutoCenterImageSelectionTimeout });
		flush();
	}

	get cropEnableZoomMatchImageAspectRatio() {
		return this.$$.ctx[91];
	}

	set cropEnableZoomMatchImageAspectRatio(cropEnableZoomMatchImageAspectRatio) {
		this.$set({ cropEnableZoomMatchImageAspectRatio });
		flush();
	}

	get cropEnableRotateMatchImageAspectRatio() {
		return this.$$.ctx[92];
	}

	set cropEnableRotateMatchImageAspectRatio(cropEnableRotateMatchImageAspectRatio) {
		this.$set({ cropEnableRotateMatchImageAspectRatio });
		flush();
	}

	get cropEnableRotationInput() {
		return this.$$.ctx[93];
	}

	set cropEnableRotationInput(cropEnableRotationInput) {
		this.$set({ cropEnableRotationInput });
		flush();
	}

	get cropEnableZoom() {
		return this.$$.ctx[3];
	}

	set cropEnableZoom(cropEnableZoom) {
		this.$set({ cropEnableZoom });
		flush();
	}

	get cropEnableZoomInput() {
		return this.$$.ctx[94];
	}

	set cropEnableZoomInput(cropEnableZoomInput) {
		this.$set({ cropEnableZoomInput });
		flush();
	}

	get cropEnableZoomAutoHide() {
		return this.$$.ctx[95];
	}

	set cropEnableZoomAutoHide(cropEnableZoomAutoHide) {
		this.$set({ cropEnableZoomAutoHide });
		flush();
	}

	get cropEnableImageSelection() {
		return this.$$.ctx[96];
	}

	set cropEnableImageSelection(cropEnableImageSelection) {
		this.$set({ cropEnableImageSelection });
		flush();
	}

	get cropEnableInfoIndicator() {
		return this.$$.ctx[97];
	}

	set cropEnableInfoIndicator(cropEnableInfoIndicator) {
		this.$set({ cropEnableInfoIndicator });
		flush();
	}

	get cropEnableZoomTowardsWheelPosition() {
		return this.$$.ctx[98];
	}

	set cropEnableZoomTowardsWheelPosition(cropEnableZoomTowardsWheelPosition) {
		this.$set({ cropEnableZoomTowardsWheelPosition });
		flush();
	}

	get cropEnableLimitWheelInputToCropSelection() {
		return this.$$.ctx[99];
	}

	set cropEnableLimitWheelInputToCropSelection(cropEnableLimitWheelInputToCropSelection) {
		this.$set({ cropEnableLimitWheelInputToCropSelection });
		flush();
	}

	get cropEnableCenterImageSelection() {
		return this.$$.ctx[100];
	}

	set cropEnableCenterImageSelection(cropEnableCenterImageSelection) {
		this.$set({ cropEnableCenterImageSelection });
		flush();
	}

	get cropEnableButtonRotateLeft() {
		return this.$$.ctx[101];
	}

	set cropEnableButtonRotateLeft(cropEnableButtonRotateLeft) {
		this.$set({ cropEnableButtonRotateLeft });
		flush();
	}

	get cropEnableButtonRotateRight() {
		return this.$$.ctx[102];
	}

	set cropEnableButtonRotateRight(cropEnableButtonRotateRight) {
		this.$set({ cropEnableButtonRotateRight });
		flush();
	}

	get cropEnableButtonFlipHorizontal() {
		return this.$$.ctx[103];
	}

	set cropEnableButtonFlipHorizontal(cropEnableButtonFlipHorizontal) {
		this.$set({ cropEnableButtonFlipHorizontal });
		flush();
	}

	get cropEnableButtonFlipVertical() {
		return this.$$.ctx[104];
	}

	set cropEnableButtonFlipVertical(cropEnableButtonFlipVertical) {
		this.$set({ cropEnableButtonFlipVertical });
		flush();
	}

	get cropSelectPresetOptions() {
		return this.$$.ctx[105];
	}

	set cropSelectPresetOptions(cropSelectPresetOptions) {
		this.$set({ cropSelectPresetOptions });
		flush();
	}

	get cropEnableSelectPreset() {
		return this.$$.ctx[106];
	}

	set cropEnableSelectPreset(cropEnableSelectPreset) {
		this.$set({ cropEnableSelectPreset });
		flush();
	}

	get cropEnableButtonToggleCropLimit() {
		return this.$$.ctx[107];
	}

	set cropEnableButtonToggleCropLimit(cropEnableButtonToggleCropLimit) {
		this.$set({ cropEnableButtonToggleCropLimit });
		flush();
	}

	get cropWillRenderTools() {
		return this.$$.ctx[108];
	}

	set cropWillRenderTools(cropWillRenderTools) {
		this.$set({ cropWillRenderTools });
		flush();
	}

	get locale() {
		return this.$$.ctx[4];
	}

	set locale(locale) {
		this.$set({ locale });
		flush();
	}

	get tools() {
		return this.$$.ctx[0];
	}

	set tools(tools) {
		this.$set({ tools });
		flush();
	}
}

// @ts-ignore
var _plugin_crop = { util: ['crop', Crop] };

/* src/core/ui/plugins/filter/index.svelte generated by Svelte v3.37.0 */

function create_option_slot$2(ctx) {
	let div1;
	let div0;
	let option = /*option*/ ctx[68];
	let t0;
	let span;

	let t1_value = (isFunction$1(/*option*/ ctx[68].label)
	? /*option*/ ctx[68].label(/*locale*/ ctx[2])
	: /*option*/ ctx[68].label) + "";

	let t1;
	let mounted;
	let dispose;

	function measure_handler_1(...args) {
		return /*measure_handler_1*/ ctx[48](/*option*/ ctx[68], ...args);
	}

	const assign_div0 = () => /*div0_binding*/ ctx[49](div0, option);
	const unassign_div0 = () => /*div0_binding*/ ctx[49](null, option);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			t0 = space();
			span = element("span");
			t1 = text$1(t1_value);
			attr(div0, "class", FILTER_PREVIEW_CLASS_NAME);
			attr(div1, "slot", "option");
			attr(div1, "class", "PinturaFilterOption");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			assign_div0();
			append(div1, t0);
			append(div1, span);
			append(span, t1);

			if (!mounted) {
				dispose = [
					listen(div0, "measure", measure_handler_1),
					action_destroyer(measurable.call(null, div0))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (option !== /*option*/ ctx[68]) {
				unassign_div0();
				option = /*option*/ ctx[68];
				assign_div0();
			}

			if (dirty[0] & /*locale*/ 4 | dirty[2] & /*option*/ 64 && t1_value !== (t1_value = (isFunction$1(/*option*/ ctx[68].label)
			? /*option*/ ctx[68].label(/*locale*/ ctx[2])
			: /*option*/ ctx[68].label) + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(div1);
			unassign_div0();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (478:8) <Scrollable              elasticity={elasticityMultiplier * scrollElasticity}              onscroll={offset => tileScrollOffset = offset}              bind:maskFeatherStartOpacity={tileLeftOpacity}             bind:maskFeatherEndOpacity={tileRightOpacity}             bind:maskFeatherSize={tileMargin}             on:measure={e => tileScrollContainerRect = e.detail}>
function create_default_slot$8(ctx) {
	let radiogroup;
	let current;

	radiogroup = new RadioGroup({
			props: {
				locale: /*locale*/ ctx[2],
				layout: "row",
				options: /*filterOptions*/ ctx[3],
				selectedIndex: /*selectedFilterIndex*/ ctx[10],
				onchange: /*handleChangeFilter*/ ctx[29],
				$$slots: {
					option: [
						create_option_slot$2,
						({ option }) => ({ 68: option }),
						({ option }) => [0, 0, option ? 64 : 0]
					]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(radiogroup.$$.fragment);
		},
		m(target, anchor) {
			mount_component(radiogroup, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const radiogroup_changes = {};
			if (dirty[0] & /*locale*/ 4) radiogroup_changes.locale = /*locale*/ ctx[2];
			if (dirty[0] & /*filterOptions*/ 8) radiogroup_changes.options = /*filterOptions*/ ctx[3];
			if (dirty[0] & /*selectedFilterIndex*/ 1024) radiogroup_changes.selectedIndex = /*selectedFilterIndex*/ ctx[10];

			if (dirty[0] & /*locale, tileElements*/ 516 | dirty[2] & /*$$scope, option*/ 192) {
				radiogroup_changes.$$scope = { dirty, ctx };
			}

			radiogroup.$set(radiogroup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(radiogroup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(radiogroup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(radiogroup, detaching);
		}
	};
}

// (477:4) 
function create_footer_slot$4(ctx) {
	let div;
	let scrollable;
	let updating_maskFeatherStartOpacity;
	let updating_maskFeatherEndOpacity;
	let updating_maskFeatherSize;
	let current;
	let mounted;
	let dispose;

	function scrollable_maskFeatherStartOpacity_binding(value) {
		/*scrollable_maskFeatherStartOpacity_binding*/ ctx[51](value);
	}

	function scrollable_maskFeatherEndOpacity_binding(value) {
		/*scrollable_maskFeatherEndOpacity_binding*/ ctx[52](value);
	}

	function scrollable_maskFeatherSize_binding(value) {
		/*scrollable_maskFeatherSize_binding*/ ctx[53](value);
	}

	let scrollable_props = {
		elasticity: /*elasticityMultiplier*/ ctx[15] * /*scrollElasticity*/ ctx[16],
		onscroll: /*func*/ ctx[50],
		$$slots: { default: [create_default_slot$8] },
		$$scope: { ctx }
	};

	if (/*tileLeftOpacity*/ ctx[4] !== void 0) {
		scrollable_props.maskFeatherStartOpacity = /*tileLeftOpacity*/ ctx[4];
	}

	if (/*tileRightOpacity*/ ctx[5] !== void 0) {
		scrollable_props.maskFeatherEndOpacity = /*tileRightOpacity*/ ctx[5];
	}

	if (/*tileMargin*/ ctx[6] !== void 0) {
		scrollable_props.maskFeatherSize = /*tileMargin*/ ctx[6];
	}

	scrollable = new Scrollable({ props: scrollable_props });
	binding_callbacks.push(() => bind$1(scrollable, "maskFeatherStartOpacity", scrollable_maskFeatherStartOpacity_binding));
	binding_callbacks.push(() => bind$1(scrollable, "maskFeatherEndOpacity", scrollable_maskFeatherEndOpacity_binding));
	binding_callbacks.push(() => bind$1(scrollable, "maskFeatherSize", scrollable_maskFeatherSize_binding));
	scrollable.$on("measure", /*measure_handler_2*/ ctx[54]);

	return {
		c() {
			div = element("div");
			create_component(scrollable.$$.fragment);
			attr(div, "slot", "footer");
			attr(div, "style", /*footerStyle*/ ctx[11]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(scrollable, div, null);
			current = true;

			if (!mounted) {
				dispose = listen(div, "transitionend", /*handleTransitionEnd*/ ctx[27]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			const scrollable_changes = {};
			if (dirty[0] & /*tileScrollOffset*/ 128) scrollable_changes.onscroll = /*func*/ ctx[50];

			if (dirty[0] & /*locale, filterOptions, selectedFilterIndex, tileElements*/ 1548 | dirty[2] & /*$$scope*/ 128) {
				scrollable_changes.$$scope = { dirty, ctx };
			}

			if (!updating_maskFeatherStartOpacity && dirty[0] & /*tileLeftOpacity*/ 16) {
				updating_maskFeatherStartOpacity = true;
				scrollable_changes.maskFeatherStartOpacity = /*tileLeftOpacity*/ ctx[4];
				add_flush_callback(() => updating_maskFeatherStartOpacity = false);
			}

			if (!updating_maskFeatherEndOpacity && dirty[0] & /*tileRightOpacity*/ 32) {
				updating_maskFeatherEndOpacity = true;
				scrollable_changes.maskFeatherEndOpacity = /*tileRightOpacity*/ ctx[5];
				add_flush_callback(() => updating_maskFeatherEndOpacity = false);
			}

			if (!updating_maskFeatherSize && dirty[0] & /*tileMargin*/ 64) {
				updating_maskFeatherSize = true;
				scrollable_changes.maskFeatherSize = /*tileMargin*/ ctx[6];
				add_flush_callback(() => updating_maskFeatherSize = false);
			}

			scrollable.$set(scrollable_changes);

			if (!current || dirty[0] & /*footerStyle*/ 2048) {
				attr(div, "style", /*footerStyle*/ ctx[11]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(scrollable.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(scrollable.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(scrollable);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$i(ctx) {
	let util;
	let current;

	util = new Util({
			props: {
				$$slots: { footer: [create_footer_slot$4] },
				$$scope: { ctx }
			}
		});

	util.$on("measure", /*measure_handler*/ ctx[55]);

	return {
		c() {
			create_component(util.$$.fragment);
		},
		m(target, anchor) {
			mount_component(util, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const util_changes = {};

			if (dirty[0] & /*footerStyle, tileScrollOffset, tileLeftOpacity, tileRightOpacity, tileMargin, tileScrollContainerRect, locale, filterOptions, selectedFilterIndex, tileElements*/ 4092 | dirty[2] & /*$$scope*/ 128) {
				util_changes.$$scope = { dirty, ctx };
			}

			util.$set(util_changes);
		},
		i(local) {
			if (current) return;
			transition_in(util.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(util.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(util, detaching);
		}
	};
}

let FILTER_PREVIEW_CLASS_NAME = "PinturaFilterPreview";

function instance$i($$self, $$props, $$invalidate) {
	let filterOptionsFlattened;
	let selectedFilterIndex;
	let footerStyle;
	let $imageColorMatrix;
	let $tileRects;
	let $canvasSize;
	let $imageTransforms;
	let $animation;

	let $isActive,
		$$unsubscribe_isActive = noop$2,
		$$subscribe_isActive = () => ($$unsubscribe_isActive(), $$unsubscribe_isActive = subscribe(isActive, $$value => $$invalidate(40, $isActive = $$value)), isActive);

	let $utilRect;
	let $stageRect;
	let $imageGamma;
	let $imagePreview;
	let $imageSize;
	let $imageBackgroundColor;

	let $isActiveFraction,
		$$unsubscribe_isActiveFraction = noop$2,
		$$subscribe_isActiveFraction = () => ($$unsubscribe_isActiveFraction(), $$unsubscribe_isActiveFraction = subscribe(isActiveFraction, $$value => $$invalidate(45, $isActiveFraction = $$value)), isActiveFraction);

	let $footerOffset;
	let $imageTiles;
	$$self.$$.on_destroy.push(() => $$unsubscribe_isActive());
	$$self.$$.on_destroy.push(() => $$unsubscribe_isActiveFraction());
	const name = "filter";
	let { isActive } = $$props;
	$$subscribe_isActive();
	let { isActiveFraction } = $$props;
	$$subscribe_isActiveFraction();
	let { stores } = $$props;
	let { locale } = $$props;
	let { filterFunctions } = $$props;
	let { filterOptions } = $$props;

	// connect filter choice to stores
	const { history, interfaceImages, stageRect, utilRect, animation, elasticityMultiplier, scrollElasticity, imageSize, imagePreview, imageCropRect, imageRotation, imageFlipX, imageFlipY, imageBackgroundColor, imageGamma, imageColorMatrix } = stores;

	component_subscribe($$self, stageRect, value => $$invalidate(42, $stageRect = value));
	component_subscribe($$self, utilRect, value => $$invalidate(41, $utilRect = value));
	component_subscribe($$self, animation, value => $$invalidate(39, $animation = value));
	component_subscribe($$self, imageSize, value => $$invalidate(57, $imageSize = value));
	component_subscribe($$self, imagePreview, value => $$invalidate(44, $imagePreview = value));
	component_subscribe($$self, imageBackgroundColor, value => $$invalidate(58, $imageBackgroundColor = value));
	component_subscribe($$self, imageGamma, value => $$invalidate(43, $imageGamma = value));
	component_subscribe($$self, imageColorMatrix, value => $$invalidate(36, $imageColorMatrix = value));

	const getFilterIndex = (imageColorMatrix, filterOptionsFlattened) => {
		if (!imageColorMatrix || !imageColorMatrix["filter"] || !filterOptionsFlattened) return 0;
		const filterColorMatrix = imageColorMatrix["filter"];

		return filterOptionsFlattened.// get id and compare matrices
		findIndex(([id]) => {
			if (!filterFunctions[id]) return false;
			const matrix = filterFunctions[id]();
			return arrayEqual(matrix, filterColorMatrix);
		});
	};

	const tileRects = writable({});
	component_subscribe($$self, tileRects, value => $$invalidate(37, $tileRects = value));
	const handleTileResize = (item, rect) => set_store_value(tileRects, $tileRects[item.value] = rect, $tileRects);

	const canvasSize = derived(tileRects, $tileRects => {
		if (!$tileRects[undefined]) return;
		const tileRectFirst = $tileRects[undefined];
		if ($canvasSize && sizeEqual($canvasSize, tileRectFirst)) return $canvasSize;
		return sizeClone(tileRectFirst);
	});

	component_subscribe($$self, canvasSize, value => $$invalidate(56, $canvasSize = value));

	const imageTransforms = derived(
		[
			isActive,
			canvasSize,
			imageCropRect,
			imageSize,
			imageRotation,
			imageFlipX,
			imageFlipY
		],
		([
				$isActive,
				$canvasSize,
				$imageCropRect,
				$imageSize,
				$imageRotation,
				$imageFlipX,
				$imageFlipY
			], set) => {
			if (!$isActive || !$canvasSize || !$imageSize) return $imageTransforms;
			const imageRect = rectCreateFromSize($imageSize);
			const imageCenter = rectCenter(imageRect);

			// get base crop rect so we can correctly apply transforms
			const cropRectBase = getBaseCropRect($imageSize, $imageCropRect, $imageRotation);

			const cropRectBaseCenter = rectCenter(cropRectBase);
			const imageTranslation = vectorSubtract(vectorClone(imageCenter), cropRectBaseCenter);
			const imageOrigin = vectorInvert(vectorClone(imageTranslation));

			// scalar
			const imageScalar = Math.max($canvasSize.width / $imageCropRect.width, $canvasSize.height / $imageCropRect.height);

			// update preview transforms
			set({
				origin: imageOrigin,
				translation: imageTranslation,
				rotation: {
					x: $imageFlipY ? Math.PI : 0,
					y: $imageFlipX ? Math.PI : 0,
					z: $imageRotation
				},
				perspective: vectorCreateEmpty(),
				scale: imageScalar
			});
		}
	);

	component_subscribe($$self, imageTransforms, value => $$invalidate(38, $imageTransforms = value));

	const cloneImageTransforms = imageTransforms => ({
		origin: vectorClone(imageTransforms.origin),
		translation: vectorClone(imageTransforms.translation),
		rotation: { ...imageTransforms.rotation },
		perspective: vectorClone(imageTransforms.perspective),
		scale: imageTransforms.scale
	});

	//
	// Footer
	//
	const footerOffset = spring$2($animation ? 20 : 0);

	component_subscribe($$self, footerOffset, value => $$invalidate(46, $footerOffset = value));
	let tileCornerRadius;
	const tileElements = {};

	const handleTransitionEnd = e => {
		if (e.target.className !== FILTER_PREVIEW_CLASS_NAME) return;

		$$invalidate(33, tileCornerRadius = Object.keys(tileElements).reduce(
			(prev, curr) => {
				const element = tileElements[curr];
				const style = getComputedStyle(element);

				const corners = ["top-left", "top-right", "bottom-left", "bottom-right"].map(corner => style.getPropertyValue(`border-${corner}-radius`)).map(unitToPixels).// this better aligns WebGL rounded corner with css rounded corner
				map(v => v * 1.25);

				prev[curr] = corners;
				return prev;
			},
			{}
		));
	};

	let tileLeftOpacity; // set by Scrollable
	let tileRightOpacity; // set by Scrollable
	let tileMargin; // set by Scrollable
	let tileScrollOffset = { x: 0, y: 0 };
	let tileScrollContainerRect;
	let tileWrapperOffset;
	const imageTiles = writable([]);
	component_subscribe($$self, imageTiles, value => $$invalidate(47, $imageTiles = value));

	// clones an image tile for use in canvas
	const cloneImageTile = tile => {
		const clone = {
			// doesn't clone everything but should be enough
			...tile,
			data: $imagePreview,
			size: $imageSize,
			offset: { ...tile.offset },
			mask: { ...tile.mask },
			backgroundColor: $imageBackgroundColor
		};

		clone.opacity = $isActiveFraction;
		clone.offset.y += $footerOffset;
		clone.mask.y += $footerOffset;
		return clone;
	};

	const handleChangeFilter = ({ value }) => {
		set_store_value(
			imageColorMatrix,
			$imageColorMatrix = {
				...$imageColorMatrix,
				"filter": isFunction$1(filterFunctions[value])
				? filterFunctions[value]()
				: undefined
			},
			$imageColorMatrix
		);

		history.write();
	};

	// when destroyed we need to make sure all image previews are cleared
	onDestroy(() => {
		interfaceImages.set([]);
	});

	const measure_handler_1 = (option, e) => handleTileResize(option, e.detail);

	function div0_binding($$value, option) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			tileElements[option.value] = $$value;
			$$invalidate(9, tileElements);
		});
	}

	const func = offset => $$invalidate(7, tileScrollOffset = offset);

	function scrollable_maskFeatherStartOpacity_binding(value) {
		tileLeftOpacity = value;
		$$invalidate(4, tileLeftOpacity);
	}

	function scrollable_maskFeatherEndOpacity_binding(value) {
		tileRightOpacity = value;
		$$invalidate(5, tileRightOpacity);
	}

	function scrollable_maskFeatherSize_binding(value) {
		tileMargin = value;
		$$invalidate(6, tileMargin);
	}

	const measure_handler_2 = e => $$invalidate(8, tileScrollContainerRect = e.detail);

	function measure_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("isActive" in $$props) $$subscribe_isActive($$invalidate(0, isActive = $$props.isActive));
		if ("isActiveFraction" in $$props) $$subscribe_isActiveFraction($$invalidate(1, isActiveFraction = $$props.isActiveFraction));
		if ("stores" in $$props) $$invalidate(31, stores = $$props.stores);
		if ("locale" in $$props) $$invalidate(2, locale = $$props.locale);
		if ("filterFunctions" in $$props) $$invalidate(32, filterFunctions = $$props.filterFunctions);
		if ("filterOptions" in $$props) $$invalidate(3, filterOptions = $$props.filterOptions);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*filterOptions*/ 8) {
			$$invalidate(35, filterOptionsFlattened = flattenOptions(filterOptions));
		}

		if ($$self.$$.dirty[1] & /*$imageColorMatrix, filterOptionsFlattened*/ 48) {
			$$invalidate(10, selectedFilterIndex = getFilterIndex($imageColorMatrix, filterOptionsFlattened));
		}

		if ($$self.$$.dirty[1] & /*$animation, $isActive*/ 768) {
			$animation && footerOffset.set($isActive ? 0 : 20);
		}

		if ($$self.$$.dirty[1] & /*$isActive, $utilRect, $stageRect*/ 3584) {
			if ($isActive && $utilRect && $stageRect) {
				const tileTopOffset = $stageRect.y + $stageRect.height + $utilRect.y;

				$$invalidate(34, tileWrapperOffset = {
					x: $stageRect.x - $utilRect.x,
					y: tileTopOffset
				});
			}
		}

		if ($$self.$$.dirty[0] & /*tileScrollOffset, tileScrollContainerRect, tileMargin, tileLeftOpacity, tileRightOpacity*/ 496 | $$self.$$.dirty[1] & /*$imageTransforms, tileWrapperOffset, tileCornerRadius, filterOptionsFlattened, $tileRects, $imageColorMatrix, filterFunctions, $imageGamma*/ 4350) {
			if ($imageTransforms && tileWrapperOffset && tileScrollOffset && tileScrollContainerRect && tileCornerRadius) {
				const boundsX = tileWrapperOffset.x + tileScrollContainerRect.x;
				const offsetX = boundsX + tileScrollOffset.x;
				const offsetY = tileWrapperOffset.y;
				const containerLeft = tileScrollContainerRect.x + tileWrapperOffset.x;
				const containerRight = containerLeft + tileScrollContainerRect.width;

				imageTiles.set(filterOptionsFlattened.map(([id], i) => {
					const tileRect = $tileRects[id];

					// test if is outside of view
					const tileLeft = tileScrollOffset.x + tileRect.x;

					const tileRight = tileLeft + tileRect.width;
					if (tileRight < 0 || tileLeft > tileScrollContainerRect.width) return false;
					const x = offsetX + tileRect.x;
					const y = offsetY + tileRect.y;
					const preview = cloneImageTransforms($imageTransforms);
					preview.offset = vectorCreate(tileRect.width * 0.5 + x, tileRect.height * 0.5 + y);
					let clipX = 0;
					let clipWidth = 0;
					preview.maskOpacity = 1;
					preview.mask = rectCreate(x + clipX, y, tileRect.width + clipWidth, tileRect.height);
					preview.maskFeather = [1, 0, 1, 0, 1, containerRight, 1, containerRight];

					if (tileLeft < tileMargin && tileLeftOpacity < 1) {
						preview.maskFeather[0] = tileLeftOpacity;
						preview.maskFeather[1] = containerLeft;
						preview.maskFeather[2] = 1;
						preview.maskFeather[3] = containerLeft + tileMargin;
					}

					if (tileRight > tileScrollContainerRect.width - tileMargin && tileRightOpacity < 1) {
						preview.maskFeather[4] = tileRightOpacity;
						preview.maskFeather[5] = containerRight - tileMargin;
						preview.maskFeather[6] = 1;
						preview.maskFeather[7] = containerRight;
					}

					preview.maskCornerRadius = tileCornerRadius[id];
					let colorMatrices = $imageColorMatrix && Object.keys($imageColorMatrix).filter(name => name != "filter").map(name => $imageColorMatrix[name]) || [];

					if (isFunction$1(filterFunctions[id])) {
						colorMatrices.push(filterFunctions[id]());
					}

					preview.colorMatrix = colorMatrices.length
					? getColorMatrixFromColorMatrices(colorMatrices)
					: undefined;

					preview.gamma = $imageGamma;
					return preview;
				}).filter(Boolean));
			}
		}

		if ($$self.$$.dirty[1] & /*$isActiveFraction, $imageTiles, $footerOffset, $imagePreview*/ 122880) {
			// Will update `interfaceImages` store when
			// - $isActiveFraction is updated
			// - $imageTiles is updated
			// - $footerOffset is updated
			if ($isActiveFraction > 0 && $imageTiles) {

				// clone tiles
				interfaceImages.set($imageTiles.map(cloneImageTile));
			} else {
				interfaceImages.set([]);
			}
		}

		if ($$self.$$.dirty[1] & /*$footerOffset*/ 32768) {
			$$invalidate(11, footerStyle = $footerOffset
			? `transform: translateY(${$footerOffset}px)`
			: undefined);
		}
	};

	return [
		isActive,
		isActiveFraction,
		locale,
		filterOptions,
		tileLeftOpacity,
		tileRightOpacity,
		tileMargin,
		tileScrollOffset,
		tileScrollContainerRect,
		tileElements,
		selectedFilterIndex,
		footerStyle,
		stageRect,
		utilRect,
		animation,
		elasticityMultiplier,
		scrollElasticity,
		imageSize,
		imagePreview,
		imageBackgroundColor,
		imageGamma,
		imageColorMatrix,
		tileRects,
		handleTileResize,
		canvasSize,
		imageTransforms,
		footerOffset,
		handleTransitionEnd,
		imageTiles,
		handleChangeFilter,
		name,
		stores,
		filterFunctions,
		tileCornerRadius,
		tileWrapperOffset,
		filterOptionsFlattened,
		$imageColorMatrix,
		$tileRects,
		$imageTransforms,
		$animation,
		$isActive,
		$utilRect,
		$stageRect,
		$imageGamma,
		$imagePreview,
		$isActiveFraction,
		$footerOffset,
		$imageTiles,
		measure_handler_1,
		div0_binding,
		func,
		scrollable_maskFeatherStartOpacity_binding,
		scrollable_maskFeatherEndOpacity_binding,
		scrollable_maskFeatherSize_binding,
		measure_handler_2,
		measure_handler
	];
}

class Filter extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$i,
			create_fragment$i,
			safe_not_equal,
			{
				name: 30,
				isActive: 0,
				isActiveFraction: 1,
				stores: 31,
				locale: 2,
				filterFunctions: 32,
				filterOptions: 3
			},
			[-1, -1, -1]
		);
	}

	get name() {
		return this.$$.ctx[30];
	}

	get isActive() {
		return this.$$.ctx[0];
	}

	set isActive(isActive) {
		this.$set({ isActive });
		flush();
	}

	get isActiveFraction() {
		return this.$$.ctx[1];
	}

	set isActiveFraction(isActiveFraction) {
		this.$set({ isActiveFraction });
		flush();
	}

	get stores() {
		return this.$$.ctx[31];
	}

	set stores(stores) {
		this.$set({ stores });
		flush();
	}

	get locale() {
		return this.$$.ctx[2];
	}

	set locale(locale) {
		this.$set({ locale });
		flush();
	}

	get filterFunctions() {
		return this.$$.ctx[32];
	}

	set filterFunctions(filterFunctions) {
		this.$set({ filterFunctions });
		flush();
	}

	get filterOptions() {
		return this.$$.ctx[3];
	}

	set filterOptions(filterOptions) {
		this.$set({ filterOptions });
		flush();
	}
}

// @ts-ignore
var _plugin_filter = { util: ['filter', Filter] };

/* src/core/ui/plugins/finetune/index.svelte generated by Svelte v3.37.0 */

function create_default_slot_2$1(ctx) {
	let span;
	let t_value = /*tab*/ ctx[37].label + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(t_value);
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty[1] & /*tab*/ 64 && t_value !== (t_value = /*tab*/ ctx[37].label + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (153:8) <Scrollable elasticity={elasticityMultiplier * scrollElasticity} class="PinturaControlListScroller">
function create_default_slot_1$2(ctx) {
	let tablist;
	let current;

	const tablist_spread_levels = [
		{ class: "PinturaControlList" },
		{ tabs: /*tabs*/ ctx[1] },
		/*tabsConfig*/ ctx[3]
	];

	let tablist_props = {
		$$slots: {
			default: [
				create_default_slot_2$1,
				({ tab }) => ({ 37: tab }),
				({ tab }) => [0, tab ? 64 : 0]
			]
		},
		$$scope: { ctx }
	};

	for (let i = 0; i < tablist_spread_levels.length; i += 1) {
		tablist_props = assign(tablist_props, tablist_spread_levels[i]);
	}

	tablist = new TabList({ props: tablist_props });
	tablist.$on("select", /*select_handler*/ ctx[22]);

	return {
		c() {
			create_component(tablist.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tablist, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const tablist_changes = (dirty[0] & /*tabs, tabsConfig*/ 10)
			? get_spread_update(tablist_spread_levels, [
					tablist_spread_levels[0],
					dirty[0] & /*tabs*/ 2 && { tabs: /*tabs*/ ctx[1] },
					dirty[0] & /*tabsConfig*/ 8 && get_spread_object(/*tabsConfig*/ ctx[3])
				])
			: {};

			if (dirty[1] & /*$$scope, tab*/ 192) {
				tablist_changes.$$scope = { dirty, ctx };
			}

			tablist.$set(tablist_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tablist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tablist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tablist, detaching);
		}
	};
}

// (159:8) <TabPanels class="PinturaControlPanels" panelClass="PinturaControlPanel" {panels} {...tabsConfig} let:panel>
function create_default_slot$7(ctx) {
	let rangeinput;
	let current;
	const rangeinput_spread_levels = [/*$rangeInputConfig*/ ctx[5][/*panel*/ ctx[36]]];
	let rangeinput_props = {};

	for (let i = 0; i < rangeinput_spread_levels.length; i += 1) {
		rangeinput_props = assign(rangeinput_props, rangeinput_spread_levels[i]);
	}

	rangeinput = new RangeInput({ props: rangeinput_props });

	return {
		c() {
			create_component(rangeinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(rangeinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const rangeinput_changes = (dirty[0] & /*$rangeInputConfig*/ 32 | dirty[1] & /*panel*/ 32)
			? get_spread_update(rangeinput_spread_levels, [get_spread_object(/*$rangeInputConfig*/ ctx[5][/*panel*/ ctx[36]])])
			: {};

			rangeinput.$set(rangeinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(rangeinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(rangeinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(rangeinput, detaching);
		}
	};
}

// (151:4) 
function create_footer_slot$3(ctx) {
	let div;
	let scrollable;
	let t;
	let tabpanels;
	let current;

	scrollable = new Scrollable({
			props: {
				elasticity: /*elasticityMultiplier*/ ctx[9] * /*scrollElasticity*/ ctx[8],
				class: "PinturaControlListScroller",
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			}
		});

	const tabpanels_spread_levels = [
		{ class: "PinturaControlPanels" },
		{ panelClass: "PinturaControlPanel" },
		{ panels: /*panels*/ ctx[4] },
		/*tabsConfig*/ ctx[3]
	];

	let tabpanels_props = {
		$$slots: {
			default: [
				create_default_slot$7,
				({ panel }) => ({ 36: panel }),
				({ panel }) => [0, panel ? 32 : 0]
			]
		},
		$$scope: { ctx }
	};

	for (let i = 0; i < tabpanels_spread_levels.length; i += 1) {
		tabpanels_props = assign(tabpanels_props, tabpanels_spread_levels[i]);
	}

	tabpanels = new TabPanels({ props: tabpanels_props });

	return {
		c() {
			div = element("div");
			create_component(scrollable.$$.fragment);
			t = space();
			create_component(tabpanels.$$.fragment);
			attr(div, "slot", "footer");
			attr(div, "style", /*footerStyle*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(scrollable, div, null);
			append(div, t);
			mount_component(tabpanels, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const scrollable_changes = {};

			if (dirty[0] & /*tabs, tabsConfig, tabSelected*/ 14 | dirty[1] & /*$$scope*/ 128) {
				scrollable_changes.$$scope = { dirty, ctx };
			}

			scrollable.$set(scrollable_changes);

			const tabpanels_changes = (dirty[0] & /*panels, tabsConfig*/ 24)
			? get_spread_update(tabpanels_spread_levels, [
					tabpanels_spread_levels[0],
					tabpanels_spread_levels[1],
					dirty[0] & /*panels*/ 16 && { panels: /*panels*/ ctx[4] },
					dirty[0] & /*tabsConfig*/ 8 && get_spread_object(/*tabsConfig*/ ctx[3])
				])
			: {};

			if (dirty[0] & /*$rangeInputConfig*/ 32 | dirty[1] & /*$$scope, panel*/ 160) {
				tabpanels_changes.$$scope = { dirty, ctx };
			}

			tabpanels.$set(tabpanels_changes);

			if (!current || dirty[0] & /*footerStyle*/ 64) {
				attr(div, "style", /*footerStyle*/ ctx[6]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(scrollable.$$.fragment, local);
			transition_in(tabpanels.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(scrollable.$$.fragment, local);
			transition_out(tabpanels.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(scrollable);
			destroy_component(tabpanels);
		}
	};
}

function create_fragment$h(ctx) {
	let util;
	let current;

	util = new Util({
			props: {
				$$slots: { footer: [create_footer_slot$3] },
				$$scope: { ctx }
			}
		});

	util.$on("measure", /*measure_handler*/ ctx[23]);

	return {
		c() {
			create_component(util.$$.fragment);
		},
		m(target, anchor) {
			mount_component(util, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const util_changes = {};

			if (dirty[0] & /*footerStyle, panels, tabsConfig, $rangeInputConfig, tabs, tabSelected*/ 126 | dirty[1] & /*$$scope*/ 128) {
				util_changes.$$scope = { dirty, ctx };
			}

			util.$set(util_changes);
		},
		i(local) {
			if (current) return;
			transition_in(util.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(util.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(util, detaching);
		}
	};
}

function instance$h($$self, $$props, $$invalidate) {
	let tabs;
	let tabSelected;
	let tabsConfig;
	let panels;
	let footerStyle;
	let $rangeInputConfig;
	let $panelValues;
	let $animation;

	let $isActive,
		$$unsubscribe_isActive = noop$2,
		$$subscribe_isActive = () => ($$unsubscribe_isActive(), $$unsubscribe_isActive = subscribe(isActive, $$value => $$invalidate(20, $isActive = $$value)), isActive);

	let $footerOffset;
	$$self.$$.on_destroy.push(() => $$unsubscribe_isActive());
	const name = "finetune";
	let { stores } = $$props;
	let { isActive } = $$props;
	$$subscribe_isActive();
	let { locale = {} } = $$props;
	let { finetuneControlConfiguration } = $$props;
	let { finetuneOptions } = $$props;
	const { history, animation, scrollElasticity, elasticityMultiplier, rangeInputElasticity, imageColorMatrix, imageConvolutionMatrix, imageGamma, imageVignette, imageNoise } = stores;
	component_subscribe($$self, animation, value => $$invalidate(19, $animation = value));

	const imageEffectStores = {
		imageColorMatrix,
		imageConvolutionMatrix,
		imageGamma,
		imageVignette,
		imageNoise
	};

	//
	// Tabs
	//
	const uid = `finetune-${getUniqueId()}`;

	//
	// Range inputs
	//
	const panelValues = writable({});

	component_subscribe($$self, panelValues, value => $$invalidate(18, $panelValues = value));
	const rangeInputConfig = writable({});
	component_subscribe($$self, rangeInputConfig, value => $$invalidate(5, $rangeInputConfig = value));

	const updateRangeInputState = () => {
		set_store_value(
			rangeInputConfig,
			$rangeInputConfig = Object.keys($panelValues).reduce(
				(config, id) => {
					const { base, min, max, getLabel, getStore, setValue = (store, v) => store.set(v) } = finetuneControlConfiguration[id];
					const store = getStore(imageEffectStores);
					const value = $panelValues[id] != null ? $panelValues[id] : base;

					config[id] = {
						base,
						min,
						max,
						value,
						valueLabel: getLabel
						? getLabel(value, min, max, max - min)
						: Math.round(100 * value),
						oninputmove: v => {
							setValue(store, v);
						},
						oninputend: v => {
							setValue(store, v);
							history.write();
						},
						elasticity: elasticityMultiplier * rangeInputElasticity,
						labelReset: locale.labelReset
					};

					return config;
				},
				{}
			),
			$rangeInputConfig
		);
	};

	// need to unsubscribe when redrawing vie
	let unsubs = [];

	const subscribePanelStores = config => {
		if (unsubs) unsubs.forEach(unsub => unsub());

		unsubs = panels.map(id => {
			const { getStore, getValue = passthrough } = config[id];
			const store = getStore(imageEffectStores);

			return store.subscribe(value => {
				const currentValue = value != null ? getValue(value) : value;
				set_store_value(panelValues, $panelValues = { ...$panelValues, [id]: currentValue }, $panelValues);
			});
		});
	};

	//
	// Footer
	//
	const footerOffset = spring$2($animation ? 20 : 0);

	component_subscribe($$self, footerOffset, value => $$invalidate(21, $footerOffset = value));
	const select_handler = ({ detail }) => $$invalidate(2, tabSelected = detail);

	function measure_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("stores" in $$props) $$invalidate(14, stores = $$props.stores);
		if ("isActive" in $$props) $$subscribe_isActive($$invalidate(0, isActive = $$props.isActive));
		if ("locale" in $$props) $$invalidate(15, locale = $$props.locale);
		if ("finetuneControlConfiguration" in $$props) $$invalidate(16, finetuneControlConfiguration = $$props.finetuneControlConfiguration);
		if ("finetuneOptions" in $$props) $$invalidate(17, finetuneOptions = $$props.finetuneOptions);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*finetuneOptions, locale*/ 163840) {
			$$invalidate(1, tabs = finetuneOptions
			? finetuneOptions.map(([id, label]) => ({
					id,
					label: isFunction$1(label) ? label(locale) : label
				}))
			: []);
		}

		if ($$self.$$.dirty[0] & /*tabs*/ 2) {
			$$invalidate(2, tabSelected = tabs.length && tabs[0].id);
		}

		if ($$self.$$.dirty[0] & /*tabSelected*/ 4) {
			$$invalidate(3, tabsConfig = { name: uid, selected: tabSelected });
		}

		if ($$self.$$.dirty[0] & /*tabs*/ 2) {
			$$invalidate(4, panels = tabs.map(tab => tab.id));
		}

		if ($$self.$$.dirty[0] & /*finetuneControlConfiguration*/ 65536) {
			finetuneControlConfiguration && subscribePanelStores(finetuneControlConfiguration);
		}

		if ($$self.$$.dirty[0] & /*finetuneControlConfiguration, $panelValues*/ 327680) {
			finetuneControlConfiguration && $panelValues && updateRangeInputState();
		}

		if ($$self.$$.dirty[0] & /*$animation, $isActive*/ 1572864) {
			$animation && footerOffset.set($isActive ? 0 : 20);
		}

		if ($$self.$$.dirty[0] & /*$footerOffset*/ 2097152) {
			$$invalidate(6, footerStyle = $footerOffset
			? `transform: translateY(${$footerOffset}px)`
			: undefined);
		}
	};

	return [
		isActive,
		tabs,
		tabSelected,
		tabsConfig,
		panels,
		$rangeInputConfig,
		footerStyle,
		animation,
		scrollElasticity,
		elasticityMultiplier,
		panelValues,
		rangeInputConfig,
		footerOffset,
		name,
		stores,
		locale,
		finetuneControlConfiguration,
		finetuneOptions,
		$panelValues,
		$animation,
		$isActive,
		$footerOffset,
		select_handler,
		measure_handler
	];
}

class Finetune extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$h,
			create_fragment$h,
			safe_not_equal,
			{
				name: 13,
				stores: 14,
				isActive: 0,
				locale: 15,
				finetuneControlConfiguration: 16,
				finetuneOptions: 17
			},
			[-1, -1]
		);
	}

	get name() {
		return this.$$.ctx[13];
	}

	get stores() {
		return this.$$.ctx[14];
	}

	set stores(stores) {
		this.$set({ stores });
		flush();
	}

	get isActive() {
		return this.$$.ctx[0];
	}

	set isActive(isActive) {
		this.$set({ isActive });
		flush();
	}

	get locale() {
		return this.$$.ctx[15];
	}

	set locale(locale) {
		this.$set({ locale });
		flush();
	}

	get finetuneControlConfiguration() {
		return this.$$.ctx[16];
	}

	set finetuneControlConfiguration(finetuneControlConfiguration) {
		this.$set({ finetuneControlConfiguration });
		flush();
	}

	get finetuneOptions() {
		return this.$$.ctx[17];
	}

	set finetuneOptions(finetuneOptions) {
		this.$set({ finetuneOptions });
		flush();
	}
}

// @ts-ignore
var _plugin_finetune = { util: ['finetune', Finetune] };

/* src/core/ui/components/ShapeManipulator.svelte generated by Svelte v3.37.0 */

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[47] = list[i].key;
	child_ctx[48] = list[i].index;
	child_ctx[49] = list[i].translate;
	child_ctx[50] = list[i].scale;
	child_ctx[14] = list[i].rotate;
	child_ctx[51] = list[i].dir;
	child_ctx[52] = list[i].center;
	child_ctx[53] = list[i].type;
	return child_ctx;
}

// (307:0) {#if type ==='edge' && resizeAxis !== 'both'}
function create_if_block_1$3(ctx) {
	let div;
	let div_style_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", "PinturaShapeManipulator");
			attr(div, "data-control", "point");
			attr(div, "style", div_style_value = `pointer-events:none;transform: translate3d(${/*center*/ ctx[52].x}px, ${/*center*/ ctx[52].y}px, 0) scale(${/*$selectionScale*/ ctx[5]}, ${/*$selectionScale*/ ctx[5]}); opacity: ${/*$selectionOpacity*/ ctx[6]}`);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*resizeControls, $selectionScale, $selectionOpacity*/ 104 && div_style_value !== (div_style_value = `pointer-events:none;transform: translate3d(${/*center*/ ctx[52].x}px, ${/*center*/ ctx[52].y}px, 0) scale(${/*$selectionScale*/ ctx[5]}, ${/*$selectionScale*/ ctx[5]}); opacity: ${/*$selectionOpacity*/ ctx[6]}`)) {
				attr(div, "style", div_style_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (291:0) {#each resizeControls as { key, index, translate, scale, rotate, dir, center, type }
function create_each_block$4(key_1, ctx) {
	let div;
	let div_aria_label_value;
	let div_tabindex_value;
	let div_data_control_value;
	let div_style_value;
	let t;
	let if_block_anchor;
	let mounted;
	let dispose;

	function nudge_handler(...args) {
		return /*nudge_handler*/ ctx[18](/*index*/ ctx[48], ...args);
	}

	let if_block = /*type*/ ctx[53] === "edge" && /*resizeAxis*/ ctx[2] !== "both" && create_if_block_1$3(ctx);

	return {
		key: key_1,
		first: null,
		c() {
			div = element("div");
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty$1();
			attr(div, "role", "button");
			attr(div, "aria-label", div_aria_label_value = `Drag ${/*type*/ ctx[53]} ${/*key*/ ctx[47]}`);
			attr(div, "tabindex", div_tabindex_value = /*type*/ ctx[53] === "edge" ? -1 : 0);
			attr(div, "class", "PinturaShapeManipulator");
			attr(div, "data-control", div_data_control_value = /*type*/ ctx[53]);

			attr(div, "style", div_style_value = `cursor: ${/*dir*/ ctx[51] ? /*dir*/ ctx[51] + "-resize" : "move"}; transform: translate3d(${/*translate*/ ctx[49].x}px, ${/*translate*/ ctx[49].y}px, 0)${/*type*/ ctx[53] === "edge"
			? ` rotate(${/*rotate*/ ctx[14]}rad)`
			: ""} scale(${/*type*/ ctx[53] === "point"
			? /*$selectionScale*/ ctx[5]
			: /*scale*/ ctx[50].x}, ${/*type*/ ctx[53] === "point"
			? /*$selectionScale*/ ctx[5]
			: /*scale*/ ctx[50].y}); opacity: ${/*$selectionOpacity*/ ctx[6]}`);

			this.first = div;
		},
		m(target, anchor) {
			insert(target, div, anchor);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);

			if (!mounted) {
				dispose = [
					listen(div, "keydown", /*handleKeyDown*/ ctx[7]),
					listen(div, "keyup", /*handleKeyUp*/ ctx[8]),
					listen(div, "nudge", nudge_handler),
					action_destroyer(nudgeable.call(null, div)),
					listen(div, "interactionstart", function () {
						if (is_function(/*resize*/ ctx[11]("start", /*index*/ ctx[48]))) /*resize*/ ctx[11]("start", /*index*/ ctx[48]).apply(this, arguments);
					}),
					listen(div, "interactionupdate", function () {
						if (is_function(/*resize*/ ctx[11]("move", /*index*/ ctx[48]))) /*resize*/ ctx[11]("move", /*index*/ ctx[48]).apply(this, arguments);
					}),
					listen(div, "interactionend", function () {
						if (is_function(/*resize*/ ctx[11]("end", /*index*/ ctx[48]))) /*resize*/ ctx[11]("end", /*index*/ ctx[48]).apply(this, arguments);
					}),
					action_destroyer(interactable.call(null, div))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*resizeControls*/ 8 && div_aria_label_value !== (div_aria_label_value = `Drag ${/*type*/ ctx[53]} ${/*key*/ ctx[47]}`)) {
				attr(div, "aria-label", div_aria_label_value);
			}

			if (dirty[0] & /*resizeControls*/ 8 && div_tabindex_value !== (div_tabindex_value = /*type*/ ctx[53] === "edge" ? -1 : 0)) {
				attr(div, "tabindex", div_tabindex_value);
			}

			if (dirty[0] & /*resizeControls*/ 8 && div_data_control_value !== (div_data_control_value = /*type*/ ctx[53])) {
				attr(div, "data-control", div_data_control_value);
			}

			if (dirty[0] & /*resizeControls, $selectionScale, $selectionOpacity*/ 104 && div_style_value !== (div_style_value = `cursor: ${/*dir*/ ctx[51] ? /*dir*/ ctx[51] + "-resize" : "move"}; transform: translate3d(${/*translate*/ ctx[49].x}px, ${/*translate*/ ctx[49].y}px, 0)${/*type*/ ctx[53] === "edge"
			? ` rotate(${/*rotate*/ ctx[14]}rad)`
			: ""} scale(${/*type*/ ctx[53] === "point"
			? /*$selectionScale*/ ctx[5]
			: /*scale*/ ctx[50].x}, ${/*type*/ ctx[53] === "point"
			? /*$selectionScale*/ ctx[5]
			: /*scale*/ ctx[50].y}); opacity: ${/*$selectionOpacity*/ ctx[6]}`)) {
				attr(div, "style", div_style_value);
			}

			if (/*type*/ ctx[53] === "edge" && /*resizeAxis*/ ctx[2] !== "both") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$3(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (311:0) {#if enableRotating && rotationControlActive}
function create_if_block$3(ctx) {
	let div;
	let div_style_value;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			attr(div, "role", "button");
			attr(div, "aria-label", "Drag rotator");
			attr(div, "tabindex", "0");
			attr(div, "class", "PinturaShapeManipulator");
			attr(div, "data-control", "rotate");
			attr(div, "style", div_style_value = `transform: translate3d(${/*rotatorPoint*/ ctx[0].x}px, ${/*rotatorPoint*/ ctx[0].y}px, 0) scale(${/*$selectionScale*/ ctx[5]}, ${/*$selectionScale*/ ctx[5]}); opacity: ${/*$selectionOpacity*/ ctx[6]}`);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (!mounted) {
				dispose = [
					listen(div, "keydown", /*handleKeyDown*/ ctx[7]),
					listen(div, "keyup", /*handleKeyUp*/ ctx[8]),
					listen(div, "nudge", /*handleRotateNudge*/ ctx[13]),
					action_destroyer(nudgeable.call(null, div)),
					listen(div, "interactionstart", /*rotate*/ ctx[14]("start")),
					listen(div, "interactionupdate", /*rotate*/ ctx[14]("move")),
					listen(div, "interactionend", /*rotate*/ ctx[14]("end")),
					action_destroyer(interactable.call(null, div))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rotatorPoint, $selectionScale, $selectionOpacity*/ 97 && div_style_value !== (div_style_value = `transform: translate3d(${/*rotatorPoint*/ ctx[0].x}px, ${/*rotatorPoint*/ ctx[0].y}px, 0) scale(${/*$selectionScale*/ ctx[5]}, ${/*$selectionScale*/ ctx[5]}); opacity: ${/*$selectionOpacity*/ ctx[6]}`)) {
				attr(div, "style", div_style_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$g(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t;
	let if_block_anchor;
	let each_value = /*resizeControls*/ ctx[3];
	const get_key = ctx => /*key*/ ctx[47];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$4(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$4(key, child_ctx));
	}

	let if_block = /*enableRotating*/ ctx[1] && /*rotationControlActive*/ ctx[4] && create_if_block$3(ctx);

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty$1();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*resizeControls, $selectionScale, $selectionOpacity, resizeAxis, handleKeyDown, handleKeyUp, handleResizeNudge, resize*/ 6636) {
				each_value = /*resizeControls*/ ctx[3];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, t.parentNode, destroy_block, create_each_block$4, t, get_each_context$4);
			}

			if (/*enableRotating*/ ctx[1] && /*rotationControlActive*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop$2,
		o: noop$2,
		d(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$g($$self, $$props, $$invalidate) {
	let resizeAxis;
	let resizeControls;
	let rotationControlActive;
	let $selectionScale;
	let $selectionOpacity;
	const dispatch = createEventDispatcher();

	// which cursor to render
	const EIGTH_PI = QUART_PI * 0.5;

	const N = HALF_PI;
	const N0 = N - EIGTH_PI;
	const N1 = N + EIGTH_PI;
	const S = -HALF_PI;
	const S0 = S - EIGTH_PI;
	const S1 = S + EIGTH_PI;
	const E = PI;
	const E0 = E - EIGTH_PI;
	const E1 = -PI + EIGTH_PI;
	const W0 = EIGTH_PI;
	const W1 = -EIGTH_PI;
	const NW = N - QUART_PI;
	const NW0 = NW - EIGTH_PI;
	const NW1 = NW + EIGTH_PI;
	const NE = PI - QUART_PI;
	const NE0 = NE - EIGTH_PI;
	const NE1 = NE + EIGTH_PI;
	const SE = S - QUART_PI;
	const SE0 = SE + EIGTH_PI;
	const SE1 = SE - EIGTH_PI;
	const SW = S + QUART_PI;
	const SW0 = SW + EIGTH_PI;
	const SW1 = SW - EIGTH_PI;
	let { points = [] } = $$props;
	let { rotatorPoint = undefined } = $$props;
	let { visible = false } = $$props;
	let { enableResizing = true } = $$props;
	let { enableRotating = true } = $$props;

	// // internal
	let shiftKey = false;

	const handleKeyDown = e => shiftKey = e.shiftKey;
	const handleKeyUp = e => shiftKey = false;

	// state
	const selectionScale = spring$2(0.5, {
		precision: 0.0001,
		stiffness: 0.3,
		damping: 0.7
	});

	component_subscribe($$self, selectionScale, value => $$invalidate(5, $selectionScale = value));

	const selectionOpacity = spring$2(0, {
		precision: 0.001,
		stiffness: 0.3,
		damping: 0.7
	});

	component_subscribe($$self, selectionOpacity, value => $$invalidate(6, $selectionOpacity = value));

	const rotate = type => ({ detail }) => {
		// always make sure we have a translation to work with
		const translation = detail && detail.translation
		? detail.translation
		: vectorCreate(0, 0);

		dispatch(`rotate${type}`, { translation, shiftKey });
	};

	const resize = (type, indexes) => ({ detail }) => {
		// always make sure we have a translation to work with
		const translation = detail && detail.translation
		? detail.translation
		: vectorCreate(0, 0);

		// done transforming the points
		dispatch(`resize${type}`, { indexes, translation, shiftKey });
	};

	// https://en.wikipedia.org/wiki/Radian#/media/File:Degree-Radian_Conversion.svg
	const getDirectionByAngle = angle => {
		let dir = "";
		const isNorth = angle <= N1 && angle >= N0;
		const isSouth = angle >= S0 && angle <= S1;
		const isEast = angle <= E1 || angle >= E0;
		const isWest = angle >= W1 && angle <= W0;
		const isNorthEast = angle >= NE0 && angle <= NE1;
		const isNorthWest = angle >= NW0 && angle <= NW1;
		const isSouthEast = angle <= SE0 && angle >= SE1;
		const isSouthWest = angle <= SW0 && angle >= SW1;
		if (isNorth || isSouth) dir = "ns";
		if (isEast || isWest) dir = "ew";
		if (isNorthEast || isSouthWest) dir = "nesw";
		if (isNorthWest || isSouthEast) dir = "nwse";
		return dir;
	};

	// 2 points -> [corner, corner]
	// 3 points => [corner, edge, corner, edge, corner, edge],
	// 4 points => [corner, edge, corner, edge, corner, edge, corner, edge]
	const mapPointsToControls = (points, axis) => {
		let i = 0;
		const center = vectorCenter(points);
		const out = [];
		const l = points.length;
		const isLine = l === 2;
		const isAxisLimited = axis !== "both";

		for (; i < l; i++) {
			const p0 = points[i - 1] || points[points.length - 1];
			const p1 = points[i];
			const p2 = points[i + 1] || points[0];
			const dir = Math.atan2(p2.y - p1.y, p2.x - p1.x);

			// create corner, only allowed if axis equal 'both'
			if (!isAxisLimited) {
				const a = vectorNormalize(vectorCreate(p0.x - p1.x, p0.y - p1.y));
				const b = vectorNormalize(vectorCreate(p2.x - p1.x, p2.y - p1.y));
				const cornerVector = vectorCreate(a.x + b.x, a.y + b.y);

				out.push({
					index: [i],
					key: `point-${i}`,
					type: "point",
					scale: { x: 1, y: 1 },
					translate: { x: p1.x, y: p1.y },
					angle: undefined,
					rotate: isLine ? 0 : dir,
					center: p1,
					dir: isLine
					? undefined
					: getDirectionByAngle(Math.atan2(cornerVector.y, cornerVector.x))
				});
			}

			// if only two points, skip edge
			if (isLine) continue;

			const mid = vectorCreate(p1.x + (p2.x - p1.x) * 0.5, p1.y + (p2.y - p1.y) * 0.5);

			// only allow horizontal controls
			if (axis === "horizontal" && i % 2 === 0) continue;

			// only allow vertical controls
			if (axis === "vertical" && i % 2 !== 0) continue;

			// create edge
			out.push({
				index: [i, i + 1 === l ? 0 : i + 1],
				key: `edge-${i}`,
				type: "edge",
				scale: { x: vectorDistance(p1, p2), y: 1 },
				translate: { x: p1.x, y: p1.y },
				angle: dir,
				rotate: dir,
				center: mid,
				dir: getDirectionByAngle(Math.atan2(center.y - mid.y, center.x - mid.x))
			});
		}

		return out;
	};

	const handleResizeNudge = (indexes, translation) => {
		dispatch(`resizestart`, {
			indexes,
			translation: vectorCreateEmpty()
		});

		dispatch(`resizemove`, { indexes, translation });

		dispatch(`resizeend`, {
			indexes,
			translation: vectorCreateEmpty()
		});
	};

	const handleRotateNudge = ({ detail }) => {
		dispatch(`rotatestart`, { translation: vectorCreateEmpty() });
		dispatch(`rotatemove`, { translation: detail });
		dispatch(`rotateend`, { translation: vectorCreateEmpty() });
	};

	const nudge_handler = (index, { detail }) => handleResizeNudge(index, detail);

	$$self.$$set = $$props => {
		if ("points" in $$props) $$invalidate(15, points = $$props.points);
		if ("rotatorPoint" in $$props) $$invalidate(0, rotatorPoint = $$props.rotatorPoint);
		if ("visible" in $$props) $$invalidate(16, visible = $$props.visible);
		if ("enableResizing" in $$props) $$invalidate(17, enableResizing = $$props.enableResizing);
		if ("enableRotating" in $$props) $$invalidate(1, enableRotating = $$props.enableRotating);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*visible*/ 65536) {
			selectionScale.set(visible ? 1 : 0.5);
		}

		if ($$self.$$.dirty[0] & /*visible*/ 65536) {
			selectionOpacity.set(visible ? 1 : 0);
		}

		if ($$self.$$.dirty[0] & /*enableResizing*/ 131072) {
			$$invalidate(2, resizeAxis = !enableResizing
			? false
			: isString(enableResizing) ? enableResizing : "both");
		}

		if ($$self.$$.dirty[0] & /*resizeAxis, points*/ 32772) {
			$$invalidate(3, resizeControls = resizeAxis && mapPointsToControls(points, resizeAxis) || []);
		}

		if ($$self.$$.dirty[0] & /*points*/ 32768) {
			$$invalidate(4, rotationControlActive = points.length > 2);
		}
	};

	return [
		rotatorPoint,
		enableRotating,
		resizeAxis,
		resizeControls,
		rotationControlActive,
		$selectionScale,
		$selectionOpacity,
		handleKeyDown,
		handleKeyUp,
		selectionScale,
		selectionOpacity,
		resize,
		handleResizeNudge,
		handleRotateNudge,
		rotate,
		points,
		visible,
		enableResizing,
		nudge_handler
	];
}

class ShapeManipulator extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$g,
			create_fragment$g,
			safe_not_equal,
			{
				points: 15,
				rotatorPoint: 0,
				visible: 16,
				enableResizing: 17,
				enableRotating: 1
			},
			[-1, -1]
		);
	}
}

var getEventPositionInEditor = (e, viewOffset) => {
    const positionInViewport = getEventPositionInViewport(e);
    return vectorSubtract(positionInViewport, viewOffset);
};

let result$1 = null;
var isAndroid = () => {
    if (result$1 === null)
        result$1 = isUserAgent(/Android/);
    return result$1;
};

var cursorMoveToEnd = (field) => (field.selectionStart = field.selectionEnd = field.value.length);

let result = null;
var supportsVisualViewport = () => {
    if (result === null) {
        result = isBrowser() && 'visualViewport' in window$1;
    }
    return result;
};

var createSoftKeyboardObserver = (cb) => {
    if (!supportsVisualViewport())
        return false;
    const heightNormal = visualViewport.height;
    const testState = () => {
        cb(visualViewport.height < heightNormal ? 'visible' : 'hidden');
    };
    visualViewport.addEventListener('resize', testState);
    return () => visualViewport.removeEventListener('resize', testState);
};

/* src/core/ui/components/InputForm.svelte generated by Svelte v3.37.0 */

function create_fragment$f(ctx) {
	let div2;
	let div1;
	let button0;
	let t0;
	let div0;
	let t1;
	let button1;
	let current;
	let mounted;
	let dispose;

	button0 = new Button({
			props: {
				onclick: /*oncancel*/ ctx[1],
				label: /*labelCancel*/ ctx[5],
				icon: /*iconCancel*/ ctx[7],
				hideLabel: !/*labelCancelShow*/ ctx[6]
			}
		});

	const default_slot_template = /*#slots*/ ctx[20].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

	button1 = new Button({
			props: {
				onclick: /*onconfirm*/ ctx[0],
				label: /*labelConfirm*/ ctx[2],
				icon: /*iconConfirm*/ ctx[4],
				hideLabel: !/*labelConfirmShow*/ ctx[3],
				class: "PinturaInputFormButtonConfirm"
			}
		});

	return {
		c() {
			div2 = element("div");
			div1 = element("div");
			create_component(button0.$$.fragment);
			t0 = space();
			div0 = element("div");
			if (default_slot) default_slot.c();
			t1 = space();
			create_component(button1.$$.fragment);
			attr(div0, "class", "PinturaInputFormFields");
			attr(div1, "class", "PinturaInputFormInner");
			attr(div2, "class", "PinturaInputForm");
			attr(div2, "style", /*style*/ ctx[9]);
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div1);
			mount_component(button0, div1, null);
			append(div1, t0);
			append(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			append(div1, t1);
			mount_component(button1, div1, null);
			/*div2_binding*/ ctx[21](div2);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div2, "focusin", /*handleFocusIn*/ ctx[10]),
					listen(div2, "focusout", /*handleFocusOut*/ ctx[11]),
					listen(div2, "measure", /*handleMeasure*/ ctx[12]),
					action_destroyer(measurable.call(null, div2))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			const button0_changes = {};
			if (dirty[0] & /*oncancel*/ 2) button0_changes.onclick = /*oncancel*/ ctx[1];
			if (dirty[0] & /*labelCancel*/ 32) button0_changes.label = /*labelCancel*/ ctx[5];
			if (dirty[0] & /*iconCancel*/ 128) button0_changes.icon = /*iconCancel*/ ctx[7];
			if (dirty[0] & /*labelCancelShow*/ 64) button0_changes.hideLabel = !/*labelCancelShow*/ ctx[6];
			button0.$set(button0_changes);

			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 524288) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, null, null);
				}
			}

			const button1_changes = {};
			if (dirty[0] & /*onconfirm*/ 1) button1_changes.onclick = /*onconfirm*/ ctx[0];
			if (dirty[0] & /*labelConfirm*/ 4) button1_changes.label = /*labelConfirm*/ ctx[2];
			if (dirty[0] & /*iconConfirm*/ 16) button1_changes.icon = /*iconConfirm*/ ctx[4];
			if (dirty[0] & /*labelConfirmShow*/ 8) button1_changes.hideLabel = !/*labelConfirmShow*/ ctx[3];
			button1.$set(button1_changes);

			if (!current || dirty[0] & /*style*/ 512) {
				attr(div2, "style", /*style*/ ctx[9]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(default_slot, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(default_slot, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			destroy_component(button0);
			if (default_slot) default_slot.d(detaching);
			destroy_component(button1);
			/*div2_binding*/ ctx[21](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

const panelDelay = 200;

function instance$f($$self, $$props, $$invalidate) {
	let computedStyle;
	let shouldStickToKeyboard;
	let style;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { onconfirm } = $$props;
	let { oncancel } = $$props;
	let { autoFocus = true } = $$props;
	let { autoPositionCursor = true } = $$props;
	let { labelConfirm } = $$props;
	let { labelConfirmShow = true } = $$props;
	let { iconConfirm } = $$props;
	let { labelCancel } = $$props;
	let { labelCancelShow = false } = $$props;
	let { iconCancel } = $$props;
	let { panelOffset = vectorCreateEmpty() } = $$props;
	let panelVisible = false;
	let panelHeight = undefined;
	let panelRevealTimeout = undefined;
	let panelPosition = "";
	let panelOpacity = 0;
	let root;
	const isTextarea = element => (/textarea/i).test(element);

	const preventTextAreaScrollingOnIOS = element => {
		// preventsDefault on textarea events when can no longer scroll up or down in textarea
		let lastScreenY;

		const handleTouchStart = e => lastScreenY = e.touches[0].screenY;

		const handleTouchMove = e => {
			const currentScreenY = e.touches[0].screenY;
			const target = e.target;

			if ((/textarea/i).test(target.nodeName)) {
				// moving down
				if (currentScreenY > lastScreenY) {
					if (target.scrollTop == 0) {
						e.preventDefault();
					}
				} else // moving up
				if (currentScreenY < lastScreenY) {
					if (target.scrollTop + target.offsetHeight == target.scrollHeight) {
						e.preventDefault();
					}
				} else {
					e.preventDefault();
				}

				lastScreenY = currentScreenY;
			} else {
				e.preventDefault();
			}
		};

		element.addEventListener("touchstart", handleTouchStart);
		element.addEventListener("touchmove", handleTouchMove);

		return () => {
			element.removeEventListener("touchstart", handleTouchStart);
			element.removeEventListener("touchmove", handleTouchMove);
		};
	};

	const focus = () => {
		const field = root.querySelector("input, textarea");
		field.focus();
		field.select();
	};

	const show = () => {
		panelVisible = true;

		// browser does not support keyboard listener, place modal at top of view
		if (!unsubSoftKeyboardListener && (isIOS() || isAndroid())) {
			$$invalidate(16, panelPosition = "top:1em;bottom:auto;");
		}

		// prevent interacting with the root element
		if (isIOS()) preventTextAreaScrollingOnIOS(root);

		// reveal
		$$invalidate(17, panelOpacity = 1);
	};

	const hide = () => {
		panelVisible = false;
		$$invalidate(17, panelOpacity = 0);
	};

	const handleSoftKeyboard = keyboardState => {
		// shouldn't stick, we'll stick it to the top of the viewport so the keyboard doesn't obscure the input field
		if (!shouldStickToKeyboard) {
			$$invalidate(16, panelPosition = `top: 4.5em; bottom: auto`);
			return;
		}

		

		// no need to continue, already hidden
		if (keyboardState === "hidden" && !panelVisible) {
			focus();
			return;
		}

		// gonna update position here
		clearTimeout(panelRevealTimeout);

		panelRevealTimeout = undefined;

		// position
		$$invalidate(16, panelPosition = `top:${visualViewport.height - panelHeight - panelOffset.y}px`);

		// if a soft keyboard is detected, turn into modal mode
		if (keyboardState === "visible") {
			// stick to keyboard
			$$invalidate(8, root.dataset.layout = "stick", root);

			// need to refocus
			focus();

			// place above keyboard
			show();
		} else // keyboard is hidden
		{
			hide();
		}
	};

	let focusDateTime;

	const handleFocusIn = e => {
		if (!isTextarea(e.target)) return;

		// we need to remember focus time so we can detect unrealistic blur event caused by soft keyboard shenanigans
		focusDateTime = Date.now();

		// move cursor
		if (autoPositionCursor) cursorMoveToEnd(e.target);

		// wait a couple milliseconds
		clearTimeout(panelRevealTimeout);

		panelRevealTimeout = setTimeout(show, panelDelay);
	};

	const handleFocusOut = e => {
		const focusDuration = Date.now() - focusDateTime;
		if (focusDuration > 50) return;

		// unrealistic blur, refocus
		e.stopPropagation();

		focus();
	};

	const unsubSoftKeyboardListener = createSoftKeyboardObserver(handleSoftKeyboard);

	const handleMeasure = ({ detail }) => {
		panelHeight = detail.height;
	};

	onMount(() => {
		if (!autoFocus) return;
		focus();
	});

	onDestroy(() => {
		unsubSoftKeyboardListener && unsubSoftKeyboardListener();
	});

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			root = $$value;
			$$invalidate(8, root);
		});
	}

	$$self.$$set = $$props => {
		if ("onconfirm" in $$props) $$invalidate(0, onconfirm = $$props.onconfirm);
		if ("oncancel" in $$props) $$invalidate(1, oncancel = $$props.oncancel);
		if ("autoFocus" in $$props) $$invalidate(13, autoFocus = $$props.autoFocus);
		if ("autoPositionCursor" in $$props) $$invalidate(14, autoPositionCursor = $$props.autoPositionCursor);
		if ("labelConfirm" in $$props) $$invalidate(2, labelConfirm = $$props.labelConfirm);
		if ("labelConfirmShow" in $$props) $$invalidate(3, labelConfirmShow = $$props.labelConfirmShow);
		if ("iconConfirm" in $$props) $$invalidate(4, iconConfirm = $$props.iconConfirm);
		if ("labelCancel" in $$props) $$invalidate(5, labelCancel = $$props.labelCancel);
		if ("labelCancelShow" in $$props) $$invalidate(6, labelCancelShow = $$props.labelCancelShow);
		if ("iconCancel" in $$props) $$invalidate(7, iconCancel = $$props.iconCancel);
		if ("panelOffset" in $$props) $$invalidate(15, panelOffset = $$props.panelOffset);
		if ("$$scope" in $$props) $$invalidate(19, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*root*/ 256) {
			$$invalidate(18, computedStyle = root && getComputedStyle(root));
		}

		if ($$self.$$.dirty[0] & /*computedStyle*/ 262144) {
			shouldStickToKeyboard = computedStyle && computedStyle.getPropertyValue("--editor-modal") === "1";
		}

		if ($$self.$$.dirty[0] & /*panelOpacity, panelPosition*/ 196608) {
			$$invalidate(9, style = `opacity:${panelOpacity};${panelPosition}`);
		}
	};

	return [
		onconfirm,
		oncancel,
		labelConfirm,
		labelConfirmShow,
		iconConfirm,
		labelCancel,
		labelCancelShow,
		iconCancel,
		root,
		style,
		handleFocusIn,
		handleFocusOut,
		handleMeasure,
		autoFocus,
		autoPositionCursor,
		panelOffset,
		panelPosition,
		panelOpacity,
		computedStyle,
		$$scope,
		slots,
		div2_binding
	];
}

class InputForm extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$f,
			create_fragment$f,
			safe_not_equal,
			{
				onconfirm: 0,
				oncancel: 1,
				autoFocus: 13,
				autoPositionCursor: 14,
				labelConfirm: 2,
				labelConfirmShow: 3,
				iconConfirm: 4,
				labelCancel: 5,
				labelCancelShow: 6,
				iconCancel: 7,
				panelOffset: 15
			},
			[-1, -1]
		);
	}
}

/* src/core/ui/components/ShapeLayoutEditor.svelte generated by Svelte v3.37.0 */

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[176] = list[i];
	child_ctx[178] = i;
	return child_ctx;
}

// (2425:8) {#each shapeNavList as item, index (item.id) }
function create_each_block$3(key_1, ctx) {
	let li;
	let button;
	let colorpreview;
	let t0;
	let span;
	let t1_value = /*item*/ ctx[176].name + "";
	let t1;
	let button_aria_label_value;
	let t2;
	let current;
	let mounted;
	let dispose;

	colorpreview = new ColorPreview({
			props: { color: /*item*/ ctx[176].color }
		});

	function click_handler(...args) {
		return /*click_handler*/ ctx[124](/*index*/ ctx[178], ...args);
	}

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			button = element("button");
			create_component(colorpreview.$$.fragment);
			t0 = space();
			span = element("span");
			t1 = text$1(t1_value);
			t2 = space();
			attr(button, "class", "PinturaShapeListItem");
			attr(button, "type", "button");
			attr(button, "aria-label", button_aria_label_value = "Select shape " + /*item*/ ctx[176].name);
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, button);
			mount_component(colorpreview, button, null);
			append(button, t0);
			append(button, span);
			append(span, t1);
			append(li, t2);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const colorpreview_changes = {};
			if (dirty[0] & /*shapeNavList*/ 524288) colorpreview_changes.color = /*item*/ ctx[176].color;
			colorpreview.$set(colorpreview_changes);
			if ((!current || dirty[0] & /*shapeNavList*/ 524288) && t1_value !== (t1_value = /*item*/ ctx[176].name + "")) set_data(t1, t1_value);

			if (!current || dirty[0] & /*shapeNavList*/ 524288 && button_aria_label_value !== (button_aria_label_value = "Select shape " + /*item*/ ctx[176].name)) {
				attr(button, "aria-label", button_aria_label_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(colorpreview.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(colorpreview.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			destroy_component(colorpreview);
			mounted = false;
			dispose();
		}
	};
}

// (2436:4) {#if shouldRenderShapeManipulator}
function create_if_block_2$2(ctx) {
	let shapemanipulator;
	let current;

	shapemanipulator = new ShapeManipulator({
			props: {
				visible: true,
				points: /*shapeManipulatorPoints*/ ctx[8],
				rotatorPoint: /*shapeManipulatorRotationPointPosition*/ ctx[14],
				enableResizing: /*allowedResizeControls*/ ctx[13],
				enableRotating: /*allowRotateControls*/ ctx[6]
			}
		});

	shapemanipulator.$on("resizestart", /*handleManipulatorResizeGrab*/ ctx[25]);
	shapemanipulator.$on("resizemove", /*handleManipulatorResizeDrag*/ ctx[26]);
	shapemanipulator.$on("resizeend", /*handleManipulatorResizeEnd*/ ctx[27]);
	shapemanipulator.$on("rotatestart", /*handleManipulatorRotateGrab*/ ctx[28]);
	shapemanipulator.$on("rotatemove", /*handleManipulatorRotateDrag*/ ctx[29]);
	shapemanipulator.$on("rotateend", /*handleManipulatorRotateEnd*/ ctx[30]);

	return {
		c() {
			create_component(shapemanipulator.$$.fragment);
		},
		m(target, anchor) {
			mount_component(shapemanipulator, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const shapemanipulator_changes = {};
			if (dirty[0] & /*shapeManipulatorPoints*/ 256) shapemanipulator_changes.points = /*shapeManipulatorPoints*/ ctx[8];
			if (dirty[0] & /*shapeManipulatorRotationPointPosition*/ 16384) shapemanipulator_changes.rotatorPoint = /*shapeManipulatorRotationPointPosition*/ ctx[14];
			if (dirty[0] & /*allowedResizeControls*/ 8192) shapemanipulator_changes.enableResizing = /*allowedResizeControls*/ ctx[13];
			if (dirty[0] & /*allowRotateControls*/ 64) shapemanipulator_changes.enableRotating = /*allowRotateControls*/ ctx[6];
			shapemanipulator.$set(shapemanipulator_changes);
		},
		i(local) {
			if (current) return;
			transition_in(shapemanipulator.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(shapemanipulator.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(shapemanipulator, detaching);
		}
	};
}

// (2451:4) {#if shouldRenderTextInput}
function create_if_block_1$2(ctx) {
	let inputform;
	let current;

	inputform = new InputForm({
			props: {
				panelOffset: /*offset*/ ctx[1],
				onconfirm: /*handleTextConfirm*/ ctx[36],
				oncancel: /*handleTextCancel*/ ctx[37],
				labelCancel: /*locale*/ ctx[3].shapeLabelInputCancel,
				iconCancel: /*locale*/ ctx[3].shapeIconInputCancel,
				labelConfirm: /*locale*/ ctx[3].shapeLabelInputConfirm,
				iconConfirm: /*locale*/ ctx[3].shapeIconInputConfirm,
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(inputform.$$.fragment);
		},
		m(target, anchor) {
			mount_component(inputform, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const inputform_changes = {};
			if (dirty[0] & /*offset*/ 2) inputform_changes.panelOffset = /*offset*/ ctx[1];
			if (dirty[0] & /*locale*/ 8) inputform_changes.labelCancel = /*locale*/ ctx[3].shapeLabelInputCancel;
			if (dirty[0] & /*locale*/ 8) inputform_changes.iconCancel = /*locale*/ ctx[3].shapeIconInputCancel;
			if (dirty[0] & /*locale*/ 8) inputform_changes.labelConfirm = /*locale*/ ctx[3].shapeLabelInputConfirm;
			if (dirty[0] & /*locale*/ 8) inputform_changes.iconConfirm = /*locale*/ ctx[3].shapeIconInputConfirm;

			if (dirty[0] & /*markupTextInputStyle, textInputText, textInput*/ 100352 | dirty[5] & /*$$scope*/ 16777216) {
				inputform_changes.$$scope = { dirty, ctx };
			}

			inputform.$set(inputform_changes);
		},
		i(local) {
			if (current) return;
			transition_in(inputform.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(inputform.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(inputform, detaching);
		}
	};
}

// (2452:4) <InputForm          panelOffset={offset}         onconfirm={handleTextConfirm}          oncancel={handleTextCancel}         labelCancel={locale.shapeLabelInputCancel}         iconCancel={locale.shapeIconInputCancel}         labelConfirm={locale.shapeLabelInputConfirm}         iconConfirm={locale.shapeIconInputConfirm}>
function create_default_slot$6(ctx) {
	let textarea;
	let mounted;
	let dispose;

	return {
		c() {
			textarea = element("textarea");
			attr(textarea, "style", /*markupTextInputStyle*/ ctx[16]);
			attr(textarea, "spellcheck", "false");
			attr(textarea, "autocorrect", "off");
			attr(textarea, "autocapitalize", "off");
			textarea.value = /*textInputText*/ ctx[15];
		},
		m(target, anchor) {
			insert(target, textarea, anchor);
			/*textarea_binding*/ ctx[125](textarea);

			if (!mounted) {
				dispose = [
					listen(textarea, "keydown", /*handleTextInputKeyDown*/ ctx[34]),
					listen(textarea, "keypress", /*handleTextInputAttempt*/ ctx[33]),
					listen(textarea, "keyup", /*handleTextInputKeyUp*/ ctx[35]),
					listen(textarea, "input", /*handleTextInput*/ ctx[32])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*markupTextInputStyle*/ 65536) {
				attr(textarea, "style", /*markupTextInputStyle*/ ctx[16]);
			}

			if (dirty[0] & /*textInputText*/ 32768) {
				textarea.value = /*textInputText*/ ctx[15];
			}
		},
		d(detaching) {
			if (detaching) detach(textarea);
			/*textarea_binding*/ ctx[125](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (2470:4) {#if $markupControlsOpacity > 0}
function create_if_block$2(ctx) {
	let div;
	let dynamiccomponenttree;
	let current;
	let mounted;
	let dispose;

	dynamiccomponenttree = new DynamicComponentTree_1({
			props: { items: /*shapeControls*/ ctx[18] }
		});

	return {
		c() {
			div = element("div");
			create_component(dynamiccomponenttree.$$.fragment);
			attr(div, "class", "PinturaShapeControls");
			attr(div, "style", /*markupControlsStyle*/ ctx[17]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(dynamiccomponenttree, div, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "measure", /*measure_handler_1*/ ctx[126]),
					action_destroyer(measurable.call(null, div))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			const dynamiccomponenttree_changes = {};
			if (dirty[0] & /*shapeControls*/ 262144) dynamiccomponenttree_changes.items = /*shapeControls*/ ctx[18];
			dynamiccomponenttree.$set(dynamiccomponenttree_changes);

			if (!current || dirty[0] & /*markupControlsStyle*/ 131072) {
				attr(div, "style", /*markupControlsStyle*/ ctx[17]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(dynamiccomponenttree.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dynamiccomponenttree.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(dynamiccomponenttree);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$e(ctx) {
	let div;
	let nav;
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t0;
	let t1;
	let t2;
	let interactable_action;
	let current;
	let mounted;
	let dispose;
	let each_value = /*shapeNavList*/ ctx[19];
	const get_key = ctx => /*item*/ ctx[176].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$3(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
	}

	let if_block0 = /*shouldRenderShapeManipulator*/ ctx[7] && create_if_block_2$2(ctx);
	let if_block1 = /*shouldRenderTextInput*/ ctx[9] && create_if_block_1$2(ctx);
	let if_block2 = /*$markupControlsOpacity*/ ctx[10] > 0 && create_if_block$2(ctx);

	return {
		c() {
			div = element("div");
			nav = element("nav");
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			attr(nav, "class", "PinturaShapeList");
			attr(nav, "data-visible", /*showShapeList*/ ctx[12]);
			attr(div, "class", "PinturaShapeEditor");
			attr(div, "tabindex", "0");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, nav);
			append(nav, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			append(div, t0);
			if (if_block0) if_block0.m(div, null);
			append(div, t1);
			if (if_block1) if_block1.m(div, null);
			append(div, t2);
			if (if_block2) if_block2.m(div, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(nav, "focusin", /*handleFocusIn*/ ctx[40]),
					listen(nav, "focusout", /*handleFocusOut*/ ctx[41]),
					listen(div, "keydown", /*handleKey*/ ctx[31]),
					listen(div, "nudge", /*handleNudge*/ ctx[39]),
					listen(div, "measure", /*measure_handler*/ ctx[123]),
					action_destroyer(measurable.call(null, div)),
					action_destroyer(nudgeable.call(null, div)),
					listen(div, "interactionstart", /*handleInteractionStart*/ ctx[21]),
					listen(div, "interactionupdate", /*handleInteractionUpdate*/ ctx[22]),
					listen(div, "interactionrelease", /*handleInteractionRelease*/ ctx[23]),
					listen(div, "interactionend", /*handleInteractionEnd*/ ctx[24]),
					action_destroyer(interactable_action = interactable.call(null, div, {
						drag: true,
						pinch: true,
						inertia: true,
						matchTarget: true,
						getEventPosition: /*interactable_function*/ ctx[127]
					}))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*shapeNavList, selectShape, markup*/ 524305) {
				each_value = /*shapeNavList*/ ctx[19];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
				check_outros();
			}

			if (!current || dirty[0] & /*showShapeList*/ 4096) {
				attr(nav, "data-visible", /*showShapeList*/ ctx[12]);
			}

			if (/*shouldRenderShapeManipulator*/ ctx[7]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*shouldRenderShapeManipulator*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*shouldRenderTextInput*/ ctx[9]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*shouldRenderTextInput*/ 512) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*$markupControlsOpacity*/ ctx[10] > 0) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*$markupControlsOpacity*/ 1024) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block$2(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (interactable_action && is_function(interactable_action.update) && dirty[0] & /*rootRect*/ 4) interactable_action.update.call(null, {
				drag: true,
				pinch: true,
				inertia: true,
				matchTarget: true,
				getEventPosition: /*interactable_function*/ ctx[127]
			});
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

const ROTATION_CONTROL_OFFSET = 20;
const MIN_TEXT_MARKUP_WIDTH = 10;
const shapeControlDist = 16;

function instance$e($$self, $$props, $$invalidate) {
	let activeMarkup;
	let activeShapeId;
	let activeMarkupComputed;
	let activeMarkupItemIsDraft;
	let shapeProps;
	let shapeActivePoints;
	let allowResizeControls;
	let allowRotateControls;
	let allowedResizeControls;
	let shouldRenderShapeManipulator;
	let shapeActiveScreenPoints;
	let shapeManipulatorPoints;
	let shapeManipulatorRotationPoint;
	let shapeManipulatorRotationPointPosition;
	let isTextMarkupSelected;
	let shouldRenderTextInput;
	let textShapeOrigin;
	let textShapeDisplayOrigin;
	let textSizeDisplayOrigin;
	let textRectDisplayOrigin;
	let textInputText;
	let markupTextInputStyle;
	let controlledMarkupItem;
	let allowShapeFlip;
	let allowShapeChangeTextLayout;
	let allowShapeDuplicate;
	let allowShapeRemove;
	let allowShapeReorder;
	let allowShapeInput;
	let allowShapeAdjustOpacity;
	let markupControlsAnchorPosition;
	let shapeControlsPosition;
	let markupControlsStyle;
	let shapeControls;
	let shapeNavList;
	let $keysPressedStored;
	let $markupControlsOpacity;
	let { uid = getUniqueId() } = $$props; // used to control manipulator lines
	let { ui } = $$props;
	let { markup } = $$props;
	let { offset } = $$props;
	let { contextRotation = 0 } = $$props;
	let { contextFlipX = false } = $$props;
	let { contextFlipY = false } = $$props;
	let { contextScale } = $$props;
	let { active = false } = $$props;
	let { opacity = 1 } = $$props;
	let { parentRect } = $$props;
	let { rootRect } = $$props;
	let { utilRect } = $$props;
	let { oninteractionstart = noop$1 } = $$props;
	let { oninteractionupdate = noop$1 } = $$props;
	let { oninteractionrelease = noop$1 } = $$props;
	let { oninteractionend = noop$1 } = $$props;
	let { onaddshape = noop$1 } = $$props;
	let { onupdateshape = noop$1 } = $$props;
	let { onselectshape = noop$1 } = $$props;
	let { onremoveshape = noop$1 } = $$props;
	let { beforeSelectShape = () => true } = $$props;
	let { beforeDeselectShape = () => true } = $$props;
	let { beforeRemoveShape = () => true } = $$props;
	let { beforeUpdateShape = (shape, props) => props } = $$props;
	let { willRenderShapeControls = passthrough } = $$props;
	let { mapEditorPointToImagePoint } = $$props;
	let { mapImagePointToEditorPoint } = $$props;
	let { eraseRadius = undefined } = $$props;
	let { selectRadius = undefined } = $$props;
	let { enableButtonFlipVertical = false } = $$props;
	let { enableTapToAddText = true } = $$props;
	let { locale } = $$props;

	//
	// Cache
	//
	const updateShape = (shape, props, parentRect) => {
		let propsToUpdate = beforeUpdateShape({ ...shape }, props, { ...parentRect });
		shapeUpdateProps(shape, propsToUpdate, parentRect);
	};

	//
	// Helpers
	//
	const circleOverlapsWithLine = (point, radius, from, to) => {
		const ac = vectorCreate(point.x - from.x, point.y - from.y);
		const ab = vectorCreate(to.x - from.x, to.y - from.y);
		const ab2 = vectorDot(ab, ab);
		const acab = vectorDot(ac, ab);
		let t = acab / ab2;
		t = t < 0 ? 0 : t;
		t = t > 1 ? 1 : t;
		const h = vectorCreate(ab.x * t + from.x - point.x, ab.y * t + from.y - point.y);
		const h2 = vectorDot(h, h);
		return h2 <= radius * radius;
	};

	const circleOverlapsWithPolygon = (position, radius, points) => {
		// if center is in polygon
		if (pointInPoly(position, points)) return true;

		const count = points.length;

		for (let i = 0; i < count - 1; i++) {
			if (circleOverlapsWithLine(position, radius, points[i], points[i + 1])) return true;
		}

		return circleOverlapsWithLine(position, radius, points[0], points[count - 1]);
	};

	const circleOverlapsWithEllipse = (position, radius, ellipse, rotation, flipX, flipY) => {
		const points = ellipseToPolygon(vectorCreate(ellipse.x, ellipse.y), ellipse.rx, ellipse.ry, rotation, flipX, flipY, 12);
		return circleOverlapsWithPolygon(position, radius, points);
	};

	const circleOverlapsWithRect = (position, radius, rect, rotation, pivot) => circleOverlapsWithPolygon(position, radius, rectRotate(rect, rotation, pivot || rectCenter(rect)));

	const shapeToPoly = (computedShape, resolution = 12) => {
		if (shapeIsRect(computedShape)) {
			return rectRotate(computedShape, computedShape.rotation, rectCenter(computedShape));
		} else if (shapeIsText(computedShape)) {
			const computedRect = getMarkupShapeRect(computedShape);
			return rectRotate(computedRect, computedShape.rotation, rectCenter(computedRect));
		} else if (shapeIsEllipse(computedShape)) {
			return ellipseToPolygon(vectorCreate(computedShape.x, computedShape.y), computedShape.rx, computedShape.ry, computedShape.rotation, computedShape.flipX, computedShape.flipY, resolution);
		}

		return [];
	};

	//
	// Shape creator
	//
	const keysPressedStored = getContext("keysPressed");

	component_subscribe($$self, keysPressedStored, value => $$invalidate(136, $keysPressedStored = value));

	const getShapeUpdateRotation = (rotation, flipX, flipY) => {
		if (rotation === 0) return rotation;
		if (flipX && flipY) return rotation;
		if (flipX) return -rotation;
		if (flipY) return -rotation;
		return rotation;
	};

	const createShape = (shapeDefault, options = {}) => {
		// state
		let interactionOrigin;

		let interactionRadius;
		let interactionPosition;
		let isEllipse = shapeIsEllipse(shapeDefault);
		let isText = shapeIsText(shapeDefault);
		let isRelative = options.position === "relative";

		if (shapeIsPath(shapeDefault)) {
			return {
				start: e => {
					const { origin } = e.detail;
					interactionRadius = 4;
					interactionOrigin = vectorClone(origin);
					interactionPosition = vectorClone(origin);
					const originPoint = mapEditorPointToImagePoint(origin);

					if (isRelative) {
						originPoint.x = isRelative
						? toPercentage(originPoint.x, parentRect.width)
						: originPoint.x;

						originPoint.y = isRelative
						? toPercentage(originPoint.y, parentRect.height)
						: originPoint.y;
					}

					// add to markup so it's drawn
					addMarkupItemDraft({ ...shapeDefault, points: [originPoint] });
				},
				update: e => {
					const draft = getMarkupItemDraft();
					const { translation } = e.detail;

					// position
					const pointerPosition = vectorCreate(interactionOrigin.x + translation.x, interactionOrigin.y + translation.y);

					// distance between interaction and pointer if it's too close, we don't draw this point
					const dist = vectorDistance(interactionPosition, pointerPosition);

					if (fixPrecision(dist, 5) <= interactionRadius) return;

					// get angle between interaction and pointer
					const angle = vectorAngleBetween(pointerPosition, interactionPosition);

					// move brush towards pointer at angle
					const moveDist = interactionRadius - dist;

					interactionPosition.x += moveDist * Math.cos(angle);
					interactionPosition.y += moveDist * Math.sin(angle);

					// create point
					const point = mapEditorPointToImagePoint(interactionPosition);

					if (point) {
						point.x = isRelative
						? toPercentage(point.x, parentRect.width)
						: point.x;

						point.y = isRelative
						? toPercentage(point.y, parentRect.height)
						: point.y;
					}

					draft.points = draft.points.concat(point);
					syncShapes();
				},
				release: e => e.detail.preventInertia(),
				end: e => {
					if (e.detail.isTap) return discardMarkupItemDraft();
					const shape = confirmMarkupItemDraft();
					onaddshape(shape);
				}
			};
		} else if (isEllipse || isText || shapeIsRect(shapeDefault)) {
			return {
				start: e => {
					const { origin } = e.detail;

					// need to remember origin so we can correctly apply interaction translation
					interactionOrigin = vectorClone(origin);

					const mappedOriginPosition = mapEditorPointToImagePoint(interactionOrigin);

					// add to markup so it's drawn
					const draft = {
						...shapeDefault,
						rotation: -1 * getShapeUpdateRotation(contextRotation, contextFlipX, contextFlipY),
						x: isRelative
						? toPercentage(mappedOriginPosition.x, parentRect.width)
						: mappedOriginPosition.x,
						y: isRelative
						? toPercentage(mappedOriginPosition.y, parentRect.height)
						: mappedOriginPosition.y
					};

					// de-flip shape
					draft.flipX = contextFlipX;

					draft.flipY = contextFlipY;

					// remove position
					delete draft.position;

					// hide initially
					draft.opacity = 0;

					// 
					if (isEllipse) {
						draft.rx = isRelative ? toPercentage(0) : 0;
						draft.ry = isRelative ? toPercentage(0) : 0;
					} else {
						draft.width = isRelative ? toPercentage(0) : 0;
						draft.height = isRelative ? toPercentage(0) : 0;
					}

					addMarkupItemDraft(draft);
				},
				update: e => {
					const draft = getMarkupItemDraft();
					draft.opacity = 1;
					const { aspectRatio } = draft;
					let { translation } = e.detail;

					// limit to aspect ratio
					if (aspectRatio) {
						const t = Math.abs(translation.x) * aspectRatio;
						translation.x = translation.x;
						translation.y = t * Math.sign(translation.y);
					}

					// position
					const pointerPosition = vectorCreate(interactionOrigin.x + translation.x, interactionOrigin.y + translation.y);

					const mappedOriginPosition = mapEditorPointToImagePoint(interactionOrigin);
					const mappedPointerPosition = mapEditorPointToImagePoint(pointerPosition);

					const pivot = {
						x: mappedOriginPosition.x + (mappedPointerPosition.x - mappedOriginPosition.x) * 0.5,
						y: mappedOriginPosition.y + (mappedPointerPosition.y - mappedOriginPosition.y) * 0.5
					};

					const rotation = getShapeUpdateRotation(contextRotation, contextFlipX, contextFlipY);
					vectorRotate(mappedOriginPosition, rotation, pivot);
					vectorRotate(mappedPointerPosition, rotation, pivot);
					const l = Math.min(mappedOriginPosition.x, mappedPointerPosition.x);
					const t = Math.min(mappedOriginPosition.y, mappedPointerPosition.y);
					const r = Math.max(mappedOriginPosition.x, mappedPointerPosition.x);
					const b = Math.max(mappedOriginPosition.y, mappedPointerPosition.y);
					let width = r - l;
					let height = b - t;
					let props = {};

					if (isEllipse) {
						props.x = l + width * 0.5;
						props.y = t + height * 0.5;
						props.rx = width * 0.5;
						props.ry = height * 0.5;
					} else {
						props.x = l;
						props.y = t;
						props.width = width;
						props.height = height;
					}

					updateShape(draft, props, parentRect);
					syncShapes();
				},
				release: e => {
					e.detail.preventInertia();
				},
				end: e => {
					const draft = getMarkupItemDraft();

					if (e.detail.isTap) {
						// will cancel if is not text shape
						if (!shapeIsText(draft) || !enableTapToAddText || interactionTarget) return discardMarkupItemDraft();

						// will add 'auto' text shape if not targetting other shape
						delete draft.width;

						delete draft.height;
						delete draft.textAlign;

						// position the shape correctly
						const draftComputedShape = shapeComputeDisplay({ ...draft }, parentRect);

						const size = textSize(draft.text, draftComputedShape);
						size.width *= contextScale;
						size.height *= contextScale;

						const mappedOriginPosition = mapEditorPointToImagePoint({
							x: interactionOrigin.x,
							y: interactionOrigin.y - size.height * 0.5
						});

						const mappedPointerPosition = mapEditorPointToImagePoint({
							x: interactionOrigin.x + size.width,
							y: interactionOrigin.y + size.height * 0.5
						});

						const pivot = {
							x: mappedOriginPosition.x + (mappedPointerPosition.x - mappedOriginPosition.x) * 0.5,
							y: mappedOriginPosition.y + (mappedPointerPosition.y - mappedOriginPosition.y) * 0.5
						};

						const rotation = getShapeUpdateRotation(contextRotation, contextFlipX, contextFlipY);
						vectorRotate(mappedOriginPosition, rotation, pivot);
						vectorRotate(mappedPointerPosition, rotation, pivot);
						const l = Math.min(mappedOriginPosition.x, mappedPointerPosition.x);
						const t = Math.min(mappedOriginPosition.y, mappedPointerPosition.y);

						draft.x = isString(draft.x)
						? toPercentage(l, parentRect.width)
						: l;

						draft.y = isString(draft.y)
						? toPercentage(t, parentRect.height)
						: t;
					}

					// reveal
					draft.opacity = 1;

					// finish markup
					if (!shapeIsText(draft)) {
						const shape = confirmMarkupItemDraft();
						onaddshape(shape);
					}

					// select the draft
					selectShape(draft);

					// also enable editing the text
					if (shapeIsText(draft)) editMarkupItem(draft);
				}
			};
		} else if (shapeIsLine(shapeDefault)) {
			return {
				start: e => {
					const { origin } = e.detail;
					const originMapped = mapEditorPointToImagePoint(origin);
					const originSnapped = vectorApply(originMapped, snapToPixel);
					interactionOrigin = vectorClone(origin);

					// add to markup so it's drawn
					addMarkupItemDraft({
						...shapeDefault,
						x1: isRelative
						? toPercentage(originSnapped.x, parentRect.width)
						: originSnapped.x,
						y1: isRelative
						? toPercentage(originSnapped.y, parentRect.height)
						: originSnapped.y,
						x2: isRelative
						? toPercentage(originSnapped.x, parentRect.width)
						: originSnapped.x,
						y2: isRelative
						? toPercentage(originSnapped.y, parentRect.height)
						: originSnapped.y,
						opacity: 0
					});
				},
				update: e => {
					const draft = getMarkupItemDraft();
					const { translation } = e.detail;
					const interactionTarget = vectorAdd(vectorClone(interactionOrigin), translation);

					// shift pressed
					if ($keysPressedStored.includes(16)) {
						const length = vectorDistance(interactionOrigin, interactionTarget);
						const angle = vectorAngleBetween(interactionOrigin, interactionTarget);
						const angleSnapInterval = Math.PI / 4;
						const angleSnapped = angleSnapInterval * Math.round(angle / angleSnapInterval);
						interactionTarget.x = interactionOrigin.x + length * Math.cos(angleSnapped);
						interactionTarget.y = interactionOrigin.y + length * Math.sin(angleSnapped);
					}

					// update line end position
					const point = mapEditorPointToImagePoint(interactionTarget);

					updateMarkupShape(draft, {
						x2: isRelative
						? toPercentage(point.x, parentRect.width)
						: point.x,
						y2: isRelative
						? toPercentage(point.y, parentRect.height)
						: point.y,
						opacity: 1
					});

					syncShapes();
				},
				release: e => e.detail.preventInertia(),
				end: e => {
					const draft = getMarkupItemDraft();
					if (e.detail.isTap) return discardMarkupItemDraft();
					draft.opacity = 1;

					// finish markup
					const shape = confirmMarkupItemDraft();

					onaddshape(shape);

					// select the draft
					selectShape(shape);
				}
			};
		}
	};

	const eraseShape = () => {
		let origin;
		let positionPrevious;

		return {
			start: e => {
				origin = e.detail.origin;
				positionPrevious = origin;
			},
			update: e => {
				const { translation } = e.detail;
				const positionCurrent = vectorCreate(origin.x + translation.x, origin.y + translation.y);
				const shapesThatCanBeErased = markup.filter(shape => !shape.disableErase);
				const shapesFound = getShapesBetweenPoints(shapesThatCanBeErased, mapEditorPointToImagePoint(positionPrevious), mapEditorPointToImagePoint(positionCurrent), eraseRadius);
				const shapesRemoved = removeMarkupItems(shapesFound);
				shapesRemoved.forEach(onremoveshape);
				positionPrevious = vectorClone(positionCurrent);
			},
			release: e => e.detail.preventInertia(),
			end: () => {
				
			}
		};
	};

	//
	// Mapping coordinates
	//
	const getImagePointWithScreenTranslation = (point, translation) => {
		const pointInScreenSpace = mapImagePointToEditorPoint(point);
		return mapEditorPointToImagePoint(vectorAdd(pointInScreenSpace, translation));
	};

	//
	// Interaction
	//
	// image zoom
	// const handleWheel = (e) => {
	// TODO: ZOOM image
	// }
	// image pan
	// const handleImagePan = (e) => {
	// TODO: PAN image
	// }
	//
	// markup manipulate
	//
	const translateShape = (shapeCurrent, shapeOriginComputed, translation) => {
		if (shapeIsLine(shapeCurrent)) {
			const beginImageOffset = getImagePointWithScreenTranslation(shapeLineGetStartPoint(shapeOriginComputed), translation);
			const endImageOffset = getImagePointWithScreenTranslation(shapeLineGetEndPoint(shapeOriginComputed), translation);

			updateShape(
				shapeCurrent,
				{
					x1: beginImageOffset.x,
					y1: beginImageOffset.y,
					x2: endImageOffset.x,
					y2: endImageOffset.y
				},
				parentRect
			);
		} else if (shapeIsRect(shapeCurrent) || shapeIsText(shapeCurrent) || shapeIsEllipse(shapeCurrent)) {
			const imagePoint = getImagePointWithScreenTranslation(shapeOriginComputed, translation);
			updateShape(shapeCurrent, imagePoint, parentRect);
		}

		syncShapes();
	};

	const IndexFlipXMap = { 0: 1, 1: 0, 2: 3, 3: 2 };
	const IndexFlipYMap = { 0: 3, 1: 2, 2: 1, 3: 0 };

	const resizeMarkup = (shapeCurrent, shapeOriginComputed, indexes, translation, options) => {
		if (shapeIsLine(shapeCurrent)) {
			const [targetIndex] = indexes;

			const snap = $keysPressedStored.includes(16)
			? (origin, target) => {
					const length = vectorDistance(origin, target);
					const angle = vectorAngleBetween(origin, target);
					const angleSnapInterval = Math.PI / 4;
					const angleSnapped = angleSnapInterval * Math.round(angle / angleSnapInterval) - contextRotation % angleSnapInterval;
					target.x = origin.x + length * Math.cos(angleSnapped);
					target.y = origin.y + length * Math.sin(angleSnapped);
				}
			: (origin, target) => target;

			if (targetIndex === 0) {
				const point = getImagePointWithScreenTranslation(shapeLineGetStartPoint(shapeOriginComputed), translation);
				snap(vectorCreate(shapeOriginComputed.x2, shapeOriginComputed.y2), point);
				updateShape(shapeCurrent, { x1: point.x, y1: point.y }, parentRect);
			} else if (targetIndex === 1) {
				const point = getImagePointWithScreenTranslation(shapeLineGetEndPoint(shapeOriginComputed), translation);
				snap(vectorCreate(shapeOriginComputed.x1, shapeOriginComputed.y1), point);
				updateShape(shapeCurrent, { x2: point.x, y2: point.y }, parentRect);
			}
		} else if (shapeHasSize(shapeCurrent) || shapeIsEllipse(shapeCurrent) || shapeIsTextBox(shapeCurrent)) {
			let hasAutoHeight = false;
			let shapeOriginRect;

			if (shapeIsEllipse(shapeCurrent)) {
				shapeOriginRect = rectCreateFromEllipse(shapeOriginComputed);
			} else if (shapeHasSize(shapeCurrent)) {
				shapeOriginRect = rectCreateFromAny(shapeOriginComputed);
			} else {
				// is text with 'width' only
				hasAutoHeight = true;

				shapeOriginRect = rectCreateFromAny(shapeOriginComputed);
				const size = textSize(shapeOriginComputed.text, shapeOriginComputed);
				shapeOriginRect.height = size.height;
			}

			let shapeAspectRatio;

			if (shapeCurrent.aspectRatio) {
				shapeAspectRatio = shapeCurrent.aspectRatio;
			} else if (options.shiftKey && !hasAutoHeight) {
				shapeAspectRatio = shapeOriginRect.width / shapeOriginRect.height;
			}

			// current shape
			const rectAligned = rectCreateFromAny(shapeOriginRect);

			const rectAlignedCenterPosition = rectCenter(rectAligned);
			const rectRotation = shapeCurrent.rotation;
			const rectAlignedCorners = rectGetCorners(rectAligned);
			const rectCorners = rectRotate(rectAligned, rectRotation);

			// is translating one corner
			if (indexes.length === 1) {
				// corner
				let cornerIndex = indexes[0];

				if (shapeCurrent.flipX) cornerIndex = IndexFlipXMap[cornerIndex];
				if (shapeCurrent.flipY) cornerIndex = IndexFlipYMap[cornerIndex];
				const [tl, tr, br, bl] = rectAlignedCorners;
				const screenTargetPosition = mapImagePointToEditorPoint(rectCorners[cornerIndex]);
				vectorAdd(screenTargetPosition, translation);
				const imageTargetPosition = mapEditorPointToImagePoint(screenTargetPosition);
				const imageTargetTranslation = vectorCreate(imageTargetPosition.x - rectCorners[cornerIndex].x, imageTargetPosition.y - rectCorners[cornerIndex].y);

				// if (shapeCurrent.flipX) imageTargetTranslation.x = -imageTargetTranslation.x;
				// if (shapeCurrent.flipY) imageTargetTranslation.y = -imageTargetTranslation.y;
				const imageTargetTranslationAligned = vectorRotate(vectorClone(imageTargetTranslation), -rectRotation);

				const imageTargetPositionAligned = vectorCreate(rectAlignedCorners[cornerIndex].x + imageTargetTranslationAligned.x, rectAlignedCorners[cornerIndex].y + imageTargetTranslationAligned.y);
				let anchor;
				if (cornerIndex === 0) anchor = br;
				if (cornerIndex === 1) anchor = bl;
				if (cornerIndex === 2) anchor = tl;
				if (cornerIndex === 3) anchor = tr;

				// create an aligned and updated rectangle
				const rectAlignedResized = rectCreateFromPoints(anchor, imageTargetPositionAligned);

				// limit rect
				if (shapeAspectRatio) {
					// get size that adheres to aspect ratio but still fits current rectangle
					const { width, height } = rectContainRect(rectAlignedResized, shapeAspectRatio);

					const [t, r, b, l] = rectToBounds(rectAlignedResized);

					// update size
					rectAlignedResized.width = width;

					rectAlignedResized.height = height;

					// align to anchor
					if (imageTargetPositionAligned.y < anchor.y) {
						rectAlignedResized.y = b - height;
					}

					if (imageTargetPositionAligned.x < anchor.x) {
						rectAlignedResized.x = r - width;
					}
				}

				// rotate the aligned rectangle around it's original pivot point
				const rr = rectRotate(rectAlignedResized, rectRotation, rectAlignedCenterPosition);

				// now calculate the new center and then rotate the tl and br corners around that center to find their new positions
				const rrc = vectorCenter(rr);

				const p1 = vectorRotate(rr[0], -rectRotation, rrc);
				const p2 = vectorRotate(rr[2], -rectRotation, rrc);

				// if (shapeCurrent.flipX || shapeCurrent.flipY) {
				//     vectorsFlip([p1, p2], shapeCurrent.flipX, shapeCurrent.flipY, rectAlignedCenterPosition.x, rectAlignedCenterPosition.y)
				// }
				const rectUpdated = rectCreateFromPoints(p1, p2);

				updateShape(
					shapeCurrent,
					shapeIsEllipse(shapeCurrent)
					? ellipseCreateFromRect(rectUpdated)
					: rectUpdated,
					parentRect
				);
			} else // is translating two corner points
			{
				// 0-1 -> 2-3
				// 1-2 -> 3-0
				// 2-3 -> 0-1
				// 3-0 -> 1-2
				indexes = indexes.map(index => {
					if (shapeCurrent.flipX) index = IndexFlipXMap[index];
					if (shapeCurrent.flipY) index = IndexFlipYMap[index];
					return index;
				});

				const [cornerA, cornerB] = indexes.map(index => rectCorners[index]);

				const mid = {
					x: cornerA.x + (cornerB.x - cornerA.x) * 0.5,
					y: cornerA.y + (cornerB.y - cornerA.y) * 0.5
				};

				const [cornerAlignedA, cornerAlignedB] = indexes.map(index => rectAlignedCorners[index]);

				const [cornerAlignedC, cornerAlignedD] = indexes.map(index => {
					const mappedIndex = index + 2;
					if (mappedIndex < 4) return rectAlignedCorners[mappedIndex];
					return rectAlignedCorners[mappedIndex - 4];
				});

				// const midAligned = {
				//     x: cornerAlignedA.x + (cornerAlignedB.x - cornerAlignedA.x) * .5,
				//     y: cornerAlignedA.y + (cornerAlignedB.y - cornerAlignedA.y) * .5
				// };
				const midAnchorAligned = {
					x: cornerAlignedC.x + (cornerAlignedD.x - cornerAlignedC.x) * 0.5,
					y: cornerAlignedC.y + (cornerAlignedD.y - cornerAlignedC.y) * 0.5
				};

				const screenTargetPosition = mapImagePointToEditorPoint(mid);
				vectorAdd(screenTargetPosition, translation);
				const imageTargetPosition = mapEditorPointToImagePoint(screenTargetPosition);
				const imageTargetTranslation = vectorCreate(imageTargetPosition.x - mid.x, imageTargetPosition.y - mid.y);

				// if (shapeCurrent.flipX) imageTargetTranslation.x = -imageTargetTranslation.x;
				// if (shapeCurrent.flipY) imageTargetTranslation.y = -imageTargetTranslation.y;
				const imageTargetTranslationAligned = vectorRotate(vectorClone(imageTargetTranslation), -rectRotation);

				// const imageTargetPositionAligned = vectorCreate(
				//     midAligned.x + imageTargetTranslationAligned.x,
				//     midAligned.y + imageTargetTranslationAligned.y,
				// );
				const d = vectorSubtract(vectorClone(cornerAlignedA), cornerAlignedB);

				const f = vectorApply(d, v => 1 - Math.abs(Math.sign(v)));
				const t = vectorCreate(imageTargetTranslationAligned.x * f.x, imageTargetTranslationAligned.y * f.y);
				vectorAdd(cornerAlignedA, t);
				vectorAdd(cornerAlignedB, t);
				const rectAlignedResized = rectCreateFromPoints(rectAlignedCorners);

				// limit rect
				if (shapeAspectRatio) {
					let width = rectAlignedResized.width;
					let height = rectAlignedResized.height;

					if (f.y === 0) {
						height = width / shapeAspectRatio;
					} else {
						width = height * shapeAspectRatio;
					}

					// update size
					rectAlignedResized.width = width;

					rectAlignedResized.height = height;

					// align to anchor
					if (f.y === 0) {
						rectAlignedResized.y = midAnchorAligned.y - height * 0.5;
					} else {
						rectAlignedResized.x = midAnchorAligned.x - width * 0.5;
					}
				}

				// rotate the aligned rectangle around it's original pivot point
				const rr = rectRotate(rectAlignedResized, rectRotation, rectAlignedCenterPosition);

				// now calculate the new center and then rotate the tl and br corners around that center to find their new positions
				const rrc = vectorCenter(rr);

				const p1 = vectorRotate(rr[0], -rectRotation, rrc);
				const p2 = vectorRotate(rr[2], -rectRotation, rrc);

				// if (shapeCurrent.flipX || shapeCurrent.flipY) {
				//     vectorsFlip([p1, p2], shapeCurrent.flipX, shapeCurrent.flipY, rectAlignedCenterPosition.x, rectAlignedCenterPosition.y)
				// }
				const rectUpdated = rectCreateFromPoints(p1, p2);

				let props;

				if (shapeIsEllipse(shapeCurrent)) {
					props = ellipseCreateFromRect(rectUpdated);
				} else if (shapeHasSize(shapeCurrent)) {
					props = rectUpdated;
				} else if (hasAutoHeight) {
					props = {
						x: rectUpdated.x,
						y: rectUpdated.y,
						width: rectUpdated.width
					};
				}

				updateShape(shapeCurrent, props, parentRect);
			}
		}

		syncShapes();
	};

	let rotatorInitialPosition;

	const rotateMarkup = (shapeCurrent, shapeOriginComputed, translation, options) => {
		// calculate angle between translated rotation control and origin
		const shapeRect = getMarkupShapeRect(shapeComputeDisplay(shapeDeepCopy(shapeCurrent), parentRect));

		const shapeCenter = rectCenter(shapeRect);
		const p = getImagePointWithScreenTranslation(rotatorInitialPosition, translation);
		let shapeRotation = vectorAngleBetween(p, shapeCenter) + Math.PI / 2;

		if (options.shiftKey) {
			const rotatorSnapInterval = Math.PI / 16;
			shapeRotation = rotatorSnapInterval * Math.round(shapeRotation / rotatorSnapInterval) - contextRotation % rotatorSnapInterval;
		}

		updateShape(shapeCurrent, { rotation: shapeRotation }, parentRect);
		syncShapes();
	};

	const getMarkupItemDraft = () => {
		if (!markup.length) return;
		return markup.find(shapeIsDraft);
	};

	const getMarkupItemDraftIndex = () => {
		if (!markup.length) return;
		return markup.findIndex(shapeIsDraft);
	};

	const addMarkupItemDraft = (shape, sync = true) => {
		if (getMarkupItemDraft()) return;
		shapeMakeDraft(shape);
		return addShape(shape, sync);
	};

	const confirmMarkupItemDraft = () => {
		const markupItem = getMarkupItemDraft();
		if (!markupItem) return;
		shapeMakeFinal(markupItem);
		syncShapes();
		return markupItem;
	};

	const discardMarkupItemDraft = () => {
		if (!getMarkupItemDraft()) return;
		markup.splice(getMarkupItemDraftIndex(), 1);
		syncShapes();
	};

	const createMarkupItem = (props = {}) => ({ id: getUniqueId(), ...props });
	const syncShapes = () => $$invalidate(0, markup);

	const addShape = (shape, sync = true) => {
		markup.push(shape);

		// sync markup array
		if (sync) syncShapes();

		return shape;
	};

	const removeMarkupShapeProps = (shape, props = [], sync = true) => {
		props.forEach(prop => delete shape[prop]);

		// sync markup array
		if (!sync) return;

		syncShapes();
	};

	const updateMarkupShape = (shape, props, sync = true) => {
		// update markup
		shape = Object.assign(shape, props);

		// sync markup array
		if (!sync) return;

		syncShapes();
	};

	const updateMarkupShapeProperty = (shape, name, value, sync = true) => {
		shape[name] = value;

		// sync markup array
		if (!sync) return;

		syncShapes();
	};

	const updateMarkupItemsShapeProperty = (name, value, sync = true) => {
		markup.forEach(shape => updateMarkupShapeProperty(shape, name, value, false));

		// sync markup array
		if (!sync) return;

		syncShapes();
	};

	const updateMarkupShapeItems = (props, sync = true) => {
		markup.forEach(markupItem => updateMarkupShape(markupItem, props, false));

		// sync markup array
		if (!sync) return;

		syncShapes();
	};

	const getActiveMarkupItem = () => [...markup].reverse().find(shapeIsSelected);
	const hasActiveMarkupItem = () => !!getActiveMarkupItem();

	const removeShape = (shapeToRemove, sync = true) => {
		if (!beforeRemoveShape(shapeToRemove)) return false;
		const markupWithoutShape = markup.filter(shape => shape !== shapeToRemove);
		onremoveshape(shapeToRemove);
		if (!sync) return;
		$$invalidate(0, markup = markupWithoutShape);
	};

	const removeActiveMarkupItem = () => {
		const activeShape = getActiveMarkupItem();
		if (!activeShape) return;

		// get removable markup items, 
		const removableShapes = markup.filter(shape => shapeCanRemove(shape) && shapeCanSelect(shape));

		// find index of active shape so we can select the next active shape on removal
		const index = removableShapes.findIndex(shape => shape === activeShape);

		// remove the active ship from the shape array
		const didRemove = removeShape(activeShape);

		if (didRemove === false) return;

		// remember selection
		previousSelectedShape = activeShape;

		// if no more markup items, release active shape
		if (removableShapes.length - 1 <= 0) return blurShapes();

		// select next active markup item
		const indexNext = index - 1 < 0 ? removableShapes.length - 1 : index - 1;

		selectShape(removableShapes[indexNext]);
	};

	let previousSelectedShape = undefined;

	const blurShapes = () => {
		// clear text state cache, when a text shape is blurred the changes are confirmed
		Object.keys(ShapeTextStateCache).forEach(key => ShapeTextStateCache[key] = {});

		previousSelectedShape = getSelectedShape();
		updateMarkupShapeItems({ isSelected: false, isEditing: false });
	};

	const getSelectedShape = () => markup.find(shapeIsSelected);

	const selectShape = (shape, sync = true) => {
		// can't select draft
		if (shapeIsDraft(shape)) return;

		// get currently selected shape
		const selectedShape = getSelectedShape() || previousSelectedShape;

		// reset previous selected shape
		previousSelectedShape = undefined;

		// if is returned false will cancel select operation
		if (!beforeSelectShape(selectedShape, shape)) return;

		// remove selected state from other markup
		blurShapes();

		// select
		shapeSelect(shape);

		// selected this shape
		onselectshape(shape);

		// sync
		if (!sync) return;

		syncShapes();
	};

	const deselectMarkupItem = markupItem => {
		updateMarkupShape(markupItem, { isSelected: false, isEditing: false });
	};

	const editMarkupItem = markupItem => {
		updateMarkupShape(markupItem, { isSelected: true, isEditing: true });
	};

	const finishEditMarkupItem = markupItem => {
		updateMarkupShape(markupItem, { isSelected: true, isEditing: false });
	};

	const removeMarkupItems = shapesToRemove => {
		const shapesToRemoveFiltered = shapesToRemove.filter(beforeRemoveShape);
		$$invalidate(0, markup = markup.filter(shape => !shapesToRemoveFiltered.includes(shape)));
		return shapesToRemoveFiltered;
	};

	const getTextShapeRect = shape => {
		const size = textSize(shape.text, shape);

		return rectCreate(
			shape.x,
			shape.y,
			shape.width
			? Math.min(shape.width, size.width)
			: size.width,
			shape.height
			? Math.min(shape.height, size.height)
			: size.height
		);
	};

	const getMarkupShapeRect = shape => {
		// has own rect
		if (shapeHasSize(shape)) return rectCreateFromAny(shape);

		if (shapeIsEllipse(shape)) return rectCreateFromEllipse(shape);

		// calculate the size on canvas
		const rect = getTextShapeRect(shape);

		rect.width = Math.max(MIN_TEXT_MARKUP_WIDTH, shape.width || rect.width);
		return rect;
	};

	const getShapesNearPosition = (position, range = 0) => [...markup].// reverse the array, want to select from top to bottom
	reverse().map(shape => ({ shape, priority: 1 })).// can't select paths
	filter(result => shapeCanSelect(result.shape)).// find markup near pointer
	filter(result => {
		// get shape
		const { shape } = result;

		// we need to know where the shape will end up
		const computedShape = shapeComputeDisplay(shapeDeepCopy(shape), parentRect);

		// add stroke width to range
		const r = range + (computedShape.strokeWidth || 0);

		// test if clicked in rect
		if (shapeIsRect(computedShape)) {
			return circleOverlapsWithRect(position, r, computedShape, shape.rotation);
		} else if (shapeIsText(computedShape)) {
			const shapeRect = getMarkupShapeRect(computedShape);
			const isPositionInBounds = circleOverlapsWithRect(position, r, shapeRect, shape.rotation);
			let isPositionInVisual = false;

			if (isPositionInBounds && !shapeIsSelected(shape)) {
				const visualRect = getTextShapeRect(computedShape);

				if (shape.textAlign === "right" && !shape.flipX) {
					visualRect.x = shapeRect.x + shapeRect.width - visualRect.width;
				}

				if (shape.textAlign === "center") {
					visualRect.x = shapeRect.x + shapeRect.width * 0.5 - visualRect.width * 0.5;
				}

				isPositionInVisual = circleOverlapsWithRect(position, r, visualRect, shape.rotation, rectCenter(shapeRect));
				if (!isPositionInVisual) result.priority = -1;
			}

			return isPositionInBounds;
		} else // test if is ellipse
		if (shapeIsEllipse(computedShape)) {
			return circleOverlapsWithEllipse(position, r, computedShape, shape.rotation, shape.flipX, shape.flipY);
		} else // test if clicked on line
		if (shapeIsLine(computedShape)) {
			// radius around click position, test if line intersects
			return circleOverlapsWithLine(position, Math.max(16, r), shapeLineGetStartPoint(computedShape), shapeLineGetEndPoint(computedShape)); // always increase range when selecting lines
		}

		return false;
	}).sort((a, b) => {
		if (a.priority < b.priority) return 1;
		if (a.priority > b.priority) return -1;
		return 0;
	});

	const getShapesBetweenPoints = (shapes, a, b, range = 0) => {
		// make sure range is not negative
		const r = Math.abs(range);

		// eraseLine should be in image space
		const eraseLine = lineExtend(lineCreate(a, b), r);

		// create line polygon
		const erasePoly = lineExtrude(eraseLine, r);

		// loop over shapes and find intersecting shapes
		return shapes.// .filter(shapeCanErase)
		filter(shape => {
			const computedShape = shapeComputeDisplay(shapeDeepCopy(shape), parentRect);

			// if shape is line or path
			if (shapeIsLine(computedShape) || shapeIsPath(computedShape)) return !!linePointsIntersection(eraseLine, getMarkupShapePoints(computedShape));

			// else turn into polygon and compare polygons
			return polyIntersectsWithPoly(erasePoly, shapeToPoly(computedShape));
		});
	};

	//
	// Generic interaction
	//
	let interactionTimer = undefined;

	let interactionTarget = undefined;
	let interactionShape = undefined;
	let interactionShapeOrigin = undefined;
	let interactionShapeOriginComputed = undefined;
	let isInteracting = false;

	const handleInteractionStart = e => {
		const { origin } = e.detail;
		interactionShape = undefined;
		interactionShapeOrigin = undefined;
		interactionShapeOriginComputed = undefined;
		interactionTarget = undefined;
		clearTimeout(interactionTimer);
		interactionTimer = setTimeout(() => $$invalidate(99, isInteracting = true), 250);

		// if is editing text
		const draft = getMarkupItemDraft();

		if (draft) confirmMarkupItemDraft();

		// test if target is a shape, if not, run interaction handler
		const point = mapEditorPointToImagePoint(vectorClone(origin));

		const foundShapes = getShapesNearPosition(point, selectRadius);
		const targettedMarkupItem = foundShapes.length && foundShapes.shift().shape;

		// check if markup was targetted
		if (targettedMarkupItem && shapeIsSelected(targettedMarkupItem)) {
			interactionShape = targettedMarkupItem;

			// create a deep copy so we can check on end interaction if the shape was changed
			interactionShapeOrigin = shapeDeepCopy(interactionShape);

			// clone shape we're interacting with so we can update it properly
			interactionShapeOriginComputed = shapeComputeDisplay(shapeDeepCopy(interactionShape), parentRect);

			return;
		}

		// set target
		interactionTarget = targettedMarkupItem;

		// started interacting
		const didStartInteraction = oninteractionstart(e);

		// drag current targetted it as fallback interaction, helps make sticker interaction easier
		if (!didStartInteraction && targettedMarkupItem) {
			selectShape(targettedMarkupItem);
			interactionShape = targettedMarkupItem;

			// create a deep copy so we can check on end interaction if the shape was changed
			interactionShapeOrigin = shapeDeepCopy(interactionShape);

			// clone shape we're interacting with so we can update it properly
			interactionShapeOriginComputed = shapeComputeDisplay(shapeDeepCopy(interactionShape), parentRect);
		}
	};

	const handleInteractionUpdate = e => {
		// is interacting with shape
		if (interactionShape) {
			// prevent moving if not allowed
			if (!shapeCanMove(interactionShape)) return;

			// prevent moving if is editing text
			if (shapeIsTextEditing(interactionShape)) return;

			return translateShape(interactionShape, interactionShapeOriginComputed, e.detail.translation);
		}

		oninteractionupdate(e);
	};

	const handleInteractionRelease = e => {
		clearTimeout(interactionTimer);
		$$invalidate(99, isInteracting = false);

		// test if is text and if we double tapped, if so, switch to text edit mode
		if (interactionShape) {
			if (interactionShape.isEditing) {
				handleTextCancel();
			} else if (e.detail.isDoubleTap && shapeIsText(interactionShape) && shapeCanInput(interactionShape) !== false) {
				editMarkupItem(interactionShape);
			}

			return;
		}

		oninteractionrelease(e);
	};

	const handleInteractionEnd = e => {
		const isSelectInteraction = interactionTarget && e.detail.isTap;

		// shape remains active so user can resize, rotate
		if (interactionShape) {
			if (!shapeEqual(interactionShape, interactionShapeOrigin)) onupdateshape(interactionShape);
			interactionShape = undefined;
			return;
		}

		// can we deselect the current shape?
		const currentSelectedShape = getSelectedShape();

		const allowDeselectShape = currentSelectedShape
		? beforeDeselectShape(currentSelectedShape, interactionTarget)
		: true;

		if (allowDeselectShape) {
			blurShapes();
		}

		oninteractionend(e);

		if (allowDeselectShape && isSelectInteraction) {
			selectShape(interactionTarget);
		}
	};

	//
	// Shape manipulation
	//
	const getMarkupShapePoints = shape => {
		let points;

		if (shapeIsRect(shape)) {
			const center = rectCenter(shape);
			points = rectGetCorners(shape);
			if (shape.flipX || shape.flipY) vectorsFlip(points, shape.flipX, shape.flipY, center.x, center.y);
			points = vectorsRotate(points, shape.rotation, center.x, center.y);
		} else if (shapeIsEllipse(shape)) {
			const center = shape;
			points = rectGetCorners(rectCreateFromEllipse(shape));
			if (shape.flipX || shape.flipY) vectorsFlip(points, shape.flipX, shape.flipY, center.x, center.y);
			points = vectorsRotate(points, shape.rotation, center.x, center.y);
		} else if (shapeIsLine(shape)) {
			points = [shapeLineGetStartPoint(shape), shapeLineGetEndPoint(shape)];
		} else if (shapeIsPath(shape)) {
			points = [...shape.points];
		} else if (shapeIsText(shape)) {
			const rect = getMarkupShapeRect(shape);
			rect.width = Math.max(MIN_TEXT_MARKUP_WIDTH, rect.width);
			const center = rectCenter(rect);
			points = rectGetCorners(rect);
			if (shape.flipX || shape.flipY) vectorsFlip(points, shape.flipX, shape.flipY, center.x, center.y);
			points = vectorsRotate(points, shape.rotation, center.x, center.y);
		}

		return points;
	};

	const getShapeRotationPoint = shape => {
		const points = getMarkupShapePoints(shape);
		let origin;
		let dir;

		if (shape.flipY) {
			origin = vectorCenter([points[0], points[1]]);
			dir = vectorNormalize(vectorCreate(points[1].x - points[2].x, points[1].y - points[2].y));
		} else {
			origin = vectorCenter([points[2], points[3]]);
			dir = vectorNormalize(vectorCreate(points[2].x - points[1].x, points[2].y - points[1].y));
		}

		vectorMultiply(dir, ROTATION_CONTROL_OFFSET / contextScale);
		return { origin, dir };
	};

	const getShapeRotationPointOnScreen = shape => {
		const markupPoint = getShapeRotationPoint(shape);

		const screenPosition = mapImagePointToEditorPoint({
			x: markupPoint.origin.x + markupPoint.dir.x,
			y: markupPoint.origin.y + markupPoint.dir.y
		});

		const screenOrigin = mapImagePointToEditorPoint(markupPoint.origin);

		return {
			origin: screenOrigin,
			position: screenPosition
		};
	};

	// draw shape manipulator edges
	let shapeManipulatorUid = `markup-manipulator-segment`;

	const claimManipulatorLines = () => {
		$$invalidate(42, ui = ui.map(shape => {
			if (shape.id !== shapeManipulatorUid) return shape;
			shape._group = uid;
			return shape;
		}));
	};

	const shouldManipulateLines = () => !!ui.find(segment => segment._group === uid);

	const redrawManipulatorLines = opacity => {
		// get current line opacity
		const current = ui.find(segment => segment.id === shapeManipulatorUid);

		const manipulatorOpacity = current ? Math.max(current.opacity, opacity) : opacity;

		// create manipulator outline segments
		[...shapeActiveScreenPoints, shapeActiveScreenPoints[0]];
		const segments = [];
		const shadowOpacity = 0.1 * manipulatorOpacity;
		const lineOpacity = manipulatorOpacity;
		const strokeColorShadow = [0, 0, 0];
		const strokeColor = [1, 1, 1];
		const strokeWidth = 1.5;

		// shadows
		segments.push({
			id: shapeManipulatorUid,
			points: shapeActiveScreenPoints.map(p => vectorCreate(p.x + 1, p.y + 1)),
			pathClose: true,
			strokeColor: strokeColorShadow,
			strokeWidth: 2,
			opacity: shadowOpacity,
			_group: uid
		});

		if (shapeManipulatorRotationPoint) {
			// add rotator line shadow
			segments.push({
				id: shapeManipulatorUid,
				points: [
					vectorCreate(shapeManipulatorRotationPoint.origin.x + 1, shapeManipulatorRotationPoint.origin.y + 1),
					vectorCreate(shapeManipulatorRotationPoint.position.x + 1, shapeManipulatorRotationPoint.position.y + 1)
				],
				strokeColor: strokeColorShadow,
				strokeWidth: 2,
				opacity: shadowOpacity,
				_group: uid
			});
		}

		// lines
		segments.push({
			id: shapeManipulatorUid,
			points: shapeActiveScreenPoints,
			pathClose: true,
			strokeColor,
			strokeWidth,
			opacity: lineOpacity,
			_group: uid
		});

		if (shapeManipulatorRotationPoint) {
			// add rotator line
			segments.push({
				id: shapeManipulatorUid,
				points: [
					{
						x: shapeManipulatorRotationPoint.origin.x,
						y: shapeManipulatorRotationPoint.origin.y
					},
					{
						x: shapeManipulatorRotationPoint.position.x,
						y: shapeManipulatorRotationPoint.position.y
					}
				],
				strokeColor,
				strokeWidth,
				opacity: lineOpacity,
				_group: uid
			});
		}

		// replace existing segments
		$$invalidate(42, ui = [...ui.filter(guide => guide.id !== shapeManipulatorUid), ...segments]);
	};

	const removeMarkupManipulatorLines = () => {
		$$invalidate(42, ui = ui.filter(guide => guide.opacity === 0 && guide.id !== shapeManipulatorUid));
	};

	onDestroy(() => {
		// clean up invisible lines
		removeMarkupManipulatorLines();
	});

	const handleManipulatorResizeGrab = e => {
		$$invalidate(99, isInteracting = true);
		interactionShape = activeMarkup;
		interactionShapeOriginComputed = activeMarkupComputed;
	};

	const handleManipulatorResizeDrag = e => {
		const { translation, indexes, shiftKey } = e.detail;
		resizeMarkup(interactionShape, interactionShapeOriginComputed, indexes, translation, { shiftKey });
	};

	const handleManipulatorResizeEnd = e => {
		selectShape(interactionShape);
		interactionShape = undefined;
		$$invalidate(99, isInteracting = false);
		onupdateshape(activeMarkup);
	};

	const handleManipulatorRotateGrab = e => {
		rotatorInitialPosition = getShapeRotationPoint(activeMarkupComputed).origin;
		$$invalidate(99, isInteracting = true);
		interactionShape = activeMarkup;
		interactionShapeOriginComputed = activeMarkupComputed;
	};

	const handleManipulatorRotateDrag = e => {
		const { translation, shiftKey } = e.detail;
		rotateMarkup(interactionShape, interactionShapeOriginComputed, translation, { shiftKey });
	};

	const handleManipulatorRotateEnd = () => {
		selectShape(interactionShape);
		interactionShape = undefined;
		$$invalidate(99, isInteracting = false);
		onupdateshape(activeMarkup);
	};

	//
	// Keyboard
	//
	const handleKey = e => {
		// only handle key input if a shape has been selected
		if (!hasActiveMarkupItem()) return;

		// get key type
		const { key } = e;

		// if is escape deselect active item
		if ((/escape/i).test(key)) {
			return deselectMarkupItem(activeMarkup);
		}

		// if is tab, select next markup item
		/*
if (/arrow/i.test(key)) {
    const success = e.shiftKey 
        ? selectPreviousMarkupItem(activeMarkup)
        : selectNextMarkupItem(activeMarkup);
    
    if (success) {
        e.preventDefault();
        e.stopPropagation();
    }
}
*/
		// if is remove active
		if ((/backspace/i).test(key) && !(/input|textarea/i).test(e.target.nodeName)) {
			// prevent back navigation on Firefox
			e.preventDefault();

			// remove the item
			removeActiveMarkupItem();
		}
	};

	//
	// Text input
	//
	let textInput;

	const getTextShapeOriginSnapshot = () => ({ ...activeMarkup });

	const handleTextInput = () => {
		const value = shapeIsTextLine(activeMarkup)
		? filterNewlines(textInput.value)
		: textInput.value;

		const canInput = shapeCanInput(activeMarkup, value);
		const text = canInput === true ? value : canInput;
		let x = textShapeDisplayOrigin.x;
		let y = textShapeDisplayOrigin.y;

		// if does not have height we need to adjust offset if is rotated
		if (!activeMarkup.height) {
			// draw origin rect
			const originRotatedRect = rectRotate({ ...textRectDisplayOrigin }, activeMarkup.rotation);

			// draw current rect
			const size = textSize(text, activeMarkupComputed);

			const currentRotatedRect = rectRotate({ x, y, ...size }, activeMarkup.rotation);
			const [originTopLeft, ,originBottomRight] = originRotatedRect;
			const [currentTopLeft, ,currentBottomRight] = currentRotatedRect;
			let a = originTopLeft;
			let b = currentTopLeft;

			// if flipped we need to 'extend' the text field in the opposite direction
			if (activeMarkup.flipX) {
				a = originBottomRight;
				b = currentBottomRight;
			}

			// move
			const d = vectorSubtract(vectorClone(a), b);

			x += d.x;
			y += d.y;
		}

		updateMarkupShape(activeMarkup, {
			x: isString(textShapeOrigin.x)
			? toPercentage(x, parentRect.width)
			: x,
			y: isString(textShapeOrigin.y)
			? toPercentage(y, parentRect.height)
			: y,
			text
		});
	};

	const getShapeSizeTranslation = (originRect, targetRect, { flipX, flipY, rotation }, anchor = "top left") => {
		let a, b;

		// draw origin rect
		const [originTopLeft, originTopRight, originBottomRight, originBottomLeft] = rectRotate(originRect, rotation);

		// draw target rect
		const [targetTopLeft, targetTopRight, targetBottomRight, targetBottomLeft] = rectRotate(targetRect, rotation);

		if (anchor === "top center") {
			// for now doesn't matter if it's flipped horizontal
			const originMid = vectorCenter(flipY
			? [originBottomLeft, originBottomRight]
			: [originTopLeft, originTopRight]);

			const targetMid = vectorCenter(flipY
			? [targetBottomLeft, targetBottomRight]
			: [targetTopLeft, targetTopRight]);

			a = originMid;
			b = targetMid;
		} else if (anchor === "top right" && !flipX || anchor === "top left" && flipX) {
			// tr
			a = flipY ? originBottomRight : originTopRight;

			b = flipY ? targetBottomRight : targetTopRight;
		} else {
			// tl
			a = flipY ? originBottomLeft : originTopLeft;

			b = flipY ? targetBottomLeft : targetTopLeft;
		}

		return vectorSubtract(vectorClone(a), b);
	};

	const translateRelative = (current, position, translation) => vectorCreate(
		isString(current.x)
		? toPercentage(position.x + translation.x, parentRect.width)
		: position.x + translation.x,
		isString(current.y)
		? toPercentage(position.y + translation.y, parentRect.height)
		: position.y + translation.y
	);

	const ShapeTextStateCache = {};

	const handleTextSwitchLayout = () => {
		const shapeTextSize = textSize(activeMarkup.text, activeMarkupComputed);
		const isFixedBox = hasProp(activeMarkup, "height");
		const isAutoHeightBox = !isFixedBox && hasProp(activeMarkup, "width");

		// set/get cache entries for this text shapw
		const key = activeMarkup.id;

		let cache = ShapeTextStateCache[key];

		if (!cache) {
			ShapeTextStateCache[key] = {};
			cache = ShapeTextStateCache[key];
		}

		const toAutoWidth = sizeFrom => {
			const { width, ...autoSizeProps } = activeMarkupComputed;
			const sizeTo = textSize(activeMarkup.text, autoSizeProps);

			// this will change dimensions so if rotated we have to calculate new position
			const translation = getShapeSizeTranslation(rectCreate(activeMarkupComputed.x, activeMarkupComputed.y, sizeFrom.width, sizeFrom.height), rectCreate(activeMarkupComputed.x, activeMarkupComputed.y, sizeTo.width, sizeTo.height), activeMarkupComputed, `top ${activeMarkup.textAlign}`);

			// switch to auto mode
			removeMarkupShapeProps(activeMarkup, ["width", "height", "textAlign"]);

			// update position based on size translation
			updateMarkupShape(activeMarkup, {
				...translateRelative(activeMarkup, activeMarkupComputed, translation)
			});
		};

		const toAutoHeight = sizeFrom => {
			// -> switch to auto height mode
			const sizeTo = sizeCreate(cache.width || activeMarkupComputed.width || shapeTextSize.width, shapeTextSize.height);

			const textAlign = cache.textAlign || "left";

			// this will change dimensions so if rotated we have to calculate new position
			const translation = getShapeSizeTranslation(rectCreate(activeMarkupComputed.x, activeMarkupComputed.y, sizeFrom.width, sizeFrom.height), rectCreate(activeMarkupComputed.x, activeMarkupComputed.y, sizeTo.width, sizeTo.height), activeMarkupComputed, `top ${textAlign}`);

			// switch to auto-height mode
			removeMarkupShapeProps(activeMarkup, ["height"]);

			// update position based on size translation
			updateMarkupShape(activeMarkup, {
				...translateRelative(activeMarkup, activeMarkupComputed, translation),
				width: isString(activeMarkup.width)
				? toPercentage(sizeTo.width, parentRect.width)
				: sizeTo.width,
				textAlign
			});
		};

		const toFixedSize = sizeFrom => {
			// this can change dimensions so we need to recalculate position
			const sizeTo = sizeCreate(cache.width || shapeTextSize.width, cache.height || shapeTextSize.height);

			const textAlign = cache.textAlign || "left";

			// this will change dimensions so if rotated we have to calculate new position
			const translation = getShapeSizeTranslation(rectCreate(activeMarkupComputed.x, activeMarkupComputed.y, sizeFrom.width, sizeFrom.height), rectCreate(activeMarkupComputed.x, activeMarkupComputed.y, sizeTo.width, sizeTo.height), activeMarkupComputed, `top ${textAlign}`);

			// switch to fixed box, use stored alignment or default to left text align
			updateMarkupShape(activeMarkup, {
				...translateRelative(activeMarkup, activeMarkupComputed, translation),
				width: isString(activeMarkup.width)
				? toPercentage(sizeTo.width, parentRect.width)
				: sizeTo.width,
				height: isString(activeMarkup.width)
				? toPercentage(sizeTo.height, parentRect.height)
				: sizeTo.height,
				textAlign
			});
		};

		if (isFixedBox) {
			// store size so we can restore it later
			cache.textAlign = activeMarkup.textAlign;

			cache.width = activeMarkupComputed.width;
			cache.height = activeMarkupComputed.height;
			const sizeFrom = sizeCreate(activeMarkupComputed.width, activeMarkupComputed.height);

			if (shapeCanChangeTextLayout(activeMarkup, "auto-height")) {
				toAutoHeight(sizeFrom);
			} else if (shapeCanChangeTextLayout(activeMarkup, "auto-width")) {
				toAutoWidth(sizeFrom);
			}
		} else if (isAutoHeightBox) {
			// store alignment so we can restore it later
			cache.textAlign = activeMarkup.textAlign;

			cache.width = activeMarkupComputed.width;

			// -> switch to auto width
			const sizeFrom = sizeCreate(activeMarkupComputed.width, shapeTextSize.height);

			if (shapeCanChangeTextLayout(activeMarkup, "auto-width")) {
				toAutoWidth(sizeFrom);
			} else if (shapeCanChangeTextLayout(activeMarkup, "fixed-size")) {
				toFixedSize(sizeFrom);
			}
		} else {
			// -> switch to fixed size or auto height
			const sizeFrom = sizeCreate(shapeTextSize.width, shapeTextSize.height);

			if (shapeCanChangeTextLayout(activeMarkup, "fixed-size")) {
				toFixedSize(sizeFrom);
			} else if (shapeCanChangeTextLayout(activeMarkup, "auto-height")) {
				toAutoHeight(sizeFrom);
			}
		}
	};

	const handleEditTextActiveMarkup = () => editMarkupItem(activeMarkup);

	const handleTextInputAttempt = e => {
		const currentValue = e.target.value;
		const selectionStart = e.target.selectionStart;
		const selectionEnd = e.target.selectionEnd;
		const currentValueStart = currentValue.substring(0, selectionStart);
		const currentValueEnd = currentValue.substring(selectionEnd);
		const intendedValue = currentValueStart + e.key + currentValueEnd;
		const filteredValue = shapeCanInput(activeMarkup, intendedValue);
		if (filteredValue !== intendedValue) return e.preventDefault();
	};

	const filterNewlines = value => value.// split on lines so we can create compressed normal line of text
	split(/[\n\r]/g).// rempve spaces around lines
	map(str => str.trim()).// remove empty strings
	filter(str => str.length).// create new line
	join(" ");

	// prevent moving shape when focusing text field, and close field if escape pressed
	const handleTextInputKeyDown = e => {
		if (shapeIsTextLine(activeMarkup) && (/enter/i).test(e.code)) return e.preventDefault();
		if ((/arrow/i).test(e.code)) return e.stopPropagation();
		if ((/escape/i).test(e.key)) return handleTextCancel();
	};

	// handle alt/ctrl/cmd + return
	const handleTextInputKeyUp = e => {
		// get key type
		const { key, ctrlKey, altKey } = e;

		// confirm multi line text elements
		if ((/enter/i).test(key) && ctrlKey | altKey) return handleTextConfirm();
	};

	const handleTextConfirm = () => {
		// if was draft, now need to confirm
		let wasDraft = activeMarkup._isDraft;

		if (shapeIsDraft(activeMarkup)) confirmMarkupItemDraft();

		// final text input check
		handleTextInput();

		// done
		finishEditMarkupItem(activeMarkup);

		if (wasDraft) onaddshape(activeMarkup); else onupdateshape(activeMarkup);
	};

	const handleTextCancel = () => {
		if (shapeIsDraft(activeMarkup)) {
			discardMarkupItemDraft();
		} else {
			updateMarkupShape(activeMarkup, {
				text: textShapeOrigin.text,
				x: textShapeOrigin.x,
				y: textShapeOrigin.y
			});

			finishEditMarkupItem(activeMarkup);
		}
	};

	//
	// Controls
	//
	const handleFlipX = e => {
		e.stopPropagation();
		const flipX = activeMarkup.flipX || false;
		updateMarkupShapeProperty(activeMarkup, "flipX", !flipX);
		onupdateshape(activeMarkup);
	};

	const handleFlipY = e => {
		e.stopPropagation();
		const flipY = activeMarkup.flipY || false;
		updateMarkupShapeProperty(activeMarkup, "flipY", !flipY);
		onupdateshape(activeMarkup);
	};

	const handleAdjustOpacity = value => {
		updateMarkupShapeProperty(activeMarkup, "opacity", value);
		onupdateshape(activeMarkup);
	};

	const handleRemoveActiveMarkup = e => {
		e.stopPropagation();
		e.target.blur(); // cancels focus of remove button
		removeActiveMarkupItem();
	};

	const handleMoveToFrontActiveMarkup = e => {
		e.stopPropagation();

		// test if is not already at top of stack, if so, exit
		const index = markup.findIndex(shape => shape === activeMarkup);

		if (index === markup.length - 1) return;

		// add to last index
		$$invalidate(0, markup = markup.filter(markupItem => markupItem !== activeMarkup).concat([activeMarkup]));

		onupdateshape(activeMarkup);
	};

	const handleDuplicateActiveMarkup = e => {
		e.stopPropagation();

		// create clone
		const clone = shapeDeepCopy(activeMarkup);

		clone.id = getUniqueId();
		const duplicationOffset = vectorCreate(50, -50);

		// offset
		if (shapeIsLine(clone)) {
			const linePosition = shapeGetPropsPixelValues(clone, ["x1", "y1", "x2", "y2"], parentRect);
			linePosition.x1 += duplicationOffset.x;
			linePosition.y1 += duplicationOffset.y;
			linePosition.x2 += duplicationOffset.x;
			linePosition.y2 += duplicationOffset.y;
			shapeUpdateProps(clone, linePosition, parentRect);
		} else {
			const currentPosition = shapeGetPropsPixelValues(clone, ["x", "y"], parentRect);
			currentPosition.x += 50;
			currentPosition.y -= 50;
			shapeUpdateProps(clone, currentPosition, parentRect);
		}

		// add clone
		markup.push(clone);

		// added
		onaddshape(clone);

		// select clone
		selectShape(clone);
	};

	const getMarkupControlsAnchorPosition = rect => vectorApply(vectorCreate(rect.x + rect.width * 0.5, rect.y), snapToPixel);

	//
	// show & position markup controls panel
	//
	const markupControlsOpacity = spring$2(0, { stiffness: 0.2, damping: 0.7 });

	component_subscribe($$self, markupControlsOpacity, value => $$invalidate(10, $markupControlsOpacity = value));
	let shapeControlsSize;

	const getShapeControlPositionOnCanvas = position => {
		const left = utilRect.x;
		const top = utilRect.y;
		const right = left + utilRect.width;
		let x = Math.max(position.x - shapeControlsSize.width * 0.5, left);
		let y = Math.max(position.y - shapeControlsSize.height - shapeControlDist, top);
		if (x + shapeControlsSize.width > right) x = right - shapeControlsSize.width;
		return vectorCreate(x, y);
	};

	const TextLayoutChangeIcon = (locale, shape) => {
		const { disableTextLayout = [] } = shape;

		// is fixed size
		if ("height" in shape) {
			if (disableTextLayout.includes("auto-height")) {
				// next is auto-width, no need to set as is empty
				return locale.shapeIconButtonTextLayoutAutoWidth;
			} else {
				// next is auto-height
				return locale.shapeIconButtonTextLayoutAutoHeight;
			}
		} else // is auto-height
		if ("width" in shape) {
			if (disableTextLayout.includes("auto-width")) {
				// next is fixed-size
				return locale.shapeIconButtonTextLayoutFixedSize;
			} else {
				// next is auto-width, no need to set as is empty
				return locale.shapeIconButtonTextLayoutAutoWidth;
			}
		} else // is auto-width
		{
			// next is fixed-size
			if (disableTextLayout.includes("fixed-size")) {
				// next is fixed-size
				return locale.shapeIconButtonTextLayoutAutoHeight;
			} else {
				// next is auto-width, no need to set as is empty
				return locale.shapeIconButtonTextLayoutFixedSize;
			}
		}
	};

	const TextLayoutChangeLabel = (locale, shape) => {
		const { disableTextLayout = [] } = shape;

		// is fixed size
		if ("height" in shape) {
			if (disableTextLayout.includes("auto-height")) {
				// next is auto-width, no need to set as is empty
				return locale.shapeTitleButtonTextLayoutAutoWidth;
			} else {
				// next is auto-height
				return locale.shapeTitleButtonTextLayoutAutoHeight;
			}
		} else // is auto-height
		if ("width" in shape) {
			if (disableTextLayout.includes("auto-width")) {
				// next is fixed-size
				return locale.shapeTitleButtonTextLayoutFixedSize;
			} else {
				// next is auto-width, no need to set as is empty
				return locale.shapeTitleButtonTextLayoutAutoWidth;
			}
		} else // is auto-width
		{
			// next is fixed-size
			if (disableTextLayout.includes("fixed-size")) {
				// next is fixed-size
				return locale.shapeTitleButtonTextLayoutAutoHeight;
			} else {
				// next is auto-width, no need to set as is empty
				return locale.shapeTitleButtonTextLayoutFixedSize;
			}
		}
	};

	const handleNudge = e => {
		const shape = getActiveMarkupItem();
		if (!shape) return;
		if (!shapeCanMove(shape)) return;
		interactionShape = shape;
		interactionShapeOriginComputed = shapeComputeDisplay(shapeDeepCopy(interactionShape), parentRect);
		translateShape(interactionShape, interactionShapeOriginComputed, e.detail);
	};

	// shape navigator
	let showShapeList = false;

	const handleFocusIn = e => {
		$$invalidate(12, showShapeList = true);
	};

	const handleFocusOut = ({ relatedTarget }) => {
		// still in list
		if (relatedTarget && relatedTarget.classList.contains("shape-selector__button")) return;

		$$invalidate(12, showShapeList = false);
	};

	function measure_handler(event) {
		bubble($$self, event);
	}

	const click_handler = (index, e) => selectShape(markup[index]);

	function textarea_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			textInput = $$value;
			$$invalidate(11, textInput);
		});
	}

	const measure_handler_1 = e => $$invalidate(5, shapeControlsSize = e.detail);
	const interactable_function = e => getEventPositionInEditor(e, rootRect);

	$$self.$$set = $$props => {
		if ("uid" in $$props) $$invalidate(43, uid = $$props.uid);
		if ("ui" in $$props) $$invalidate(42, ui = $$props.ui);
		if ("markup" in $$props) $$invalidate(0, markup = $$props.markup);
		if ("offset" in $$props) $$invalidate(1, offset = $$props.offset);
		if ("contextRotation" in $$props) $$invalidate(44, contextRotation = $$props.contextRotation);
		if ("contextFlipX" in $$props) $$invalidate(45, contextFlipX = $$props.contextFlipX);
		if ("contextFlipY" in $$props) $$invalidate(46, contextFlipY = $$props.contextFlipY);
		if ("contextScale" in $$props) $$invalidate(47, contextScale = $$props.contextScale);
		if ("active" in $$props) $$invalidate(48, active = $$props.active);
		if ("opacity" in $$props) $$invalidate(49, opacity = $$props.opacity);
		if ("parentRect" in $$props) $$invalidate(50, parentRect = $$props.parentRect);
		if ("rootRect" in $$props) $$invalidate(2, rootRect = $$props.rootRect);
		if ("utilRect" in $$props) $$invalidate(51, utilRect = $$props.utilRect);
		if ("oninteractionstart" in $$props) $$invalidate(52, oninteractionstart = $$props.oninteractionstart);
		if ("oninteractionupdate" in $$props) $$invalidate(53, oninteractionupdate = $$props.oninteractionupdate);
		if ("oninteractionrelease" in $$props) $$invalidate(54, oninteractionrelease = $$props.oninteractionrelease);
		if ("oninteractionend" in $$props) $$invalidate(55, oninteractionend = $$props.oninteractionend);
		if ("onaddshape" in $$props) $$invalidate(56, onaddshape = $$props.onaddshape);
		if ("onupdateshape" in $$props) $$invalidate(57, onupdateshape = $$props.onupdateshape);
		if ("onselectshape" in $$props) $$invalidate(58, onselectshape = $$props.onselectshape);
		if ("onremoveshape" in $$props) $$invalidate(59, onremoveshape = $$props.onremoveshape);
		if ("beforeSelectShape" in $$props) $$invalidate(60, beforeSelectShape = $$props.beforeSelectShape);
		if ("beforeDeselectShape" in $$props) $$invalidate(61, beforeDeselectShape = $$props.beforeDeselectShape);
		if ("beforeRemoveShape" in $$props) $$invalidate(62, beforeRemoveShape = $$props.beforeRemoveShape);
		if ("beforeUpdateShape" in $$props) $$invalidate(63, beforeUpdateShape = $$props.beforeUpdateShape);
		if ("willRenderShapeControls" in $$props) $$invalidate(64, willRenderShapeControls = $$props.willRenderShapeControls);
		if ("mapEditorPointToImagePoint" in $$props) $$invalidate(65, mapEditorPointToImagePoint = $$props.mapEditorPointToImagePoint);
		if ("mapImagePointToEditorPoint" in $$props) $$invalidate(66, mapImagePointToEditorPoint = $$props.mapImagePointToEditorPoint);
		if ("eraseRadius" in $$props) $$invalidate(67, eraseRadius = $$props.eraseRadius);
		if ("selectRadius" in $$props) $$invalidate(68, selectRadius = $$props.selectRadius);
		if ("enableButtonFlipVertical" in $$props) $$invalidate(69, enableButtonFlipVertical = $$props.enableButtonFlipVertical);
		if ("enableTapToAddText" in $$props) $$invalidate(70, enableTapToAddText = $$props.enableTapToAddText);
		if ("locale" in $$props) $$invalidate(3, locale = $$props.locale);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*markup*/ 1) {
			$$invalidate(100, activeMarkup = markup && (getMarkupItemDraft() || getActiveMarkupItem()));
		}

		if ($$self.$$.dirty[3] & /*activeMarkup*/ 128) {
			$$invalidate(101, activeShapeId = activeMarkup && !shapeIsDraft(activeMarkup)
			? activeMarkup.id
			: undefined);
		}

		if ($$self.$$.dirty[0] & /*rootRect*/ 4 | $$self.$$.dirty[1] & /*parentRect*/ 524288 | $$self.$$.dirty[3] & /*activeMarkup*/ 128) {
			// rootRect is in there so it recomputes the shape when the editor is resized
			$$invalidate(102, activeMarkupComputed = rootRect && activeMarkup && shapeComputeDisplay(shapeDeepCopy(activeMarkup), parentRect));
		}

		if ($$self.$$.dirty[3] & /*activeMarkup*/ 128) {
			$$invalidate(103, activeMarkupItemIsDraft = !!(activeMarkup && shapeIsDraft(activeMarkup)));
		}

		if ($$self.$$.dirty[3] & /*activeMarkup*/ 128) {
			$$invalidate(104, shapeProps = activeMarkup || undefined);
		}

		if ($$self.$$.dirty[1] & /*opacity*/ 262144 | $$self.$$.dirty[3] & /*activeMarkup, activeMarkupComputed*/ 640) {
			// TODO: we use opacity to trigger a redraw of the active points, this should be changed to the image zoom factor in a future release
			$$invalidate(105, shapeActivePoints = activeMarkup && opacity && !shapeIsPath(activeMarkupComputed) && getMarkupShapePoints(activeMarkupComputed) || []);
		}

		if ($$self.$$.dirty[3] & /*activeMarkup*/ 128) {
			$$invalidate(106, allowResizeControls = activeMarkup && shapeCanResize(activeMarkup) && !shapeIsTextEditing(activeMarkup));
		}

		if ($$self.$$.dirty[3] & /*activeMarkup*/ 128) {
			$$invalidate(6, allowRotateControls = activeMarkup && shapeCanRotate(activeMarkup) && !shapeIsTextEditing(activeMarkup));
		}

		if ($$self.$$.dirty[3] & /*allowResizeControls, activeMarkup*/ 8320) {
			$$invalidate(13, allowedResizeControls = allowResizeControls && (hasProp(activeMarkup, "text") && !activeMarkup.height)
			? "horizontal"
			: allowResizeControls);
		}

		if ($$self.$$.dirty[3] & /*activeMarkup, shapeActivePoints*/ 4224) {
			$$invalidate(7, shouldRenderShapeManipulator = activeMarkup && shapeActivePoints.length > 1);
		}

		if ($$self.$$.dirty[2] & /*mapImagePointToEditorPoint*/ 16 | $$self.$$.dirty[3] & /*shapeActivePoints*/ 4096) {
			$$invalidate(107, shapeActiveScreenPoints = shapeActivePoints.map(mapImagePointToEditorPoint));
		}

		if ($$self.$$.dirty[0] & /*offset*/ 2 | $$self.$$.dirty[3] & /*shapeActiveScreenPoints*/ 16384) {
			$$invalidate(8, shapeManipulatorPoints = shapeActiveScreenPoints.map(point => vectorCreate(point.x - offset.x, point.y - offset.y)));
		}

		if ($$self.$$.dirty[0] & /*shouldRenderShapeManipulator, allowRotateControls*/ 192 | $$self.$$.dirty[1] & /*opacity*/ 262144 | $$self.$$.dirty[3] & /*activeMarkupComputed*/ 512) {
			// TODO: we use opacity to trigger a redraw of the active points, this should be changed to the image zoom factor in a future release
			$$invalidate(108, shapeManipulatorRotationPoint = shouldRenderShapeManipulator && allowRotateControls && opacity && getShapeRotationPointOnScreen(activeMarkupComputed));
		}

		if ($$self.$$.dirty[0] & /*offset*/ 2 | $$self.$$.dirty[3] & /*shapeManipulatorRotationPoint*/ 32768) {
			$$invalidate(14, shapeManipulatorRotationPointPosition = shapeManipulatorRotationPoint && vectorCreate(shapeManipulatorRotationPoint.position.x - offset.x, shapeManipulatorRotationPoint.position.y - offset.y));
		}

		if ($$self.$$.dirty[0] & /*shapeManipulatorPoints*/ 256 | $$self.$$.dirty[1] & /*active, opacity*/ 393216 | $$self.$$.dirty[3] & /*activeMarkup*/ 128) {
			if (active) {
				// show when something selected
				if (opacity > 0) {
					claimManipulatorLines();

					if (shapeManipulatorPoints.length > 2) {
						redrawManipulatorLines(opacity);
					} else {
						removeMarkupManipulatorLines();
					}
				} else // hide when nothing selected
				if (!activeMarkup) {
					redrawManipulatorLines(opacity);
				}
			} else if (shouldManipulateLines()) {
				redrawManipulatorLines(opacity);
			}
		}

		if ($$self.$$.dirty[3] & /*activeMarkup*/ 128) {
			$$invalidate(109, isTextMarkupSelected = activeMarkup && shapeIsText(activeMarkup));
		}

		if ($$self.$$.dirty[3] & /*isTextMarkupSelected, activeMarkup*/ 65664) {
			$$invalidate(9, shouldRenderTextInput = isTextMarkupSelected && shapeCanInput(activeMarkup) !== false && activeMarkup.isEditing);
		}

		if ($$self.$$.dirty[0] & /*shouldRenderTextInput*/ 512) {
			$$invalidate(110, textShapeOrigin = shouldRenderTextInput
			? getTextShapeOriginSnapshot()
			: undefined);
		}

		if ($$self.$$.dirty[1] & /*parentRect*/ 524288 | $$self.$$.dirty[3] & /*textShapeOrigin*/ 131072) {
			$$invalidate(111, textShapeDisplayOrigin = textShapeOrigin && shapeComputeDisplay({ ...textShapeOrigin }, parentRect));
		}

		if ($$self.$$.dirty[3] & /*textShapeDisplayOrigin*/ 262144) {
			$$invalidate(112, textSizeDisplayOrigin = textShapeDisplayOrigin && textSize(textShapeDisplayOrigin.text, textShapeDisplayOrigin));
		}

		if ($$self.$$.dirty[3] & /*textShapeDisplayOrigin, textSizeDisplayOrigin*/ 786432) {
			textRectDisplayOrigin = textShapeDisplayOrigin && rectCreate(textShapeDisplayOrigin.x, textShapeDisplayOrigin.y, textSizeDisplayOrigin.width, textSizeDisplayOrigin.height);
		}

		if ($$self.$$.dirty[0] & /*shouldRenderTextInput*/ 512 | $$self.$$.dirty[3] & /*activeMarkup*/ 128) {
			$$invalidate(15, textInputText = shouldRenderTextInput ? activeMarkup.text : "");
		}

		if ($$self.$$.dirty[0] & /*shouldRenderTextInput*/ 512 | $$self.$$.dirty[3] & /*shapeProps*/ 2048) {
			$$invalidate(16, markupTextInputStyle = shouldRenderTextInput && `
    text-align: ${shapeProps.textAlign || "left"};
    font-family: ${shapeProps.fontFamily || "sans-serif"};
`);
		}

		if ($$self.$$.dirty[3] & /*activeMarkup, activeMarkupItemIsDraft, controlledMarkupItem*/ 1049728) {
			$$invalidate(113, controlledMarkupItem = activeMarkup && !activeMarkupItemIsDraft
			? activeMarkup
			: controlledMarkupItem);
		}

		if ($$self.$$.dirty[3] & /*controlledMarkupItem*/ 1048576) {
			$$invalidate(114, allowShapeFlip = controlledMarkupItem && shapeCanFlip(controlledMarkupItem));
		}

		if ($$self.$$.dirty[3] & /*controlledMarkupItem*/ 1048576) {
			$$invalidate(115, allowShapeChangeTextLayout = controlledMarkupItem && shapeCanChangeTextLayout(controlledMarkupItem));
		}

		if ($$self.$$.dirty[3] & /*controlledMarkupItem*/ 1048576) {
			$$invalidate(116, allowShapeDuplicate = controlledMarkupItem && shapeCanDuplicate(controlledMarkupItem));
		}

		if ($$self.$$.dirty[3] & /*controlledMarkupItem*/ 1048576) {
			$$invalidate(117, allowShapeRemove = controlledMarkupItem && shapeCanRemove(controlledMarkupItem));
		}

		if ($$self.$$.dirty[3] & /*controlledMarkupItem*/ 1048576) {
			$$invalidate(118, allowShapeReorder = controlledMarkupItem && shapeCanReorder(controlledMarkupItem));
		}

		if ($$self.$$.dirty[3] & /*controlledMarkupItem*/ 1048576) {
			$$invalidate(119, allowShapeInput = controlledMarkupItem && shapeCanInput(controlledMarkupItem) !== false);
		}

		if ($$self.$$.dirty[3] & /*controlledMarkupItem*/ 1048576) {
			$$invalidate(120, allowShapeAdjustOpacity = controlledMarkupItem && hasProp(controlledMarkupItem, "backgroundImage") && shapeCanStyle(controlledMarkupItem, "opacity"));
		}

		if ($$self.$$.dirty[0] & /*shouldRenderTextInput*/ 512 | $$self.$$.dirty[3] & /*activeMarkup, activeMarkupItemIsDraft, isInteracting*/ 1216) {
			markupControlsOpacity.set(activeMarkup && !activeMarkupItemIsDraft && !isInteracting && !shouldRenderTextInput
			? 1
			: 0);
		}

		if ($$self.$$.dirty[0] & /*shapeManipulatorPoints*/ 256 | $$self.$$.dirty[3] & /*activeMarkup, activeMarkupItemIsDraft, markupControlsAnchorPosition*/ 268436608) {
			$$invalidate(121, markupControlsAnchorPosition = activeMarkup && !activeMarkupItemIsDraft
			? getMarkupControlsAnchorPosition(rectCreateFromPoints(shapeManipulatorPoints))
			: markupControlsAnchorPosition);
		}

		if ($$self.$$.dirty[0] & /*shapeControlsSize*/ 32 | $$self.$$.dirty[1] & /*utilRect*/ 1048576 | $$self.$$.dirty[3] & /*markupControlsAnchorPosition*/ 268435456) {
			$$invalidate(122, shapeControlsPosition = markupControlsAnchorPosition && shapeControlsSize && utilRect && getShapeControlPositionOnCanvas(markupControlsAnchorPosition));
		}

		if ($$self.$$.dirty[0] & /*$markupControlsOpacity*/ 1024 | $$self.$$.dirty[3] & /*shapeControlsPosition*/ 536870912) {
			$$invalidate(17, markupControlsStyle = shapeControlsPosition && `transform: translate(${shapeControlsPosition.x}px, ${shapeControlsPosition.y}px);opacity:${$markupControlsOpacity}`);
		}

		if ($$self.$$.dirty[0] & /*locale*/ 8 | $$self.$$.dirty[2] & /*willRenderShapeControls, enableButtonFlipVertical*/ 132 | $$self.$$.dirty[3] & /*activeShapeId, allowShapeAdjustOpacity, activeMarkup, allowShapeFlip, allowShapeReorder, allowShapeDuplicate, allowShapeRemove, allowShapeInput, allowShapeChangeTextLayout*/ 266338688) {
			$$invalidate(18, shapeControls = activeShapeId && willRenderShapeControls(
				[
					allowShapeAdjustOpacity && [
						"div",
						"alpha",
						{ class: "PinturaShapeControlsGroup" },
						[
							[
								"Slider",
								"adjust-opacity",
								{
									onchange: handleAdjustOpacity,
									step: 0.01,
									value: hasProp(activeMarkup, "opacity")
									? activeMarkup.opacity
									: 1,
									label: (value, min, max) => `${Math.round(value / max * 100)}%`,
									min: 0,
									max: 1,
									direction: "x"
								}
							]
						]
					],
					[
						"div",
						"beta",
						{ class: "PinturaShapeControlsGroup" },
						[
							allowShapeFlip && [
								"Button",
								"flip-horizontal",
								{
									onclick: handleFlipX,
									label: locale.shapeTitleButtonFlipHorizontal,
									icon: locale.shapeIconButtonFlipHorizontal,
									hideLabel: true
								}
							],
							allowShapeFlip && enableButtonFlipVertical && [
								"Button",
								"flip-vertical",
								{
									onclick: handleFlipY,
									label: locale.shapeTitleButtonFlipVertical,
									icon: locale.shapeIconButtonFlipVertical,
									hideLabel: true
								}
							],
							allowShapeReorder && [
								"Button",
								"to-front",
								{
									onclick: handleMoveToFrontActiveMarkup,
									label: locale.shapeTitleButtonMoveToFront,
									icon: locale.shapeIconButtonMoveToFront,
									hideLabel: true
								}
							],
							allowShapeDuplicate && [
								"Button",
								"duplicate",
								{
									onclick: handleDuplicateActiveMarkup,
									label: locale.shapeTitleButtonDuplicate,
									icon: locale.shapeIconButtonDuplicate,
									hideLabel: true
								}
							],
							allowShapeRemove && [
								"Button",
								"remove",
								{
									onclick: handleRemoveActiveMarkup,
									label: locale.shapeTitleButtonRemove,
									icon: locale.shapeIconButtonRemove,
									hideLabel: true
								}
							]
						].filter(Boolean)
					],
					allowShapeInput && allowShapeChangeTextLayout && [
						"div",
						"gamma",
						{ class: "PinturaShapeControlsGroup" },
						[
							[
								"Button",
								"text-layout",
								{
									onclick: handleTextSwitchLayout,
									label: localize(TextLayoutChangeLabel, locale, activeMarkup),
									icon: localize(TextLayoutChangeIcon, locale, activeMarkup),
									hideLabel: true
								}
							]
						]
					],
					allowShapeInput && [
						"div",
						"delta",
						{ class: "PinturaShapeControlsGroup" },
						[
							[
								"Button",
								"edit-text",
								{
									label: locale.shapeLabelInputText,
									onclick: handleEditTextActiveMarkup
								}
							]
						]
					]
				].filter(Boolean),
				activeShapeId
			));
		}

		if ($$self.$$.dirty[0] & /*markup, locale*/ 9) {
			$$invalidate(19, shapeNavList = markup.filter(shapeCanSelect).filter(shape => !shapeIsDraft(shape)).map(shape => ({
				id: shape.id,
				color: shapeIsText(shape)
				? shape.color
				: shapeIsLine(shape)
					? shape.strokeColor
					: shape.backgroundColor,
				name: shape.name || locale[`shapeLabelTool${capitalizeFirstLetter(shapeGetDescription(shape))}`]
			})));
		}
	};

	return [
		markup,
		offset,
		rootRect,
		locale,
		selectShape,
		shapeControlsSize,
		allowRotateControls,
		shouldRenderShapeManipulator,
		shapeManipulatorPoints,
		shouldRenderTextInput,
		$markupControlsOpacity,
		textInput,
		showShapeList,
		allowedResizeControls,
		shapeManipulatorRotationPointPosition,
		textInputText,
		markupTextInputStyle,
		markupControlsStyle,
		shapeControls,
		shapeNavList,
		keysPressedStored,
		handleInteractionStart,
		handleInteractionUpdate,
		handleInteractionRelease,
		handleInteractionEnd,
		handleManipulatorResizeGrab,
		handleManipulatorResizeDrag,
		handleManipulatorResizeEnd,
		handleManipulatorRotateGrab,
		handleManipulatorRotateDrag,
		handleManipulatorRotateEnd,
		handleKey,
		handleTextInput,
		handleTextInputAttempt,
		handleTextInputKeyDown,
		handleTextInputKeyUp,
		handleTextConfirm,
		handleTextCancel,
		markupControlsOpacity,
		handleNudge,
		handleFocusIn,
		handleFocusOut,
		ui,
		uid,
		contextRotation,
		contextFlipX,
		contextFlipY,
		contextScale,
		active,
		opacity,
		parentRect,
		utilRect,
		oninteractionstart,
		oninteractionupdate,
		oninteractionrelease,
		oninteractionend,
		onaddshape,
		onupdateshape,
		onselectshape,
		onremoveshape,
		beforeSelectShape,
		beforeDeselectShape,
		beforeRemoveShape,
		beforeUpdateShape,
		willRenderShapeControls,
		mapEditorPointToImagePoint,
		mapImagePointToEditorPoint,
		eraseRadius,
		selectRadius,
		enableButtonFlipVertical,
		enableTapToAddText,
		createShape,
		eraseShape,
		getMarkupItemDraft,
		getMarkupItemDraftIndex,
		addMarkupItemDraft,
		confirmMarkupItemDraft,
		discardMarkupItemDraft,
		createMarkupItem,
		syncShapes,
		addShape,
		removeMarkupShapeProps,
		updateMarkupShape,
		updateMarkupShapeProperty,
		updateMarkupItemsShapeProperty,
		updateMarkupShapeItems,
		getActiveMarkupItem,
		hasActiveMarkupItem,
		removeShape,
		removeActiveMarkupItem,
		blurShapes,
		deselectMarkupItem,
		editMarkupItem,
		finishEditMarkupItem,
		removeMarkupItems,
		getTextShapeRect,
		getMarkupShapeRect,
		getShapesNearPosition,
		getShapesBetweenPoints,
		isInteracting,
		activeMarkup,
		activeShapeId,
		activeMarkupComputed,
		activeMarkupItemIsDraft,
		shapeProps,
		shapeActivePoints,
		allowResizeControls,
		shapeActiveScreenPoints,
		shapeManipulatorRotationPoint,
		isTextMarkupSelected,
		textShapeOrigin,
		textShapeDisplayOrigin,
		textSizeDisplayOrigin,
		controlledMarkupItem,
		allowShapeFlip,
		allowShapeChangeTextLayout,
		allowShapeDuplicate,
		allowShapeRemove,
		allowShapeReorder,
		allowShapeInput,
		allowShapeAdjustOpacity,
		markupControlsAnchorPosition,
		shapeControlsPosition,
		measure_handler,
		click_handler,
		textarea_binding,
		measure_handler_1,
		interactable_function
	];
}

class ShapeLayoutEditor extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$e,
			create_fragment$e,
			safe_not_equal,
			{
				uid: 43,
				ui: 42,
				markup: 0,
				offset: 1,
				contextRotation: 44,
				contextFlipX: 45,
				contextFlipY: 46,
				contextScale: 47,
				active: 48,
				opacity: 49,
				parentRect: 50,
				rootRect: 2,
				utilRect: 51,
				oninteractionstart: 52,
				oninteractionupdate: 53,
				oninteractionrelease: 54,
				oninteractionend: 55,
				onaddshape: 56,
				onupdateshape: 57,
				onselectshape: 58,
				onremoveshape: 59,
				beforeSelectShape: 60,
				beforeDeselectShape: 61,
				beforeRemoveShape: 62,
				beforeUpdateShape: 63,
				willRenderShapeControls: 64,
				mapEditorPointToImagePoint: 65,
				mapImagePointToEditorPoint: 66,
				eraseRadius: 67,
				selectRadius: 68,
				enableButtonFlipVertical: 69,
				enableTapToAddText: 70,
				locale: 3,
				createShape: 71,
				eraseShape: 72,
				getMarkupItemDraft: 73,
				getMarkupItemDraftIndex: 74,
				addMarkupItemDraft: 75,
				confirmMarkupItemDraft: 76,
				discardMarkupItemDraft: 77,
				createMarkupItem: 78,
				syncShapes: 79,
				addShape: 80,
				removeMarkupShapeProps: 81,
				updateMarkupShape: 82,
				updateMarkupShapeProperty: 83,
				updateMarkupItemsShapeProperty: 84,
				updateMarkupShapeItems: 85,
				getActiveMarkupItem: 86,
				hasActiveMarkupItem: 87,
				removeShape: 88,
				removeActiveMarkupItem: 89,
				blurShapes: 90,
				selectShape: 4,
				deselectMarkupItem: 91,
				editMarkupItem: 92,
				finishEditMarkupItem: 93,
				removeMarkupItems: 94,
				getTextShapeRect: 95,
				getMarkupShapeRect: 96,
				getShapesNearPosition: 97,
				getShapesBetweenPoints: 98
			},
			[-1, -1, -1, -1, -1, -1]
		);
	}

	get createShape() {
		return this.$$.ctx[71];
	}

	get eraseShape() {
		return this.$$.ctx[72];
	}

	get getMarkupItemDraft() {
		return this.$$.ctx[73];
	}

	get getMarkupItemDraftIndex() {
		return this.$$.ctx[74];
	}

	get addMarkupItemDraft() {
		return this.$$.ctx[75];
	}

	get confirmMarkupItemDraft() {
		return this.$$.ctx[76];
	}

	get discardMarkupItemDraft() {
		return this.$$.ctx[77];
	}

	get createMarkupItem() {
		return this.$$.ctx[78];
	}

	get syncShapes() {
		return this.$$.ctx[79];
	}

	get addShape() {
		return this.$$.ctx[80];
	}

	get removeMarkupShapeProps() {
		return this.$$.ctx[81];
	}

	get updateMarkupShape() {
		return this.$$.ctx[82];
	}

	get updateMarkupShapeProperty() {
		return this.$$.ctx[83];
	}

	get updateMarkupItemsShapeProperty() {
		return this.$$.ctx[84];
	}

	get updateMarkupShapeItems() {
		return this.$$.ctx[85];
	}

	get getActiveMarkupItem() {
		return this.$$.ctx[86];
	}

	get hasActiveMarkupItem() {
		return this.$$.ctx[87];
	}

	get removeShape() {
		return this.$$.ctx[88];
	}

	get removeActiveMarkupItem() {
		return this.$$.ctx[89];
	}

	get blurShapes() {
		return this.$$.ctx[90];
	}

	get selectShape() {
		return this.$$.ctx[4];
	}

	get deselectMarkupItem() {
		return this.$$.ctx[91];
	}

	get editMarkupItem() {
		return this.$$.ctx[92];
	}

	get finishEditMarkupItem() {
		return this.$$.ctx[93];
	}

	get removeMarkupItems() {
		return this.$$.ctx[94];
	}

	get getTextShapeRect() {
		return this.$$.ctx[95];
	}

	get getMarkupShapeRect() {
		return this.$$.ctx[96];
	}

	get getShapesNearPosition() {
		return this.$$.ctx[97];
	}

	get getShapesBetweenPoints() {
		return this.$$.ctx[98];
	}
}

/* src/core/ui/components/ShapeStyleControls.svelte generated by Svelte v3.37.0 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

// (19:8) {#each controls as control (control.id) }
function create_each_block$2(key_1, ctx) {
	let li;
	let span;
	let t0_value = localize(/*control*/ ctx[7].componentProps.title, /*locale*/ ctx[1]) + "";
	let t0;
	let t1;
	let switch_instance;
	let t2;
	let current;
	const switch_instance_spread_levels = [/*control*/ ctx[7].componentProps];
	var switch_value = /*control*/ ctx[7].component;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props());
	}

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			span = element("span");
			t0 = text$1(t0_value);
			t1 = space();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			t2 = space();
			attr(span, "class", "PinturaShapeStyleLabel");
			attr(li, "class", "PinturaShapeStyle");
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, span);
			append(span, t0);
			append(li, t1);

			if (switch_instance) {
				mount_component(switch_instance, li, null);
			}

			append(li, t2);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty & /*controls, locale*/ 3) && t0_value !== (t0_value = localize(/*control*/ ctx[7].componentProps.title, /*locale*/ ctx[1]) + "")) set_data(t0, t0_value);

			const switch_instance_changes = (dirty & /*controls*/ 1)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*control*/ ctx[7].componentProps)])
			: {};

			if (switch_value !== (switch_value = /*control*/ ctx[7].component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, li, t2);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (switch_instance) destroy_component(switch_instance);
		}
	};
}

// (17:0) <Scrollable class="PinturaShapeStyles" elasticity={scrollElasticity}>
function create_default_slot$5(ctx) {
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let each_value = /*controls*/ ctx[0];
	const get_key = ctx => /*control*/ ctx[7].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$2(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
	}

	return {
		c() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(ul, "class", "PinturaShapeStyleList");
		},
		m(target, anchor) {
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*controls, localize, locale*/ 3) {
				each_value = /*controls*/ ctx[0];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$2, null, get_each_context$2);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

function create_fragment$d(ctx) {
	let div;
	let scrollable;
	let current;

	scrollable = new Scrollable({
			props: {
				class: "PinturaShapeStyles",
				elasticity: /*scrollElasticity*/ ctx[2],
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(scrollable.$$.fragment);
			attr(div, "style", /*style*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(scrollable, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const scrollable_changes = {};
			if (dirty & /*scrollElasticity*/ 4) scrollable_changes.elasticity = /*scrollElasticity*/ ctx[2];

			if (dirty & /*$$scope, controls, locale*/ 1027) {
				scrollable_changes.$$scope = { dirty, ctx };
			}

			scrollable.$set(scrollable_changes);

			if (!current || dirty & /*style*/ 8) {
				attr(div, "style", /*style*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(scrollable.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(scrollable.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(scrollable);
		}
	};
}

function instance$d($$self, $$props, $$invalidate) {
	let style;
	let $opacity;
	let { isActive = false } = $$props;
	let { controls = [] } = $$props;
	let { locale } = $$props;
	let { scrollElasticity } = $$props;
	const opacity = spring$2(0);
	component_subscribe($$self, opacity, value => $$invalidate(6, $opacity = value));

	$$self.$$set = $$props => {
		if ("isActive" in $$props) $$invalidate(5, isActive = $$props.isActive);
		if ("controls" in $$props) $$invalidate(0, controls = $$props.controls);
		if ("locale" in $$props) $$invalidate(1, locale = $$props.locale);
		if ("scrollElasticity" in $$props) $$invalidate(2, scrollElasticity = $$props.scrollElasticity);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*isActive*/ 32) {
			opacity.set(isActive ? 1 : 0);
		}

		if ($$self.$$.dirty & /*$opacity, isActive*/ 96) {
			$$invalidate(3, style = `opacity:${$opacity};${!isActive ? "pointer-events:none;" : ""}${$opacity <= 0 ? "visibility:hidden" : ""}`);
		}
	};

	return [controls, locale, scrollElasticity, style, opacity, isActive, $opacity];
}

class ShapeStyleControls extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$d, create_fragment$d, safe_not_equal, {
			isActive: 5,
			controls: 0,
			locale: 1,
			scrollElasticity: 2
		});
	}
}

/* src/core/ui/components/ShapeStyleEditor.svelte generated by Svelte v3.37.0 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i].key;
	child_ctx[2] = list[i].controls;
	child_ctx[12] = list[i].isActive;
	return child_ctx;
}

// (360:4) {#each currentStyleControlSets as { key, controls, isActive }
function create_each_block$1(key_1, ctx) {
	let first;
	let shapestylecontrols;
	let current;

	shapestylecontrols = new ShapeStyleControls({
			props: {
				isActive: /*isActive*/ ctx[12],
				controls: /*controls*/ ctx[2],
				locale: /*locale*/ ctx[0],
				scrollElasticity: /*scrollElasticity*/ ctx[1]
			}
		});

	return {
		key: key_1,
		first: null,
		c() {
			first = empty$1();
			create_component(shapestylecontrols.$$.fragment);
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);
			mount_component(shapestylecontrols, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const shapestylecontrols_changes = {};
			if (dirty & /*currentStyleControlSets*/ 8) shapestylecontrols_changes.isActive = /*isActive*/ ctx[12];
			if (dirty & /*currentStyleControlSets*/ 8) shapestylecontrols_changes.controls = /*controls*/ ctx[2];
			if (dirty & /*locale*/ 1) shapestylecontrols_changes.locale = /*locale*/ ctx[0];
			if (dirty & /*scrollElasticity*/ 2) shapestylecontrols_changes.scrollElasticity = /*scrollElasticity*/ ctx[1];
			shapestylecontrols.$set(shapestylecontrols_changes);
		},
		i(local) {
			if (current) return;
			transition_in(shapestylecontrols.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(shapestylecontrols.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			destroy_component(shapestylecontrols, detaching);
		}
	};
}

function create_fragment$c(ctx) {
	let div;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let each_value = /*currentStyleControlSets*/ ctx[3];
	const get_key = ctx => /*key*/ ctx[11];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$1(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "PinturaShapeStyleEditor");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*currentStyleControlSets, locale, scrollElasticity*/ 11) {
				each_value = /*currentStyleControlSets*/ ctx[3];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$1, null, get_each_context$1);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	let controlKeys;
	let activeControls;
	let currentStyleControlSets;
	let { controls = {} } = $$props;
	let { shape = undefined } = $$props;
	let { onchange } = $$props;
	let { locale } = $$props;
	let { scrollElasticity } = $$props;

	const getShapeControls = shape => {
		const shapeId = shape.id || "tool";

		const activeControls = controlKeys.filter(styleKey => styleKey.split("_").every(styleKey => // shape needs to have the property
		hasProp(shape, styleKey) && // shape needs to be able to style the property
		shapeCanStyle(shape, styleKey))).map(styleKey => {
			const styleKeys = styleKey.split("_");

			const currentValue = styleKeys.length > 1
			? styleKeys.map(key => shape[key])
			: shape[styleKey];

			let [component, componentProps] = controls[styleKey];

			// is reference to other control
			if (isString(component)) {
				// exif if not a valid default control
				if (!controls[component]) return;

				// create component based on reference
				const componentCustomProps = { ...componentProps };

				[component, componentProps] = controls[component];

				componentProps = {
					...componentProps,
					...componentCustomProps
				};
			}

			const options = isFunction$1(componentProps.options)
			? componentProps.options(shape)
			: componentProps.options;

			return {
				id: `${shapeId}_${styleKey}`,
				component,
				componentProps: {
					...componentProps,
					// set the options prop
					options,
					// defaults
					locale,
					value: currentValue,
					optionLabelClass: "PinturaButtonLabel",
					onchange: detail => {
						const value = isObject$1(detail) && !isArray(detail)
						? detail.value
						: detail;

						// allow custom changes
						if (componentProps.onchange) componentProps.onchange(value, shape);

						// internal change                        
						const props = styleKeys.length > 1
						? styleKeys.reduce(
								(prev, key, index) => {
									return {
										...prev,
										[key]: Array.isArray(value) ? value[index] : value
									};
								},
								{}
							)
						: { [styleKey]: value };

						onchange(props);
					}
				}
			};
		}).filter(Boolean);

		return activeControls;
	};

	const styleControlSets = [];

	const getStyleControlSets = (key, controls) => {
		let controlSet = styleControlSets.find(controlSet => controlSet.key === key);

		if (!controlSet) {
			// create
			controlSet = { key, controls };

			// add
			styleControlSets.push(controlSet);
		}

		// hide all
		styleControlSets.forEach(controlSet => controlSet.isActive = false);

		// update active controls
		controlSet.controls = controls;

		// show active
		controlSet.isActive = true;

		return styleControlSets;
	};

	$$self.$$set = $$props => {
		if ("controls" in $$props) $$invalidate(2, controls = $$props.controls);
		if ("shape" in $$props) $$invalidate(4, shape = $$props.shape);
		if ("onchange" in $$props) $$invalidate(5, onchange = $$props.onchange);
		if ("locale" in $$props) $$invalidate(0, locale = $$props.locale);
		if ("scrollElasticity" in $$props) $$invalidate(1, scrollElasticity = $$props.scrollElasticity);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*controls*/ 4) {
			// finds the controls needed to style the selected shape
			$$invalidate(6, controlKeys = Object.keys(controls).filter(key => controls[key]));
		}

		if ($$self.$$.dirty & /*shape, controlKeys*/ 80) {
			$$invalidate(7, activeControls = shape && controlKeys && shapeCanStyle(shape)
			? getShapeControls(shape)
			: []);
		}

		if ($$self.$$.dirty & /*shape, activeControls*/ 144) {
			$$invalidate(3, currentStyleControlSets = shape
			? getStyleControlSets(Object.keys(shape).join("_"), activeControls)
			: []);
		}
	};

	return [
		locale,
		scrollElasticity,
		controls,
		currentStyleControlSets,
		shape,
		onchange,
		controlKeys,
		activeControls
	];
}

class ShapeStyleEditor extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$c, create_fragment$c, safe_not_equal, {
			controls: 2,
			shape: 4,
			onchange: 5,
			locale: 0,
			scrollElasticity: 1
		});
	}
}

/* src/core/ui/components/DragButton.svelte generated by Svelte v3.37.0 */

function create_fragment$b(ctx) {
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			attr(button, "class", "PinturaDragButton");
			attr(button, "title", /*title*/ ctx[1]);
			button.disabled = /*disabled*/ ctx[2];
		},
		m(target, anchor) {
			insert(target, button, anchor);
			button.innerHTML = /*html*/ ctx[0];
			/*button_binding*/ ctx[9](button);

			if (!mounted) {
				dispose = listen(button, "pointerdown", /*handleDown*/ ctx[4]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*html*/ 1) button.innerHTML = /*html*/ ctx[0];
			if (dirty & /*title*/ 2) {
				attr(button, "title", /*title*/ ctx[1]);
			}

			if (dirty & /*disabled*/ 4) {
				button.disabled = /*disabled*/ ctx[2];
			}
		},
		i: noop$2,
		o: noop$2,
		d(detaching) {
			if (detaching) detach(button);
			/*button_binding*/ ctx[9](null);
			mounted = false;
			dispose();
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	let { html } = $$props;
	let { title } = $$props;
	let { onclick } = $$props;
	let { disabled = false } = $$props;
	let { ongrab = noop$1 } = $$props;
	let { ondrag = noop$1 } = $$props;
	let { ondrop = noop$1 } = $$props;
	let element;
	const isOverButton = e => vectorDistanceSquared(downPosition, vectorCreate(e.pageX, e.pageY)) < 256;
	let downPosition;

	const handleDown = e => {
		downPosition = vectorCreate(e.pageX, e.pageY);
		ongrab(e);
		document.documentElement.addEventListener("pointermove", handleMove);
		document.documentElement.addEventListener("pointerup", handleUp);
	};

	const handleUp = e => {
		document.documentElement.removeEventListener("pointermove", handleMove);
		document.documentElement.removeEventListener("pointerup", handleUp);
		const upPosition = vectorCreate(e.pageX, e.pageY);

		// must have moved enough distance to drop
		if (vectorDistanceSquared(downPosition, upPosition) < 32) return onclick(e);

		// cant drop in button
		if (isOverButton(e)) return;

		// was dragging
		ondrop(e);
	};

	const handleMove = e => {
		// must have moved enough distance from button
		if (isOverButton(e)) return;

		// dragging out of button
		ondrag(e);
	};

	function button_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(3, element);
		});
	}

	$$self.$$set = $$props => {
		if ("html" in $$props) $$invalidate(0, html = $$props.html);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("onclick" in $$props) $$invalidate(5, onclick = $$props.onclick);
		if ("disabled" in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ("ongrab" in $$props) $$invalidate(6, ongrab = $$props.ongrab);
		if ("ondrag" in $$props) $$invalidate(7, ondrag = $$props.ondrag);
		if ("ondrop" in $$props) $$invalidate(8, ondrop = $$props.ondrop);
	};

	return [
		html,
		title,
		disabled,
		element,
		handleDown,
		onclick,
		ongrab,
		ondrag,
		ondrop,
		button_binding
	];
}

class DragButton extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$b, create_fragment$b, safe_not_equal, {
			html: 0,
			title: 1,
			onclick: 5,
			disabled: 2,
			ongrab: 6,
			ondrag: 7,
			ondrop: 8
		});
	}
}

/* src/core/ui/components/ShapePresetsList.svelte generated by Svelte v3.37.0 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

// (63:4) {#each presets as preset (preset.id)}
function create_each_block(key_1, ctx) {
	let li;
	let dragbutton;
	let t;
	let didMountPresetThumb_action;
	let current;
	let mounted;
	let dispose;

	function func() {
		return /*func*/ ctx[10](/*preset*/ ctx[14]);
	}

	function func_1(...args) {
		return /*func_1*/ ctx[11](/*preset*/ ctx[14], ...args);
	}

	function func_2(...args) {
		return /*func_2*/ ctx[12](/*preset*/ ctx[14], ...args);
	}

	function func_3(...args) {
		return /*func_3*/ ctx[13](/*preset*/ ctx[14], ...args);
	}

	dragbutton = new DragButton({
			props: {
				onclick: func,
				ongrab: func_1,
				ondrag: func_2,
				ondrop: func_3,
				disabled: /*disabled*/ ctx[1] || /*preset*/ ctx[14].disabled,
				title: /*preset*/ ctx[14].title,
				html: /*preset*/ ctx[14].thumb
			}
		});

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			create_component(dragbutton.$$.fragment);
			t = space();
			attr(li, "class", "PinturaShapePreset");
			attr(li, "style", /*style*/ ctx[6]);
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			mount_component(dragbutton, li, null);
			append(li, t);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(didMountPresetThumb_action = /*didMountPresetThumb*/ ctx[8].call(null, li, /*preset*/ ctx[14]));
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const dragbutton_changes = {};
			if (dirty & /*onclickpreset, presets*/ 5) dragbutton_changes.onclick = func;
			if (dirty & /*ongrabpreset, presets*/ 9) dragbutton_changes.ongrab = func_1;
			if (dirty & /*ondragpreset, presets*/ 17) dragbutton_changes.ondrag = func_2;
			if (dirty & /*ondroppreset, presets*/ 33) dragbutton_changes.ondrop = func_3;
			if (dirty & /*disabled, presets*/ 3) dragbutton_changes.disabled = /*disabled*/ ctx[1] || /*preset*/ ctx[14].disabled;
			if (dirty & /*presets*/ 1) dragbutton_changes.title = /*preset*/ ctx[14].title;
			if (dirty & /*presets*/ 1) dragbutton_changes.html = /*preset*/ ctx[14].thumb;
			dragbutton.$set(dragbutton_changes);

			if (!current || dirty & /*style*/ 64) {
				attr(li, "style", /*style*/ ctx[6]);
			}

			if (didMountPresetThumb_action && is_function(didMountPresetThumb_action.update) && dirty & /*presets*/ 1) didMountPresetThumb_action.update.call(null, /*preset*/ ctx[14]);
		},
		i(local) {
			if (current) return;
			transition_in(dragbutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dragbutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			destroy_component(dragbutton);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$a(ctx) {
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let each_value = /*presets*/ ctx[0];
	const get_key = ctx => /*preset*/ ctx[14].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(ul, "class", "PinturaShapePresetsList");
		},
		m(target, anchor) {
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*style, presets, onclickpreset, ongrabpreset, ondragpreset, ondroppreset, disabled*/ 127) {
				each_value = /*presets*/ ctx[0];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block, null, get_each_context);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let style;
	let $anim;
	let { presets } = $$props;
	let { disabled = undefined } = $$props;
	let { onclickpreset } = $$props;
	let { ongrabpreset = undefined } = $$props;
	let { ondragpreset = undefined } = $$props;
	let { ondroppreset = undefined } = $$props;
	const anim = tweened(0, { duration: 300 });
	component_subscribe($$self, anim, value => $$invalidate(9, $anim = value));
	const didMountPresetThumb = (element, item) => item.mount && item.mount(element.firstChild, item);
	onMount(() => anim.set(1));
	const func = preset => onclickpreset(preset.id);
	const func_1 = (preset, e) => ongrabpreset && ongrabpreset(preset.id, e);
	const func_2 = (preset, e) => ondragpreset && ondragpreset(preset.id, e);
	const func_3 = (preset, e) => ondroppreset && ondroppreset(preset.id, e);

	$$self.$$set = $$props => {
		if ("presets" in $$props) $$invalidate(0, presets = $$props.presets);
		if ("disabled" in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ("onclickpreset" in $$props) $$invalidate(2, onclickpreset = $$props.onclickpreset);
		if ("ongrabpreset" in $$props) $$invalidate(3, ongrabpreset = $$props.ongrabpreset);
		if ("ondragpreset" in $$props) $$invalidate(4, ondragpreset = $$props.ondragpreset);
		if ("ondroppreset" in $$props) $$invalidate(5, ondroppreset = $$props.ondroppreset);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$anim*/ 512) {
			$$invalidate(6, style = `opacity:${$anim}`);
		}
	};

	return [
		presets,
		disabled,
		onclickpreset,
		ongrabpreset,
		ondragpreset,
		ondroppreset,
		style,
		anim,
		didMountPresetThumb,
		$anim,
		func,
		func_1,
		func_2,
		func_3
	];
}

class ShapePresetsList extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$a, create_fragment$a, safe_not_equal, {
			presets: 0,
			disabled: 1,
			onclickpreset: 2,
			ongrabpreset: 3,
			ondragpreset: 4,
			ondroppreset: 5
		});
	}
}

var isSVGMarkup = (str) => /<svg /.test(str);

/* src/core/ui/components/ShapePresetsPalette.svelte generated by Svelte v3.37.0 */

function create_if_block_6(ctx) {
	let dynamiccomponenttree;
	let current;

	dynamiccomponenttree = new DynamicComponentTree_1({
			props: { items: /*presetToolbar*/ ctx[13] }
		});

	return {
		c() {
			create_component(dynamiccomponenttree.$$.fragment);
		},
		m(target, anchor) {
			mount_component(dynamiccomponenttree, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const dynamiccomponenttree_changes = {};
			if (dirty & /*presetToolbar*/ 8192) dynamiccomponenttree_changes.items = /*presetToolbar*/ ctx[13];
			dynamiccomponenttree.$set(dynamiccomponenttree_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dynamiccomponenttree.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dynamiccomponenttree.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(dynamiccomponenttree, detaching);
		}
	};
}

// (246:4) {#if shouldRenderPresets}
function create_if_block$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*shouldGroupPresets*/ ctx[7]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty$1();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (300:8) {:else}
function create_else_block$1(ctx) {
	let div;
	let t;
	let scrollable;
	let current;
	let if_block = /*presetToolbar*/ ctx[13] && create_if_block_5$1(ctx);

	scrollable = new Scrollable({
			props: {
				scrollAutoCancel: /*shouldRenderPresets*/ ctx[6],
				elasticity: /*scrollElasticity*/ ctx[0],
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			create_component(scrollable.$$.fragment);
			attr(div, "class", "PinturaShapePresetsFlat");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append(div, t);
			mount_component(scrollable, div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*presetToolbar*/ ctx[13]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*presetToolbar*/ 8192) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_5$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const scrollable_changes = {};
			if (dirty & /*shouldRenderPresets*/ 64) scrollable_changes.scrollAutoCancel = /*shouldRenderPresets*/ ctx[6];
			if (dirty & /*scrollElasticity*/ 1) scrollable_changes.elasticity = /*scrollElasticity*/ ctx[0];

			if (dirty & /*$$scope, presetsMapped, onaddpreset, ongrabpreset, ondragpreset, ondroppreset*/ 536870974) {
				scrollable_changes.$$scope = { dirty, ctx };
			}

			scrollable.$set(scrollable_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(scrollable.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(scrollable.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			destroy_component(scrollable);
		}
	};
}

// (249:8) {#if shouldGroupPresets}
function create_if_block_1$1(ctx) {
	let div1;
	let div0;
	let t0;
	let tablist;
	let t1;
	let tabpanels;
	let current;
	let if_block = /*presetToolbar*/ ctx[13] && create_if_block_4$1(ctx);

	const tablist_spread_levels = [
		{ class: "PinturaControlList" },
		{ tabs: /*tabs*/ ctx[8] },
		/*tabsConfig*/ ctx[11],
		{ layout: "compact" }
	];

	let tablist_props = {
		$$slots: {
			default: [
				create_default_slot_2,
				({ tab }) => ({ 28: tab }),
				({ tab }) => tab ? 268435456 : 0
			]
		},
		$$scope: { ctx }
	};

	for (let i = 0; i < tablist_spread_levels.length; i += 1) {
		tablist_props = assign(tablist_props, tablist_spread_levels[i]);
	}

	tablist = new TabList({ props: tablist_props });
	tablist.$on("select", /*select_handler*/ ctx[18]);

	const tabpanels_spread_levels = [
		{ class: "PinturaControlPanels" },
		{ panelClass: "PinturaControlPanel" },
		{ panels: /*panels*/ ctx[12] },
		/*tabsConfig*/ ctx[11]
	];

	let tabpanels_props = {
		$$slots: {
			default: [
				create_default_slot$4,
				({ panel, panelIsActive }) => ({ 26: panel, 27: panelIsActive }),
				({ panel, panelIsActive }) => (panel ? 67108864 : 0) | (panelIsActive ? 134217728 : 0)
			]
		},
		$$scope: { ctx }
	};

	for (let i = 0; i < tabpanels_spread_levels.length; i += 1) {
		tabpanels_props = assign(tabpanels_props, tabpanels_spread_levels[i]);
	}

	tabpanels = new TabPanels({ props: tabpanels_props });

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			create_component(tablist.$$.fragment);
			t1 = space();
			create_component(tabpanels.$$.fragment);
			attr(div0, "class", "PinturaShapePresetsGroups");
			attr(div1, "class", "PinturaShapePresetsGrouped");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			if (if_block) if_block.m(div0, null);
			append(div0, t0);
			mount_component(tablist, div0, null);
			append(div1, t1);
			mount_component(tabpanels, div1, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*presetToolbar*/ ctx[13]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*presetToolbar*/ 8192) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_4$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div0, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const tablist_changes = (dirty & /*tabs, tabsConfig*/ 2304)
			? get_spread_update(tablist_spread_levels, [
					tablist_spread_levels[0],
					dirty & /*tabs*/ 256 && { tabs: /*tabs*/ ctx[8] },
					dirty & /*tabsConfig*/ 2048 && get_spread_object(/*tabsConfig*/ ctx[11]),
					tablist_spread_levels[3]
				])
			: {};

			if (dirty & /*$$scope, tab*/ 805306368) {
				tablist_changes.$$scope = { dirty, ctx };
			}

			tablist.$set(tablist_changes);

			const tabpanels_changes = (dirty & /*panels, tabsConfig*/ 6144)
			? get_spread_update(tabpanels_spread_levels, [
					tabpanels_spread_levels[0],
					tabpanels_spread_levels[1],
					dirty & /*panels*/ 4096 && { panels: /*panels*/ ctx[12] },
					dirty & /*tabsConfig*/ 2048 && get_spread_object(/*tabsConfig*/ ctx[11])
				])
			: {};

			if (dirty & /*$$scope, panelIsActive, shouldRenderPresets, scrollElasticity, presetTabs, panel, onaddpreset, ongrabpreset, ondragpreset, ondroppreset*/ 738198623) {
				tabpanels_changes.$$scope = { dirty, ctx };
			}

			tabpanels.$set(tabpanels_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(tablist.$$.fragment, local);
			transition_in(tabpanels.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(tablist.$$.fragment, local);
			transition_out(tabpanels.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block) if_block.d();
			destroy_component(tablist);
			destroy_component(tabpanels);
		}
	};
}

// (305:12) {#if presetToolbar}
function create_if_block_5$1(ctx) {
	let dynamiccomponenttree;
	let current;

	dynamiccomponenttree = new DynamicComponentTree_1({
			props: { items: /*presetToolbar*/ ctx[13] }
		});

	return {
		c() {
			create_component(dynamiccomponenttree.$$.fragment);
		},
		m(target, anchor) {
			mount_component(dynamiccomponenttree, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const dynamiccomponenttree_changes = {};
			if (dirty & /*presetToolbar*/ 8192) dynamiccomponenttree_changes.items = /*presetToolbar*/ ctx[13];
			dynamiccomponenttree.$set(dynamiccomponenttree_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dynamiccomponenttree.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dynamiccomponenttree.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(dynamiccomponenttree, detaching);
		}
	};
}

// (309:12) <Scrollable scrollAutoCancel={shouldRenderPresets} elasticity={scrollElasticity}>
function create_default_slot_4(ctx) {
	let shapepresetslist;
	let current;

	shapepresetslist = new ShapePresetsList({
			props: {
				presets: /*presetsMapped*/ ctx[5],
				onclickpreset: /*onaddpreset*/ ctx[1],
				ongrabpreset: /*ongrabpreset*/ ctx[2],
				ondragpreset: /*ondragpreset*/ ctx[3],
				ondroppreset: /*ondroppreset*/ ctx[4]
			}
		});

	return {
		c() {
			create_component(shapepresetslist.$$.fragment);
		},
		m(target, anchor) {
			mount_component(shapepresetslist, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const shapepresetslist_changes = {};
			if (dirty & /*presetsMapped*/ 32) shapepresetslist_changes.presets = /*presetsMapped*/ ctx[5];
			if (dirty & /*onaddpreset*/ 2) shapepresetslist_changes.onclickpreset = /*onaddpreset*/ ctx[1];
			if (dirty & /*ongrabpreset*/ 4) shapepresetslist_changes.ongrabpreset = /*ongrabpreset*/ ctx[2];
			if (dirty & /*ondragpreset*/ 8) shapepresetslist_changes.ondragpreset = /*ondragpreset*/ ctx[3];
			if (dirty & /*ondroppreset*/ 16) shapepresetslist_changes.ondroppreset = /*ondroppreset*/ ctx[4];
			shapepresetslist.$set(shapepresetslist_changes);
		},
		i(local) {
			if (current) return;
			transition_in(shapepresetslist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(shapepresetslist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(shapepresetslist, detaching);
		}
	};
}

// (254:20) {#if presetToolbar}
function create_if_block_4$1(ctx) {
	let dynamiccomponenttree;
	let current;

	dynamiccomponenttree = new DynamicComponentTree_1({
			props: { items: /*presetToolbar*/ ctx[13] }
		});

	return {
		c() {
			create_component(dynamiccomponenttree.$$.fragment);
		},
		m(target, anchor) {
			mount_component(dynamiccomponenttree, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const dynamiccomponenttree_changes = {};
			if (dirty & /*presetToolbar*/ 8192) dynamiccomponenttree_changes.items = /*presetToolbar*/ ctx[13];
			dynamiccomponenttree.$set(dynamiccomponenttree_changes);
		},
		i(local) {
			if (current) return;
			transition_in(dynamiccomponenttree.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dynamiccomponenttree.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(dynamiccomponenttree, detaching);
		}
	};
}

// (262:24) {#if tab.icon }
function create_if_block_3$1(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(icon.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope, tab*/ 805306368) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon, detaching);
		}
	};
}

// (263:24) <Icon>
function create_default_slot_3(ctx) {
	let g;
	let raw_value = /*tab*/ ctx[28].icon + "";

	return {
		c() {
			g = svg_element("g");
		},
		m(target, anchor) {
			insert(target, g, anchor);
			g.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty & /*tab*/ 268435456 && raw_value !== (raw_value = /*tab*/ ctx[28].icon + "")) g.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) detach(g);
		}
	};
}

// (265:24) {#if !tab.hideLabel}
function create_if_block_2$1(ctx) {
	let span;
	let t_value = /*tab*/ ctx[28].label + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text$1(t_value);
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*tab*/ 268435456 && t_value !== (t_value = /*tab*/ ctx[28].label + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (258:20) <TabList class="PinturaControlList"                          {tabs} {...tabsConfig}                          layout="compact"                         on:select={({ detail }) => tabSelected = detail} let:tab={tab}>
function create_default_slot_2(ctx) {
	let t;
	let if_block1_anchor;
	let current;
	let if_block0 = /*tab*/ ctx[28].icon && create_if_block_3$1(ctx);
	let if_block1 = !/*tab*/ ctx[28].hideLabel && create_if_block_2$1(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty$1();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*tab*/ ctx[28].icon) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*tab*/ 268435456) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (!/*tab*/ ctx[28].hideLabel) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2$1(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (280:16) <Scrollable                      scroll={panelIsActive ? { scrollOffset: 0, animate: false } : undefined}                     scrollAutoCancel={shouldRenderPresets}                      elasticity={scrollElasticity}>
function create_default_slot_1$1(ctx) {
	let shapepresetslist;
	let current;

	shapepresetslist = new ShapePresetsList({
			props: {
				presets: /*presetTabs*/ ctx[10][/*panel*/ ctx[26]].items,
				disabled: /*presetTabs*/ ctx[10][/*panel*/ ctx[26]].disabled,
				onclickpreset: /*onaddpreset*/ ctx[1],
				ongrabpreset: /*ongrabpreset*/ ctx[2],
				ondragpreset: /*ondragpreset*/ ctx[3],
				ondroppreset: /*ondroppreset*/ ctx[4]
			}
		});

	return {
		c() {
			create_component(shapepresetslist.$$.fragment);
		},
		m(target, anchor) {
			mount_component(shapepresetslist, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const shapepresetslist_changes = {};
			if (dirty & /*presetTabs, panel*/ 67109888) shapepresetslist_changes.presets = /*presetTabs*/ ctx[10][/*panel*/ ctx[26]].items;
			if (dirty & /*presetTabs, panel*/ 67109888) shapepresetslist_changes.disabled = /*presetTabs*/ ctx[10][/*panel*/ ctx[26]].disabled;
			if (dirty & /*onaddpreset*/ 2) shapepresetslist_changes.onclickpreset = /*onaddpreset*/ ctx[1];
			if (dirty & /*ongrabpreset*/ 4) shapepresetslist_changes.ongrabpreset = /*ongrabpreset*/ ctx[2];
			if (dirty & /*ondragpreset*/ 8) shapepresetslist_changes.ondragpreset = /*ondragpreset*/ ctx[3];
			if (dirty & /*ondroppreset*/ 16) shapepresetslist_changes.ondroppreset = /*ondroppreset*/ ctx[4];
			shapepresetslist.$set(shapepresetslist_changes);
		},
		i(local) {
			if (current) return;
			transition_in(shapepresetslist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(shapepresetslist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(shapepresetslist, detaching);
		}
	};
}

// (272:12) <TabPanels                  class="PinturaControlPanels"                  panelClass="PinturaControlPanel"                  {panels}                  {...tabsConfig}                  let:panel                  let:panelIsActive>
function create_default_slot$4(ctx) {
	let scrollable;
	let current;

	scrollable = new Scrollable({
			props: {
				scroll: /*panelIsActive*/ ctx[27]
				? { scrollOffset: 0, animate: false }
				: undefined,
				scrollAutoCancel: /*shouldRenderPresets*/ ctx[6],
				elasticity: /*scrollElasticity*/ ctx[0],
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(scrollable.$$.fragment);
		},
		m(target, anchor) {
			mount_component(scrollable, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const scrollable_changes = {};

			if (dirty & /*panelIsActive*/ 134217728) scrollable_changes.scroll = /*panelIsActive*/ ctx[27]
			? { scrollOffset: 0, animate: false }
			: undefined;

			if (dirty & /*shouldRenderPresets*/ 64) scrollable_changes.scrollAutoCancel = /*shouldRenderPresets*/ ctx[6];
			if (dirty & /*scrollElasticity*/ 1) scrollable_changes.elasticity = /*scrollElasticity*/ ctx[0];

			if (dirty & /*$$scope, presetTabs, panel, onaddpreset, ongrabpreset, ondragpreset, ondroppreset*/ 603980830) {
				scrollable_changes.$$scope = { dirty, ctx };
			}

			scrollable.$set(scrollable_changes);
		},
		i(local) {
			if (current) return;
			transition_in(scrollable.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(scrollable.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(scrollable, detaching);
		}
	};
}

function create_fragment$9(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$1, create_if_block_6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*shouldRenderPresets*/ ctx[6]) return 0;
		if (/*presetToolbar*/ ctx[13]) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "class", "PinturaShapePresetsPalette");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let presetsMapped;
	let shouldRenderPresets;
	let shouldGroupPresets;
	let tabs;
	let presetTabs;
	let tabSelected;
	let tabsConfig;
	let panels;
	let presetToolbar;
	let { locale } = $$props;
	let { presets } = $$props;
	let { scrollElasticity } = $$props;
	let { enableSelectImage = true } = $$props;
	let { willRenderPresetToolbar = passthrough } = $$props;
	let { onaddpreset = noop$1 } = $$props;
	let { ongrabpreset = undefined } = $$props;
	let { ondragpreset = undefined } = $$props;
	let { ondroppreset = undefined } = $$props;
	const uid = `presets-${getUniqueId()}`;
	const isPresetGroup = item => isArray(item) && isString(item[0]) && isArray(item[1]);

	const getPresetThumb = (value, alt = "") => {
		// could be svg
		if (isSVGMarkup(value)) return value;

		// test if is emoji
		if (isEmoji(value)) return getEmojiSVG(value, alt);

		// must be URL
		return `<img src="${value}" alt="${alt}"/>`;
	};

	const getAltFromSrc = src => getFilenameWithoutExtension(getFilenameFromURL(src));
	const excludedStickerItemProps = ["src", "alt", "thumb", "shape", "id", "mount", "disabled"];

	const mapPreset = item => {
		let id = item;
		let src;
		let shape;
		let shapeProps;
		let thumb;
		let alt;
		let mount;
		let disabled;

		// if item is a string, it's either an emoji or a URL
		if (isString(item)) {
			// is emoji
			if (isEmoji(item)) {
				src = item;
				alt = item;
				thumb = getPresetThumb(src, alt);
			} else // must be URL
			{
				src = item;
				alt = getAltFromSrc(src);
				thumb = getPresetThumb(src, alt);
			}
		} else {
			// set custom thumbnail if defined
			src = item.src;

			alt = item.alt || (isString(src)
			? getAltFromSrc(src)
			: isString(item.thumb)
				? getAltFromSrc(item.thumb)
				: undefined);

			thumb = getPresetThumb(item.thumb || src, alt);
			shape = item.shape;
			mount = item.mount;
			disabled = item.disabled;

			shapeProps = Object.keys(item).reduce(
				(prev, curr) => {
					if (excludedStickerItemProps.includes(curr)) return prev;
					prev[curr] = item[curr];
					return prev;
				},
				{}
			);
		}

		return {
			id,
			src,
			thumb,
			shape,
			shapeProps,
			alt,
			title: alt,
			mount,
			disabled
		};
	};

	const mapPresets = items => items.map(item => {
		if (isPresetGroup(item)) {
			return {
				...item[2],
				id: `${uid}-${item[0].toLowerCase()}`,
				label: item[0],
				items: mapPresets(item[1])
			};
		}

		return mapPreset(item);
	});

	const select_handler = ({ detail }) => $$invalidate(9, tabSelected = detail);

	$$self.$$set = $$props => {
		if ("locale" in $$props) $$invalidate(14, locale = $$props.locale);
		if ("presets" in $$props) $$invalidate(15, presets = $$props.presets);
		if ("scrollElasticity" in $$props) $$invalidate(0, scrollElasticity = $$props.scrollElasticity);
		if ("enableSelectImage" in $$props) $$invalidate(16, enableSelectImage = $$props.enableSelectImage);
		if ("willRenderPresetToolbar" in $$props) $$invalidate(17, willRenderPresetToolbar = $$props.willRenderPresetToolbar);
		if ("onaddpreset" in $$props) $$invalidate(1, onaddpreset = $$props.onaddpreset);
		if ("ongrabpreset" in $$props) $$invalidate(2, ongrabpreset = $$props.ongrabpreset);
		if ("ondragpreset" in $$props) $$invalidate(3, ondragpreset = $$props.ondragpreset);
		if ("ondroppreset" in $$props) $$invalidate(4, ondroppreset = $$props.ondroppreset);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*presets*/ 32768) {
			$$invalidate(5, presetsMapped = mapPresets(presets));
		}

		if ($$self.$$.dirty & /*presetsMapped*/ 32) {
			//
			// handle file input
			//
			$$invalidate(6, shouldRenderPresets = presetsMapped.length);
		}

		if ($$self.$$.dirty & /*shouldRenderPresets, presetsMapped*/ 96) {
			$$invalidate(7, shouldGroupPresets = shouldRenderPresets && presetsMapped.some(preset => !!preset.items));
		}

		if ($$self.$$.dirty & /*shouldGroupPresets, presetsMapped*/ 160) {
			$$invalidate(8, tabs = shouldGroupPresets && presetsMapped);
		}

		if ($$self.$$.dirty & /*shouldGroupPresets, presetsMapped*/ 160) {
			$$invalidate(10, presetTabs = shouldGroupPresets && presetsMapped.reduce(
				(prev, curr) => {
					prev[curr.id] = curr;
					return prev;
				},
				{}
			));
		}

		if ($$self.$$.dirty & /*tabSelected, tabs*/ 768) {
			$$invalidate(9, tabSelected = tabSelected || tabs && (tabs.find(tab => !tab.disabled) || {}).id);
		}

		if ($$self.$$.dirty & /*tabSelected*/ 512) {
			$$invalidate(11, tabsConfig = { name: uid, selected: tabSelected });
		}

		if ($$self.$$.dirty & /*tabs*/ 256) {
			$$invalidate(12, panels = tabs && tabs.map(tab => tab.id));
		}

		if ($$self.$$.dirty & /*locale, willRenderPresetToolbar, enableSelectImage, onaddpreset*/ 212994) {
			$$invalidate(13, presetToolbar = locale && willRenderPresetToolbar([
				enableSelectImage && [
					"Button",
					"browse",
					{
						label: locale.shapeLabelButtonSelectSticker,
						icon: locale.shapeIconButtonSelectSticker,
						onclick: () => {
							// create file input box
							const fileInput = h$1("input", {
								type: "file",
								accept: "image/*",
								onchange: () => {
									const [file] = fileInput.files;
									if (!file) return;
									onaddpreset(file);
								}
							});

							// open browse window
							fileInput.click();
						}
					}
				]
			]));
		}
	};

	return [
		scrollElasticity,
		onaddpreset,
		ongrabpreset,
		ondragpreset,
		ondroppreset,
		presetsMapped,
		shouldRenderPresets,
		shouldGroupPresets,
		tabs,
		tabSelected,
		presetTabs,
		tabsConfig,
		panels,
		presetToolbar,
		locale,
		presets,
		enableSelectImage,
		willRenderPresetToolbar,
		select_handler
	];
}

class ShapePresetsPalette extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$9, create_fragment$9, safe_not_equal, {
			locale: 14,
			presets: 15,
			scrollElasticity: 0,
			enableSelectImage: 16,
			willRenderPresetToolbar: 17,
			onaddpreset: 1,
			ongrabpreset: 2,
			ondragpreset: 3,
			ondroppreset: 4
		});
	}
}

var createPingDispatcher = (node) => (type, data) => {
    node.dispatchEvent(new CustomEvent('ping', {
        detail: {
            type,
            data,
        },
        cancelable: true,
        bubbles: true,
    }));
};

/* src/core/ui/components/ShapeUtil.svelte generated by Svelte v3.37.0 */

function create_if_block_5(ctx) {
	let shapelayouteditor;
	let updating_markup;
	let updating_ui;
	let current;

	const shapelayouteditor_spread_levels = [
		{ locale: /*locale*/ ctx[4] },
		{ uid: /*utilKey*/ ctx[12] },
		{ parentRect: /*$parentRect*/ ctx[22] },
		{ rootRect: /*$rootRect*/ ctx[29] },
		{ utilRect: /*$utilRect*/ ctx[24] },
		{ offset: /*markupOffset*/ ctx[31] },
		{
			contextScale: /*$presentationScalar*/ ctx[41]
		},
		{
			contextRotation: /*imageRotation*/ ctx[15]
		},
		{ contextFlipX: /*imageFlipX*/ ctx[16] },
		{ contextFlipY: /*imageFlipY*/ ctx[17] },
		{ active: /*$isActive*/ ctx[23] },
		{ opacity: /*$isActiveFraction*/ ctx[26] },
		{ eraseRadius: /*toolEraseRadius*/ ctx[33] },
		{
			selectRadius: /*toolSelectRadius*/ ctx[6]
		},
		{
			enableButtonFlipVertical: /*enableButtonFlipVertical*/ ctx[8]
		},
		{
			mapEditorPointToImagePoint: /*mapScreenPointToImagePoint*/ ctx[13]
		},
		{
			mapImagePointToEditorPoint: /*mapImagePointToScreenPoint*/ ctx[14]
		},
		{
			enableTapToAddText: /*enableTapToAddText*/ ctx[10]
		},
		{
			oninteractionstart: /*handleInteractionStart*/ ctx[52]
		},
		{
			oninteractionupdate: /*handleInteractionUpdate*/ ctx[53]
		},
		{
			oninteractionrelease: /*handleInteractionRelease*/ ctx[54]
		},
		{
			oninteractionend: /*handleInteractionEnd*/ ctx[55]
		},
		{ onaddshape: /*func_1*/ ctx[85] },
		{ onselectshape: /*func_2*/ ctx[86] },
		{ onupdateshape: /*func_3*/ ctx[87] },
		{ onremoveshape: /*func_4*/ ctx[88] },
		/*layoutEditorHooks*/ ctx[38]
	];

	function shapelayouteditor_markup_binding(value) {
		/*shapelayouteditor_markup_binding*/ ctx[90](value);
	}

	function shapelayouteditor_ui_binding(value) {
		/*shapelayouteditor_ui_binding*/ ctx[91](value);
	}

	let shapelayouteditor_props = {};

	for (let i = 0; i < shapelayouteditor_spread_levels.length; i += 1) {
		shapelayouteditor_props = assign(shapelayouteditor_props, shapelayouteditor_spread_levels[i]);
	}

	if (/*$shapes*/ ctx[25] !== void 0) {
		shapelayouteditor_props.markup = /*$shapes*/ ctx[25];
	}

	if (/*$imageOverlayMarkup*/ ctx[40] !== void 0) {
		shapelayouteditor_props.ui = /*$imageOverlayMarkup*/ ctx[40];
	}

	shapelayouteditor = new ShapeLayoutEditor({ props: shapelayouteditor_props });
	/*shapelayouteditor_binding*/ ctx[89](shapelayouteditor);
	binding_callbacks.push(() => bind$1(shapelayouteditor, "markup", shapelayouteditor_markup_binding));
	binding_callbacks.push(() => bind$1(shapelayouteditor, "ui", shapelayouteditor_ui_binding));

	return {
		c() {
			create_component(shapelayouteditor.$$.fragment);
		},
		m(target, anchor) {
			mount_component(shapelayouteditor, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const shapelayouteditor_changes = (dirty[0] & /*locale, utilKey, $parentRect, $rootRect, $utilRect, imageRotation, imageFlipX, imageFlipY, $isActive, $isActiveFraction, toolSelectRadius, enableButtonFlipVertical, mapScreenPointToImagePoint, mapImagePointToScreenPoint, enableTapToAddText*/ 633599312 | dirty[1] & /*markupOffset, $presentationScalar, toolEraseRadius, handleInteractionStart, handleInteractionUpdate, handleInteractionRelease, handleInteractionEnd, ping, layoutEditorHooks*/ 31458453 | dirty[2] & /*handleMarkupUpdate*/ 1)
			? get_spread_update(shapelayouteditor_spread_levels, [
					dirty[0] & /*locale*/ 16 && { locale: /*locale*/ ctx[4] },
					dirty[0] & /*utilKey*/ 4096 && { uid: /*utilKey*/ ctx[12] },
					dirty[0] & /*$parentRect*/ 4194304 && { parentRect: /*$parentRect*/ ctx[22] },
					dirty[0] & /*$rootRect*/ 536870912 && { rootRect: /*$rootRect*/ ctx[29] },
					dirty[0] & /*$utilRect*/ 16777216 && { utilRect: /*$utilRect*/ ctx[24] },
					dirty[1] & /*markupOffset*/ 1 && { offset: /*markupOffset*/ ctx[31] },
					dirty[1] & /*$presentationScalar*/ 1024 && {
						contextScale: /*$presentationScalar*/ ctx[41]
					},
					dirty[0] & /*imageRotation*/ 32768 && {
						contextRotation: /*imageRotation*/ ctx[15]
					},
					dirty[0] & /*imageFlipX*/ 65536 && { contextFlipX: /*imageFlipX*/ ctx[16] },
					dirty[0] & /*imageFlipY*/ 131072 && { contextFlipY: /*imageFlipY*/ ctx[17] },
					dirty[0] & /*$isActive*/ 8388608 && { active: /*$isActive*/ ctx[23] },
					dirty[0] & /*$isActiveFraction*/ 67108864 && { opacity: /*$isActiveFraction*/ ctx[26] },
					dirty[1] & /*toolEraseRadius*/ 4 && { eraseRadius: /*toolEraseRadius*/ ctx[33] },
					dirty[0] & /*toolSelectRadius*/ 64 && {
						selectRadius: /*toolSelectRadius*/ ctx[6]
					},
					dirty[0] & /*enableButtonFlipVertical*/ 256 && {
						enableButtonFlipVertical: /*enableButtonFlipVertical*/ ctx[8]
					},
					dirty[0] & /*mapScreenPointToImagePoint*/ 8192 && {
						mapEditorPointToImagePoint: /*mapScreenPointToImagePoint*/ ctx[13]
					},
					dirty[0] & /*mapImagePointToScreenPoint*/ 16384 && {
						mapImagePointToEditorPoint: /*mapImagePointToScreenPoint*/ ctx[14]
					},
					dirty[0] & /*enableTapToAddText*/ 1024 && {
						enableTapToAddText: /*enableTapToAddText*/ ctx[10]
					},
					dirty[1] & /*handleInteractionStart*/ 2097152 && {
						oninteractionstart: /*handleInteractionStart*/ ctx[52]
					},
					dirty[1] & /*handleInteractionUpdate*/ 4194304 && {
						oninteractionupdate: /*handleInteractionUpdate*/ ctx[53]
					},
					dirty[1] & /*handleInteractionRelease*/ 8388608 && {
						oninteractionrelease: /*handleInteractionRelease*/ ctx[54]
					},
					dirty[1] & /*handleInteractionEnd*/ 16777216 && {
						oninteractionend: /*handleInteractionEnd*/ ctx[55]
					},
					dirty[1] & /*ping*/ 16 | dirty[2] & /*handleMarkupUpdate*/ 1 && { onaddshape: /*func_1*/ ctx[85] },
					dirty[1] & /*ping*/ 16 && { onselectshape: /*func_2*/ ctx[86] },
					dirty[1] & /*ping*/ 16 | dirty[2] & /*handleMarkupUpdate*/ 1 && { onupdateshape: /*func_3*/ ctx[87] },
					dirty[1] & /*ping*/ 16 | dirty[2] & /*handleMarkupUpdate*/ 1 && { onremoveshape: /*func_4*/ ctx[88] },
					dirty[1] & /*layoutEditorHooks*/ 128 && get_spread_object(/*layoutEditorHooks*/ ctx[38])
				])
			: {};

			if (!updating_markup && dirty[0] & /*$shapes*/ 33554432) {
				updating_markup = true;
				shapelayouteditor_changes.markup = /*$shapes*/ ctx[25];
				add_flush_callback(() => updating_markup = false);
			}

			if (!updating_ui && dirty[1] & /*$imageOverlayMarkup*/ 512) {
				updating_ui = true;
				shapelayouteditor_changes.ui = /*$imageOverlayMarkup*/ ctx[40];
				add_flush_callback(() => updating_ui = false);
			}

			shapelayouteditor.$set(shapelayouteditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(shapelayouteditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(shapelayouteditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			/*shapelayouteditor_binding*/ ctx[89](null);
			destroy_component(shapelayouteditor, detaching);
		}
	};
}

// (506:4) 
function create_main_slot(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	let if_block = /*shouldRenderShapeEditor*/ ctx[30] && create_if_block_5(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "slot", "main");
			set_style(div, "cursor", "crosshair");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			/*div_binding*/ ctx[92](div);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(dropable.call(null, div)),
					listen(div, "dropfiles", /*handleDropFiles*/ ctx[61]),
					action_destroyer(measurable.call(null, div)),
					listen(div, "measure", /*measure_handler_1*/ ctx[83])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*shouldRenderShapeEditor*/ ctx[30]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*shouldRenderShapeEditor*/ 1073741824) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_5(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			/*div_binding*/ ctx[92](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (601:38) 
function create_if_block_4(ctx) {
	let shapepresetspalette;
	let current;

	shapepresetspalette = new ShapePresetsPalette({
			props: {
				locale: /*locale*/ ctx[4],
				presets: /*shapePresets*/ ctx[11],
				enableSelectImage: /*enablePresetSelectImage*/ ctx[9],
				willRenderPresetToolbar: /*runWillRenderPresetToolbarHook*/ ctx[37],
				onaddpreset: /*handleAddPreset*/ ctx[60],
				ongrabpreset: /*handleGrabPreset*/ ctx[57],
				ondragpreset: /*handleDragPreset*/ ctx[58],
				ondroppreset: /*handleDropPreset*/ ctx[59],
				scrollElasticity: /*computedScrollElasticity*/ ctx[36]
			}
		});

	return {
		c() {
			create_component(shapepresetspalette.$$.fragment);
		},
		m(target, anchor) {
			mount_component(shapepresetspalette, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const shapepresetspalette_changes = {};
			if (dirty[0] & /*locale*/ 16) shapepresetspalette_changes.locale = /*locale*/ ctx[4];
			if (dirty[0] & /*shapePresets*/ 2048) shapepresetspalette_changes.presets = /*shapePresets*/ ctx[11];
			if (dirty[0] & /*enablePresetSelectImage*/ 512) shapepresetspalette_changes.enableSelectImage = /*enablePresetSelectImage*/ ctx[9];
			if (dirty[1] & /*runWillRenderPresetToolbarHook*/ 64) shapepresetspalette_changes.willRenderPresetToolbar = /*runWillRenderPresetToolbarHook*/ ctx[37];
			if (dirty[1] & /*computedScrollElasticity*/ 32) shapepresetspalette_changes.scrollElasticity = /*computedScrollElasticity*/ ctx[36];
			shapepresetspalette.$set(shapepresetspalette_changes);
		},
		i(local) {
			if (current) return;
			transition_in(shapepresetspalette.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(shapepresetspalette.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(shapepresetspalette, detaching);
		}
	};
}

// (554:8) {#if shouldRenderControls}
function create_if_block(ctx) {
	let div;
	let current_block_type_index;
	let if_block0;
	let t;
	let if_block1_anchor;
	let current;
	const if_block_creators = [create_if_block_3, create_else_block];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*shouldRenderPresets*/ ctx[34]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*showToolbar*/ ctx[21] && create_if_block_1(ctx);

	return {
		c() {
			div = element("div");
			if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty$1();
			attr(div, "class", "PinturaControlPanels");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(div, null);
			}

			if (/*showToolbar*/ ctx[21]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*showToolbar*/ 2097152) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
			if (detaching) detach(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (569:16) {:else}
function create_else_block(ctx) {
	let div;
	let shapestyleeditor;
	let current;

	shapestyleeditor = new ShapeStyleEditor({
			props: {
				locale: /*locale*/ ctx[4],
				shape: /*markupShapeSelected*/ ctx[32],
				onchange: /*handleUpdateSelectedMarkupShape*/ ctx[56],
				controls: /*shapeControls*/ ctx[7],
				scrollElasticity: /*computedScrollElasticity*/ ctx[36]
			}
		});

	return {
		c() {
			div = element("div");
			create_component(shapestyleeditor.$$.fragment);
			attr(div, "class", "PinturaControlPanel");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(shapestyleeditor, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const shapestyleeditor_changes = {};
			if (dirty[0] & /*locale*/ 16) shapestyleeditor_changes.locale = /*locale*/ ctx[4];
			if (dirty[1] & /*markupShapeSelected*/ 2) shapestyleeditor_changes.shape = /*markupShapeSelected*/ ctx[32];
			if (dirty[0] & /*shapeControls*/ 128) shapestyleeditor_changes.controls = /*shapeControls*/ ctx[7];
			if (dirty[1] & /*computedScrollElasticity*/ 32) shapestyleeditor_changes.scrollElasticity = /*computedScrollElasticity*/ ctx[36];
			shapestyleeditor.$set(shapestyleeditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(shapestyleeditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(shapestyleeditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(shapestyleeditor);
		}
	};
}

// (557:16) {#if shouldRenderPresets}
function create_if_block_3(ctx) {
	let div;
	let shapepresetspalette;
	let current;

	shapepresetspalette = new ShapePresetsPalette({
			props: {
				locale: /*locale*/ ctx[4],
				presets: /*shapePresets*/ ctx[11],
				enableSelectImage: /*enablePresetSelectImage*/ ctx[9],
				willRenderPresetToolbar: /*runWillRenderPresetToolbarHook*/ ctx[37],
				onaddpreset: /*handleAddPreset*/ ctx[60],
				ongrabpreset: /*handleGrabPreset*/ ctx[57],
				ondragpreset: /*handleDragPreset*/ ctx[58],
				ondroppreset: /*handleDropPreset*/ ctx[59],
				scrollElasticity: /*computedScrollElasticity*/ ctx[36]
			}
		});

	return {
		c() {
			div = element("div");
			create_component(shapepresetspalette.$$.fragment);
			attr(div, "class", "PinturaControlPanel");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(shapepresetspalette, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const shapepresetspalette_changes = {};
			if (dirty[0] & /*locale*/ 16) shapepresetspalette_changes.locale = /*locale*/ ctx[4];
			if (dirty[0] & /*shapePresets*/ 2048) shapepresetspalette_changes.presets = /*shapePresets*/ ctx[11];
			if (dirty[0] & /*enablePresetSelectImage*/ 512) shapepresetspalette_changes.enableSelectImage = /*enablePresetSelectImage*/ ctx[9];
			if (dirty[1] & /*runWillRenderPresetToolbarHook*/ 64) shapepresetspalette_changes.willRenderPresetToolbar = /*runWillRenderPresetToolbarHook*/ ctx[37];
			if (dirty[1] & /*computedScrollElasticity*/ 32) shapepresetspalette_changes.scrollElasticity = /*computedScrollElasticity*/ ctx[36];
			shapepresetspalette.$set(shapepresetspalette_changes);
		},
		i(local) {
			if (current) return;
			transition_in(shapepresetspalette.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(shapepresetspalette.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(shapepresetspalette);
		}
	};
}

// (580:12) {#if showToolbar }
function create_if_block_1(ctx) {
	let scrollable;
	let current;

	scrollable = new Scrollable({
			props: {
				class: "PinturaControlListScroller",
				elasticity: /*computedScrollElasticity*/ ctx[36],
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(scrollable.$$.fragment);
		},
		m(target, anchor) {
			mount_component(scrollable, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const scrollable_changes = {};
			if (dirty[1] & /*computedScrollElasticity*/ 32) scrollable_changes.elasticity = /*computedScrollElasticity*/ ctx[36];

			if (dirty[0] & /*locale, toolsFiltered, toolActive*/ 1048593 | dirty[3] & /*$$scope*/ 131072) {
				scrollable_changes.$$scope = { dirty, ctx };
			}

			scrollable.$set(scrollable_changes);
		},
		i(local) {
			if (current) return;
			transition_in(scrollable.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(scrollable.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(scrollable, detaching);
		}
	};
}

// (592:24) {#if option.icon}
function create_if_block_2(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(icon.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const icon_changes = {};

			if (dirty[0] & /*locale*/ 16 | dirty[3] & /*$$scope, option*/ 196608) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon, detaching);
		}
	};
}

// (593:24) <Icon>
function create_default_slot_1(ctx) {
	let g;

	let raw_value = (isFunction$1(/*option*/ ctx[109].icon)
	? /*option*/ ctx[109].icon(/*locale*/ ctx[4])
	: /*option*/ ctx[109].icon) + "";

	return {
		c() {
			g = svg_element("g");
		},
		m(target, anchor) {
			insert(target, g, anchor);
			g.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*locale*/ 16 | dirty[3] & /*option*/ 65536 && raw_value !== (raw_value = (isFunction$1(/*option*/ ctx[109].icon)
			? /*option*/ ctx[109].icon(/*locale*/ ctx[4])
			: /*option*/ ctx[109].icon) + "")) g.innerHTML = raw_value;		},
		d(detaching) {
			if (detaching) detach(g);
		}
	};
}

// (591:20) 
function create_option_slot$1(ctx) {
	let div;
	let t0;
	let span;

	let t1_value = (isFunction$1(/*option*/ ctx[109].label)
	? /*option*/ ctx[109].label(/*locale*/ ctx[4])
	: /*option*/ ctx[109].label) + "";

	let t1;
	let current;
	let if_block = /*option*/ ctx[109].icon && create_if_block_2(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t0 = space();
			span = element("span");
			t1 = text$1(t1_value);
			attr(div, "slot", "option");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append(div, t0);
			append(div, span);
			append(span, t1);
			current = true;
		},
		p(ctx, dirty) {
			if (/*option*/ ctx[109].icon) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[3] & /*option*/ 65536) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*locale*/ 16 | dirty[3] & /*option*/ 65536) && t1_value !== (t1_value = (isFunction$1(/*option*/ ctx[109].label)
			? /*option*/ ctx[109].label(/*locale*/ ctx[4])
			: /*option*/ ctx[109].label) + "")) set_data(t1, t1_value);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
		}
	};
}

// (581:12) <Scrollable class="PinturaControlListScroller" elasticity={computedScrollElasticity}>
function create_default_slot$3(ctx) {
	let radiogroup;
	let current;

	radiogroup = new RadioGroup({
			props: {
				locale: /*locale*/ ctx[4],
				class: "PinturaControlList",
				optionClass: "PinturaControlListOption",
				layout: "row",
				options: /*toolsFiltered*/ ctx[20],
				selectedIndex: /*toolsFiltered*/ ctx[20].findIndex(/*func*/ ctx[84]),
				onchange: /*updateActiveTool*/ ctx[51],
				$$slots: {
					option: [
						create_option_slot$1,
						({ option }) => ({ 109: option }),
						({ option }) => [0, 0, 0, option ? 65536 : 0]
					]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(radiogroup.$$.fragment);
		},
		m(target, anchor) {
			mount_component(radiogroup, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const radiogroup_changes = {};
			if (dirty[0] & /*locale*/ 16) radiogroup_changes.locale = /*locale*/ ctx[4];
			if (dirty[0] & /*toolsFiltered*/ 1048576) radiogroup_changes.options = /*toolsFiltered*/ ctx[20];
			if (dirty[0] & /*toolsFiltered, toolActive*/ 1048577) radiogroup_changes.selectedIndex = /*toolsFiltered*/ ctx[20].findIndex(/*func*/ ctx[84]);

			if (dirty[0] & /*locale*/ 16 | dirty[3] & /*$$scope, option*/ 196608) {
				radiogroup_changes.$$scope = { dirty, ctx };
			}

			radiogroup.$set(radiogroup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(radiogroup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(radiogroup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(radiogroup, detaching);
		}
	};
}

// (553:4) 
function create_footer_slot$2(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block, create_if_block_4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*shouldRenderControls*/ ctx[28]) return 0;
		if (/*shouldRenderPresets*/ ctx[34]) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "slot", "footer");
			attr(div, "style", /*footerStyle*/ ctx[39]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				} else {
					if_block = null;
				}
			}

			if (!current || dirty[1] & /*footerStyle*/ 256) {
				attr(div, "style", /*footerStyle*/ ctx[39]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}
		}
	};
}

function create_fragment$8(ctx) {
	let util;
	let current;

	util = new Util({
			props: {
				$$slots: {
					footer: [create_footer_slot$2],
					main: [create_main_slot]
				},
				$$scope: { ctx }
			}
		});

	util.$on("measure", /*measure_handler*/ ctx[93]);

	return {
		c() {
			create_component(util.$$.fragment);
		},
		m(target, anchor) {
			mount_component(util, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const util_changes = {};

			if (dirty[0] & /*locale, toolsFiltered, toolActive, showToolbar, shapePresets, enablePresetSelectImage, shapeControls, shouldRenderControls, pingHub, utilKey, $parentRect, $rootRect, $utilRect, imageRotation, imageFlipX, imageFlipY, $isActive, $isActiveFraction, toolSelectRadius, enableButtonFlipVertical, mapScreenPointToImagePoint, mapImagePointToScreenPoint, enableTapToAddText, markupEditor, $shapes, shouldRenderShapeEditor*/ 2147221457 | dirty[1] & /*footerStyle, computedScrollElasticity, runWillRenderPresetToolbarHook, shouldRenderPresets, markupShapeSelected, markupOffset, $presentationScalar, toolEraseRadius, ping, layoutEditorHooks, $imageOverlayMarkup*/ 2047 | dirty[3] & /*$$scope*/ 131072) {
				util_changes.$$scope = { dirty, ctx };
			}

			util.$set(util_changes);
		},
		i(local) {
			if (current) return;
			transition_in(util.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(util.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(util, detaching);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	let toolsFiltered;
	let showToolbar;
	let hasTools;
	let hasActiveTool;
	let shouldRenderControls;
	let shouldRenderShapeEditor;
	let markupOffset;
	let markupShapeKeys;
	let markupSelected;
	let markupToolShape;
	let markupToolStylesComputed;
	let markupShapeSelected;
	let toolEraseRadius;
	let shouldRenderPresets;
	let shouldStickToImage;
	let ping;
	let computedScrollElasticity;
	let runWillRenderPresetToolbarHook;
	let layoutEditorHooks;
	let footerStyle;

	let $parentRect,
		$$unsubscribe_parentRect = noop$2,
		$$subscribe_parentRect = () => ($$unsubscribe_parentRect(), $$unsubscribe_parentRect = subscribe(parentRect, $$value => $$invalidate(22, $parentRect = $$value)), parentRect);

	let $rootRect;

	let $isActive,
		$$unsubscribe_isActive = noop$2,
		$$subscribe_isActive = () => ($$unsubscribe_isActive(), $$unsubscribe_isActive = subscribe(isActive, $$value => $$invalidate(23, $isActive = $$value)), isActive);

	let $imagePreviewModifiers;

	let $isVisible,
		$$unsubscribe_isVisible = noop$2,
		$$subscribe_isVisible = () => ($$unsubscribe_isVisible(), $$unsubscribe_isVisible = subscribe(isVisible, $$value => $$invalidate(75, $isVisible = $$value)), isVisible);

	let $utilRect;
	let $stageRect;

	let $shapes,
		$$unsubscribe_shapes = noop$2,
		$$subscribe_shapes = () => ($$unsubscribe_shapes(), $$unsubscribe_shapes = subscribe(shapes, $$value => $$invalidate(25, $shapes = $$value)), shapes);

	let $isActiveFraction,
		$$unsubscribe_isActiveFraction = noop$2,
		$$subscribe_isActiveFraction = () => ($$unsubscribe_isActiveFraction(), $$unsubscribe_isActiveFraction = subscribe(isActiveFraction, $$value => $$invalidate(26, $isActiveFraction = $$value)), isActiveFraction);

	let $imageCropRect;
	let $env;
	let $animation;
	let $footerOffset;
	let $imageOverlayMarkup;
	let $presentationScalar;
	$$self.$$.on_destroy.push(() => $$unsubscribe_parentRect());
	$$self.$$.on_destroy.push(() => $$unsubscribe_isActive());
	$$self.$$.on_destroy.push(() => $$unsubscribe_isVisible());
	$$self.$$.on_destroy.push(() => $$unsubscribe_shapes());
	$$self.$$.on_destroy.push(() => $$unsubscribe_isActiveFraction());
	let { isActive } = $$props;
	$$subscribe_isActive();
	let { isActiveFraction } = $$props;
	$$subscribe_isActiveFraction();
	let { isVisible } = $$props;
	$$subscribe_isVisible();
	let { stores } = $$props;
	let { locale = {} } = $$props;
	let { shapes } = $$props;
	$$subscribe_shapes();
	let { tools = [] } = $$props;
	let { toolShapes = [] } = $$props;
	let { toolActive = undefined } = $$props;
	let { toolSelectRadius = undefined } = $$props;
	let { shapeControls = [] } = $$props;
	let { enableButtonFlipVertical = false } = $$props;
	let { enablePresetSelectImage = true } = $$props;
	let { enableSelectToolToAddShape = false } = $$props;
	let { enableTapToAddText = false } = $$props;
	let { willRenderPresetToolbar = undefined } = $$props;
	let { shapePresets = [] } = $$props;
	let { utilKey } = $$props;
	let { mapScreenPointToImagePoint } = $$props;
	let { mapImagePointToScreenPoint } = $$props;
	let { imageRotation = 0 } = $$props;
	let { imageFlipX = false } = $$props;
	let { imageFlipY = false } = $$props;
	let { parentRect } = $$props;
	$$subscribe_parentRect();
	let { hooks = {} } = $$props;

	const { env, animation, history, rootRect, stageRect, utilRect, elasticityMultiplier, scrollElasticity, imageOverlayMarkup, imagePreviewModifiers, imageCropRect, presentationScalar, // for panning / scaling the image
	imagePresentationScale, imagePresentationPan } = stores;

	component_subscribe($$self, env, value => $$invalidate(80, $env = value));
	component_subscribe($$self, animation, value => $$invalidate(81, $animation = value));
	component_subscribe($$self, rootRect, value => $$invalidate(29, $rootRect = value));
	component_subscribe($$self, stageRect, value => $$invalidate(76, $stageRect = value));
	component_subscribe($$self, utilRect, value => $$invalidate(24, $utilRect = value));
	component_subscribe($$self, imageOverlayMarkup, value => $$invalidate(40, $imageOverlayMarkup = value));
	component_subscribe($$self, imagePreviewModifiers, value => $$invalidate(73, $imagePreviewModifiers = value));
	component_subscribe($$self, imageCropRect, value => $$invalidate(97, $imageCropRect = value));
	component_subscribe($$self, presentationScalar, value => $$invalidate(41, $presentationScalar = value));

	const updateActiveTool = ({ value }, event) => {
		$$invalidate(0, toolActive = value);

		// if is keyboard navigating or should add shape
		if (enableSelectToolToAddShape || isConfirmKey(event.key)) {
			AddToolDefaultShape(value);
		}
	};

	const AddToolDefaultShape = tool => {
		const [shape, options] = toolShapes[tool];
		let isRelative = options.position === "relative";
		let shapeToAdd;
		const size = isRelative ? "20%" : $parentRect.width * 0.2;
		const x = isRelative ? "0%" : 0;
		const y = isRelative ? "0%" : 0;

		if (shapeIsRect(shape) || shapeIsText(shape)) {
			shapeToAdd = shapeDeepCopy(shape);
			shapeToAdd.x = x;
			shapeToAdd.y = y;
			shapeUpdateProps(shapeToAdd, { width: size, height: size }, $parentRect);
		} else if (shapeIsEllipse(shape)) {
			shapeToAdd = shapeDeepCopy(shape);
			shapeToAdd.x = x;
			shapeToAdd.y = y;
			shapeUpdateProps(shapeToAdd, { rx: size, ry: size }, $parentRect);
		} else if (shapeIsLine(shape)) {
			shapeToAdd = shapeDeepCopy(shape);
			shapeToAdd.x1 = x;
			shapeToAdd.y1 = y;
			shapeToAdd.x2 = x;
			shapeToAdd.y2 = y;
		}

		if (!shapeToAdd) return;

		Promise.resolve().then(() => {
			addShape(createShapeAtPosition(shapeToAdd, undefined, size));
		});
	};

	const mapScreenEventToImagePoint = e => mapScreenPointToImagePoint(getEventPositionInEditor(e, $rootRect));

	// A reference to the markup editor, we need this so we can call exported functions
	let markupEditor;

	// the current tool styles
	let markupToolStyles = {};

	//
	// Create new shape
	//
	let interactionHandler;

	const handleInteractionStart = e => {
		if (toolActive === "eraser") {
			interactionHandler = markupEditor.eraseShape();
		} else if (toolActive && toolShapes[toolActive]) {
			const [shape, options] = toolShapes[toolActive];
			interactionHandler = markupEditor.createShape({ ...shape, ...markupToolStylesComputed }, options);
		} else {
			interactionHandler = undefined;
		}

		if (!interactionHandler) return false;
		interactionHandler.start(e);
		return true;
	};

	const handleInteractionUpdate = e => {
		if (!interactionHandler) return false;
		interactionHandler.update(e);
		return true;
	};

	const handleInteractionRelease = e => {
		if (!interactionHandler) return false;
		interactionHandler.release(e);
		return true;
	};

	const handleInteractionEnd = e => {
		if (!interactionHandler) return false;
		interactionHandler.end(e);
		interactionHandler = undefined;
		return true;
	};

	function handleUpdateSelectedMarkupShape(props) {
		// remember style for when creating or styling other element
		Object.keys(props).forEach(key => $$invalidate(70, markupToolStyles[key] = props[key], markupToolStyles));

		// it's possible we're only updating default styles
		if (!markupSelected) return;

		// update element
		markupEditor.updateMarkupShape(markupSelected, props);

		// update markup style
		handleMarkupUpdate();
	}

	const createShapeAtPosition = (shape, position, size) => {
		// position defaults to crop center
		let positionIsCenter = false;

		if (!position) {
			// is centering to stage
			positionIsCenter = true;

			// calculate image or rect position
			position = shouldStickToImage
			? mapScreenPointToImagePoint(rectCenter($stageRect))
			: rectCenter($imageCropRect);
		}

		// adjust offset if parent rect is image crop rect
		position.x -= $parentRect.x || 0;

		position.y -= $parentRect.y || 0;

		// de-flip shape
		if (imageFlipX || imageFlipY) {
			shape.flipX = imageFlipX;
			shape.flipY = imageFlipY;
		}

		// reposition if there's already shapes at position and shape isn't full screen
		const shapesAlreadyAtPosition = markupEditor.getShapesNearPosition(position);

		if (positionIsCenter && shapesAlreadyAtPosition.length) {
			const dist = Math.min($imageCropRect.width, $imageCropRect.height) * 0.1;
			position.x += Math.round(-dist + Math.random() * dist * 2);
			position.y += Math.round(-dist + Math.random() * dist * 2);
		}

		// de-rotate shape
		if (imageRotation !== 0) {
			if (imageFlipX && imageFlipY) shape.rotation = -imageRotation; else if (imageFlipX) shape.rotation = imageRotation; else if (imageFlipY) shape.rotation = imageRotation; else shape.rotation = -imageRotation;
		}

		if (hasProp(shape, "width") && hasProp(shape, "height")) {
			const { width, height } = shapeGetPropsPixelValues(shape, ["width", "height"], $parentRect);

			shapeUpdateProps(
				shape,
				{
					x: position.x - width * 0.5,
					y: position.y - height * 0.5
				},
				$parentRect
			);
		} else if (shapeIsEllipse(shape)) {
			shapeUpdateProps(shape, { x: position.x, y: position.y }, $parentRect);
		} else if (shapeIsLine(shape)) {
			const { x1, y1, x2, y2 } = shapeGetPropsPixelValues(shape, ["x1", "y1", "x2", "y2"], $parentRect);
			const dist = vectorDistance(vectorCreate(x1, y1), vectorCreate(x2, y2));

			const l = dist || isString(size)
			? toPixelValue(size, $parentRect.width)
			: size;

			shapeUpdateProps(
				shape,
				{
					x1: position.x - l,
					y1: position.y + l,
					x2: position.x + l,
					y2: position.y - l
				},
				$parentRect
			);
		}

		return shape;
	};

	const addPreset = (preset, position) => {
		const shape = createShapeAtPosition(shapeCreateFromPreset(preset, $imageCropRect), position);
		return addShape(shape);
	};

	const addShape = shape => {
		const { beforeAddShape = () => true } = hooks;
		if (!beforeAddShape(shape)) return;
		markupEditor.addShape(shape);
		markupEditor.selectShape(shape);
		history.write();
		return shape;
	};

	let dragCancelled = false;

	const handleGrabPreset = () => {
		dragCancelled = false;
	};

	const handleDragPreset = (preset, e) => {
		if (dragCancelled) return;
		const { beforeAddShape = () => true } = hooks;
		const position = mapScreenEventToImagePoint(e);

		// create or update if is inside image
		const draft = markupEditor.getMarkupItemDraft();

		const inCropRect = rectContainsPoint($imageCropRect, {
			// adjust offset if parent rect is image crop rect
			x: position.x + ($parentRect.x || 0),
			y: position.y + ($parentRect.y || 0)
		});

		// remove draft if not dragging inside image
		if (draft && !inCropRect) markupEditor.discardMarkupItemDraft();

		// stop here if we're not in the crop rect
		if (!inCropRect) return;

		// create draft shape
		if (!draft) {
			const shape = createShapeAtPosition(shapeCreateFromPreset(preset, $imageCropRect), position);

			if (!beforeAddShape(shape)) {
				dragCancelled = true;
				e.preventDefault();
				return;
			}

			shapeMakeDraft(shape);
			markupEditor.addShape(shape);
			return;
		}

		// center shape on pointer if it has dimensions
		if (shapeIsRect(draft)) {
			position.x -= draft.width * 0.5;
			position.y -= draft.height * 0.5;
		}

		// update the draft shape
		markupEditor.updateMarkupShape(draft, position);
	};

	const handleDropPreset = (_, e) => {
		if (dragCancelled) return;
		const position = mapScreenEventToImagePoint(e);

		if (!rectContainsPoint($imageCropRect, {
			x: position.x + ($parentRect.x || 0),
			y: position.y + ($parentRect.y || 0)
		})) {
			markupEditor.discardMarkupItemDraft();
			return;
		}

		// confirm shape
		const shape = markupEditor.confirmMarkupItemDraft();

		markupEditor.selectShape(shape);

		// update history
		history.write();
	};

	const handleAddPreset = preset => addPreset(preset);
	const handleAddFiles = (files, position) => files.forEach(file => addPreset(file, position));
	const handleDropFiles = e => handleAddFiles(e.detail.resources, mapScreenEventToImagePoint(e.detail.event));

	//
	// Zoom
	//
	// const handleWheel = (e) => {
	//     // don't run default actions, prevent other actions from running
	//     e.preventDefault();
	//     e.stopPropagation();
	//     // convert wheel delta to scalar
	//     const delta = getWheelDelta(e);
	//     const scalar = 1 + (delta / 100);
	//     // update image zoom
	//     imagePresentationScale.update(v => v * scalar)
	// }
	// on:wheel|nonpassive={handleWheel} 
	//
	// History
	//
	const handleMarkupUpdate = () => history.write();

	// used to fire ping events from
	let pingHub;

	//
	// Footer style
	//
	const footerOffset = spring$2($animation ? 20 : 0);

	component_subscribe($$self, footerOffset, value => $$invalidate(82, $footerOffset = value));

	function measure_handler_1(event) {
		bubble($$self, event);
	}

	const func = option => option[0] === toolActive;

	const func_1 = shape => {
		ping("addshape", shape);
		handleMarkupUpdate();
	};

	const func_2 = shape => {
		ping("selectshape", shape);
	};

	const func_3 = shape => {
		ping("updateshape", shape);
		handleMarkupUpdate();
	};

	const func_4 = shape => {
		ping("removeshape", shape);
		handleMarkupUpdate();
	};

	function shapelayouteditor_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			markupEditor = $$value;
			$$invalidate(27, markupEditor);
		});
	}

	function shapelayouteditor_markup_binding(value) {
		$shapes = value;
		shapes.set($shapes);
	}

	function shapelayouteditor_ui_binding(value) {
		$imageOverlayMarkup = value;
		imageOverlayMarkup.set($imageOverlayMarkup);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			pingHub = $$value;
			$$invalidate(19, pingHub);
		});
	}

	function measure_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("isActive" in $$props) $$subscribe_isActive($$invalidate(1, isActive = $$props.isActive));
		if ("isActiveFraction" in $$props) $$subscribe_isActiveFraction($$invalidate(2, isActiveFraction = $$props.isActiveFraction));
		if ("isVisible" in $$props) $$subscribe_isVisible($$invalidate(3, isVisible = $$props.isVisible));
		if ("stores" in $$props) $$invalidate(64, stores = $$props.stores);
		if ("locale" in $$props) $$invalidate(4, locale = $$props.locale);
		if ("shapes" in $$props) $$subscribe_shapes($$invalidate(5, shapes = $$props.shapes));
		if ("tools" in $$props) $$invalidate(65, tools = $$props.tools);
		if ("toolShapes" in $$props) $$invalidate(66, toolShapes = $$props.toolShapes);
		if ("toolActive" in $$props) $$invalidate(0, toolActive = $$props.toolActive);
		if ("toolSelectRadius" in $$props) $$invalidate(6, toolSelectRadius = $$props.toolSelectRadius);
		if ("shapeControls" in $$props) $$invalidate(7, shapeControls = $$props.shapeControls);
		if ("enableButtonFlipVertical" in $$props) $$invalidate(8, enableButtonFlipVertical = $$props.enableButtonFlipVertical);
		if ("enablePresetSelectImage" in $$props) $$invalidate(9, enablePresetSelectImage = $$props.enablePresetSelectImage);
		if ("enableSelectToolToAddShape" in $$props) $$invalidate(67, enableSelectToolToAddShape = $$props.enableSelectToolToAddShape);
		if ("enableTapToAddText" in $$props) $$invalidate(10, enableTapToAddText = $$props.enableTapToAddText);
		if ("willRenderPresetToolbar" in $$props) $$invalidate(68, willRenderPresetToolbar = $$props.willRenderPresetToolbar);
		if ("shapePresets" in $$props) $$invalidate(11, shapePresets = $$props.shapePresets);
		if ("utilKey" in $$props) $$invalidate(12, utilKey = $$props.utilKey);
		if ("mapScreenPointToImagePoint" in $$props) $$invalidate(13, mapScreenPointToImagePoint = $$props.mapScreenPointToImagePoint);
		if ("mapImagePointToScreenPoint" in $$props) $$invalidate(14, mapImagePointToScreenPoint = $$props.mapImagePointToScreenPoint);
		if ("imageRotation" in $$props) $$invalidate(15, imageRotation = $$props.imageRotation);
		if ("imageFlipX" in $$props) $$invalidate(16, imageFlipX = $$props.imageFlipX);
		if ("imageFlipY" in $$props) $$invalidate(17, imageFlipY = $$props.imageFlipY);
		if ("parentRect" in $$props) $$subscribe_parentRect($$invalidate(18, parentRect = $$props.parentRect));
		if ("hooks" in $$props) $$invalidate(69, hooks = $$props.hooks);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*shapePresets*/ 2048 | $$self.$$.dirty[2] & /*tools*/ 8) {
			// remove presets tool if no shape presets defined
			$$invalidate(20, toolsFiltered = shapePresets.length === 0
			? tools.filter(tool => tool[0] !== "preset")
			: tools);
		}

		if ($$self.$$.dirty[0] & /*toolsFiltered*/ 1048576) {
			$$invalidate(21, showToolbar = toolsFiltered.length > 1);
		}

		if ($$self.$$.dirty[0] & /*toolsFiltered*/ 1048576) {
			$$invalidate(71, hasTools = !!toolsFiltered.length);
		}

		if ($$self.$$.dirty[0] & /*showToolbar, toolActive, toolsFiltered*/ 3145729) {
			// set to first tool in tools list if not defined
			if (showToolbar && toolActive === undefined) $$invalidate(0, toolActive = toolsFiltered[0][0]);
		}

		if ($$self.$$.dirty[0] & /*toolActive*/ 1) {
			$$invalidate(72, hasActiveTool = toolActive !== undefined);
		}

		if ($$self.$$.dirty[2] & /*hasActiveTool, hasTools*/ 1536) {
			$$invalidate(28, shouldRenderControls = !hasActiveTool || hasTools);
		}

		if ($$self.$$.dirty[0] & /*$isActive, utilKey*/ 8392704 | $$self.$$.dirty[2] & /*$imagePreviewModifiers*/ 2048) {
			//
			// enable seeing the markup outlines outside of the crop area
			// 
			if ($isActive) {
				set_store_value(imagePreviewModifiers, $imagePreviewModifiers[utilKey] = { maskMarkupOpacity: 0.85 }, $imagePreviewModifiers);
			} else {
				delete $imagePreviewModifiers[utilKey];
			}
		}

		if ($$self.$$.dirty[2] & /*$isVisible*/ 8192) {
			$$invalidate(30, shouldRenderShapeEditor = $isVisible);
		}

		if ($$self.$$.dirty[0] & /*$utilRect*/ 16777216 | $$self.$$.dirty[2] & /*$stageRect*/ 16384) {
			$$invalidate(31, markupOffset = $utilRect && vectorCreate($stageRect.x - $utilRect.x, $stageRect.y - $utilRect.y));
		}

		if ($$self.$$.dirty[0] & /*shapeControls*/ 128) {
			$$invalidate(77, markupShapeKeys = Object.keys(shapeControls));
		}

		if ($$self.$$.dirty[0] & /*$shapes*/ 33554432) {
			$$invalidate(78, markupSelected = ($shapes.filter(shapeIsSelected) || [])[0]);
		}

		if ($$self.$$.dirty[0] & /*$isActive, toolActive*/ 8388609 | $$self.$$.dirty[2] & /*toolShapes*/ 16) {
			$$invalidate(79, markupToolShape = $isActive && (toolShapes[toolActive]
			? shapeFormat(shapeDeepCopy(toolShapes[toolActive][0]))
			: {}));
		}

		if ($$self.$$.dirty[2] & /*markupToolShape, markupShapeKeys, markupToolStyles*/ 164096) {
			$$invalidate(74, markupToolStylesComputed = markupToolShape && Object.keys(markupToolShape).reduce(
				(prev, key) => {
					const isDisableStyleProp = key === "disableStyle";
					const isStylableProp = markupShapeKeys.find(shapeKey => shapeKey.split("_").includes(key));

					// skip props that can't be styled, but keep all `disable` props
					if (!isDisableStyleProp && !isStylableProp) return prev;

					// skip props that are set to undefined, this means they won't auto-inherit current styles (line won't inherit line ends)
					if (markupToolShape[key] === undefined) return prev;

					// apply this style
					prev[key] = markupToolStyles[key] || markupToolShape[key];

					return prev;
				},
				{}
			));
		}

		if ($$self.$$.dirty[2] & /*markupSelected, markupToolStylesComputed*/ 69632) {
			$$invalidate(32, markupShapeSelected = markupSelected || markupToolStylesComputed);
		}

		if ($$self.$$.dirty[2] & /*markupToolShape*/ 131072) {
			$$invalidate(33, toolEraseRadius = markupToolShape && isNumber$1(markupToolShape.eraseRadius)
			? markupToolShape.eraseRadius
			: undefined);
		}

		if ($$self.$$.dirty[0] & /*$isActiveFraction, toolActive, shapePresets, enablePresetSelectImage*/ 67111425) {
			//
			// presets
			//
			$$invalidate(34, shouldRenderPresets = $isActiveFraction > 0 && toolActive === "preset" && (shapePresets.length > 0 || enablePresetSelectImage));
		}

		if ($$self.$$.dirty[0] & /*$parentRect*/ 4194304) {
			// if parent rect is a `Size` we're sticking presets to the image context
			shouldStickToImage = !hasProp($parentRect, "x") && !hasProp($parentRect, "y");
		}

		if ($$self.$$.dirty[0] & /*pingHub*/ 524288) {
			$$invalidate(35, ping = pingHub && createPingDispatcher(pingHub));
		}

		if ($$self.$$.dirty[2] & /*willRenderPresetToolbar, $env*/ 262208) {
			//
			//
			//
			$$invalidate(37, runWillRenderPresetToolbarHook = willRenderPresetToolbar
			? toolbar => willRenderPresetToolbar(toolbar, addPreset, { ...$env })
			: passthrough);
		}

		if ($$self.$$.dirty[2] & /*hooks*/ 128) {
			//
			// filter out beforeAdd hook
			//
			$$invalidate(38, layoutEditorHooks = Object.keys(hooks).reduce(
				(prev, curr) => {
					if (curr === "beforeAddShape") return prev;
					prev[curr] = hooks[curr];
					return prev;
				},
				{}
			));
		}

		if ($$self.$$.dirty[0] & /*$isActive*/ 8388608 | $$self.$$.dirty[2] & /*$animation*/ 524288) {
			$animation && footerOffset.set($isActive ? 0 : 20);
		}

		if ($$self.$$.dirty[2] & /*$footerOffset*/ 1048576) {
			$$invalidate(39, footerStyle = $footerOffset
			? `transform: translateY(${$footerOffset}px)`
			: undefined);
		}
	};

	$$invalidate(36, computedScrollElasticity = elasticityMultiplier * scrollElasticity);

	return [
		toolActive,
		isActive,
		isActiveFraction,
		isVisible,
		locale,
		shapes,
		toolSelectRadius,
		shapeControls,
		enableButtonFlipVertical,
		enablePresetSelectImage,
		enableTapToAddText,
		shapePresets,
		utilKey,
		mapScreenPointToImagePoint,
		mapImagePointToScreenPoint,
		imageRotation,
		imageFlipX,
		imageFlipY,
		parentRect,
		pingHub,
		toolsFiltered,
		showToolbar,
		$parentRect,
		$isActive,
		$utilRect,
		$shapes,
		$isActiveFraction,
		markupEditor,
		shouldRenderControls,
		$rootRect,
		shouldRenderShapeEditor,
		markupOffset,
		markupShapeSelected,
		toolEraseRadius,
		shouldRenderPresets,
		ping,
		computedScrollElasticity,
		runWillRenderPresetToolbarHook,
		layoutEditorHooks,
		footerStyle,
		$imageOverlayMarkup,
		$presentationScalar,
		env,
		animation,
		rootRect,
		stageRect,
		utilRect,
		imageOverlayMarkup,
		imagePreviewModifiers,
		imageCropRect,
		presentationScalar,
		updateActiveTool,
		handleInteractionStart,
		handleInteractionUpdate,
		handleInteractionRelease,
		handleInteractionEnd,
		handleUpdateSelectedMarkupShape,
		handleGrabPreset,
		handleDragPreset,
		handleDropPreset,
		handleAddPreset,
		handleDropFiles,
		handleMarkupUpdate,
		footerOffset,
		stores,
		tools,
		toolShapes,
		enableSelectToolToAddShape,
		willRenderPresetToolbar,
		hooks,
		markupToolStyles,
		hasTools,
		hasActiveTool,
		$imagePreviewModifiers,
		markupToolStylesComputed,
		$isVisible,
		$stageRect,
		markupShapeKeys,
		markupSelected,
		markupToolShape,
		$env,
		$animation,
		$footerOffset,
		measure_handler_1,
		func,
		func_1,
		func_2,
		func_3,
		func_4,
		shapelayouteditor_binding,
		shapelayouteditor_markup_binding,
		shapelayouteditor_ui_binding,
		div_binding,
		measure_handler
	];
}

class ShapeUtil extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$8,
			create_fragment$8,
			safe_not_equal,
			{
				isActive: 1,
				isActiveFraction: 2,
				isVisible: 3,
				stores: 64,
				locale: 4,
				shapes: 5,
				tools: 65,
				toolShapes: 66,
				toolActive: 0,
				toolSelectRadius: 6,
				shapeControls: 7,
				enableButtonFlipVertical: 8,
				enablePresetSelectImage: 9,
				enableSelectToolToAddShape: 67,
				enableTapToAddText: 10,
				willRenderPresetToolbar: 68,
				shapePresets: 11,
				utilKey: 12,
				mapScreenPointToImagePoint: 13,
				mapImagePointToScreenPoint: 14,
				imageRotation: 15,
				imageFlipX: 16,
				imageFlipY: 17,
				parentRect: 18,
				hooks: 69
			},
			[-1, -1, -1, -1]
		);
	}

	get isActive() {
		return this.$$.ctx[1];
	}

	set isActive(isActive) {
		this.$set({ isActive });
		flush();
	}

	get isActiveFraction() {
		return this.$$.ctx[2];
	}

	set isActiveFraction(isActiveFraction) {
		this.$set({ isActiveFraction });
		flush();
	}

	get isVisible() {
		return this.$$.ctx[3];
	}

	set isVisible(isVisible) {
		this.$set({ isVisible });
		flush();
	}

	get stores() {
		return this.$$.ctx[64];
	}

	set stores(stores) {
		this.$set({ stores });
		flush();
	}

	get locale() {
		return this.$$.ctx[4];
	}

	set locale(locale) {
		this.$set({ locale });
		flush();
	}

	get shapes() {
		return this.$$.ctx[5];
	}

	set shapes(shapes) {
		this.$set({ shapes });
		flush();
	}

	get tools() {
		return this.$$.ctx[65];
	}

	set tools(tools) {
		this.$set({ tools });
		flush();
	}

	get toolShapes() {
		return this.$$.ctx[66];
	}

	set toolShapes(toolShapes) {
		this.$set({ toolShapes });
		flush();
	}

	get toolActive() {
		return this.$$.ctx[0];
	}

	set toolActive(toolActive) {
		this.$set({ toolActive });
		flush();
	}

	get toolSelectRadius() {
		return this.$$.ctx[6];
	}

	set toolSelectRadius(toolSelectRadius) {
		this.$set({ toolSelectRadius });
		flush();
	}

	get shapeControls() {
		return this.$$.ctx[7];
	}

	set shapeControls(shapeControls) {
		this.$set({ shapeControls });
		flush();
	}

	get enableButtonFlipVertical() {
		return this.$$.ctx[8];
	}

	set enableButtonFlipVertical(enableButtonFlipVertical) {
		this.$set({ enableButtonFlipVertical });
		flush();
	}

	get enablePresetSelectImage() {
		return this.$$.ctx[9];
	}

	set enablePresetSelectImage(enablePresetSelectImage) {
		this.$set({ enablePresetSelectImage });
		flush();
	}

	get enableSelectToolToAddShape() {
		return this.$$.ctx[67];
	}

	set enableSelectToolToAddShape(enableSelectToolToAddShape) {
		this.$set({ enableSelectToolToAddShape });
		flush();
	}

	get enableTapToAddText() {
		return this.$$.ctx[10];
	}

	set enableTapToAddText(enableTapToAddText) {
		this.$set({ enableTapToAddText });
		flush();
	}

	get willRenderPresetToolbar() {
		return this.$$.ctx[68];
	}

	set willRenderPresetToolbar(willRenderPresetToolbar) {
		this.$set({ willRenderPresetToolbar });
		flush();
	}

	get shapePresets() {
		return this.$$.ctx[11];
	}

	set shapePresets(shapePresets) {
		this.$set({ shapePresets });
		flush();
	}

	get utilKey() {
		return this.$$.ctx[12];
	}

	set utilKey(utilKey) {
		this.$set({ utilKey });
		flush();
	}

	get mapScreenPointToImagePoint() {
		return this.$$.ctx[13];
	}

	set mapScreenPointToImagePoint(mapScreenPointToImagePoint) {
		this.$set({ mapScreenPointToImagePoint });
		flush();
	}

	get mapImagePointToScreenPoint() {
		return this.$$.ctx[14];
	}

	set mapImagePointToScreenPoint(mapImagePointToScreenPoint) {
		this.$set({ mapImagePointToScreenPoint });
		flush();
	}

	get imageRotation() {
		return this.$$.ctx[15];
	}

	set imageRotation(imageRotation) {
		this.$set({ imageRotation });
		flush();
	}

	get imageFlipX() {
		return this.$$.ctx[16];
	}

	set imageFlipX(imageFlipX) {
		this.$set({ imageFlipX });
		flush();
	}

	get imageFlipY() {
		return this.$$.ctx[17];
	}

	set imageFlipY(imageFlipY) {
		this.$set({ imageFlipY });
		flush();
	}

	get parentRect() {
		return this.$$.ctx[18];
	}

	set parentRect(parentRect) {
		this.$set({ parentRect });
		flush();
	}

	get hooks() {
		return this.$$.ctx[69];
	}

	set hooks(hooks) {
		this.$set({ hooks });
		flush();
	}
}

var _mapImagePointToScreenPoint = (imagePoint, canvasSize, imageSize, imageOrigin, imageTranslation, imageRotation, imageScalar, imageFlipX, imageFlipY) => {
    const mappedPoint = vectorClone(imagePoint);
    const imageCenterX = imageSize.width * 0.5;
    const imageCenterY = imageSize.height * 0.5;
    const canvasCenterX = canvasSize.width * 0.5;
    const canvasCenterY = canvasSize.height * 0.5;
    const imageOffsetX = imageTranslation.x + imageOrigin.x;
    const imageOffsetY = imageTranslation.y + imageOrigin.y;
    if (imageFlipX)
        mappedPoint.x = imageSize.width - mappedPoint.x;
    if (imageFlipY)
        mappedPoint.y = imageSize.height - mappedPoint.y;
    // rotate around image center based on if image is rotated
    const c = Math.cos(imageRotation);
    const s = Math.sin(imageRotation);
    mappedPoint.x -= imageCenterX;
    mappedPoint.y -= imageCenterY;
    const rx = mappedPoint.x * c - mappedPoint.y * s;
    const ry = mappedPoint.x * s + mappedPoint.y * c;
    mappedPoint.x = imageCenterX + rx;
    mappedPoint.y = imageCenterY + ry;
    // position based on screen transforms
    mappedPoint.x *= imageScalar;
    mappedPoint.y *= imageScalar;
    mappedPoint.x += canvasCenterX;
    mappedPoint.y += canvasCenterY;
    mappedPoint.x += imageOffsetX;
    mappedPoint.y += imageOffsetY;
    mappedPoint.x -= imageCenterX * imageScalar;
    mappedPoint.y -= imageCenterY * imageScalar;
    const tx = (imageTranslation.x - imageOffsetX) * imageScalar;
    const ty = (imageTranslation.y - imageOffsetY) * imageScalar;
    const rtx = tx * c - ty * s;
    const rty = tx * s + ty * c;
    mappedPoint.x += rtx;
    mappedPoint.y += rty;
    return mappedPoint;
};

var _mapScreenPointToImagePoint = (screenPoint, canvasSize, imageSize, imageOrigin, imageTranslation, imageRotation, imageScalar, imageFlipX, imageFlipY) => {
    const mappedPoint = vectorClone(screenPoint);
    const imageCenter = sizeCenter(imageSize);
    const canvasCenter = sizeCenter(canvasSize);
    const imageOffset = vectorCreate(imageTranslation.x + imageOrigin.x, imageTranslation.y + imageOrigin.y);
    const c = Math.cos(imageRotation);
    const s = Math.sin(imageRotation);
    mappedPoint.x -= canvasCenter.x;
    mappedPoint.y -= canvasCenter.y;
    const tx = (imageTranslation.x - imageOffset.x) * imageScalar;
    const ty = (imageTranslation.y - imageOffset.y) * imageScalar;
    const rtx = tx * c - ty * s;
    const rty = tx * s + ty * c;
    mappedPoint.x -= rtx;
    mappedPoint.y -= rty;
    mappedPoint.x -= imageOffset.x;
    mappedPoint.y -= imageOffset.y;
    mappedPoint.x /= imageScalar;
    mappedPoint.y /= imageScalar;
    const rx = mappedPoint.x * c + mappedPoint.y * s;
    const ry = mappedPoint.x * s - mappedPoint.y * c;
    mappedPoint.x = rx;
    mappedPoint.y = -ry;
    mappedPoint.x += imageCenter.x;
    mappedPoint.y += imageCenter.y;
    if (imageFlipX)
        mappedPoint.x = imageSize.width - mappedPoint.x;
    if (imageFlipY)
        mappedPoint.y = imageSize.height - mappedPoint.y;
    return mappedPoint;
};

/* src/core/ui/plugins/annotate/index.svelte generated by Svelte v3.37.0 */

function create_fragment$7(ctx) {
	let shapeutil;
	let updating_toolActive;
	let current;

	function shapeutil_toolActive_binding(value) {
		/*shapeutil_toolActive_binding*/ ctx[39](value);
	}

	let shapeutil_props = {
		stores: /*stores*/ ctx[4],
		locale: /*locale*/ ctx[5],
		isActive: /*isActive*/ ctx[1],
		isActiveFraction: /*isActiveFraction*/ ctx[2],
		isVisible: /*isVisible*/ ctx[3],
		mapScreenPointToImagePoint: /*mapScreenPointToImagePoint*/ ctx[36],
		mapImagePointToScreenPoint: /*mapImagePointToScreenPoint*/ ctx[37],
		utilKey: "annotate",
		imageRotation: /*$imageRotation*/ ctx[28],
		imageFlipX: /*$imageFlipX*/ ctx[26],
		imageFlipY: /*$imageFlipY*/ ctx[27],
		shapes: /*imageAnnotation*/ ctx[30],
		tools: /*annotateTools*/ ctx[11] || /*markupEditorToolbar*/ ctx[6],
		toolShapes: /*annotateToolShapes*/ ctx[12] || /*markupEditorToolStyles*/ ctx[7],
		enableSelectToolToAddShape: /*enableSelectToolToAddShape*/ ctx[18],
		enableTapToAddText: /*enableTapToAddText*/ ctx[19],
		shapeControls: /*annotateShapeControls*/ ctx[13] || /*markupEditorShapeStyleControls*/ ctx[8],
		shapePresets: /*annotatePresets*/ ctx[16],
		enableButtonFlipVertical: /*annotateEnableButtonFlipVertical*/ ctx[14],
		parentRect: /*imageSize*/ ctx[31],
		enablePresetSelectImage: /*annotateEnableSelectImagePreset*/ ctx[15],
		toolSelectRadius: /*markupEditorToolSelectRadius*/ ctx[9],
		willRenderPresetToolbar: /*annotateWillRenderShapePresetToolbar*/ ctx[17] || /*willRenderShapePresetToolbar*/ ctx[10],
		hooks: {
			willRenderShapeControls: /*willRenderShapeControls*/ ctx[20],
			beforeAddShape: /*beforeAddShape*/ ctx[21],
			beforeRemoveShape: /*beforeRemoveShape*/ ctx[22],
			beforeDeselectShape: /*beforeDeselectShape*/ ctx[23],
			beforeSelectShape: /*beforeSelectShape*/ ctx[24],
			beforeUpdateShape: /*beforeUpdateShape*/ ctx[25]
		}
	};

	if (/*annotateActiveTool*/ ctx[0] !== void 0) {
		shapeutil_props.toolActive = /*annotateActiveTool*/ ctx[0];
	}

	shapeutil = new ShapeUtil({ props: shapeutil_props });
	binding_callbacks.push(() => bind$1(shapeutil, "toolActive", shapeutil_toolActive_binding));
	shapeutil.$on("measure", /*measure_handler*/ ctx[40]);

	return {
		c() {
			create_component(shapeutil.$$.fragment);
		},
		m(target, anchor) {
			mount_component(shapeutil, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const shapeutil_changes = {};
			if (dirty[0] & /*stores*/ 16) shapeutil_changes.stores = /*stores*/ ctx[4];
			if (dirty[0] & /*locale*/ 32) shapeutil_changes.locale = /*locale*/ ctx[5];
			if (dirty[0] & /*isActive*/ 2) shapeutil_changes.isActive = /*isActive*/ ctx[1];
			if (dirty[0] & /*isActiveFraction*/ 4) shapeutil_changes.isActiveFraction = /*isActiveFraction*/ ctx[2];
			if (dirty[0] & /*isVisible*/ 8) shapeutil_changes.isVisible = /*isVisible*/ ctx[3];
			if (dirty[0] & /*$imageRotation*/ 268435456) shapeutil_changes.imageRotation = /*$imageRotation*/ ctx[28];
			if (dirty[0] & /*$imageFlipX*/ 67108864) shapeutil_changes.imageFlipX = /*$imageFlipX*/ ctx[26];
			if (dirty[0] & /*$imageFlipY*/ 134217728) shapeutil_changes.imageFlipY = /*$imageFlipY*/ ctx[27];
			if (dirty[0] & /*annotateTools, markupEditorToolbar*/ 2112) shapeutil_changes.tools = /*annotateTools*/ ctx[11] || /*markupEditorToolbar*/ ctx[6];
			if (dirty[0] & /*annotateToolShapes, markupEditorToolStyles*/ 4224) shapeutil_changes.toolShapes = /*annotateToolShapes*/ ctx[12] || /*markupEditorToolStyles*/ ctx[7];
			if (dirty[0] & /*enableSelectToolToAddShape*/ 262144) shapeutil_changes.enableSelectToolToAddShape = /*enableSelectToolToAddShape*/ ctx[18];
			if (dirty[0] & /*enableTapToAddText*/ 524288) shapeutil_changes.enableTapToAddText = /*enableTapToAddText*/ ctx[19];
			if (dirty[0] & /*annotateShapeControls, markupEditorShapeStyleControls*/ 8448) shapeutil_changes.shapeControls = /*annotateShapeControls*/ ctx[13] || /*markupEditorShapeStyleControls*/ ctx[8];
			if (dirty[0] & /*annotatePresets*/ 65536) shapeutil_changes.shapePresets = /*annotatePresets*/ ctx[16];
			if (dirty[0] & /*annotateEnableButtonFlipVertical*/ 16384) shapeutil_changes.enableButtonFlipVertical = /*annotateEnableButtonFlipVertical*/ ctx[14];
			if (dirty[0] & /*annotateEnableSelectImagePreset*/ 32768) shapeutil_changes.enablePresetSelectImage = /*annotateEnableSelectImagePreset*/ ctx[15];
			if (dirty[0] & /*markupEditorToolSelectRadius*/ 512) shapeutil_changes.toolSelectRadius = /*markupEditorToolSelectRadius*/ ctx[9];
			if (dirty[0] & /*annotateWillRenderShapePresetToolbar, willRenderShapePresetToolbar*/ 132096) shapeutil_changes.willRenderPresetToolbar = /*annotateWillRenderShapePresetToolbar*/ ctx[17] || /*willRenderShapePresetToolbar*/ ctx[10];

			if (dirty[0] & /*willRenderShapeControls, beforeAddShape, beforeRemoveShape, beforeDeselectShape, beforeSelectShape, beforeUpdateShape*/ 66060288) shapeutil_changes.hooks = {
				willRenderShapeControls: /*willRenderShapeControls*/ ctx[20],
				beforeAddShape: /*beforeAddShape*/ ctx[21],
				beforeRemoveShape: /*beforeRemoveShape*/ ctx[22],
				beforeDeselectShape: /*beforeDeselectShape*/ ctx[23],
				beforeSelectShape: /*beforeSelectShape*/ ctx[24],
				beforeUpdateShape: /*beforeUpdateShape*/ ctx[25]
			};

			if (!updating_toolActive && dirty[0] & /*annotateActiveTool*/ 1) {
				updating_toolActive = true;
				shapeutil_changes.toolActive = /*annotateActiveTool*/ ctx[0];
				add_flush_callback(() => updating_toolActive = false);
			}

			shapeutil.$set(shapeutil_changes);
		},
		i(local) {
			if (current) return;
			transition_in(shapeutil.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(shapeutil.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(shapeutil, detaching);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let $rootRect;
	let $imageSize;
	let $imageTransforms;
	let $imageFlipX;
	let $imageFlipY;
	let $imageRotation;
	const name = "annotate";
	let { isActive } = $$props;
	let { isActiveFraction } = $$props;
	let { isVisible } = $$props;
	let { stores } = $$props;
	let { locale = {} } = $$props;
	let { markupEditorToolbar = undefined } = $$props;
	let { markupEditorToolStyles = undefined } = $$props;
	let { markupEditorShapeStyleControls = undefined } = $$props;
	let { markupEditorToolSelectRadius = undefined } = $$props;
	let { willRenderShapePresetToolbar = undefined } = $$props;
	let { annotateTools = undefined } = $$props;
	let { annotateToolShapes = undefined } = $$props;
	let { annotateShapeControls = undefined } = $$props;
	let { annotateActiveTool = undefined } = $$props;
	let { annotateEnableButtonFlipVertical = false } = $$props;
	let { annotateEnableSelectImagePreset = false } = $$props;
	let { annotatePresets = [] } = $$props;
	let { annotateWillRenderShapePresetToolbar = undefined } = $$props;
	let { enableSelectToolToAddShape = undefined } = $$props;
	let { enableTapToAddText = undefined } = $$props;
	let { willRenderShapeControls = undefined } = $$props;
	let { beforeAddShape = undefined } = $$props;
	let { beforeRemoveShape = undefined } = $$props;
	let { beforeDeselectShape = undefined } = $$props;
	let { beforeSelectShape = undefined } = $$props;
	let { beforeUpdateShape = undefined } = $$props;

	// connect filter choice to stores
	const { rootRect, imageAnnotation, imageSize, imageTransforms, imageRotation, imageFlipX, imageFlipY } = stores;

	component_subscribe($$self, rootRect, value => $$invalidate(41, $rootRect = value));
	component_subscribe($$self, imageSize, value => $$invalidate(42, $imageSize = value));
	component_subscribe($$self, imageTransforms, value => $$invalidate(43, $imageTransforms = value));
	component_subscribe($$self, imageRotation, value => $$invalidate(28, $imageRotation = value));
	component_subscribe($$self, imageFlipX, value => $$invalidate(26, $imageFlipX = value));
	component_subscribe($$self, imageFlipY, value => $$invalidate(27, $imageFlipY = value));

	//
	// Mapping coordinates
	//
	const mapScreenPointToImagePoint = point => _mapScreenPointToImagePoint(point, $rootRect, $imageSize, $imageTransforms.origin, $imageTransforms.translation, $imageTransforms.rotation.z, $imageTransforms.scale, $imageFlipX, $imageFlipY);

	const mapImagePointToScreenPoint = point => _mapImagePointToScreenPoint(point, $rootRect, $imageSize, $imageTransforms.origin, $imageTransforms.translation, $imageTransforms.rotation.z, $imageTransforms.scale, $imageFlipX, $imageFlipY);

	function shapeutil_toolActive_binding(value) {
		annotateActiveTool = value;
		$$invalidate(0, annotateActiveTool);
	}

	function measure_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("isActive" in $$props) $$invalidate(1, isActive = $$props.isActive);
		if ("isActiveFraction" in $$props) $$invalidate(2, isActiveFraction = $$props.isActiveFraction);
		if ("isVisible" in $$props) $$invalidate(3, isVisible = $$props.isVisible);
		if ("stores" in $$props) $$invalidate(4, stores = $$props.stores);
		if ("locale" in $$props) $$invalidate(5, locale = $$props.locale);
		if ("markupEditorToolbar" in $$props) $$invalidate(6, markupEditorToolbar = $$props.markupEditorToolbar);
		if ("markupEditorToolStyles" in $$props) $$invalidate(7, markupEditorToolStyles = $$props.markupEditorToolStyles);
		if ("markupEditorShapeStyleControls" in $$props) $$invalidate(8, markupEditorShapeStyleControls = $$props.markupEditorShapeStyleControls);
		if ("markupEditorToolSelectRadius" in $$props) $$invalidate(9, markupEditorToolSelectRadius = $$props.markupEditorToolSelectRadius);
		if ("willRenderShapePresetToolbar" in $$props) $$invalidate(10, willRenderShapePresetToolbar = $$props.willRenderShapePresetToolbar);
		if ("annotateTools" in $$props) $$invalidate(11, annotateTools = $$props.annotateTools);
		if ("annotateToolShapes" in $$props) $$invalidate(12, annotateToolShapes = $$props.annotateToolShapes);
		if ("annotateShapeControls" in $$props) $$invalidate(13, annotateShapeControls = $$props.annotateShapeControls);
		if ("annotateActiveTool" in $$props) $$invalidate(0, annotateActiveTool = $$props.annotateActiveTool);
		if ("annotateEnableButtonFlipVertical" in $$props) $$invalidate(14, annotateEnableButtonFlipVertical = $$props.annotateEnableButtonFlipVertical);
		if ("annotateEnableSelectImagePreset" in $$props) $$invalidate(15, annotateEnableSelectImagePreset = $$props.annotateEnableSelectImagePreset);
		if ("annotatePresets" in $$props) $$invalidate(16, annotatePresets = $$props.annotatePresets);
		if ("annotateWillRenderShapePresetToolbar" in $$props) $$invalidate(17, annotateWillRenderShapePresetToolbar = $$props.annotateWillRenderShapePresetToolbar);
		if ("enableSelectToolToAddShape" in $$props) $$invalidate(18, enableSelectToolToAddShape = $$props.enableSelectToolToAddShape);
		if ("enableTapToAddText" in $$props) $$invalidate(19, enableTapToAddText = $$props.enableTapToAddText);
		if ("willRenderShapeControls" in $$props) $$invalidate(20, willRenderShapeControls = $$props.willRenderShapeControls);
		if ("beforeAddShape" in $$props) $$invalidate(21, beforeAddShape = $$props.beforeAddShape);
		if ("beforeRemoveShape" in $$props) $$invalidate(22, beforeRemoveShape = $$props.beforeRemoveShape);
		if ("beforeDeselectShape" in $$props) $$invalidate(23, beforeDeselectShape = $$props.beforeDeselectShape);
		if ("beforeSelectShape" in $$props) $$invalidate(24, beforeSelectShape = $$props.beforeSelectShape);
		if ("beforeUpdateShape" in $$props) $$invalidate(25, beforeUpdateShape = $$props.beforeUpdateShape);
	};

	return [
		annotateActiveTool,
		isActive,
		isActiveFraction,
		isVisible,
		stores,
		locale,
		markupEditorToolbar,
		markupEditorToolStyles,
		markupEditorShapeStyleControls,
		markupEditorToolSelectRadius,
		willRenderShapePresetToolbar,
		annotateTools,
		annotateToolShapes,
		annotateShapeControls,
		annotateEnableButtonFlipVertical,
		annotateEnableSelectImagePreset,
		annotatePresets,
		annotateWillRenderShapePresetToolbar,
		enableSelectToolToAddShape,
		enableTapToAddText,
		willRenderShapeControls,
		beforeAddShape,
		beforeRemoveShape,
		beforeDeselectShape,
		beforeSelectShape,
		beforeUpdateShape,
		$imageFlipX,
		$imageFlipY,
		$imageRotation,
		rootRect,
		imageAnnotation,
		imageSize,
		imageTransforms,
		imageRotation,
		imageFlipX,
		imageFlipY,
		mapScreenPointToImagePoint,
		mapImagePointToScreenPoint,
		name,
		shapeutil_toolActive_binding,
		measure_handler
	];
}

class Annotate extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$7,
			create_fragment$7,
			safe_not_equal,
			{
				name: 38,
				isActive: 1,
				isActiveFraction: 2,
				isVisible: 3,
				stores: 4,
				locale: 5,
				markupEditorToolbar: 6,
				markupEditorToolStyles: 7,
				markupEditorShapeStyleControls: 8,
				markupEditorToolSelectRadius: 9,
				willRenderShapePresetToolbar: 10,
				annotateTools: 11,
				annotateToolShapes: 12,
				annotateShapeControls: 13,
				annotateActiveTool: 0,
				annotateEnableButtonFlipVertical: 14,
				annotateEnableSelectImagePreset: 15,
				annotatePresets: 16,
				annotateWillRenderShapePresetToolbar: 17,
				enableSelectToolToAddShape: 18,
				enableTapToAddText: 19,
				willRenderShapeControls: 20,
				beforeAddShape: 21,
				beforeRemoveShape: 22,
				beforeDeselectShape: 23,
				beforeSelectShape: 24,
				beforeUpdateShape: 25
			},
			[-1, -1]
		);
	}

	get name() {
		return this.$$.ctx[38];
	}

	get isActive() {
		return this.$$.ctx[1];
	}

	set isActive(isActive) {
		this.$set({ isActive });
		flush();
	}

	get isActiveFraction() {
		return this.$$.ctx[2];
	}

	set isActiveFraction(isActiveFraction) {
		this.$set({ isActiveFraction });
		flush();
	}

	get isVisible() {
		return this.$$.ctx[3];
	}

	set isVisible(isVisible) {
		this.$set({ isVisible });
		flush();
	}

	get stores() {
		return this.$$.ctx[4];
	}

	set stores(stores) {
		this.$set({ stores });
		flush();
	}

	get locale() {
		return this.$$.ctx[5];
	}

	set locale(locale) {
		this.$set({ locale });
		flush();
	}

	get markupEditorToolbar() {
		return this.$$.ctx[6];
	}

	set markupEditorToolbar(markupEditorToolbar) {
		this.$set({ markupEditorToolbar });
		flush();
	}

	get markupEditorToolStyles() {
		return this.$$.ctx[7];
	}

	set markupEditorToolStyles(markupEditorToolStyles) {
		this.$set({ markupEditorToolStyles });
		flush();
	}

	get markupEditorShapeStyleControls() {
		return this.$$.ctx[8];
	}

	set markupEditorShapeStyleControls(markupEditorShapeStyleControls) {
		this.$set({ markupEditorShapeStyleControls });
		flush();
	}

	get markupEditorToolSelectRadius() {
		return this.$$.ctx[9];
	}

	set markupEditorToolSelectRadius(markupEditorToolSelectRadius) {
		this.$set({ markupEditorToolSelectRadius });
		flush();
	}

	get willRenderShapePresetToolbar() {
		return this.$$.ctx[10];
	}

	set willRenderShapePresetToolbar(willRenderShapePresetToolbar) {
		this.$set({ willRenderShapePresetToolbar });
		flush();
	}

	get annotateTools() {
		return this.$$.ctx[11];
	}

	set annotateTools(annotateTools) {
		this.$set({ annotateTools });
		flush();
	}

	get annotateToolShapes() {
		return this.$$.ctx[12];
	}

	set annotateToolShapes(annotateToolShapes) {
		this.$set({ annotateToolShapes });
		flush();
	}

	get annotateShapeControls() {
		return this.$$.ctx[13];
	}

	set annotateShapeControls(annotateShapeControls) {
		this.$set({ annotateShapeControls });
		flush();
	}

	get annotateActiveTool() {
		return this.$$.ctx[0];
	}

	set annotateActiveTool(annotateActiveTool) {
		this.$set({ annotateActiveTool });
		flush();
	}

	get annotateEnableButtonFlipVertical() {
		return this.$$.ctx[14];
	}

	set annotateEnableButtonFlipVertical(annotateEnableButtonFlipVertical) {
		this.$set({ annotateEnableButtonFlipVertical });
		flush();
	}

	get annotateEnableSelectImagePreset() {
		return this.$$.ctx[15];
	}

	set annotateEnableSelectImagePreset(annotateEnableSelectImagePreset) {
		this.$set({ annotateEnableSelectImagePreset });
		flush();
	}

	get annotatePresets() {
		return this.$$.ctx[16];
	}

	set annotatePresets(annotatePresets) {
		this.$set({ annotatePresets });
		flush();
	}

	get annotateWillRenderShapePresetToolbar() {
		return this.$$.ctx[17];
	}

	set annotateWillRenderShapePresetToolbar(annotateWillRenderShapePresetToolbar) {
		this.$set({ annotateWillRenderShapePresetToolbar });
		flush();
	}

	get enableSelectToolToAddShape() {
		return this.$$.ctx[18];
	}

	set enableSelectToolToAddShape(enableSelectToolToAddShape) {
		this.$set({ enableSelectToolToAddShape });
		flush();
	}

	get enableTapToAddText() {
		return this.$$.ctx[19];
	}

	set enableTapToAddText(enableTapToAddText) {
		this.$set({ enableTapToAddText });
		flush();
	}

	get willRenderShapeControls() {
		return this.$$.ctx[20];
	}

	set willRenderShapeControls(willRenderShapeControls) {
		this.$set({ willRenderShapeControls });
		flush();
	}

	get beforeAddShape() {
		return this.$$.ctx[21];
	}

	set beforeAddShape(beforeAddShape) {
		this.$set({ beforeAddShape });
		flush();
	}

	get beforeRemoveShape() {
		return this.$$.ctx[22];
	}

	set beforeRemoveShape(beforeRemoveShape) {
		this.$set({ beforeRemoveShape });
		flush();
	}

	get beforeDeselectShape() {
		return this.$$.ctx[23];
	}

	set beforeDeselectShape(beforeDeselectShape) {
		this.$set({ beforeDeselectShape });
		flush();
	}

	get beforeSelectShape() {
		return this.$$.ctx[24];
	}

	set beforeSelectShape(beforeSelectShape) {
		this.$set({ beforeSelectShape });
		flush();
	}

	get beforeUpdateShape() {
		return this.$$.ctx[25];
	}

	set beforeUpdateShape(beforeUpdateShape) {
		this.$set({ beforeUpdateShape });
		flush();
	}
}

// @ts-ignore
var _plugin_annotate = { util: ['annotate', Annotate] };

/* src/core/ui/plugins/decorate/index.svelte generated by Svelte v3.37.0 */

function create_fragment$6(ctx) {
	let shapeutil;
	let updating_toolActive;
	let current;

	function shapeutil_toolActive_binding(value) {
		/*shapeutil_toolActive_binding*/ ctx[33](value);
	}

	let shapeutil_props = {
		stores: /*stores*/ ctx[4],
		locale: /*locale*/ ctx[5],
		isActive: /*isActive*/ ctx[1],
		isActiveFraction: /*isActiveFraction*/ ctx[2],
		isVisible: /*isVisible*/ ctx[3],
		mapScreenPointToImagePoint: /*mapScreenPointToImagePoint*/ ctx[30],
		mapImagePointToScreenPoint: /*mapImagePointToScreenPoint*/ ctx[31],
		utilKey: "decorate",
		shapes: /*imageDecoration*/ ctx[27],
		tools: /*decorateTools*/ ctx[11] || /*markupEditorToolbar*/ ctx[6],
		toolShapes: /*decorateToolShapes*/ ctx[12] || /*markupEditorToolStyles*/ ctx[7],
		shapeControls: /*decorateShapeControls*/ ctx[13] || /*markupEditorShapeStyleControls*/ ctx[8],
		shapePresets: /*decoratePresets*/ ctx[16],
		enableSelectToolToAddShape: /*enableSelectToolToAddShape*/ ctx[18],
		enableTapToAddText: /*enableTapToAddText*/ ctx[19],
		enablePresetSelectImage: /*decorateEnableSelectImagePreset*/ ctx[15],
		enableButtonFlipVertical: /*decorateEnableButtonFlipVertical*/ ctx[14],
		parentRect: /*imageCropRect*/ ctx[26],
		toolSelectRadius: /*markupEditorToolSelectRadius*/ ctx[9],
		willRenderPresetToolbar: /*decorateWillRenderShapePresetToolbar*/ ctx[17] || /*willRenderShapePresetToolbar*/ ctx[10],
		hooks: {
			willRenderShapeControls: /*willRenderShapeControls*/ ctx[20],
			beforeAddShape: /*beforeAddShape*/ ctx[21],
			beforeRemoveShape: /*beforeRemoveShape*/ ctx[22],
			beforeDeselectShape: /*beforeDeselectShape*/ ctx[23],
			beforeSelectShape: /*beforeSelectShape*/ ctx[24],
			beforeUpdateShape: /*beforeUpdateShape*/ ctx[25]
		}
	};

	if (/*decorateActiveTool*/ ctx[0] !== void 0) {
		shapeutil_props.toolActive = /*decorateActiveTool*/ ctx[0];
	}

	shapeutil = new ShapeUtil({ props: shapeutil_props });
	binding_callbacks.push(() => bind$1(shapeutil, "toolActive", shapeutil_toolActive_binding));
	shapeutil.$on("measure", /*measure_handler*/ ctx[34]);

	return {
		c() {
			create_component(shapeutil.$$.fragment);
		},
		m(target, anchor) {
			mount_component(shapeutil, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const shapeutil_changes = {};
			if (dirty[0] & /*stores*/ 16) shapeutil_changes.stores = /*stores*/ ctx[4];
			if (dirty[0] & /*locale*/ 32) shapeutil_changes.locale = /*locale*/ ctx[5];
			if (dirty[0] & /*isActive*/ 2) shapeutil_changes.isActive = /*isActive*/ ctx[1];
			if (dirty[0] & /*isActiveFraction*/ 4) shapeutil_changes.isActiveFraction = /*isActiveFraction*/ ctx[2];
			if (dirty[0] & /*isVisible*/ 8) shapeutil_changes.isVisible = /*isVisible*/ ctx[3];
			if (dirty[0] & /*decorateTools, markupEditorToolbar*/ 2112) shapeutil_changes.tools = /*decorateTools*/ ctx[11] || /*markupEditorToolbar*/ ctx[6];
			if (dirty[0] & /*decorateToolShapes, markupEditorToolStyles*/ 4224) shapeutil_changes.toolShapes = /*decorateToolShapes*/ ctx[12] || /*markupEditorToolStyles*/ ctx[7];
			if (dirty[0] & /*decorateShapeControls, markupEditorShapeStyleControls*/ 8448) shapeutil_changes.shapeControls = /*decorateShapeControls*/ ctx[13] || /*markupEditorShapeStyleControls*/ ctx[8];
			if (dirty[0] & /*decoratePresets*/ 65536) shapeutil_changes.shapePresets = /*decoratePresets*/ ctx[16];
			if (dirty[0] & /*enableSelectToolToAddShape*/ 262144) shapeutil_changes.enableSelectToolToAddShape = /*enableSelectToolToAddShape*/ ctx[18];
			if (dirty[0] & /*enableTapToAddText*/ 524288) shapeutil_changes.enableTapToAddText = /*enableTapToAddText*/ ctx[19];
			if (dirty[0] & /*decorateEnableSelectImagePreset*/ 32768) shapeutil_changes.enablePresetSelectImage = /*decorateEnableSelectImagePreset*/ ctx[15];
			if (dirty[0] & /*decorateEnableButtonFlipVertical*/ 16384) shapeutil_changes.enableButtonFlipVertical = /*decorateEnableButtonFlipVertical*/ ctx[14];
			if (dirty[0] & /*markupEditorToolSelectRadius*/ 512) shapeutil_changes.toolSelectRadius = /*markupEditorToolSelectRadius*/ ctx[9];
			if (dirty[0] & /*decorateWillRenderShapePresetToolbar, willRenderShapePresetToolbar*/ 132096) shapeutil_changes.willRenderPresetToolbar = /*decorateWillRenderShapePresetToolbar*/ ctx[17] || /*willRenderShapePresetToolbar*/ ctx[10];

			if (dirty[0] & /*willRenderShapeControls, beforeAddShape, beforeRemoveShape, beforeDeselectShape, beforeSelectShape, beforeUpdateShape*/ 66060288) shapeutil_changes.hooks = {
				willRenderShapeControls: /*willRenderShapeControls*/ ctx[20],
				beforeAddShape: /*beforeAddShape*/ ctx[21],
				beforeRemoveShape: /*beforeRemoveShape*/ ctx[22],
				beforeDeselectShape: /*beforeDeselectShape*/ ctx[23],
				beforeSelectShape: /*beforeSelectShape*/ ctx[24],
				beforeUpdateShape: /*beforeUpdateShape*/ ctx[25]
			};

			if (!updating_toolActive && dirty[0] & /*decorateActiveTool*/ 1) {
				updating_toolActive = true;
				shapeutil_changes.toolActive = /*decorateActiveTool*/ ctx[0];
				add_flush_callback(() => updating_toolActive = false);
			}

			shapeutil.$set(shapeutil_changes);
		},
		i(local) {
			if (current) return;
			transition_in(shapeutil.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(shapeutil.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(shapeutil, detaching);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let $imageSelectionRectPresentation;
	let $presentationScalar;
	const name = "decorate";
	let { isActive } = $$props;
	let { isActiveFraction } = $$props;
	let { isVisible } = $$props;
	let { stores } = $$props;
	let { locale = {} } = $$props;
	let { markupEditorToolbar = undefined } = $$props;
	let { markupEditorToolStyles = undefined } = $$props;
	let { markupEditorShapeStyleControls = undefined } = $$props;
	let { markupEditorToolSelectRadius = undefined } = $$props;
	let { willRenderShapePresetToolbar = undefined } = $$props;
	let { decorateTools = undefined } = $$props;
	let { decorateToolShapes = undefined } = $$props;
	let { decorateShapeControls = undefined } = $$props;
	let { decorateActiveTool = undefined } = $$props;
	let { decorateEnableButtonFlipVertical = false } = $$props;
	let { decorateEnableSelectImagePreset = false } = $$props;
	let { decoratePresets = [] } = $$props;
	let { decorateWillRenderShapePresetToolbar = undefined } = $$props;
	let { enableSelectToolToAddShape = undefined } = $$props;
	let { enableTapToAddText = undefined } = $$props;
	let { willRenderShapeControls = undefined } = $$props;
	let { beforeAddShape = undefined } = $$props;
	let { beforeRemoveShape = undefined } = $$props;
	let { beforeDeselectShape = undefined } = $$props;
	let { beforeSelectShape = undefined } = $$props;
	let { beforeUpdateShape = undefined } = $$props;
	const { imageCropRect, imageDecoration, imageSelectionRectPresentation, presentationScalar } = stores;
	component_subscribe($$self, imageSelectionRectPresentation, value => $$invalidate(35, $imageSelectionRectPresentation = value));
	component_subscribe($$self, presentationScalar, value => $$invalidate(36, $presentationScalar = value));

	const mapScreenPointToImagePoint = screenPoint => {
		const mappedPoint = vectorClone(screenPoint);
		mappedPoint.x -= $imageSelectionRectPresentation.x;
		mappedPoint.y -= $imageSelectionRectPresentation.y;
		mappedPoint.x /= $presentationScalar;
		mappedPoint.y /= $presentationScalar;
		return mappedPoint;
	};

	const mapImagePointToScreenPoint = imagePoint => {
		const mappedPoint = vectorClone(imagePoint);
		mappedPoint.x *= $presentationScalar;
		mappedPoint.y *= $presentationScalar;
		mappedPoint.x += $imageSelectionRectPresentation.x;
		mappedPoint.y += $imageSelectionRectPresentation.y;
		return mappedPoint;
	};

	function shapeutil_toolActive_binding(value) {
		decorateActiveTool = value;
		$$invalidate(0, decorateActiveTool);
	}

	function measure_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("isActive" in $$props) $$invalidate(1, isActive = $$props.isActive);
		if ("isActiveFraction" in $$props) $$invalidate(2, isActiveFraction = $$props.isActiveFraction);
		if ("isVisible" in $$props) $$invalidate(3, isVisible = $$props.isVisible);
		if ("stores" in $$props) $$invalidate(4, stores = $$props.stores);
		if ("locale" in $$props) $$invalidate(5, locale = $$props.locale);
		if ("markupEditorToolbar" in $$props) $$invalidate(6, markupEditorToolbar = $$props.markupEditorToolbar);
		if ("markupEditorToolStyles" in $$props) $$invalidate(7, markupEditorToolStyles = $$props.markupEditorToolStyles);
		if ("markupEditorShapeStyleControls" in $$props) $$invalidate(8, markupEditorShapeStyleControls = $$props.markupEditorShapeStyleControls);
		if ("markupEditorToolSelectRadius" in $$props) $$invalidate(9, markupEditorToolSelectRadius = $$props.markupEditorToolSelectRadius);
		if ("willRenderShapePresetToolbar" in $$props) $$invalidate(10, willRenderShapePresetToolbar = $$props.willRenderShapePresetToolbar);
		if ("decorateTools" in $$props) $$invalidate(11, decorateTools = $$props.decorateTools);
		if ("decorateToolShapes" in $$props) $$invalidate(12, decorateToolShapes = $$props.decorateToolShapes);
		if ("decorateShapeControls" in $$props) $$invalidate(13, decorateShapeControls = $$props.decorateShapeControls);
		if ("decorateActiveTool" in $$props) $$invalidate(0, decorateActiveTool = $$props.decorateActiveTool);
		if ("decorateEnableButtonFlipVertical" in $$props) $$invalidate(14, decorateEnableButtonFlipVertical = $$props.decorateEnableButtonFlipVertical);
		if ("decorateEnableSelectImagePreset" in $$props) $$invalidate(15, decorateEnableSelectImagePreset = $$props.decorateEnableSelectImagePreset);
		if ("decoratePresets" in $$props) $$invalidate(16, decoratePresets = $$props.decoratePresets);
		if ("decorateWillRenderShapePresetToolbar" in $$props) $$invalidate(17, decorateWillRenderShapePresetToolbar = $$props.decorateWillRenderShapePresetToolbar);
		if ("enableSelectToolToAddShape" in $$props) $$invalidate(18, enableSelectToolToAddShape = $$props.enableSelectToolToAddShape);
		if ("enableTapToAddText" in $$props) $$invalidate(19, enableTapToAddText = $$props.enableTapToAddText);
		if ("willRenderShapeControls" in $$props) $$invalidate(20, willRenderShapeControls = $$props.willRenderShapeControls);
		if ("beforeAddShape" in $$props) $$invalidate(21, beforeAddShape = $$props.beforeAddShape);
		if ("beforeRemoveShape" in $$props) $$invalidate(22, beforeRemoveShape = $$props.beforeRemoveShape);
		if ("beforeDeselectShape" in $$props) $$invalidate(23, beforeDeselectShape = $$props.beforeDeselectShape);
		if ("beforeSelectShape" in $$props) $$invalidate(24, beforeSelectShape = $$props.beforeSelectShape);
		if ("beforeUpdateShape" in $$props) $$invalidate(25, beforeUpdateShape = $$props.beforeUpdateShape);
	};

	return [
		decorateActiveTool,
		isActive,
		isActiveFraction,
		isVisible,
		stores,
		locale,
		markupEditorToolbar,
		markupEditorToolStyles,
		markupEditorShapeStyleControls,
		markupEditorToolSelectRadius,
		willRenderShapePresetToolbar,
		decorateTools,
		decorateToolShapes,
		decorateShapeControls,
		decorateEnableButtonFlipVertical,
		decorateEnableSelectImagePreset,
		decoratePresets,
		decorateWillRenderShapePresetToolbar,
		enableSelectToolToAddShape,
		enableTapToAddText,
		willRenderShapeControls,
		beforeAddShape,
		beforeRemoveShape,
		beforeDeselectShape,
		beforeSelectShape,
		beforeUpdateShape,
		imageCropRect,
		imageDecoration,
		imageSelectionRectPresentation,
		presentationScalar,
		mapScreenPointToImagePoint,
		mapImagePointToScreenPoint,
		name,
		shapeutil_toolActive_binding,
		measure_handler
	];
}

class Decorate extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$6,
			create_fragment$6,
			safe_not_equal,
			{
				name: 32,
				isActive: 1,
				isActiveFraction: 2,
				isVisible: 3,
				stores: 4,
				locale: 5,
				markupEditorToolbar: 6,
				markupEditorToolStyles: 7,
				markupEditorShapeStyleControls: 8,
				markupEditorToolSelectRadius: 9,
				willRenderShapePresetToolbar: 10,
				decorateTools: 11,
				decorateToolShapes: 12,
				decorateShapeControls: 13,
				decorateActiveTool: 0,
				decorateEnableButtonFlipVertical: 14,
				decorateEnableSelectImagePreset: 15,
				decoratePresets: 16,
				decorateWillRenderShapePresetToolbar: 17,
				enableSelectToolToAddShape: 18,
				enableTapToAddText: 19,
				willRenderShapeControls: 20,
				beforeAddShape: 21,
				beforeRemoveShape: 22,
				beforeDeselectShape: 23,
				beforeSelectShape: 24,
				beforeUpdateShape: 25
			},
			[-1, -1]
		);
	}

	get name() {
		return this.$$.ctx[32];
	}

	get isActive() {
		return this.$$.ctx[1];
	}

	set isActive(isActive) {
		this.$set({ isActive });
		flush();
	}

	get isActiveFraction() {
		return this.$$.ctx[2];
	}

	set isActiveFraction(isActiveFraction) {
		this.$set({ isActiveFraction });
		flush();
	}

	get isVisible() {
		return this.$$.ctx[3];
	}

	set isVisible(isVisible) {
		this.$set({ isVisible });
		flush();
	}

	get stores() {
		return this.$$.ctx[4];
	}

	set stores(stores) {
		this.$set({ stores });
		flush();
	}

	get locale() {
		return this.$$.ctx[5];
	}

	set locale(locale) {
		this.$set({ locale });
		flush();
	}

	get markupEditorToolbar() {
		return this.$$.ctx[6];
	}

	set markupEditorToolbar(markupEditorToolbar) {
		this.$set({ markupEditorToolbar });
		flush();
	}

	get markupEditorToolStyles() {
		return this.$$.ctx[7];
	}

	set markupEditorToolStyles(markupEditorToolStyles) {
		this.$set({ markupEditorToolStyles });
		flush();
	}

	get markupEditorShapeStyleControls() {
		return this.$$.ctx[8];
	}

	set markupEditorShapeStyleControls(markupEditorShapeStyleControls) {
		this.$set({ markupEditorShapeStyleControls });
		flush();
	}

	get markupEditorToolSelectRadius() {
		return this.$$.ctx[9];
	}

	set markupEditorToolSelectRadius(markupEditorToolSelectRadius) {
		this.$set({ markupEditorToolSelectRadius });
		flush();
	}

	get willRenderShapePresetToolbar() {
		return this.$$.ctx[10];
	}

	set willRenderShapePresetToolbar(willRenderShapePresetToolbar) {
		this.$set({ willRenderShapePresetToolbar });
		flush();
	}

	get decorateTools() {
		return this.$$.ctx[11];
	}

	set decorateTools(decorateTools) {
		this.$set({ decorateTools });
		flush();
	}

	get decorateToolShapes() {
		return this.$$.ctx[12];
	}

	set decorateToolShapes(decorateToolShapes) {
		this.$set({ decorateToolShapes });
		flush();
	}

	get decorateShapeControls() {
		return this.$$.ctx[13];
	}

	set decorateShapeControls(decorateShapeControls) {
		this.$set({ decorateShapeControls });
		flush();
	}

	get decorateActiveTool() {
		return this.$$.ctx[0];
	}

	set decorateActiveTool(decorateActiveTool) {
		this.$set({ decorateActiveTool });
		flush();
	}

	get decorateEnableButtonFlipVertical() {
		return this.$$.ctx[14];
	}

	set decorateEnableButtonFlipVertical(decorateEnableButtonFlipVertical) {
		this.$set({ decorateEnableButtonFlipVertical });
		flush();
	}

	get decorateEnableSelectImagePreset() {
		return this.$$.ctx[15];
	}

	set decorateEnableSelectImagePreset(decorateEnableSelectImagePreset) {
		this.$set({ decorateEnableSelectImagePreset });
		flush();
	}

	get decoratePresets() {
		return this.$$.ctx[16];
	}

	set decoratePresets(decoratePresets) {
		this.$set({ decoratePresets });
		flush();
	}

	get decorateWillRenderShapePresetToolbar() {
		return this.$$.ctx[17];
	}

	set decorateWillRenderShapePresetToolbar(decorateWillRenderShapePresetToolbar) {
		this.$set({ decorateWillRenderShapePresetToolbar });
		flush();
	}

	get enableSelectToolToAddShape() {
		return this.$$.ctx[18];
	}

	set enableSelectToolToAddShape(enableSelectToolToAddShape) {
		this.$set({ enableSelectToolToAddShape });
		flush();
	}

	get enableTapToAddText() {
		return this.$$.ctx[19];
	}

	set enableTapToAddText(enableTapToAddText) {
		this.$set({ enableTapToAddText });
		flush();
	}

	get willRenderShapeControls() {
		return this.$$.ctx[20];
	}

	set willRenderShapeControls(willRenderShapeControls) {
		this.$set({ willRenderShapeControls });
		flush();
	}

	get beforeAddShape() {
		return this.$$.ctx[21];
	}

	set beforeAddShape(beforeAddShape) {
		this.$set({ beforeAddShape });
		flush();
	}

	get beforeRemoveShape() {
		return this.$$.ctx[22];
	}

	set beforeRemoveShape(beforeRemoveShape) {
		this.$set({ beforeRemoveShape });
		flush();
	}

	get beforeDeselectShape() {
		return this.$$.ctx[23];
	}

	set beforeDeselectShape(beforeDeselectShape) {
		this.$set({ beforeDeselectShape });
		flush();
	}

	get beforeSelectShape() {
		return this.$$.ctx[24];
	}

	set beforeSelectShape(beforeSelectShape) {
		this.$set({ beforeSelectShape });
		flush();
	}

	get beforeUpdateShape() {
		return this.$$.ctx[25];
	}

	set beforeUpdateShape(beforeUpdateShape) {
		this.$set({ beforeUpdateShape });
		flush();
	}
}

// @ts-ignore
var _plugin_decorate = { util: ['decorate', Decorate] };

/* src/core/ui/plugins/sticker/index.svelte generated by Svelte v3.37.0 */

function create_fragment$5(ctx) {
	let shapeutil;
	let current;

	shapeutil = new ShapeUtil({
			props: {
				stores: /*stores*/ ctx[3],
				locale: /*locale*/ ctx[4],
				isActive: /*isActive*/ ctx[0],
				isActiveFraction: /*isActiveFraction*/ ctx[1],
				isVisible: /*isVisible*/ ctx[2],
				mapScreenPointToImagePoint: /*mapScreenPointToImagePoint*/ ctx[32],
				mapImagePointToScreenPoint: /*mapImagePointToScreenPoint*/ ctx[33],
				utilKey: "sticker",
				shapePresets: /*stickers*/ ctx[5],
				shapes: /*stickerStickToImage*/ ctx[6]
				? /*imageAnnotation*/ ctx[25]
				: /*imageDecoration*/ ctx[26],
				toolActive: "preset",
				imageFlipX: /*stickerStickToImage*/ ctx[6]
				? /*$imageFlipX*/ ctx[18]
				: false,
				imageFlipY: /*stickerStickToImage*/ ctx[6]
				? /*$imageFlipY*/ ctx[19]
				: false,
				imageRotation: /*stickerStickToImage*/ ctx[6]
				? /*$imageRotation*/ ctx[20]
				: 0,
				parentRect: /*stickerStickToImage*/ ctx[6]
				? /*imageSize*/ ctx[27]
				: /*imageCropRect*/ ctx[23],
				enablePresetSelectImage: /*stickerEnableSelectImage*/ ctx[7],
				enableButtonFlipVertical: /*stickersEnableButtonFlipVertical*/ ctx[8],
				toolSelectRadius: /*markupEditorToolSelectRadius*/ ctx[11],
				willRenderPresetToolbar: /*stickersWillRenderShapePresetToolbar*/ ctx[9] || /*willRenderShapePresetToolbar*/ ctx[12],
				hooks: {
					willRenderShapeControls: /*willRenderShapeControls*/ ctx[10],
					beforeAddShape: /*beforeAddShape*/ ctx[13],
					beforeRemoveShape: /*beforeRemoveShape*/ ctx[14],
					beforeDeselectShape: /*beforeDeselectShape*/ ctx[15],
					beforeSelectShape: /*beforeSelectShape*/ ctx[16],
					beforeUpdateShape: /*beforeUpdateShape*/ ctx[17]
				}
			}
		});

	shapeutil.$on("measure", /*measure_handler*/ ctx[35]);

	return {
		c() {
			create_component(shapeutil.$$.fragment);
		},
		m(target, anchor) {
			mount_component(shapeutil, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const shapeutil_changes = {};
			if (dirty[0] & /*stores*/ 8) shapeutil_changes.stores = /*stores*/ ctx[3];
			if (dirty[0] & /*locale*/ 16) shapeutil_changes.locale = /*locale*/ ctx[4];
			if (dirty[0] & /*isActive*/ 1) shapeutil_changes.isActive = /*isActive*/ ctx[0];
			if (dirty[0] & /*isActiveFraction*/ 2) shapeutil_changes.isActiveFraction = /*isActiveFraction*/ ctx[1];
			if (dirty[0] & /*isVisible*/ 4) shapeutil_changes.isVisible = /*isVisible*/ ctx[2];
			if (dirty[0] & /*stickers*/ 32) shapeutil_changes.shapePresets = /*stickers*/ ctx[5];

			if (dirty[0] & /*stickerStickToImage*/ 64) shapeutil_changes.shapes = /*stickerStickToImage*/ ctx[6]
			? /*imageAnnotation*/ ctx[25]
			: /*imageDecoration*/ ctx[26];

			if (dirty[0] & /*stickerStickToImage, $imageFlipX*/ 262208) shapeutil_changes.imageFlipX = /*stickerStickToImage*/ ctx[6]
			? /*$imageFlipX*/ ctx[18]
			: false;

			if (dirty[0] & /*stickerStickToImage, $imageFlipY*/ 524352) shapeutil_changes.imageFlipY = /*stickerStickToImage*/ ctx[6]
			? /*$imageFlipY*/ ctx[19]
			: false;

			if (dirty[0] & /*stickerStickToImage, $imageRotation*/ 1048640) shapeutil_changes.imageRotation = /*stickerStickToImage*/ ctx[6]
			? /*$imageRotation*/ ctx[20]
			: 0;

			if (dirty[0] & /*stickerStickToImage*/ 64) shapeutil_changes.parentRect = /*stickerStickToImage*/ ctx[6]
			? /*imageSize*/ ctx[27]
			: /*imageCropRect*/ ctx[23];

			if (dirty[0] & /*stickerEnableSelectImage*/ 128) shapeutil_changes.enablePresetSelectImage = /*stickerEnableSelectImage*/ ctx[7];
			if (dirty[0] & /*stickersEnableButtonFlipVertical*/ 256) shapeutil_changes.enableButtonFlipVertical = /*stickersEnableButtonFlipVertical*/ ctx[8];
			if (dirty[0] & /*markupEditorToolSelectRadius*/ 2048) shapeutil_changes.toolSelectRadius = /*markupEditorToolSelectRadius*/ ctx[11];
			if (dirty[0] & /*stickersWillRenderShapePresetToolbar, willRenderShapePresetToolbar*/ 4608) shapeutil_changes.willRenderPresetToolbar = /*stickersWillRenderShapePresetToolbar*/ ctx[9] || /*willRenderShapePresetToolbar*/ ctx[12];

			if (dirty[0] & /*willRenderShapeControls, beforeAddShape, beforeRemoveShape, beforeDeselectShape, beforeSelectShape, beforeUpdateShape*/ 254976) shapeutil_changes.hooks = {
				willRenderShapeControls: /*willRenderShapeControls*/ ctx[10],
				beforeAddShape: /*beforeAddShape*/ ctx[13],
				beforeRemoveShape: /*beforeRemoveShape*/ ctx[14],
				beforeDeselectShape: /*beforeDeselectShape*/ ctx[15],
				beforeSelectShape: /*beforeSelectShape*/ ctx[16],
				beforeUpdateShape: /*beforeUpdateShape*/ ctx[17]
			};

			shapeutil.$set(shapeutil_changes);
		},
		i(local) {
			if (current) return;
			transition_in(shapeutil.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(shapeutil.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(shapeutil, detaching);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let $rootRect;
	let $imageSize;
	let $imageTransforms;
	let $imageFlipX;
	let $imageFlipY;
	let $imageSelectionRectPresentation;
	let $presentationScalar;
	let $imageRotation;
	const name = "sticker";
	let { isActive } = $$props;
	let { isActiveFraction } = $$props;
	let { isVisible } = $$props;
	let { stores } = $$props;
	let { locale = {} } = $$props;
	let { stickers = [] } = $$props;
	let { stickerStickToImage = false } = $$props;
	let { stickerEnableSelectImage = true } = $$props;
	let { stickersEnableButtonFlipVertical = false } = $$props;
	let { stickersWillRenderShapePresetToolbar = undefined } = $$props;
	let { willRenderShapeControls = undefined } = $$props;
	let { markupEditorToolSelectRadius = undefined } = $$props;
	let { willRenderShapePresetToolbar = undefined } = $$props;
	let { beforeAddShape = undefined } = $$props;
	let { beforeRemoveShape = undefined } = $$props;
	let { beforeDeselectShape = undefined } = $$props;
	let { beforeSelectShape = undefined } = $$props;
	let { beforeUpdateShape = undefined } = $$props;

	// connect filter choice to stores
	const { presentationScalar, rootRect, imageCropRect, imageSelectionRectPresentation, imageAnnotation, imageDecoration, imageSize, imageTransforms, imageRotation, imageFlipX, imageFlipY } = stores;

	component_subscribe($$self, presentationScalar, value => $$invalidate(40, $presentationScalar = value));
	component_subscribe($$self, rootRect, value => $$invalidate(36, $rootRect = value));
	component_subscribe($$self, imageSelectionRectPresentation, value => $$invalidate(39, $imageSelectionRectPresentation = value));
	component_subscribe($$self, imageSize, value => $$invalidate(37, $imageSize = value));
	component_subscribe($$self, imageTransforms, value => $$invalidate(38, $imageTransforms = value));
	component_subscribe($$self, imageRotation, value => $$invalidate(20, $imageRotation = value));
	component_subscribe($$self, imageFlipX, value => $$invalidate(18, $imageFlipX = value));
	component_subscribe($$self, imageFlipY, value => $$invalidate(19, $imageFlipY = value));

	//
	// Mapping coordinates
	//
	const mapScreenPointToImagePoint = stickerStickToImage
	? point => _mapScreenPointToImagePoint(point, $rootRect, $imageSize, $imageTransforms.origin, $imageTransforms.translation, $imageTransforms.rotation.z, $imageTransforms.scale, $imageFlipX, $imageFlipY)
	: point => {
			const mappedPoint = vectorClone(point);
			mappedPoint.x -= $imageSelectionRectPresentation.x;
			mappedPoint.y -= $imageSelectionRectPresentation.y;
			mappedPoint.x /= $presentationScalar;
			mappedPoint.y /= $presentationScalar;
			return mappedPoint;
		};

	const mapImagePointToScreenPoint = stickerStickToImage
	? point => _mapImagePointToScreenPoint(point, $rootRect, $imageSize, $imageTransforms.origin, $imageTransforms.translation, $imageTransforms.rotation.z, $imageTransforms.scale, $imageFlipX, $imageFlipY)
	: point => {
			const mappedPoint = vectorClone(point);
			mappedPoint.x *= $presentationScalar;
			mappedPoint.y *= $presentationScalar;
			mappedPoint.x += $imageSelectionRectPresentation.x;
			mappedPoint.y += $imageSelectionRectPresentation.y;
			return mappedPoint;
		};

	function measure_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("isActive" in $$props) $$invalidate(0, isActive = $$props.isActive);
		if ("isActiveFraction" in $$props) $$invalidate(1, isActiveFraction = $$props.isActiveFraction);
		if ("isVisible" in $$props) $$invalidate(2, isVisible = $$props.isVisible);
		if ("stores" in $$props) $$invalidate(3, stores = $$props.stores);
		if ("locale" in $$props) $$invalidate(4, locale = $$props.locale);
		if ("stickers" in $$props) $$invalidate(5, stickers = $$props.stickers);
		if ("stickerStickToImage" in $$props) $$invalidate(6, stickerStickToImage = $$props.stickerStickToImage);
		if ("stickerEnableSelectImage" in $$props) $$invalidate(7, stickerEnableSelectImage = $$props.stickerEnableSelectImage);
		if ("stickersEnableButtonFlipVertical" in $$props) $$invalidate(8, stickersEnableButtonFlipVertical = $$props.stickersEnableButtonFlipVertical);
		if ("stickersWillRenderShapePresetToolbar" in $$props) $$invalidate(9, stickersWillRenderShapePresetToolbar = $$props.stickersWillRenderShapePresetToolbar);
		if ("willRenderShapeControls" in $$props) $$invalidate(10, willRenderShapeControls = $$props.willRenderShapeControls);
		if ("markupEditorToolSelectRadius" in $$props) $$invalidate(11, markupEditorToolSelectRadius = $$props.markupEditorToolSelectRadius);
		if ("willRenderShapePresetToolbar" in $$props) $$invalidate(12, willRenderShapePresetToolbar = $$props.willRenderShapePresetToolbar);
		if ("beforeAddShape" in $$props) $$invalidate(13, beforeAddShape = $$props.beforeAddShape);
		if ("beforeRemoveShape" in $$props) $$invalidate(14, beforeRemoveShape = $$props.beforeRemoveShape);
		if ("beforeDeselectShape" in $$props) $$invalidate(15, beforeDeselectShape = $$props.beforeDeselectShape);
		if ("beforeSelectShape" in $$props) $$invalidate(16, beforeSelectShape = $$props.beforeSelectShape);
		if ("beforeUpdateShape" in $$props) $$invalidate(17, beforeUpdateShape = $$props.beforeUpdateShape);
	};

	return [
		isActive,
		isActiveFraction,
		isVisible,
		stores,
		locale,
		stickers,
		stickerStickToImage,
		stickerEnableSelectImage,
		stickersEnableButtonFlipVertical,
		stickersWillRenderShapePresetToolbar,
		willRenderShapeControls,
		markupEditorToolSelectRadius,
		willRenderShapePresetToolbar,
		beforeAddShape,
		beforeRemoveShape,
		beforeDeselectShape,
		beforeSelectShape,
		beforeUpdateShape,
		$imageFlipX,
		$imageFlipY,
		$imageRotation,
		presentationScalar,
		rootRect,
		imageCropRect,
		imageSelectionRectPresentation,
		imageAnnotation,
		imageDecoration,
		imageSize,
		imageTransforms,
		imageRotation,
		imageFlipX,
		imageFlipY,
		mapScreenPointToImagePoint,
		mapImagePointToScreenPoint,
		name,
		measure_handler
	];
}

class Sticker extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$5,
			create_fragment$5,
			safe_not_equal,
			{
				name: 34,
				isActive: 0,
				isActiveFraction: 1,
				isVisible: 2,
				stores: 3,
				locale: 4,
				stickers: 5,
				stickerStickToImage: 6,
				stickerEnableSelectImage: 7,
				stickersEnableButtonFlipVertical: 8,
				stickersWillRenderShapePresetToolbar: 9,
				willRenderShapeControls: 10,
				markupEditorToolSelectRadius: 11,
				willRenderShapePresetToolbar: 12,
				beforeAddShape: 13,
				beforeRemoveShape: 14,
				beforeDeselectShape: 15,
				beforeSelectShape: 16,
				beforeUpdateShape: 17
			},
			[-1, -1]
		);
	}

	get name() {
		return this.$$.ctx[34];
	}

	get isActive() {
		return this.$$.ctx[0];
	}

	set isActive(isActive) {
		this.$set({ isActive });
		flush();
	}

	get isActiveFraction() {
		return this.$$.ctx[1];
	}

	set isActiveFraction(isActiveFraction) {
		this.$set({ isActiveFraction });
		flush();
	}

	get isVisible() {
		return this.$$.ctx[2];
	}

	set isVisible(isVisible) {
		this.$set({ isVisible });
		flush();
	}

	get stores() {
		return this.$$.ctx[3];
	}

	set stores(stores) {
		this.$set({ stores });
		flush();
	}

	get locale() {
		return this.$$.ctx[4];
	}

	set locale(locale) {
		this.$set({ locale });
		flush();
	}

	get stickers() {
		return this.$$.ctx[5];
	}

	set stickers(stickers) {
		this.$set({ stickers });
		flush();
	}

	get stickerStickToImage() {
		return this.$$.ctx[6];
	}

	set stickerStickToImage(stickerStickToImage) {
		this.$set({ stickerStickToImage });
		flush();
	}

	get stickerEnableSelectImage() {
		return this.$$.ctx[7];
	}

	set stickerEnableSelectImage(stickerEnableSelectImage) {
		this.$set({ stickerEnableSelectImage });
		flush();
	}

	get stickersEnableButtonFlipVertical() {
		return this.$$.ctx[8];
	}

	set stickersEnableButtonFlipVertical(stickersEnableButtonFlipVertical) {
		this.$set({ stickersEnableButtonFlipVertical });
		flush();
	}

	get stickersWillRenderShapePresetToolbar() {
		return this.$$.ctx[9];
	}

	set stickersWillRenderShapePresetToolbar(stickersWillRenderShapePresetToolbar) {
		this.$set({ stickersWillRenderShapePresetToolbar });
		flush();
	}

	get willRenderShapeControls() {
		return this.$$.ctx[10];
	}

	set willRenderShapeControls(willRenderShapeControls) {
		this.$set({ willRenderShapeControls });
		flush();
	}

	get markupEditorToolSelectRadius() {
		return this.$$.ctx[11];
	}

	set markupEditorToolSelectRadius(markupEditorToolSelectRadius) {
		this.$set({ markupEditorToolSelectRadius });
		flush();
	}

	get willRenderShapePresetToolbar() {
		return this.$$.ctx[12];
	}

	set willRenderShapePresetToolbar(willRenderShapePresetToolbar) {
		this.$set({ willRenderShapePresetToolbar });
		flush();
	}

	get beforeAddShape() {
		return this.$$.ctx[13];
	}

	set beforeAddShape(beforeAddShape) {
		this.$set({ beforeAddShape });
		flush();
	}

	get beforeRemoveShape() {
		return this.$$.ctx[14];
	}

	set beforeRemoveShape(beforeRemoveShape) {
		this.$set({ beforeRemoveShape });
		flush();
	}

	get beforeDeselectShape() {
		return this.$$.ctx[15];
	}

	set beforeDeselectShape(beforeDeselectShape) {
		this.$set({ beforeDeselectShape });
		flush();
	}

	get beforeSelectShape() {
		return this.$$.ctx[16];
	}

	set beforeSelectShape(beforeSelectShape) {
		this.$set({ beforeSelectShape });
		flush();
	}

	get beforeUpdateShape() {
		return this.$$.ctx[17];
	}

	set beforeUpdateShape(beforeUpdateShape) {
		this.$set({ beforeUpdateShape });
		flush();
	}
}

// @ts-ignore
var _plugin_sticker = { util: ['sticker', Sticker] };

/* src/core/ui/plugins/frame/index.svelte generated by Svelte v3.37.0 */

function create_option_slot(ctx) {
	let div;
	let html_tag;
	let raw_value = (/*getOptionThumb*/ ctx[13](/*option*/ ctx[27].value) || "") + "";
	let t0;
	let span;

	let t1_value = (isFunction$1(/*option*/ ctx[27].label)
	? /*option*/ ctx[27].label(/*locale*/ ctx[1])
	: /*option*/ ctx[27].label) + "";

	let t1;

	return {
		c() {
			div = element("div");
			t0 = space();
			span = element("span");
			t1 = text$1(t1_value);
			html_tag = new HtmlTag(t0);
			attr(div, "slot", "option");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			html_tag.m(raw_value, div);
			append(div, t0);
			append(div, span);
			append(span, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*option*/ 134217728 && raw_value !== (raw_value = (/*getOptionThumb*/ ctx[13](/*option*/ ctx[27].value) || "") + "")) html_tag.p(raw_value);

			if (dirty & /*option, locale*/ 134217730 && t1_value !== (t1_value = (isFunction$1(/*option*/ ctx[27].label)
			? /*option*/ ctx[27].label(/*locale*/ ctx[1])
			: /*option*/ ctx[27].label) + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (134:8) <Scrollable elasticity={scrollElasticity}>
function create_default_slot$2(ctx) {
	let radiogroup;
	let current;

	radiogroup = new RadioGroup({
			props: {
				locale: /*locale*/ ctx[1],
				layout: "row",
				options: /*frameOptions*/ ctx[2],
				selectedIndex: /*selectedFrameIndex*/ ctx[10],
				onchange: /*handleChangeFrame*/ ctx[11],
				$$slots: {
					option: [
						create_option_slot,
						({ option }) => ({ 27: option }),
						({ option }) => option ? 134217728 : 0
					]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(radiogroup.$$.fragment);
		},
		m(target, anchor) {
			mount_component(radiogroup, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const radiogroup_changes = {};
			if (dirty & /*locale*/ 2) radiogroup_changes.locale = /*locale*/ ctx[1];
			if (dirty & /*frameOptions*/ 4) radiogroup_changes.options = /*frameOptions*/ ctx[2];

			if (dirty & /*$$scope, option, locale*/ 402653186) {
				radiogroup_changes.$$scope = { dirty, ctx };
			}

			radiogroup.$set(radiogroup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(radiogroup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(radiogroup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(radiogroup, detaching);
		}
	};
}

// (126:4) 
function create_footer_slot$1(ctx) {
	let div;
	let shapestyleeditor;
	let t;
	let scrollable;
	let current;

	shapestyleeditor = new ShapeStyleEditor({
			props: {
				locale: /*locale*/ ctx[1],
				shape: /*$imageFrame*/ ctx[5],
				onchange: /*handleUpdateSelectedFrameShape*/ ctx[12],
				controls: /*markupEditorShapeStyleControls*/ ctx[3],
				scrollElasticity: /*computedScrollElasticity*/ ctx[4]
			}
		});

	scrollable = new Scrollable({
			props: {
				elasticity: /*scrollElasticity*/ ctx[8],
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(shapestyleeditor.$$.fragment);
			t = space();
			create_component(scrollable.$$.fragment);
			attr(div, "slot", "footer");
			attr(div, "style", /*footerStyle*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(shapestyleeditor, div, null);
			append(div, t);
			mount_component(scrollable, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const shapestyleeditor_changes = {};
			if (dirty & /*locale*/ 2) shapestyleeditor_changes.locale = /*locale*/ ctx[1];
			if (dirty & /*$imageFrame*/ 32) shapestyleeditor_changes.shape = /*$imageFrame*/ ctx[5];
			if (dirty & /*markupEditorShapeStyleControls*/ 8) shapestyleeditor_changes.controls = /*markupEditorShapeStyleControls*/ ctx[3];
			if (dirty & /*computedScrollElasticity*/ 16) shapestyleeditor_changes.scrollElasticity = /*computedScrollElasticity*/ ctx[4];
			shapestyleeditor.$set(shapestyleeditor_changes);
			const scrollable_changes = {};

			if (dirty & /*$$scope, locale, frameOptions*/ 268435462) {
				scrollable_changes.$$scope = { dirty, ctx };
			}

			scrollable.$set(scrollable_changes);

			if (!current || dirty & /*footerStyle*/ 64) {
				attr(div, "style", /*footerStyle*/ ctx[6]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(shapestyleeditor.$$.fragment, local);
			transition_in(scrollable.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(shapestyleeditor.$$.fragment, local);
			transition_out(scrollable.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(shapestyleeditor);
			destroy_component(scrollable);
		}
	};
}

function create_fragment$4(ctx) {
	let util;
	let current;

	util = new Util({
			props: {
				$$slots: { footer: [create_footer_slot$1] },
				$$scope: { ctx }
			}
		});

	util.$on("measure", /*measure_handler*/ ctx[21]);

	return {
		c() {
			create_component(util.$$.fragment);
		},
		m(target, anchor) {
			mount_component(util, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const util_changes = {};

			if (dirty & /*$$scope, footerStyle, locale, frameOptions, $imageFrame, markupEditorShapeStyleControls, computedScrollElasticity*/ 268435582) {
				util_changes.$$scope = { dirty, ctx };
			}

			util.$set(util_changes);
		},
		i(local) {
			if (current) return;
			transition_in(util.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(util.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(util, detaching);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let computedScrollElasticity;
	let footerStyle;
	let $imageFrame;
	let $animation;

	let $isActive,
		$$unsubscribe_isActive = noop$2,
		$$subscribe_isActive = () => ($$unsubscribe_isActive(), $$unsubscribe_isActive = subscribe(isActive, $$value => $$invalidate(19, $isActive = $$value)), isActive);

	let $footerOffset;
	$$self.$$.on_destroy.push(() => $$unsubscribe_isActive());
	const name = "frame";
	let { isActive } = $$props;
	$$subscribe_isActive();
	let { stores } = $$props;
	let { locale = {} } = $$props;
	let { frameStyles = {} } = $$props;
	let { frameOptions = [] } = $$props;
	let { markupEditorShapeStyleControls = undefined } = $$props;

	// connect filter choice to stores
	const { animation, elasticityMultiplier, scrollElasticity, imageFrame } = stores;

	component_subscribe($$self, animation, value => $$invalidate(18, $animation = value));
	component_subscribe($$self, imageFrame, value => $$invalidate(5, $imageFrame = value));

	// current index in frame list
	let selectedFrameIndex = $imageFrame
	? frameOptions.findIndex(([id]) => id === $imageFrame.id)
	: 0;

	// default frame styles
	let frameActiveStyles = { frameColor: [1, 1, 1] };

	const handleChangeFrame = ({ value }) => {
		// get new frame
		const frameBase = frameStyles[value];

		// no new frame selected
		if (!frameBase || !frameBase.shape) {
			imageFrame.set(undefined);
			return;
		}

		

		// create new base frame
		const frame = {
			id: value,
			// set base styles
			...frameActiveStyles,
			// copy the frame base, it's possible that this frame has a different layout
			...shapeDeepCopy(frameBase.shape)
		};

		imageFrame.set(frame);
	};

	function handleUpdateSelectedFrameShape(props) {
		// remember color style for when creating or styling other element
		if (hasProp(props, "frameColor")) frameActiveStyles.frameColor = props.frameColor;

		// it's possible we're only updating default styles
		if (!$imageFrame) return;

		// frameSelected 
		shapeUpdateProps($imageFrame, props);

		// update shape so ui shape controls are updated
		imageFrame.set($imageFrame);
	}

	const isIncompleteSVGMarkup = str => (/rect|path|circle|line|<g>/i).test(str);
	const isHTML = str => (/div/i).test(str);

	const getThumb = value => {
		if (isHTML(value)) return value;

		// could be full svg
		if (isSVGMarkup(value)) return value;

		// could be a partial svg in which case we turn it into a full svg
		if (isIncompleteSVGMarkup(value)) return `<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" stroke-width="1" stroke="currentColor" fill="none" aria-hidden="true" focusable="false" stroke-linecap="round" stroke-linejoin="round">${value}</svg>`;

		// if not, must be URL
		return `<img src="${value}" alt=""/>`;
	};

	const getOptionThumb = key => {
		const frameStyle = frameStyles[key];
		if (!frameStyle || !frameStyle.thumb) return;
		return getThumb(frameStyle.thumb);
	};

	//
	// Footer style
	//
	const footerOffset = spring$2($animation ? 20 : 0);

	component_subscribe($$self, footerOffset, value => $$invalidate(20, $footerOffset = value));

	function measure_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("isActive" in $$props) $$subscribe_isActive($$invalidate(0, isActive = $$props.isActive));
		if ("stores" in $$props) $$invalidate(16, stores = $$props.stores);
		if ("locale" in $$props) $$invalidate(1, locale = $$props.locale);
		if ("frameStyles" in $$props) $$invalidate(17, frameStyles = $$props.frameStyles);
		if ("frameOptions" in $$props) $$invalidate(2, frameOptions = $$props.frameOptions);
		if ("markupEditorShapeStyleControls" in $$props) $$invalidate(3, markupEditorShapeStyleControls = $$props.markupEditorShapeStyleControls);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$animation, $isActive*/ 786432) {
			$animation && footerOffset.set($isActive ? 0 : 20);
		}

		if ($$self.$$.dirty & /*$footerOffset*/ 1048576) {
			$$invalidate(6, footerStyle = $footerOffset
			? `transform: translateY(${$footerOffset}px)`
			: undefined);
		}
	};

	$$invalidate(4, computedScrollElasticity = elasticityMultiplier * scrollElasticity);

	return [
		isActive,
		locale,
		frameOptions,
		markupEditorShapeStyleControls,
		computedScrollElasticity,
		$imageFrame,
		footerStyle,
		animation,
		scrollElasticity,
		imageFrame,
		selectedFrameIndex,
		handleChangeFrame,
		handleUpdateSelectedFrameShape,
		getOptionThumb,
		footerOffset,
		name,
		stores,
		frameStyles,
		$animation,
		$isActive,
		$footerOffset,
		measure_handler
	];
}

class Frame extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$4, create_fragment$4, safe_not_equal, {
			name: 15,
			isActive: 0,
			stores: 16,
			locale: 1,
			frameStyles: 17,
			frameOptions: 2,
			markupEditorShapeStyleControls: 3
		});
	}

	get name() {
		return this.$$.ctx[15];
	}

	get isActive() {
		return this.$$.ctx[0];
	}

	set isActive(isActive) {
		this.$set({ isActive });
		flush();
	}

	get stores() {
		return this.$$.ctx[16];
	}

	set stores(stores) {
		this.$set({ stores });
		flush();
	}

	get locale() {
		return this.$$.ctx[1];
	}

	set locale(locale) {
		this.$set({ locale });
		flush();
	}

	get frameStyles() {
		return this.$$.ctx[17];
	}

	set frameStyles(frameStyles) {
		this.$set({ frameStyles });
		flush();
	}

	get frameOptions() {
		return this.$$.ctx[2];
	}

	set frameOptions(frameOptions) {
		this.$set({ frameOptions });
		flush();
	}

	get markupEditorShapeStyleControls() {
		return this.$$.ctx[3];
	}

	set markupEditorShapeStyleControls(markupEditorShapeStyleControls) {
		this.$set({ markupEditorShapeStyleControls });
		flush();
	}
}

// @ts-ignore
var _plugin_frame = { util: ['frame', Frame] };

/* src/core/ui/plugins/resize/DimensionInput.svelte generated by Svelte v3.37.0 */

function create_fragment$3(ctx) {
	let div;
	let label_1;
	let t0;
	let t1;
	let input;
	let input_value_value;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			label_1 = element("label");
			t0 = text$1(/*label*/ ctx[1]);
			t1 = space();
			input = element("input");
			attr(label_1, "for", /*id*/ ctx[0]);
			attr(label_1, "title", /*title*/ ctx[2]);
			attr(label_1, "aria-label", /*title*/ ctx[2]);
			attr(input, "id", /*id*/ ctx[0]);
			attr(input, "type", "text");
			attr(input, "inputmode", "numeric");
			attr(input, "pattern", "[0-9]*");
			attr(input, "data-state", /*state*/ ctx[3]);
			attr(input, "autocomplete", "off");
			attr(input, "placeholder", /*placeholder*/ ctx[4]);

			input.value = input_value_value = /*value*/ ctx[5] === undefined
			? ""
			: /*format*/ ctx[7](/*value*/ ctx[5] + "");

			attr(div, "class", "PinturaInputDimension");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, label_1);
			append(label_1, t0);
			append(div, t1);
			append(div, input);

			if (!mounted) {
				dispose = listen(input, "input", /*input_handler*/ ctx[8]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*label*/ 2) set_data(t0, /*label*/ ctx[1]);

			if (dirty & /*id*/ 1) {
				attr(label_1, "for", /*id*/ ctx[0]);
			}

			if (dirty & /*title*/ 4) {
				attr(label_1, "title", /*title*/ ctx[2]);
			}

			if (dirty & /*title*/ 4) {
				attr(label_1, "aria-label", /*title*/ ctx[2]);
			}

			if (dirty & /*id*/ 1) {
				attr(input, "id", /*id*/ ctx[0]);
			}

			if (dirty & /*state*/ 8) {
				attr(input, "data-state", /*state*/ ctx[3]);
			}

			if (dirty & /*placeholder*/ 16) {
				attr(input, "placeholder", /*placeholder*/ ctx[4]);
			}

			if (dirty & /*value, format*/ 160 && input_value_value !== (input_value_value = /*value*/ ctx[5] === undefined
			? ""
			: /*format*/ ctx[7](/*value*/ ctx[5] + "")) && input.value !== input_value_value) {
				input.value = input_value_value;
			}
		},
		i: noop$2,
		o: noop$2,
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let { id } = $$props;
	let { label } = $$props;
	let { title } = $$props;
	let { state } = $$props;
	let { placeholder } = $$props;
	let { value } = $$props;
	let { onchange } = $$props;
	let { format = str => str.replace(/\D/g, "") } = $$props;
	const input_handler = e => onchange(format(e.currentTarget.value));

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("label" in $$props) $$invalidate(1, label = $$props.label);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("state" in $$props) $$invalidate(3, state = $$props.state);
		if ("placeholder" in $$props) $$invalidate(4, placeholder = $$props.placeholder);
		if ("value" in $$props) $$invalidate(5, value = $$props.value);
		if ("onchange" in $$props) $$invalidate(6, onchange = $$props.onchange);
		if ("format" in $$props) $$invalidate(7, format = $$props.format);
	};

	return [id, label, title, state, placeholder, value, onchange, format, input_handler];
}

class DimensionInput extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$3, create_fragment$3, safe_not_equal, {
			id: 0,
			label: 1,
			title: 2,
			state: 3,
			placeholder: 4,
			value: 5,
			onchange: 6,
			format: 7
		});
	}
}

/* src/core/ui/plugins/resize/DimensionLock.svelte generated by Svelte v3.37.0 */

function create_default_slot$1(ctx) {
	let g;

	return {
		c() {
			g = svg_element("g");
		},
		m(target, anchor) {
			insert(target, g, anchor);
			g.innerHTML = /*icon*/ ctx[2];
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 4) g.innerHTML = /*icon*/ ctx[2];		},
		d(detaching) {
			if (detaching) detach(g);
		}
	};
}

function create_fragment$2(ctx) {
	let div;
	let input;
	let t;
	let label;
	let icon_1;
	let current;
	let mounted;
	let dispose;

	icon_1 = new Icon({
			props: {
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			input = element("input");
			t = space();
			label = element("label");
			create_component(icon_1.$$.fragment);
			attr(input, "id", /*id*/ ctx[0]);
			attr(input, "class", "implicit");
			attr(input, "type", "checkbox");
			input.checked = /*locked*/ ctx[1];
			attr(label, "for", /*id*/ ctx[0]);
			attr(label, "title", /*title*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			append(div, t);
			append(div, label);
			mount_component(icon_1, label, null);
			current = true;

			if (!mounted) {
				dispose = listen(input, "change", /*change_handler*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*id*/ 1) {
				attr(input, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*locked*/ 2) {
				input.checked = /*locked*/ ctx[1];
			}

			const icon_1_changes = {};

			if (dirty & /*$$scope, icon*/ 68) {
				icon_1_changes.$$scope = { dirty, ctx };
			}

			icon_1.$set(icon_1_changes);

			if (!current || dirty & /*id*/ 1) {
				attr(label, "for", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*title*/ 8) {
				attr(label, "title", /*title*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(icon_1);
			mounted = false;
			dispose();
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { id } = $$props;
	let { locked } = $$props;
	let { icon } = $$props;
	let { title } = $$props;
	let { onchange } = $$props;
	const change_handler = e => onchange(e.currentTarget.checked);

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("locked" in $$props) $$invalidate(1, locked = $$props.locked);
		if ("icon" in $$props) $$invalidate(2, icon = $$props.icon);
		if ("title" in $$props) $$invalidate(3, title = $$props.title);
		if ("onchange" in $$props) $$invalidate(4, onchange = $$props.onchange);
	};

	return [id, locked, icon, title, onchange, change_handler];
}

class DimensionLock extends SvelteComponent {
	constructor(options) {
		super();

		init$3(this, options, instance$2, create_fragment$2, safe_not_equal, {
			id: 0,
			locked: 1,
			icon: 2,
			title: 3,
			onchange: 4
		});
	}
}

/* src/core/ui/plugins/resize/index.svelte generated by Svelte v3.37.0 */

function create_default_slot(ctx) {
	let t;

	return {
		c() {
			t = text$1("Save");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (678:4) 
function create_footer_slot(ctx) {
	let form;
	let div1;
	let fieldset;
	let legend;
	let t0_value = /*locale*/ ctx[1].resizeLabelFormCaption + "";
	let t0;
	let t1;
	let div0;
	let dynamiccomponenttree;
	let t2;
	let button;
	let current;
	let mounted;
	let dispose;
	dynamiccomponenttree = new DynamicComponentTree_1({ props: { items: /*tools*/ ctx[3] } });

	button = new Button({
			props: {
				type: "submit",
				class: "implicit",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			form = element("form");
			div1 = element("div");
			fieldset = element("fieldset");
			legend = element("legend");
			t0 = text$1(t0_value);
			t1 = space();
			div0 = element("div");
			create_component(dynamiccomponenttree.$$.fragment);
			t2 = space();
			create_component(button.$$.fragment);
			attr(legend, "class", "implicit");
			attr(div0, "class", "PinturaFieldsetInner");
			attr(div1, "class", "PinturaFormInner");
			attr(form, "slot", "footer");
			attr(form, "style", /*footerStyle*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, form, anchor);
			append(form, div1);
			append(div1, fieldset);
			append(fieldset, legend);
			append(legend, t0);
			append(fieldset, t1);
			append(fieldset, div0);
			mount_component(dynamiccomponenttree, div0, null);
			/*div0_binding*/ ctx[62](div0);
			append(div1, t2);
			mount_component(button, div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "focusin", /*handleFocusIn*/ ctx[13]),
					listen(div0, "focusout", /*handleFocusOut*/ ctx[14]),
					listen(form, "submit", prevent_default(/*handleSubmit*/ ctx[15]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*locale*/ 2) && t0_value !== (t0_value = /*locale*/ ctx[1].resizeLabelFormCaption + "")) set_data(t0, t0_value);
			const dynamiccomponenttree_changes = {};
			if (dirty[0] & /*tools*/ 8) dynamiccomponenttree_changes.items = /*tools*/ ctx[3];
			dynamiccomponenttree.$set(dynamiccomponenttree_changes);
			const button_changes = {};

			if (dirty[2] & /*$$scope*/ 524288) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);

			if (!current || dirty[0] & /*footerStyle*/ 16) {
				attr(form, "style", /*footerStyle*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(dynamiccomponenttree.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(dynamiccomponenttree.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(form);
			destroy_component(dynamiccomponenttree);
			/*div0_binding*/ ctx[62](null);
			destroy_component(button);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$1(ctx) {
	let util;
	let current;

	util = new Util({
			props: {
				$$slots: { footer: [create_footer_slot] },
				$$scope: { ctx }
			}
		});

	util.$on("measure", /*measure_handler*/ ctx[63]);

	return {
		c() {
			create_component(util.$$.fragment);
		},
		m(target, anchor) {
			mount_component(util, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const util_changes = {};

			if (dirty[0] & /*footerStyle, fieldsGroup, tools, locale*/ 30 | dirty[2] & /*$$scope*/ 524288) {
				util_changes.$$scope = { dirty, ctx };
			}

			util.$set(util_changes);
		},
		i(local) {
			if (current) return;
			transition_in(util.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(util.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(util, detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let sizePresetLabel;
	let widthPresetLabel;
	let heightPresetLabel;
	let canRenderSizePresets;
	let canRenderWidthPresets;
	let canRenderHeightPresets;
	let canRenderSizeInputs;
	let tools;
	let footerStyle;
	let $imageCropRectAspectRatio;
	let $imageOutputSize;
	let $imageCropAspectRatio;
	let $imageSize;
	let $formattedResizeSizePresetOptions;
	let $formattedResizeSizePresetOptionsFlattened;
	let $formattedResizeWidthPresetOptions;
	let $formattedResizeWidthPresetOptionsFlattened;
	let $formattedResizeHeightPresetOptions;
	let $formattedResizeHeightPresetOptionsFlattened;
	let $sizePresetSelectedIndex;
	let $widthPresetSelectedIndex;
	let $heightPresetSelectedIndex;
	let $imageCropRect;
	let $iconActiveFraction;
	let $env;
	let $animation;

	let $isActive,
		$$unsubscribe_isActive = noop$2,
		$$subscribe_isActive = () => ($$unsubscribe_isActive(), $$unsubscribe_isActive = subscribe(isActive, $$value => $$invalidate(60, $isActive = $$value)), isActive);

	let $footerOffset;
	$$self.$$.on_destroy.push(() => $$unsubscribe_isActive());

	const formatValue = (value, min = 0, max = 9999) => {
		if (isString(value)) {
			value = value.replace(/\D/g, "");
			if (!value.length) return;
		}

		const v = Math.round(value);
		if (Number.isNaN(v)) return;
		return clamp(v, min, max);
	};

	const name = "resize";
	let { isActive } = $$props;
	$$subscribe_isActive();
	let { stores } = $$props;
	let { locale = {} } = $$props;
	let { resizeMinSize = sizeCreate(1, 1) } = $$props;
	let { resizeMaxSize = sizeCreate(9999, 9999) } = $$props;
	let { resizeSizePresetOptions = undefined } = $$props;
	let { resizeWidthPresetOptions = undefined } = $$props;
	let { resizeHeightPresetOptions = undefined } = $$props;
	let { resizeWillRenderFooter = passthrough } = $$props;

	// offset
	const iconActiveFraction = spring$2(0, { stiffness: 0.15, damping: 0.3 });

	component_subscribe($$self, iconActiveFraction, value => $$invalidate(57, $iconActiveFraction = value));
	const { animation, imageSize, imageCropRect, imageCropRectAspectRatio, imageCropAspectRatio, imageOutputSize, history, env } = stores;
	component_subscribe($$self, animation, value => $$invalidate(59, $animation = value));
	component_subscribe($$self, imageSize, value => $$invalidate(69, $imageSize = value));
	component_subscribe($$self, imageCropRect, value => $$invalidate(52, $imageCropRect = value));
	component_subscribe($$self, imageCropRectAspectRatio, value => $$invalidate(39, $imageCropRectAspectRatio = value));
	component_subscribe($$self, imageCropAspectRatio, value => $$invalidate(68, $imageCropAspectRatio = value));
	component_subscribe($$self, imageOutputSize, value => $$invalidate(67, $imageOutputSize = value));
	component_subscribe($$self, env, value => $$invalidate(58, $env = value));
	const formId = getUniqueId();
	let fieldsGroup;
	let maintainAspectRatio = false;
	let width;
	let height;
	let activeField;
	let lastActiveField;

	const getState = (value, field, activeField, resizeMinSize, resizeMaxSize) => value != null && activeField !== field
	? value >= resizeMinSize[field] && value <= resizeMaxSize[field]
		? "valid"
		: "invalid"
	: "undetermined";

	const getWidthPlaceholder = (value, cropAspectRatio, cropRect) => Math.round(value != null ? value * cropAspectRatio : cropRect.width);

	const getHeightPlaceholder = (value, cropAspectRatio, cropRect) => Math.round(value != null
	? value / cropAspectRatio
	: cropRect.height);

	// populate active field
	const handleFocusIn = e => {
		const id = e.target.id;

		if ((/width/).test(id)) {
			$$invalidate(37, activeField = "width");
		} else if ((/height/).test(id)) {
			$$invalidate(37, activeField = "height");
		} else if ((/aspectRatio/i).test(id)) {
			$$invalidate(37, activeField = "lock");
		} else {
			$$invalidate(37, activeField = undefined);
		}
	};

	const handleFocusOut = e => {
		if (!fieldsGroup.contains(e.relatedTarget)) handleSubmit();
		$$invalidate(37, activeField = undefined);
	};

	// sync fields if one has a value and aspect ratio should be maintained
	const syncFields = () => {
		if (!maintainAspectRatio || !width || !height) return;

		if (activeField === "width") {
			// sync height field
			$$invalidate(36, height = Math.round(width / $imageCropRectAspectRatio));
		} else if (activeField === "height") {
			// sync width field
			$$invalidate(35, width = Math.round(height * $imageCropRectAspectRatio));
		} else {
			if (lastActiveField === "width") {
				$$invalidate(36, height = Math.round(width / $imageCropRectAspectRatio));
			} else if (lastActiveField === "height") {
				$$invalidate(35, width = Math.round(height * $imageCropRectAspectRatio));
			}

			consolidateSize();
		}
	};

	// $: if (maintainAspectRatio && width && height) syncFields()
	const consolidateSize = forcedAspectRatio => {
		// first need to limit values
		let inputWidth = formatValue(width);

		let inputHeight = formatValue(height);
		let currentWidth = inputWidth;
		let currentHeight = inputHeight;
		let bothAxisDefined = currentWidth && currentHeight;
		let aspectRatio = forcedAspectRatio || $imageCropRectAspectRatio;

		// done, no consolidation needed
		if (!currentWidth && !currentHeight) return;

		// need to fill in missing values
		if (currentWidth && !currentHeight) {
			currentHeight = Math.round(currentWidth / aspectRatio);
		} else if (currentHeight && !currentWidth) {
			currentWidth = Math.round(currentHeight * aspectRatio);
		}

		aspectRatio = forcedAspectRatio || bothAxisDefined
		? getAspectRatio(currentWidth, currentHeight)
		: $imageCropRectAspectRatio;

		// now we have both width and height let's re-fit the min max size
		let currentSize = sizeCreate(currentWidth, currentHeight);

		if (!sizeContains(resizeMaxSize, currentSize)) {
			// too big
			currentSize = rectContainRect(resizeMaxSize, aspectRatio);
		}

		if (!sizeContains(currentSize, resizeMinSize)) {
			// too small
			currentSize = rectCoverRect(resizeMinSize, aspectRatio);
		}

		$$invalidate(35, width = inputWidth != null
		? Math.round(currentSize.width)
		: undefined);

		$$invalidate(36, height = inputHeight != null
		? Math.round(currentSize.height)
		: undefined);
	};

	const handleSubmit = () => {
		// calculate correct values
		consolidateSize();

		// get curent values so we can check if they were changed (if not, no need to write history or update)
		const { width: currentWidth, height: currentHeight } = $imageOutputSize || {};

		// no need to update
		if (currentWidth === width && currentHeight === height) return;

		// update state
		if (!width && !height) {
			// reset image crop
			set_store_value(imageCropAspectRatio, $imageCropAspectRatio = $imageSize.width / $imageSize.height, $imageCropAspectRatio);

			set_store_value(imageCropAspectRatio, $imageCropAspectRatio = undefined, $imageCropAspectRatio);

			// reset output size
			set_store_value(imageOutputSize, $imageOutputSize = undefined, $imageOutputSize);
		} else {
			if (width && height) set_store_value(imageCropAspectRatio, $imageCropAspectRatio = width / height, $imageCropAspectRatio);
			set_store_value(imageOutputSize, $imageOutputSize = sizeCreate(width, height), $imageOutputSize);
		}

		history.write();
	};

	// handle external updates to outputSize
	imageOutputSize.subscribe(size => {
		if (!size) {
			$$invalidate(35, width = undefined);
			$$invalidate(36, height = undefined);
			return;
		}

		$$invalidate(35, width = size.width);
		$$invalidate(36, height = size.height);

		// make sure the size conforms to min max
		consolidateSize();
	});

	// if the crop aspect ratio is changed we need to align width/height
	imageCropAspectRatio.subscribe(cropAspectRatio => {
		// exit if no dimensions supplied
		if (!width && !height) return;

		// no crop aspect ratio has been selected, so all is fine
		if (!cropAspectRatio) return;

		// fix size to match new aspect ratio of the crop
		if (width && height && getAspectRatio(width, height) !== cropAspectRatio) {
			$$invalidate(36, height = width / cropAspectRatio);
			consolidateSize(cropAspectRatio);
		} else {
			consolidateSize();
		}
	});

	//
	// size presets
	//
	const formatPresetDimensionOption = option => {
		if (isString(option[0])) {
			option[1] = option[1].map(formatPresetDimensionOption);
			return option;
		}

		return isNumber$1(option) ? [option, "" + option] : option;
	};

	const formatPresetSizeOption = option => {
		if (isString(option[0])) {
			option[1] = option[1].map(formatPresetSizeOption);
			return option;
		}

		let [value, label] = option;

		// Size only
		if (isNumber$1(value) && isNumber$1(label)) {
			const [w, h] = [value, label];
			label = `${w} × ${h}`;
			value = [w, h];
		}

		return [value, label];
	};

	const formattedResizeSizePresetOptions = writable();
	component_subscribe($$self, formattedResizeSizePresetOptions, value => $$invalidate(40, $formattedResizeSizePresetOptions = value));
	const formattedResizeSizePresetOptionsFlattened = writable();
	component_subscribe($$self, formattedResizeSizePresetOptionsFlattened, value => $$invalidate(41, $formattedResizeSizePresetOptionsFlattened = value));
	const formattedResizeWidthPresetOptions = writable();
	component_subscribe($$self, formattedResizeWidthPresetOptions, value => $$invalidate(42, $formattedResizeWidthPresetOptions = value));
	const formattedResizeWidthPresetOptionsFlattened = writable();
	component_subscribe($$self, formattedResizeWidthPresetOptionsFlattened, value => $$invalidate(43, $formattedResizeWidthPresetOptionsFlattened = value));
	const formattedResizeHeightPresetOptions = writable();
	component_subscribe($$self, formattedResizeHeightPresetOptions, value => $$invalidate(44, $formattedResizeHeightPresetOptions = value));
	const formattedResizeHeightPresetOptionsFlattened = writable();
	component_subscribe($$self, formattedResizeHeightPresetOptionsFlattened, value => $$invalidate(45, $formattedResizeHeightPresetOptionsFlattened = value));

	const sizePresetSelectedIndex = derived([imageOutputSize, formattedResizeSizePresetOptionsFlattened], ([$imageOutputSize, $formattedResizeSizePresetOptionsFlattened], set) => {
		if (!$formattedResizeSizePresetOptionsFlattened) return set(-1);

		const index = $formattedResizeSizePresetOptionsFlattened.findIndex(([value]) => {
			if (!value && !$imageOutputSize) return true;
			if (!value) return false;
			const [width, height] = value;
			return $imageOutputSize.width === width && $imageOutputSize.height === height;
		});

		set(index < 0 ? 0 : index);
	});

	component_subscribe($$self, sizePresetSelectedIndex, value => $$invalidate(47, $sizePresetSelectedIndex = value));

	const widthPresetSelectedIndex = derived([imageOutputSize, formattedResizeWidthPresetOptionsFlattened], ([$imageOutputSize, $formattedResizeWidthPresetOptionsFlattened], set) => {
		if (!$formattedResizeWidthPresetOptionsFlattened) return set(-1);

		const index = $formattedResizeWidthPresetOptionsFlattened.findIndex(([value]) => {
			if (!value && !$imageOutputSize) return true;
			if (!value) return false;
			return $imageOutputSize.width === value;
		});

		set(index < 0 ? 0 : index);
	});

	component_subscribe($$self, widthPresetSelectedIndex, value => $$invalidate(49, $widthPresetSelectedIndex = value));

	const heightPresetSelectedIndex = derived([imageOutputSize, formattedResizeHeightPresetOptionsFlattened], ([$imageOutputSize, $formattedResizeHeightPresetOptionsFlattened], set) => {
		if (!$formattedResizeHeightPresetOptionsFlattened) return set(-1);

		const index = $formattedResizeHeightPresetOptionsFlattened.findIndex(([value]) => {
			if (!value && !$imageOutputSize) return true;
			if (!value) return false;
			return $imageOutputSize.height === value;
		});

		set(index < 0 ? 0 : index);
	});

	component_subscribe($$self, heightPresetSelectedIndex, value => $$invalidate(51, $heightPresetSelectedIndex = value));
	let storedCropRect = undefined;
	let storedCropAspectRatio = undefined;

	const setImageOutputSizeWithArray = size => {
		if (size && !storedCropRect) {
			storedCropRect = { ...$imageCropRect };
			storedCropAspectRatio = $imageCropAspectRatio;
		}

		if (!size) {
			set_store_value(imageCropRect, $imageCropRect = storedCropRect, $imageCropRect);
			set_store_value(imageCropAspectRatio, $imageCropAspectRatio = storedCropAspectRatio, $imageCropAspectRatio);
			set_store_value(imageOutputSize, $imageOutputSize = undefined, $imageOutputSize);
			storedCropRect = undefined;
			storedCropAspectRatio = undefined;
		} else {
			set_store_value(imageCropAspectRatio, $imageCropAspectRatio = getAspectRatio(size[0], size[1]), $imageCropAspectRatio);
			set_store_value(imageOutputSize, $imageOutputSize = sizeCreateFromArray(size), $imageOutputSize);
		}

		history.write();
	};

	//
	// toolbar
	//
	let redrawTrigger = {};

	//
	// Footer
	//
	const footerOffset = spring$2($animation ? 20 : 0);

	component_subscribe($$self, footerOffset, value => $$invalidate(61, $footerOffset = value));

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			fieldsGroup = $$value;
			$$invalidate(2, fieldsGroup);
		});
	}

	function measure_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$props => {
		if ("isActive" in $$props) $$subscribe_isActive($$invalidate(0, isActive = $$props.isActive));
		if ("stores" in $$props) $$invalidate(27, stores = $$props.stores);
		if ("locale" in $$props) $$invalidate(1, locale = $$props.locale);
		if ("resizeMinSize" in $$props) $$invalidate(28, resizeMinSize = $$props.resizeMinSize);
		if ("resizeMaxSize" in $$props) $$invalidate(29, resizeMaxSize = $$props.resizeMaxSize);
		if ("resizeSizePresetOptions" in $$props) $$invalidate(30, resizeSizePresetOptions = $$props.resizeSizePresetOptions);
		if ("resizeWidthPresetOptions" in $$props) $$invalidate(31, resizeWidthPresetOptions = $$props.resizeWidthPresetOptions);
		if ("resizeHeightPresetOptions" in $$props) $$invalidate(32, resizeHeightPresetOptions = $$props.resizeHeightPresetOptions);
		if ("resizeWillRenderFooter" in $$props) $$invalidate(33, resizeWillRenderFooter = $$props.resizeWillRenderFooter);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*resizeSizePresetOptions*/ 1073741824 | $$self.$$.dirty[1] & /*$formattedResizeSizePresetOptions*/ 512) {
			if (resizeSizePresetOptions) {
				set_store_value(formattedResizeSizePresetOptions, $formattedResizeSizePresetOptions = resizeSizePresetOptions.map(formatPresetSizeOption), $formattedResizeSizePresetOptions);
				set_store_value(formattedResizeSizePresetOptionsFlattened, $formattedResizeSizePresetOptionsFlattened = flattenOptions($formattedResizeSizePresetOptions), $formattedResizeSizePresetOptionsFlattened);
			}
		}

		if ($$self.$$.dirty[1] & /*$formattedResizeSizePresetOptions*/ 512) {
			//
			// helper bools
			//
			$$invalidate(53, canRenderSizePresets = !!$formattedResizeSizePresetOptions);
		}

		if ($$self.$$.dirty[1] & /*$sizePresetSelectedIndex, $formattedResizeSizePresetOptionsFlattened*/ 66560) {
			$$invalidate(46, sizePresetLabel = $sizePresetSelectedIndex > -1 && $formattedResizeSizePresetOptionsFlattened[$sizePresetSelectedIndex][1]);
		}

		if ($$self.$$.dirty[1] & /*resizeWidthPresetOptions, $formattedResizeWidthPresetOptions*/ 2049) {
			if (resizeWidthPresetOptions) {
				set_store_value(formattedResizeWidthPresetOptions, $formattedResizeWidthPresetOptions = resizeWidthPresetOptions.map(formatPresetDimensionOption), $formattedResizeWidthPresetOptions);
				set_store_value(formattedResizeWidthPresetOptionsFlattened, $formattedResizeWidthPresetOptionsFlattened = flattenOptions($formattedResizeWidthPresetOptions), $formattedResizeWidthPresetOptionsFlattened);
			}
		}

		if ($$self.$$.dirty[1] & /*canRenderSizePresets, $formattedResizeWidthPresetOptions*/ 4196352) {
			$$invalidate(54, canRenderWidthPresets = !canRenderSizePresets && $formattedResizeWidthPresetOptions);
		}

		if ($$self.$$.dirty[1] & /*$widthPresetSelectedIndex, $formattedResizeWidthPresetOptionsFlattened*/ 266240) {
			$$invalidate(48, widthPresetLabel = $widthPresetSelectedIndex > -1 && $formattedResizeWidthPresetOptionsFlattened[$widthPresetSelectedIndex][1]);
		}

		if ($$self.$$.dirty[1] & /*resizeHeightPresetOptions, $formattedResizeHeightPresetOptions*/ 8194) {
			if (resizeHeightPresetOptions) {
				set_store_value(formattedResizeHeightPresetOptions, $formattedResizeHeightPresetOptions = resizeHeightPresetOptions.map(formatPresetDimensionOption), $formattedResizeHeightPresetOptions);
				set_store_value(formattedResizeHeightPresetOptionsFlattened, $formattedResizeHeightPresetOptionsFlattened = flattenOptions($formattedResizeHeightPresetOptions), $formattedResizeHeightPresetOptionsFlattened);
			}
		}

		if ($$self.$$.dirty[1] & /*canRenderSizePresets, $formattedResizeHeightPresetOptions*/ 4202496) {
			$$invalidate(55, canRenderHeightPresets = !canRenderSizePresets && $formattedResizeHeightPresetOptions);
		}

		if ($$self.$$.dirty[1] & /*$heightPresetSelectedIndex, $formattedResizeHeightPresetOptionsFlattened*/ 1064960) {
			$$invalidate(50, heightPresetLabel = $heightPresetSelectedIndex > -1 && $formattedResizeHeightPresetOptionsFlattened[$heightPresetSelectedIndex][1]);
		}

		if ($$self.$$.dirty[1] & /*canRenderSizePresets, canRenderWidthPresets, canRenderHeightPresets*/ 29360128) {
			$$invalidate(56, canRenderSizeInputs = !canRenderSizePresets && !canRenderWidthPresets && !canRenderHeightPresets);
		}

		if ($$self.$$.dirty[0] & /*locale, resizeMinSize, resizeMaxSize*/ 805306370 | $$self.$$.dirty[1] & /*redrawTrigger, resizeWillRenderFooter, canRenderSizePresets, sizePresetLabel, $formattedResizeSizePresetOptions, $sizePresetSelectedIndex, canRenderWidthPresets, widthPresetLabel, $formattedResizeWidthPresetOptions, $widthPresetSelectedIndex, canRenderHeightPresets, heightPresetLabel, $formattedResizeHeightPresetOptions, $heightPresetSelectedIndex, canRenderSizeInputs, height, $imageCropRectAspectRatio, $imageCropRect, width, activeField, maintainAspectRatio, $iconActiveFraction, $env*/ 268413948) {
			$$invalidate(3, tools = redrawTrigger && resizeWillRenderFooter(
				[
					canRenderSizePresets && [
						"Dropdown",
						"size-presets",
						{
							label: sizePresetLabel,
							options: $formattedResizeSizePresetOptions,
							onchange: item => setImageOutputSizeWithArray(item.value),
							selectedIndex: $sizePresetSelectedIndex
						}
					],
					canRenderWidthPresets && [
						"Dropdown",
						"width-presets",
						{
							label: widthPresetLabel,
							options: $formattedResizeWidthPresetOptions,
							onchange: item => {
								$$invalidate(35, width = item.value);
								handleSubmit();
							},
							selectedIndex: $widthPresetSelectedIndex
						}
					],
					canRenderWidthPresets && canRenderHeightPresets && [
						"span",
						"times",
						{
							"class": "PinturaResizeLabel",
							"innerHTML": "&times;"
						}
					],
					canRenderHeightPresets && [
						"Dropdown",
						"height-presets",
						{
							label: heightPresetLabel,
							options: $formattedResizeHeightPresetOptions,
							onchange: item => {
								$$invalidate(36, height = item.value);
								handleSubmit();
							},
							selectedIndex: $heightPresetSelectedIndex
						}
					],
					canRenderSizeInputs && [
						DimensionInput,
						"width-input",
						{
							id: `width-${formId}`,
							title: locale.resizeTitleInputWidth,
							label: locale.resizeLabelInputWidth,
							placeholder: getWidthPlaceholder(formatValue(height), $imageCropRectAspectRatio, $imageCropRect),
							value: width,
							state: getState(formatValue(width), "width", activeField, resizeMinSize, resizeMaxSize),
							onchange: value => {
								$$invalidate(35, width = value);
								syncFields();
							}
						}
					],
					canRenderSizeInputs && [
						DimensionLock,
						"aspect-ratio-lock",
						{
							id: `aspect-ratio-lock-${formId}`,
							title: locale.resizeTitleButtonMaintainAspectRatio,
							icon: isString(locale.resizeIconButtonMaintainAspectRatio)
							? locale.resizeIconButtonMaintainAspectRatio
							: locale.resizeIconButtonMaintainAspectRatio(maintainAspectRatio, $iconActiveFraction),
							locked: maintainAspectRatio,
							onchange: locked => {
								$$invalidate(34, maintainAspectRatio = locked);
								syncFields();
							}
						}
					],
					canRenderSizeInputs && [
						DimensionInput,
						"height-input",
						{
							id: `height-${formId}`,
							title: locale.resizeTitleInputHeight,
							label: locale.resizeLabelInputHeight,
							placeholder: getHeightPlaceholder(formatValue(width), $imageCropRectAspectRatio, $imageCropRect),
							value: height,
							state: getState(formatValue(height), "height", activeField, resizeMinSize, resizeMaxSize),
							onchange: value => {
								$$invalidate(36, height = value);
								syncFields();
							}
						}
					]
				].filter(Boolean),
				{ ...$env },
				() => $$invalidate(38, redrawTrigger = {})
			).filter(Boolean));
		}

		if ($$self.$$.dirty[1] & /*maintainAspectRatio*/ 8) {
			iconActiveFraction.set(maintainAspectRatio ? 1 : 0);
		}

		if ($$self.$$.dirty[1] & /*activeField*/ 64) {
			if (activeField) lastActiveField = activeField;
		}

		if ($$self.$$.dirty[1] & /*$animation, $isActive*/ 805306368) {
			$animation && footerOffset.set($isActive ? 0 : 20);
		}

		if ($$self.$$.dirty[1] & /*$footerOffset*/ 1073741824) {
			$$invalidate(4, footerStyle = $footerOffset
			? `transform: translateY(${$footerOffset}px)`
			: undefined);
		}
	};

	return [
		isActive,
		locale,
		fieldsGroup,
		tools,
		footerStyle,
		iconActiveFraction,
		animation,
		imageSize,
		imageCropRect,
		imageCropRectAspectRatio,
		imageCropAspectRatio,
		imageOutputSize,
		env,
		handleFocusIn,
		handleFocusOut,
		handleSubmit,
		formattedResizeSizePresetOptions,
		formattedResizeSizePresetOptionsFlattened,
		formattedResizeWidthPresetOptions,
		formattedResizeWidthPresetOptionsFlattened,
		formattedResizeHeightPresetOptions,
		formattedResizeHeightPresetOptionsFlattened,
		sizePresetSelectedIndex,
		widthPresetSelectedIndex,
		heightPresetSelectedIndex,
		footerOffset,
		name,
		stores,
		resizeMinSize,
		resizeMaxSize,
		resizeSizePresetOptions,
		resizeWidthPresetOptions,
		resizeHeightPresetOptions,
		resizeWillRenderFooter,
		maintainAspectRatio,
		width,
		height,
		activeField,
		redrawTrigger,
		$imageCropRectAspectRatio,
		$formattedResizeSizePresetOptions,
		$formattedResizeSizePresetOptionsFlattened,
		$formattedResizeWidthPresetOptions,
		$formattedResizeWidthPresetOptionsFlattened,
		$formattedResizeHeightPresetOptions,
		$formattedResizeHeightPresetOptionsFlattened,
		sizePresetLabel,
		$sizePresetSelectedIndex,
		widthPresetLabel,
		$widthPresetSelectedIndex,
		heightPresetLabel,
		$heightPresetSelectedIndex,
		$imageCropRect,
		canRenderSizePresets,
		canRenderWidthPresets,
		canRenderHeightPresets,
		canRenderSizeInputs,
		$iconActiveFraction,
		$env,
		$animation,
		$isActive,
		$footerOffset,
		div0_binding,
		measure_handler
	];
}

class Resize extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance$1,
			create_fragment$1,
			safe_not_equal,
			{
				name: 26,
				isActive: 0,
				stores: 27,
				locale: 1,
				resizeMinSize: 28,
				resizeMaxSize: 29,
				resizeSizePresetOptions: 30,
				resizeWidthPresetOptions: 31,
				resizeHeightPresetOptions: 32,
				resizeWillRenderFooter: 33
			},
			[-1, -1, -1]
		);
	}

	get name() {
		return this.$$.ctx[26];
	}

	get isActive() {
		return this.$$.ctx[0];
	}

	set isActive(isActive) {
		this.$set({ isActive });
		flush();
	}

	get stores() {
		return this.$$.ctx[27];
	}

	set stores(stores) {
		this.$set({ stores });
		flush();
	}

	get locale() {
		return this.$$.ctx[1];
	}

	set locale(locale) {
		this.$set({ locale });
		flush();
	}

	get resizeMinSize() {
		return this.$$.ctx[28];
	}

	set resizeMinSize(resizeMinSize) {
		this.$set({ resizeMinSize });
		flush();
	}

	get resizeMaxSize() {
		return this.$$.ctx[29];
	}

	set resizeMaxSize(resizeMaxSize) {
		this.$set({ resizeMaxSize });
		flush();
	}

	get resizeSizePresetOptions() {
		return this.$$.ctx[30];
	}

	set resizeSizePresetOptions(resizeSizePresetOptions) {
		this.$set({ resizeSizePresetOptions });
		flush();
	}

	get resizeWidthPresetOptions() {
		return this.$$.ctx[31];
	}

	set resizeWidthPresetOptions(resizeWidthPresetOptions) {
		this.$set({ resizeWidthPresetOptions });
		flush();
	}

	get resizeHeightPresetOptions() {
		return this.$$.ctx[32];
	}

	set resizeHeightPresetOptions(resizeHeightPresetOptions) {
		this.$set({ resizeHeightPresetOptions });
		flush();
	}

	get resizeWillRenderFooter() {
		return this.$$.ctx[33];
	}

	set resizeWillRenderFooter(resizeWillRenderFooter) {
		this.$set({ resizeWillRenderFooter });
		flush();
	}
}

// @ts-ignore
var _plugin_resize = { util: ['resize', Resize] };

const IconCross =
    '<g fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em"><path d="M18 6L6 18M6 6l12 12"></path></path></g>';

const CharacterA =
    '<path fill="none" d="M9 15 L12 9 L15 15 M10 13.5 h3" stroke="currentColor" stroke-width=".125em"/>';

var _locale_en_gb = {
    // generic
    labelReset: 'Reset',
    labelDefault: 'Default',
    labelAuto: 'Auto',
    labelNone: 'None',
    labelEdit: 'Edit',
    labelClose: 'Close',
    labelSupportError: (features) => `${features.join(', ')} not supported on this browser`,

    // defaults
    labelColor: 'Color',
    labelWidth: 'Width',
    labelSize: 'Size',
    labelOffset: 'Offset',
    labelAmount: 'Amount',
    labelInset: 'Inset',
    labelRadius: 'Radius',

    // sizes
    labelSizeExtraSmall: 'Extra small',
    labelSizeSmall: 'Small',
    labelSizeMediumSmall: 'Medium small',
    labelSizeMedium: 'Medium',
    labelSizeMediumLarge: 'Medium large',
    labelSizeLarge: 'Large',
    labelSizeExtraLarge: 'Extra large',

    // unused?
    labelButtonRevert: 'Revert',
    labelButtonCancel: 'Cancel',

    labelButtonUndo: 'Undo',
    labelButtonRedo: 'Redo',
    labelButtonExport: 'Done',

    iconSupportError: `<g fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><g><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></g>`,
    iconButtonClose: IconCross,
    iconButtonRevert: `<g fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em"><path d="M7.388 18.538a8 8 0 10-2.992-9.03"/><path fill="currentColor" d="M2.794 11.696L2.37 6.714l5.088 3.18z"/><path d="M12 8v4M12 12l4 2"/></g>`,
    iconButtonUndo: `<g fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em"><path d="M10 8h4c2.485 0 5 2 5 5s-2.515 5-5 5h-4"/><path fill="currentColor" d="M5 8l4-3v6z"/></g>`,
    iconButtonRedo: `<g fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em"><path d="M14 8h-4c-2.485 0-5 2-5 5s2.515 5 5 5h4"/><path fill="currentColor" d="M19 8l-4-3v6z"/></g>`,
    iconButtonExport: `<polyline points="20 6 9 17 4 12" fill="none" stroke="currentColor" stroke-width=".125em"></polyline>`,

    // status
    statusLabelButtonClose: 'Close',
    statusIconButtonClose: IconCross,
    statusLabelLoadImage: (state) => {
        if (!state || !state.task) return 'Waiting for image';
        if (state.error)
            return state.error.code === 'IMAGE_TOO_SMALL'
                ? 'Minimum image size is {minWidth} × {minHeight}'
                : 'Error loading image';
        if (state.task === 'blob-to-bitmap') return 'Creating preview…';
        return 'Loading image…';
    },

    // processing status message
    statusLabelProcessImage: (state) => {
        if (!state || !state.task) return undefined;
        if (state.task === 'store') {
            if (state.error) return 'Error uploading image';
            return 'Uploading image…';
        }
        if (state.error) return 'Error processing image';
        return 'Processing image…';
    },
};

const MarkupEditor = {
    shapeLabelButtonSelectSticker: 'Select image',
    shapeIconButtonSelectSticker: `<g fill="none" stroke="currentColor" stroke-width="0.0625em"><path d="M8 21 L15 11 L19 15"/><path d="M15 2 v5 h5"/><path d="M8 2 h8 l4 4 v12 q0 4 -4 4 h-8 q-4 0 -4 -4 v-12 q0 -4 4 -4z"/></g><circle fill="currentColor" cx="10" cy="8" r="1.5"/>`,

    shapeIconButtonFlipHorizontal: `<g stroke="currentColor" stroke-width=".125em"><path fill="none" d="M6 6.5h5v11H6z"/><path fill="currentColor" d="M15 6.5h3v11h-3z"/><path d="M11 4v16" fill="currentColor"/></g>`,
    shapeIconButtonFlipVertical: `<g stroke="currentColor" stroke-width=".125em"><rect x="7" y="8" width="11" height="5" fill="none"/><rect x="7" y="17" width="11" height="2" fill="currentColor"/><line x1="5" y1="13" x2="20" y2="13"/></g>`,
    shapeIconButtonRemove: `<g fill="none" fill-rule="evenodd"><path stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M7.5 7h9z"/><path d="M7.916 9h8.168a1 1 0 01.99 1.14l-.972 6.862a2 2 0 01-1.473 1.653c-.877.23-1.753.345-2.629.345-.876 0-1.752-.115-2.628-.345a2 2 0 01-1.473-1.653l-.973-6.862A1 1 0 017.916 9z" fill="currentColor"/><rect fill="currentColor" x="10" y="5" width="4" height="3" rx="1"/></g>`,
    shapeIconButtonDuplicate: `<g fill="none" fill-rule="evenodd"><path d="M15 13.994V16a2 2 0 01-2 2H8a2 2 0 01-2-2v-5a2 2 0 012-2h2.142" stroke="currentColor" stroke-width=".125em"/><path d="M15 9V8a1 1 0 00-2 0v1h-1a1 1 0 000 2h1v1a1 1 0 002 0v-1h1a1 1 0 000-2h-1zm-4-4h6a2 2 0 012 2v6a2 2 0 01-2 2h-6a2 2 0 01-2-2V7a2 2 0 012-2z" fill="currentColor"/></g>`,
    shapeIconButtonMoveToFront: `<g fill="none" fill-rule="evenodd"><rect fill="currentColor" x="11" y="13" width="8" height="2" rx="1"/><rect fill="currentColor" x="9" y="17" width="10" height="2" rx="1"/><path d="M11.364 8H10a5 5 0 000 10M12 6.5L14.5 8 12 9.5z" stroke="currentColor" stroke-width=".125em" stroke-linecap="round"/></g>`,

    shapeIconButtonTextLayoutAutoWidth: `${CharacterA}`,
    shapeIconButtonTextLayoutAutoHeight: `<g fill="currentColor"><circle cx="4" cy="12" r="1.5"/><circle cx="20" cy="12" r="1.5"/></g>${CharacterA}`,
    shapeIconButtonTextLayoutFixedSize: `<g fill="currentColor"><circle cx="5" cy="6" r="1.5"/><circle cx="19" cy="6" r="1.5"/><circle cx="19" cy="19" r="1.5"/><circle cx="5" cy="19" r="1.5"/></g>${CharacterA}`,

    shapeTitleButtonTextLayoutAutoWidth: 'Auto width',
    shapeTitleButtonTextLayoutAutoHeight: 'Auto height',
    shapeTitleButtonTextLayoutFixedSize: 'Fixed size',

    shapeTitleButtonFlipHorizontal: 'Flip Horizontal',
    shapeTitleButtonFlipVertical: 'Flip Vertical',
    shapeTitleButtonRemove: 'Remove',
    shapeTitleButtonDuplicate: 'Duplicate',
    shapeTitleButtonMoveToFront: 'Move to front',

    shapeLabelInputText: 'Edit text',

    shapeIconInputCancel: `<g fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em"><path d="M18 6L6 18M6 6l12 12"/></g>`,
    shapeIconInputConfirm: `<g fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em"><polyline points="20 6 9 17 4 12"/></g>`,
    shapeLabelInputCancel: 'Cancel',
    shapeLabelInputConfirm: 'Confirm',

    shapeLabelStrokeNone: 'No outline',

    shapeLabelFontStyleNormal: 'Normal',
    shapeLabelFontStyleBold: 'Bold',
    shapeLabelFontStyleItalic: 'Italic',
    shapeLabelFontStyleItalicBold: 'Bold Italic',

    shapeTitleBackgroundColor: 'Fill color',

    shapeTitleFontFamily: 'Font',
    shapeTitleFontSize: 'Font size',
    shapeTitleFontStyle: 'Font style',
    shapeTitleLineHeight: 'Leading',

    shapeTitleLineStart: 'Start',
    shapeTitleLineEnd: 'End',
    shapeTitleStrokeWidth: 'Line width',
    shapeTitleStrokeColor: 'Line color',

    shapeTitleLineDecorationBar: 'Bar',
    shapeTitleLineDecorationCircle: 'Circle',
    shapeTitleLineDecorationSquare: 'Square',
    shapeTitleLineDecorationArrow: 'Arrow',
    shapeTitleLineDecorationCircleSolid: 'Circle solid',
    shapeTitleLineDecorationSquareSolid: 'Square solid',
    shapeTitleLineDecorationArrowSolid: 'Arrow solid',

    shapeIconLineDecorationBar: `<g stroke="currentColor" stroke-linecap="round" stroke-width=".125em"><path d="M5,12 H16"/><path d="M16,8 V16"/></g>`,
    shapeIconLineDecorationCircle: `<g stroke="currentColor" stroke-linecap="round"><path stroke-width=".125em" d="M5,12 H12"/><circle fill="none" stroke-width=".125em" cx="16" cy="12" r="4"/></g>`,
    shapeIconLineDecorationSquare: `<g stroke="currentColor" stroke-linecap="round"><path stroke-width=".125em" d="M5,12 H12"/><rect fill="none" stroke-width=".125em" x="12" y="8" width="8" height="8"/></g>`,
    shapeIconLineDecorationArrow: `<g stroke="currentColor" stroke-linecap="round" stroke-width=".125em"><path d="M5,12 H16 M13,7 l6,5 l-6,5" fill="none"/></g>`,
    shapeIconLineDecorationCircleSolid: `<g stroke="currentColor" stroke-linecap="round"><path stroke-width=".125em" d="M5,12 H12"/><circle fill="currentColor" cx="16" cy="12" r="4"/></g>`,
    shapeIconLineDecorationSquareSolid: `<g stroke="currentColor" stroke-linecap="round"><path stroke-width=".125em" d="M5,12 H12"/><rect fill="currentColor" x="12" y="8" width="8" height="8"/></g>`,
    shapeIconLineDecorationArrowSolid: `<g stroke="currentColor" stroke-linecap="round" stroke-width=".125em"><path d="M5,12 H16"/><path d="M13,7 l6,5 l-6,5z" fill="currentColor"/></g>`,

    shapeTitleColorTransparent: 'Transparent',
    shapeTitleColorWhite: 'White',
    shapeTitleColorSilver: 'Silver',
    shapeTitleColorGray: 'Gray',
    shapeTitleColorBlack: 'Black',
    shapeTitleColorNavy: 'Navy',
    shapeTitleColorBlue: 'Blue',
    shapeTitleColorAqua: 'Aqua',
    shapeTitleColorTeal: 'Teal',
    shapeTitleColorOlive: 'Olive',
    shapeTitleColorGreen: 'Green',
    shapeTitleColorYellow: 'Yellow',
    shapeTitleColorOrange: 'Orange',
    shapeTitleColorRed: 'Red',
    shapeTitleColorMaroon: 'Maroon',
    shapeTitleColorFuchsia: 'Fuchsia',
    shapeTitleColorPurple: 'Purple',

    shapeTitleTextColor: 'Font color',
    shapeTitleTextAlign: 'Text align',
    shapeTitleTextAlignLeft: 'Left align text',
    shapeTitleTextAlignCenter: 'Center align text',
    shapeTitleTextAlignRight: 'Right align text',

    shapeIconTextAlignLeft: `<g stroke-width=".125em" stroke="currentColor"><line x1="5" y1="8" x2="15" y2="8"/><line x1="5" y1="12" x2="19" y2="12"/><line x1="5" y1="16" x2="14" y2="16"/></g>`,
    shapeIconTextAlignCenter: `<g stroke-width=".125em" stroke="currentColor"><line x1="7" y1="8" x2="17" y2="8"/><line x1="5" y1="12" x2="19" y2="12"/><line x1="8" y1="16" x2="16" y2="16"/></g>`,
    shapeIconTextAlignRight: `<g stroke-width=".125em" stroke="currentColor"><line x1="9" y1="8" x2="19" y2="8"/><line x1="5" y1="12" x2="19" y2="12"/><line x1="11" y1="16" x2="19" y2="16"/></g>`,

    shapeLabelToolSharpie: 'Sharpie',
    shapeLabelToolEraser: 'Eraser',
    shapeLabelToolRectangle: 'Rectangle',
    shapeLabelToolEllipse: 'Ellipse',
    shapeLabelToolArrow: 'Arrow',
    shapeLabelToolLine: 'Line',
    shapeLabelToolText: 'Text',
    shapeLabelToolPreset: 'Stickers',

    shapeIconToolSharpie: `<g stroke-width=".125em" stroke="currentColor" fill="none"><path d="M2.025 5c5.616-2.732 8.833-3.857 9.65-3.374C12.903 2.351.518 12.666 2.026 14 3.534 15.334 16.536.566 17.73 2.566 18.924 4.566 3.98 17.187 4.831 18c.851.813 9.848-6 11.643-6 1.087 0-2.53 5.11-2.92 7-.086.41 3.323-1.498 4.773-1 .494.17.64 2.317 1.319 3 .439.443 1.332.776 2.679 1" stroke="currentColor" stroke-width=".125em" fill="none" fill-rule="evenodd" stroke-linejoin="round"/></g>`,
    shapeIconToolEraser: `<g stroke-width=".125em" stroke="currentColor" stroke-linecap="round" fill="none"><g transform="translate(3, 15) rotate(-45)"><rect x="0" y="0" width="18" height="10" rx="3"/></g><line x1="11" y1="21" x2="18" y2="21"/><line x1="20" y1="21" x2="22" y2="21"/></g>`,
    shapeIconToolRectangle: `<g stroke-width=".125em" stroke="currentColor" fill="none"><rect x="2" y="2" width="20" height="20" rx="3"/></g>`,
    shapeIconToolEllipse: `<g stroke-width=".125em" stroke="currentColor" fill="none"><circle cx="12" cy="12" r="11"/></g>`,
    shapeIconToolArrow: `<g stroke-width=".125em" stroke="currentColor" fill="none"><line x1="20" y1="3" x2="6" y2="21"/><path d="m10 5 L22 1 L21 13" fill="currentColor" stroke="none"/></g>`,
    shapeIconToolLine: `<g stroke-width=".125em" stroke="currentColor" fill="none"><line x1="20" y1="3" x2="6" y2="21"/></g>`,
    shapeIconToolText: `<g stroke="none" fill="currentColor" transform="translate(6,0)"><path d="M8.14 20.085c.459 0 .901-.034 1.329-.102a8.597 8.597 0 001.015-.21v1.984c-.281.135-.695.247-1.242.336a9.328 9.328 0 01-1.477.133c-3.312 0-4.968-1.745-4.968-5.235V6.804H.344v-1.25l2.453-1.078L3.89.819h1.5v3.97h4.97v2.015H5.39v10.078c0 1.031.245 1.823.735 2.375s1.161.828 2.015.828z"/>`,
    shapeIconToolPreset: `<g fill="none" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em"><path d="M12 22c2.773 0 1.189-5.177 3-7 1.796-1.808 7-.25 7-3 0-5.523-4.477-10-10-10S2 6.477 2 12s4.477 10 10 10z"></path><path d="M20 17c-3 3-5 5-8 5"></path></g>`,
};

var _plugin_crop_locale_en_gb = {
    cropLabel: 'Crop',
    cropIcon:
        '<g stroke-width=".125em" stroke="currentColor" fill="none"><path d="M23 17H9a2 2 0 0 1-2-2v-5m0-3V1 M1 7h14a2 2 0 0 1 2 2v7m0 4v3"/></g>',
    cropIconButtonRecenter: `<path stroke="currentColor" fill="none" stroke-width="2" stroke-linejoin="bevel" d="M1.5 7.5v-6h6M1.5 16.5v6h6M22.5 16.5v6h-6M22.5 7.5v-6h-6"/><circle cx="12" cy="12" r="3.5" fill="currentColor" stroke="none"/>`,
    cropIconButtonRotateLeft:
        '<g stroke="none" fill="currentColor"><path fill="none" d="M-1-1h582v402H-1z"/><rect x="3" rx="1" height="12" width="12" y="9"/><path d="M15 5h-1a5 5 0 015 5 1 1 0 002 0 7 7 0 00-7-7h-1.374l.747-.747A1 1 0 0011.958.84L9.603 3.194a1 1 0 000 1.415l2.355 2.355a1 1 0 001.415-1.414l-.55-.55H15z"/></g>',
    cropIconButtonRotateRight:
        '<g stroke="none" fill="currentColor"><path fill="none" d="M-1-1h582v402H-1z"/><path d="M11.177 5H10a5 5 0 00-5 5 1 1 0 01-2 0 7 7 0 017-7h1.374l-.747-.747A1 1 0 0112.042.84l2.355 2.355a1 1 0 010 1.415l-2.355 2.354a1 1 0 01-1.415-1.414l.55-.55z"/><rect rx="1" height="12" width="12" y="9" x="9"/></g>',
    cropIconButtonFlipVertical:
        '<g stroke="none" fill="currentColor"><path d="M19.993 12.143H7a1 1 0 0 1-1-1V5.994a1 1 0 0 1 1.368-.93l12.993 5.15a1 1 0 0 1-.368 1.93z"/><path d="M19.993 14a1 1 0 0 1 .368 1.93L7.368 21.078A1 1 0 0 1 6 20.148V15a1 1 0 0 1 1-1h12.993z" opacity=".6"/></g>',
    cropIconButtonFlipHorizontal:
        '<g stroke="none" fill="currentColor"><path d="M11.93 7.007V20a1 1 0 0 1-1 1H5.78a1 1 0 0 1-.93-1.368l5.15-12.993a1 1 0 0 1 1.929.368z"/><path d="M14 7.007V20a1 1 0 0 0 1 1h5.149a1 1 0 0 0 .93-1.368l-5.15-12.993A1 1 0 0 0 14 7.007z" opacity=".6"/></g>',

    cropIconSelectPreset: (locale, aspectRatio) => {
        const [a, b, c] = !aspectRatio
            ? [0.2, 0.3, 0.4]
            : [
                  aspectRatio < 1 ? 1 : 0.3,
                  aspectRatio === 1 ? 0.85 : 0.5,
                  aspectRatio > 1 ? 1 : 0.3,
              ];
        return `<g fill="currentColor">
            <rect opacity="${a}" x="2" y="4" width="10" height="18" rx="1"/>
            <rect opacity="${b}" x="4" y="8" width="14" height="14" rx="1"/>
            <rect opacity="${c}" x="6" y="12" width="17" height="10" rx="1"/>
        </g>`;
    },

    cropIconCropBoundary: (locale, isBoundToImage) => {
        const [a, b, c, d] = isBoundToImage ? [0.3, 1, 0, 0] : [0, 0, 0.3, 1];
        return `<g fill="currentColor">
            <rect opacity="${a}" x="2" y="3" width="20" height="20" rx="1"/>
            <rect opacity="${b}" x="7" y="8" width="10" height="10" rx="1"/>
            <rect opacity="${c}" x="4" y="8" width="14" height="14" rx="1"/>
            <rect opacity="${d}" x="12" y="4" width="10" height="10" rx="1"/>
        </g>`;
    },

    cropLabelButtonRecenter: 'Recenter',
    cropLabelButtonRotateLeft: 'Rotate left',
    cropLabelButtonRotateRight: 'Rotate right',
    cropLabelButtonFlipHorizontal: 'Flip horizontal',
    cropLabelButtonFlipVertical: 'Flip vertical',

    cropLabelSelectPreset: 'Crop shape',

    cropLabelCropBoundary: 'Crop boundary',
    cropLabelCropBoundaryEdge: 'Edge of image',
    cropLabelCropBoundaryNone: 'None',

    cropLabelTabRotation: 'Rotation',
    cropLabelTabZoom: 'Zoom',
};

var _plugin_filter_locale_en_gb = {
    filterLabel: 'Filter',
    filterIcon:
        '<g stroke-width=".125em" stroke="currentColor" fill="none"><path d="M18.347 9.907a6.5 6.5 0 1 0-1.872 3.306M3.26 11.574a6.5 6.5 0 1 0 2.815-1.417 M10.15 17.897A6.503 6.503 0 0 0 16.5 23a6.5 6.5 0 1 0-6.183-8.51"/></g>',
    filterLabelChrome: 'Chrome',
    filterLabelFade: 'Fade',
    filterLabelCold: 'Cold',
    filterLabelWarm: 'Warm',
    filterLabelPastel: 'Pastel',
    filterLabelMonoDefault: 'Mono',
    filterLabelMonoNoir: 'Noir',
    filterLabelMonoWash: 'Wash',
    filterLabelMonoStark: 'Stark',
    filterLabelSepiaDefault: 'Sepia',
    filterLabelSepiaBlues: 'Blues',
    filterLabelSepiaRust: 'Rust',
    filterLabelSepiaColor: 'Color',
};

var _plugin_finetune_locale_en_gb = {
    finetuneLabel: 'Finetune',
    finetuneIcon:
        '<g stroke-width=".125em" stroke="currentColor" fill="none"><path d="M4 1v5.5m0 3.503V23M12 1v10.5m0 3.5v8M20 1v15.5m0 3.5v3M2 7h4M10 12h4M18 17h4"/></g>',

    finetuneLabelBrightness: 'Brightness',
    finetuneLabelContrast: 'Contrast',
    finetuneLabelSaturation: 'Saturation',
    finetuneLabelExposure: 'Exposure',
    finetuneLabelTemperature: 'Temperature',
    finetuneLabelGamma: 'Gamma',
    finetuneLabelClarity: 'Clarity',
    finetuneLabelVignette: 'Vignette',
};

var _plugin_resize_locale_en_gb = {
    resizeLabel: 'Resize',
    resizeIcon:
        '<g stroke-width=".125em" stroke="currentColor" fill="none"><rect x="2" y="12" width="10" height="10" rx="2"/><path d="M4 11.5V4a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-5.5"/><path d="M14 10l3.365-3.365M14 6h4v4"/></g>',

    resizeLabelFormCaption: 'Image output size',

    resizeLabelInputWidth: 'w',
    resizeTitleInputWidth: 'Width',
    resizeLabelInputHeight: 'h',
    resizeTitleInputHeight: 'Height',

    resizeTitleButtonMaintainAspectRatio: 'Maintain aspectratio',

    resizeIconButtonMaintainAspectRatio: (active, activeFraction) => `
        <defs>
            <mask id="mask1" x="0" y="0" width="24" height="24" >
                <rect x="0" y="0" width="24" height="10" fill="#fff" stroke="none"/>
            </mask>
        </defs>
        <g fill="none" fill-rule="evenodd">
            <g  mask="url(#mask1)">
                <path transform="translate(0 ${
                    (activeFraction - 1) * 3
                })" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" d="M9.401 10.205v-.804a2.599 2.599 0 0 1 5.198 0V17"/>
            </g>
            <rect fill="currentColor" x="7" y="10" width="10" height="7" rx="1.5"/>
        </g>
    `,
};

var _plugin_decorate_locale_en_gb = {
    decorateLabel: 'Decorate',
    decorateIcon:
        '<g fill="none" fill-rule="evenodd"><path stroke="currentColor" stroke-width=".125em" stroke-linecap="round" stroke-linejoin="round" d="M12 18.5l-6.466 3.4 1.235-7.2-5.23-5.1 7.228-1.05L12 2l3.233 6.55 7.229 1.05-5.231 5.1 1.235 7.2z"/></g>',
};

var _plugin_annotate_locale_en_gb = {
    annotateLabel: 'Annotate',
    annotateIcon:
        '<g stroke-width=".125em" stroke="currentColor" fill="none"><path d="M17.086 2.914a2.828 2.828 0 1 1 4 4l-14.5 14.5-5.5 1.5 1.5-5.5 14.5-14.5z"/></g>',
};

var _plugin_sticker_locale_en_gb = {
    stickerLabel: 'Sticker',
    stickerIcon:
        '<g fill="none" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em"><path d="M12 22c2.773 0 1.189-5.177 3-7 1.796-1.808 7-.25 7-3 0-5.523-4.477-10-10-10S2 6.477 2 12s4.477 10 10 10z"/><path d="M20 17c-3 3-5 5-8 5"/></g>',
};

var _plugin_frame_locale_en_gb = {
    frameLabel: 'Frame',
    frameIcon: `<g fill="none" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em">
            <rect x="2" y="2" width="20" height="20" rx="4"/>
            <rect x="6" y="6" width="12" height="12" rx="1"/>
        </g>`,

    frameLabelMatSharp: 'Mat',
    frameLabelMatRound: 'Bevel',
    frameLabelLineSingle: 'Line',
    frameLabelLineMultiple: 'Zebra',
    frameLabelEdgeSeparate: 'Inset',
    frameLabelEdgeOverlap: 'Plus',
    frameLabelEdgeCross: 'Lumber',
    frameLabelCornerHooks: 'Hook',
    frameLabelPolaroid: 'Polaroid',
};

var linkAccessors = (destination, origin) => {
    const descriptors = Object.getOwnPropertyDescriptors(destination);
    Object.keys(descriptors).forEach((key) => {
        // props, set new setter and getter
        if (!!descriptors[key]['get']) {
            Object.defineProperty(origin, key, {
                get: () => destination[key],
                set: (value) => (destination[key] = value),
            });
        }
        // method, copy reference
        else {
            origin[key] = destination[key];
        }
    });
};

var hasDoctype = () => isBrowser() && document.doctype !== null;

var initEditorView = (target) => {
    const accessors = {};
    const { sub, pub } = pubsub();
    // catch missing doctype
    if (!hasDoctype())
        console.warn('Browser is in quirks mode, add <!DOCTYPE html> to page to fix render issues');
    // create editor core
    const core = createImageEditor();
    linkAccessors(core, accessors);
    // create editor view
    const view = attachEditorView(target, core.stores);
    linkAccessors(view, accessors);
    // listen for UI interaction and link to editor API (internals)
    const unsubs = ['loadImage', 'processImage', 'abortProcessImage', 'abortLoadImage'].map((event) => view.on(event, (e) => {
        // run core method, if returns a promise, we silence errors as those are passed to the UI via stores
        const returned = core[event](e && e.detail);
        if (returned instanceof Promise)
            returned.catch(() => { });
    }));
    // auto subscribes on each possible publisher
    const subscribe = (event, cb) => {
        const unsubInit = sub(event, cb);
        const unsubCore = core.on(event, cb);
        const unsubView = view.on(event, cb);
        return () => {
            unsubInit();
            unsubCore();
            unsubView();
        };
    };
    // handles every event, useful for routing events from the options object
    accessors.handleEvent = noop$1;
    const handleEventUnsubs = editorEvents.map((type) => subscribe(type, (res) => accessors.handleEvent(type, res)));
    // set up new api
    defineMethods(accessors, {
        on: subscribe,
        updateImage: (src) => new Promise((resolve, reject) => {
            // save history
            const history = accessors.history.get();
            // update image
            core.loadImage(src)
                .then((res) => {
                // restore history
                accessors.history.set(history);
                // done!
                resolve(res);
            })
                .catch(reject);
        }),
        close: () => {
            pub('close');
        },
        destroy: () => {
            // unsub
            [...unsubs, ...handleEventUnsubs].forEach((unsub) => unsub());
            // destroy
            view.destroy();
            core.destroy();
            // destroyed
            pub('destroy');
        },
    });
    return accessors;
};
isBrowser() &&
    class extends HTMLElement {
        constructor() {
            super();
            this._editor = undefined;
            this._unsubs = undefined;
        }
        static get observedAttributes() {
            return ['src'];
        }
        attributeChangedCallback(attrName, oldValue, newValue) {
            this[attrName] = newValue;
        }
        connectedCallback() {
            this._editor = initEditorView(this);
            linkAccessors(this._editor, this);
            this._editor.src = this.getAttribute('src');
            this._unsubs = dispatchEditorEvents(this._editor, this);
        }
        disconnectedCallback() {
            this._editor.destroy();
            this._unsubs.forEach((unsub) => unsub());
        }
    };

const CSS_CLASS_NAME = 'pintura-editor';
var _appendEditor = (target, options = {}) => {
    const element = isString(target)
        ? document.querySelector(target)
        : target;
    if (!isElement(element))
        return undefined;
    options.class = options.class ? `${CSS_CLASS_NAME} ${options.class}` : CSS_CLASS_NAME;
    const accessors = initEditorView(element);
    return Object.assign(accessors, options);
};

/* src/core/ui/modal/index.svelte generated by Svelte v3.37.0 */

const { document: document_1 } = globals;

function create_fragment(ctx) {
	let t;
	let div;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowresize*/ ctx[20]);

	return {
		c() {
			t = space();
			div = element("div");
			attr(div, "class", /*className*/ ctx[5]);
			attr(div, "style", /*style*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
			insert(target, div, anchor);
			/*div_binding*/ ctx[21](div);

			if (!mounted) {
				dispose = [
					listen(window$1, "keydown", /*handleKey*/ ctx[10]),
					listen(window$1, "orientationchange", /*spawnMeasureElement*/ ctx[11]),
					listen(window$1, "resize", /*onwindowresize*/ ctx[20]),
					listen(document_1.body, "focusin", function () {
						if (is_function(!/*hidden*/ ctx[3] && /*handleFocusIn*/ ctx[7])) (!/*hidden*/ ctx[3] && /*handleFocusIn*/ ctx[7]).apply(this, arguments);
					}),
					listen(document_1.body, "focusout", function () {
						if (is_function(/*hasFocussedTextField*/ ctx[1] && /*handleFocusOut*/ ctx[8])) (/*hasFocussedTextField*/ ctx[1] && /*handleFocusOut*/ ctx[8]).apply(this, arguments);
					}),
					listen(div, "wheel", /*handleWheel*/ ctx[9], { passive: false })
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*className*/ 32) {
				attr(div, "class", /*className*/ ctx[5]);
			}

			if (dirty[0] & /*style*/ 16) {
				attr(div, "style", /*style*/ ctx[4]);
			}
		},
		i: noop$2,
		o: noop$2,
		d(detaching) {
			if (detaching) detach(t);
			if (detaching) detach(div);
			/*div_binding*/ ctx[21](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let viewportRules;
	let isIOSFooterVisible;
	let style;
	let className;
	let $opacity;
	const dispatch = createEventDispatcher();
	let { root } = $$props;
	let { preventZoomViewport = true } = $$props;
	let { class: klass = undefined } = $$props;
	let hidden = true;
	let hiding = false;
	let showing = false;
	const opacity = spring$2(0, { precision: 0.001, damping: 0.5 });
	component_subscribe($$self, opacity, value => $$invalidate(18, $opacity = value));

	// animate hide and show
	const unsub = opacity.subscribe(o => {
		if (showing && o >= 1) {
			showing = false; // now shown
			$$invalidate(3, hidden = false);
			dispatch("show");
		} else if (hiding && o <= 0) {
			hiding = false; // now hidden
			$$invalidate(3, hidden = true);
			dispatch("hide");
		}
	});

	// clean up when removed
	onDestroy(() => unsub());

	let hasFocussedTextField = false;
	let viewportDefaults = undefined;
	let showTimeoutId = undefined;
	const getViewPortElement = () => document.querySelector("meta[name=viewport]");

	const show = () => {
		// is visible, or busy becoming visible
		if (showing || !hidden) return;

		// now in 'showing' transition
		showing = true;

		// store default viewport element values
		const viewportElement = getViewPortElement() || h$1("meta", { name: "viewport" });

		viewportDefaults = !viewportDefaults && viewportElement.getAttribute("content");

		viewportElement.setAttribute("content", viewportRules + ((/cover/).test(viewportDefaults)
		? ",viewport-fit=cover"
		: ""));

		if (!viewportElement.parentNode) document.head.appendChild(viewportElement);
		clearTimeout(showTimeoutId);
		showTimeoutId = setTimeout(() => set_store_value(opacity, $opacity = 1, $opacity), 250);
	};

	const hide = () => {
		// is hiding or already hidden
		if (hiding || hidden) return;

		// if previous command was show, we need to prevent the timeout from kicking off
		clearTimeout(showTimeoutId);

		// now in 'hiding' transition
		hiding = true;

		// get a reference to the viewport element, it should be there as we created it earlier, 
		// we restore defaults if the viewport metatag was defined, if not, we destroy it
		const viewportElement = getViewPortElement();

		if (viewportDefaults) viewportElement.setAttribute("content", viewportDefaults); else document.head.removeChild(viewportElement);

		// let's hide!
		set_store_value(opacity, $opacity = 0, $opacity);
	};

	// handle soft keyboard impact on window height
	let focusOutTimer;

	let focusInWindowHeight;

	const handleFocusIn = e => {
		// test if is text input element
		if (!(/textarea/i).test(e.target)) return;

		// now focussing a field
		$$invalidate(1, hasFocussedTextField = true);

		focusInWindowHeight = windowHeight;
	};

	const handleFocusOut = e => {
		// test if is text input element
		if (!(/textarea/i).test(e.target)) return;

		// prevent accidentally setting two timers
		clearTimeout(focusOutTimer);

		// test if window height changed, if not, no soft keyboard appeared and we can set false to focus state immidiately
		if (focusInWindowHeight === windowHeight) {
			$$invalidate(1, hasFocussedTextField = false);
		} else // soft keyboard might have appeared, test for window height change before setting unfocus state
		{
			const windowCurrentHeight = windowHeight;
			runWhen(() => windowHeight !== windowCurrentHeight, () => $$invalidate(1, hasFocussedTextField = false));
		}
	};

	const runWhen = (test, cb) => {
		const frame = () => {
			if (test()) {
				cb();
				return;
			}

			requestAnimationFrame(frame);
		};

		requestAnimationFrame(frame);
	};

	// end soft keyboard logic
	// prevent mousewheel from scrolling content behind modal
	const handleWheel = e => e.preventDefault();

	// handle escape to close modal
	const handleKey = e => {
		// get key type
		const { key } = e;

		// only deal with escape key
		if (!(/escape/i).test(key)) return;

		// don't close when in an input or textuarea
		const targetElement = e.target;

		if (targetElement && (/input|textarea/i).test(targetElement.nodeName)) return;

		// only close if I'm the top modal
		const modals = document.querySelectorAll(".PinturaModal");

		if (modals[modals.length - 1] !== root) return;

		// request close
		dispatch("close");
	};

	// this logic scales modal to fit viewport height
	let windowHeight = 0;

	let windowHeightComputed;

	// iOS measure actual page height so we can make optional use of available space
	let measureElement;

	let measureElementHeight = undefined;

	const spawnMeasureElement = () => {
		// can't spawn more than one
		if (measureElement) return;

		measureElement = h$1("div", {
			style: "position:fixed;height:100vh;top:0"
		});

		document.body.appendChild(measureElement);
	};

	onMount(() => {
		// no need to run this logic if is not on iOS
		if (!isIOS()) return;

		// will be used in first read to determine page height and bottom padding
		spawnMeasureElement();
	});

	afterUpdate(() => {
		// will only run on iOS
		if (!measureElement) return;

		// get height and store
		$$invalidate(17, measureElementHeight = measureElement.offsetHeight);

		// remove measure element
		measureElement.parentNode.removeChild(measureElement);

		measureElement = undefined;
	});

	function onwindowresize() {
		$$invalidate(2, windowHeight = window$1.innerHeight);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			root = $$value;
			$$invalidate(0, root);
		});
	}

	$$self.$$set = $$props => {
		if ("root" in $$props) $$invalidate(0, root = $$props.root);
		if ("preventZoomViewport" in $$props) $$invalidate(12, preventZoomViewport = $$props.preventZoomViewport);
		if ("class" in $$props) $$invalidate(13, klass = $$props.class);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*preventZoomViewport*/ 4096) {
			viewportRules = "width=device-width,height=device-height,initial-scale=1" + (preventZoomViewport
			? ",maximum-scale=1,user-scalable=0"
			: "");
		}

		if ($$self.$$.dirty[0] & /*hasFocussedTextField, windowHeight*/ 6) {
			if (!hasFocussedTextField) $$invalidate(16, windowHeightComputed = windowHeight);
		}

		if ($$self.$$.dirty[0] & /*measureElementHeight, windowHeight*/ 131076) {
			$$invalidate(19, isIOSFooterVisible = isIOS()
			? `--viewport-pad-footer:${measureElementHeight > windowHeight ? 0 : 1}`
			: "");
		}

		if ($$self.$$.dirty[0] & /*windowHeightComputed, $opacity, isIOSFooterVisible*/ 851968) {
			$$invalidate(4, style = `height:${windowHeightComputed}px;opacity:${$opacity};--editor-modal:1;${isIOSFooterVisible}`);
		}

		if ($$self.$$.dirty[0] & /*klass*/ 8192) {
			$$invalidate(5, className = arrayJoin(["pintura-editor", "PinturaModal", klass]));
		}
	};

	return [
		root,
		hasFocussedTextField,
		windowHeight,
		hidden,
		style,
		className,
		opacity,
		handleFocusIn,
		handleFocusOut,
		handleWheel,
		handleKey,
		spawnMeasureElement,
		preventZoomViewport,
		klass,
		show,
		hide,
		windowHeightComputed,
		measureElementHeight,
		$opacity,
		isIOSFooterVisible,
		onwindowresize,
		div_binding
	];
}

class Modal extends SvelteComponent {
	constructor(options) {
		super();

		init$3(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				root: 0,
				preventZoomViewport: 12,
				class: 13,
				show: 14,
				hide: 15
			},
			[-1, -1]
		);
	}

	get root() {
		return this.$$.ctx[0];
	}

	set root(root) {
		this.$set({ root });
		flush();
	}

	get preventZoomViewport() {
		return this.$$.ctx[12];
	}

	set preventZoomViewport(preventZoomViewport) {
		this.$set({ preventZoomViewport });
		flush();
	}

	get class() {
		return this.$$.ctx[13];
	}

	set class(klass) {
		this.$set({ class: klass });
		flush();
	}

	get show() {
		return this.$$.ctx[14];
	}

	get hide() {
		return this.$$.ctx[15];
	}
}

// @ts-ignore
// we export a function that renders the view as to not export svelte component related code to outside the ui dir
var createModal = (options = {}, parent) => new Modal({
    target: parent || document.body,
    props: {
        class: options.class,
        preventZoomViewport: options.preventZoomViewport,
    },
});

var _openEditor = (options = {}, parent) => {
    // set up pub/sub for the app layer
    const { sub, pub } = pubsub();
    const accessors = {};
    const modal = createModal(options, parent);
    const hide = () => {
        if (!modal.hide)
            return; // was destroyed
        modal.hide();
    };
    const show = () => {
        if (!modal.show)
            return; // was destroyed
        modal.show();
    };
    const view = initEditorView(modal.root);
    linkAccessors(view, accessors);
    // link up handle event
    accessors.handleEvent = noop$1;
    view.handleEvent = (type, detail) => accessors.handleEvent(type, detail);
    // route close request from view to modal
    view.on('close', async () => {
        const { willClose } = options;
        if (!willClose)
            return hide();
        const shouldClose = await willClose();
        if (shouldClose)
            hide();
    });
    const subscribe = (event, cb) => {
        // capture modal related events
        if (/show|hide/.test(event))
            return sub(event, cb);
        // route rest of events to view
        return view.on(event, cb);
    };
    const modalHandleEventUnsubs = ['show', 'hide'].map((type) => subscribe(type, (detail) => accessors.handleEvent(type, detail)));
    // cleans up view
    const destroy = () => {
        // unsub
        modalHandleEventUnsubs.forEach((unsub) => unsub());
        // remove
        hide();
        modal.$destroy();
        view.destroy();
    };
    defineMethods(accessors, {
        on: subscribe,
        destroy,
        hide,
        show,
    });
    // add element root query
    Object.defineProperty(accessors, 'modal', {
        get: () => modal.root,
        set: () => undefined,
    });
    // route modal events
    modal.$on('close', view.close);
    modal.$on('show', () => pub('show'));
    modal.$on('hide', () => {
        pub('hide');
        destroy();
    });
    // modal behavior
    view.on('process', hide);
    view.on('loadstart', show);
    // test if should
    if (options.enableButtonClose !== false)
        options.enableButtonClose = true;
    // delete class
    delete options.class;
    // update props
    Object.assign(accessors, options);
    return accessors;
};

var _overlayEditor = (target, options) => {
    const editor = _appendEditor(target, {
        ...options,
        layout: 'overlay',
    });
    return editor;
};

// helper method to calculate end style params that are passed to lineEnd style functions
const getLineEndParams = (start, end, strokeWidth, isSolid) => {
    const direction = vectorCreate(end.x - start.x, end.y - start.y);
    const normal = vectorNormalize(direction);
    const scaledSize = 5 * strokeWidth;
    let scaledSizeHalf;
    // solid
    if (isSolid) {
        scaledSizeHalf = scaledSize * 0.5;
    }
    // stroke
    else {
        scaledSizeHalf = Math.ceil((scaledSize - 1) * 0.5);
    }
    const offset = vectorMultiply(vectorClone(normal), scaledSizeHalf);
    return {
        anchor: vectorClone(start),
        offset,
        normal,
        solid: isSolid,
        size: scaledSize,
        sizeHalf: scaledSizeHalf,
    };
};
// various available styles
const lineEndStyleArrow = ({ anchor, solid, normal, offset, size, sizeHalf, strokeWidth, strokeColor }, anchorRef) => {
    const x = anchor.x;
    const y = anchor.y;
    const tipOffset = vectorMultiply(vectorClone(normal), size);
    const inset = vectorCreate(x + tipOffset.x, y + tipOffset.y);
    vectorMultiply(tipOffset, 0.55);
    if (solid) {
        // move back so arrow triangle overlaps with end of line (otherwise line sticks out of triangle tip)
        vectorAdd(anchorRef, offset);
        const arrowOffset = vectorMultiply(vectorClone(normal), sizeHalf * 0.5);
        return [
            {
                points: [
                    vectorCreate(x - arrowOffset.x, y - arrowOffset.y),
                    vectorCreate(inset.x - tipOffset.y, inset.y + tipOffset.x),
                    vectorCreate(inset.x + tipOffset.y, inset.y - tipOffset.x),
                ],
                backgroundColor: strokeColor,
            },
        ];
    }
    else {
        // this prevents trouble with sharp line rendering in webgl
        const p = vectorMultiply(vectorPerpendicular(vectorClone(normal)), 0.5);
        const tipLeft = vectorCreate(x - p.x, y - p.y);
        const tipRight = vectorCreate(x + p.x, y + p.y);
        return [
            {
                points: [
                    vectorCreate(inset.x + tipOffset.y, inset.y - tipOffset.x),
                    tipLeft,
                    vectorCreate(x, y),
                    tipRight,
                    vectorCreate(inset.x - tipOffset.y, inset.y + tipOffset.x),
                ],
                strokeWidth: strokeWidth,
                strokeColor: strokeColor,
            },
        ];
    }
};
const lineEndStyleCircle = ({ anchor, solid, offset, normal, sizeHalf, strokeWidth, strokeColor }, anchorRef) => {
    // update anchor point position
    vectorAdd(anchorRef, offset);
    // if solid, move line slightly towards circle as to make them overlap
    if (solid)
        vectorAdd(anchorRef, vectorInvert(vectorClone(normal)));
    return [
        {
            x: anchor.x,
            y: anchor.y,
            rx: sizeHalf,
            ry: sizeHalf,
            backgroundColor: solid ? strokeColor : undefined,
            strokeWidth: solid ? undefined : strokeWidth,
            strokeColor: solid ? undefined : strokeColor,
        },
    ];
};
const lineEndStyleBar = ({ anchor, offset, strokeWidth, strokeColor }) => {
    return [
        {
            points: [
                vectorCreate(anchor.x - offset.y, anchor.y + offset.x),
                vectorCreate(anchor.x + offset.y, anchor.y - offset.x),
            ],
            strokeWidth,
            strokeColor,
        },
    ];
};
const lineEndStyleSquare = ({ anchor, solid, offset, normal, sizeHalf, strokeWidth, strokeColor }, anchorRef) => {
    // update anchor point position
    vectorAdd(anchorRef, offset);
    return [
        {
            x: anchor.x - sizeHalf,
            y: anchor.y - sizeHalf,
            width: sizeHalf * 2,
            height: sizeHalf * 2,
            rotation: vectorAngle(normal),
            backgroundColor: solid ? strokeColor : undefined,
            strokeWidth: solid ? undefined : strokeWidth,
            strokeColor: solid ? undefined : strokeColor,
        },
    ];
};
// this method parses the shape and checks if lineStart or lineEnd is being used
const createLineEndProcessor = (styles = {}) => (shape) => {
    if (!hasProp(shape, 'lineStart') && !hasProp(shape, 'lineEnd'))
        return;
    // resulting shapes
    const res = [];
    const { lineStart, lineEnd, strokeWidth, strokeColor } = shape;
    const start = vectorCreate(shape.x1, shape.y1);
    const end = vectorCreate(shape.x2, shape.y2);
    const points = [start, end];
    // handle lineStart
    if (lineStart) {
        const [style, solid] = lineStart.split('-');
        const process = styles[style];
        if (process) {
            const params = getLineEndParams(start, end, strokeWidth, !!solid);
            res.push(...process({
                ...params,
                strokeColor,
                strokeWidth,
            }, start));
        }
    }
    // handle lineEnd
    if (lineEnd) {
        const [style, solid] = lineEnd.split('-');
        const process = styles[style];
        if (process) {
            const params = getLineEndParams(end, start, strokeWidth, !!solid);
            res.push(...process({
                ...params,
                strokeColor,
                strokeWidth,
            }, end));
        }
    }
    return [
        // return inner path
        {
            points,
            strokeWidth,
            strokeColor,
        },
        // add line end styles
        ...res,
    ];
};
// the default line end styles available, can import and extend
const createDefaultLineEndStyles = () => ({
    arrow: lineEndStyleArrow,
    circle: lineEndStyleCircle,
    square: lineEndStyleSquare,
    bar: lineEndStyleBar,
});

const safeFactor = (value, factor) => {
    const v = parseFloat(value) * factor;
    return isString(value) ? `${v}%` : v;
};
const toValue = (value, total) => (isString(value) ? toPixelValue(value, total) : value);
// const toFraction = (value, total) => toValue(value, total) / total;
const frameStyleSolid = (shape) => [
    {
        ...shape,
        frameStyle: 'line',
        frameInset: 0,
        frameOffset: 0,
        frameSize: shape.frameSize ? safeFactor(shape.frameSize, 2) : '2.5%',
        frameRadius: shape.frameRound ? safeFactor(shape.frameSize, 2) : 0,
    },
];
const frameStyleLine = ({ x, y, width, height, frameInset = '3.5%', frameSize = '.25%', frameColor = [1, 1, 1], frameOffset = '5%', frameAmount = 1, frameRadius = 0, expandsCanvas = false, }, { isPreview }) => {
    const size = Math.sqrt(width * height);
    let frameSizeValue = toValue(frameSize, size);
    const frameInsetValue = toValue(frameInset, size);
    const frameOffsetValue = toValue(frameOffset, size);
    let center = 0;
    if (!isPreview) {
        frameSizeValue = Math.max(1, Math.round(frameSizeValue));
        center = frameSizeValue % 2 == 0 ? 0 : 0.5;
    }
    const r = toValue(safeFactor(frameRadius, frameAmount), size);
    return new Array(frameAmount).fill(undefined).map((_, index) => {
        const offset = frameOffsetValue * index;
        let left = x + frameInsetValue + offset;
        let top = y + frameInsetValue + offset;
        let right = x + width - frameInsetValue - offset;
        let bottom = y + height - frameInsetValue - offset;
        if (!isPreview) {
            left = Math.round(left);
            top = Math.round(top);
            right = Math.round(right);
            bottom = Math.round(bottom);
        }
        const radius = r > 0 ? r - offset : 0;
        return {
            x: left + center,
            y: top + center,
            width: right - left,
            height: bottom - top,
            cornerRadius: radius,
            strokeWidth: frameSizeValue,
            strokeColor: frameColor,
            expandsCanvas,
        };
    });
};
const frameStyleEdge = ({ x, y, width, height, frameSize = '.25%', frameOffset = 0, frameInset = '2.5%', frameColor = [1, 1, 1], }, { isPreview }) => {
    const size = Math.sqrt(width * height);
    let frameSizeValue = toValue(frameSize, size);
    let frameInsetValue = toValue(frameInset, size);
    let frameOffsetValue = toValue(frameOffset, size);
    let center = 0;
    if (!isPreview) {
        frameSizeValue = Math.max(1, Math.round(frameSizeValue));
        frameInsetValue = Math.round(frameInsetValue);
        frameOffsetValue = Math.round(frameOffsetValue);
        center = frameSizeValue % 2 == 0 ? 0 : 0.5;
    }
    const offset = frameOffsetValue - frameInsetValue;
    const left = x + frameInsetValue + center;
    const top = y + frameInsetValue + center;
    const right = x + width - frameInsetValue - center;
    const bottom = y + height - frameInsetValue - center;
    return [
        // top
        {
            points: [vectorCreate(left + offset, top), vectorCreate(right - offset, top)],
        },
        {
            points: [vectorCreate(right, top + offset), vectorCreate(right, bottom - offset)],
        },
        {
            points: [vectorCreate(right - offset, bottom), vectorCreate(left + offset, bottom)],
        },
        {
            points: [vectorCreate(left, bottom - offset), vectorCreate(left, top + offset)],
        },
    ].map((shape) => {
        shape.strokeWidth = frameSizeValue;
        shape.strokeColor = frameColor;
        return shape;
    });
};
const frameStyleHook = ({ x, y, width, height, frameSize = '.25%', frameInset = '2.5%', frameLength = '2.5%', frameColor = [1, 1, 1], }, { isPreview }) => {
    const size = Math.sqrt(width * height);
    let frameSizeValue = toValue(frameSize, size);
    let frameInsetValue = toValue(frameInset, size);
    let frameLengthValue = toValue(frameLength, size);
    let center = 0;
    if (!isPreview) {
        frameSizeValue = Math.max(1, Math.round(frameSizeValue));
        frameInsetValue = Math.round(frameInsetValue);
        frameLengthValue = Math.round(frameLengthValue);
        center = frameSizeValue % 2 == 0 ? 0 : 0.5;
    }
    const left = x + frameInsetValue + center;
    const top = y + frameInsetValue + center;
    const right = x + width - frameInsetValue - center;
    const bottom = y + height - frameInsetValue - center;
    return [
        // top
        {
            points: [
                vectorCreate(left, top + frameLengthValue),
                vectorCreate(left, top),
                vectorCreate(left + frameLengthValue, top),
            ],
        },
        {
            points: [
                vectorCreate(right - frameLengthValue, top),
                vectorCreate(right, top),
                vectorCreate(right, top + frameLengthValue),
            ],
        },
        {
            points: [
                vectorCreate(right, bottom - frameLengthValue),
                vectorCreate(right, bottom),
                vectorCreate(right - frameLengthValue, bottom),
            ],
        },
        {
            points: [
                vectorCreate(left + frameLengthValue, bottom),
                vectorCreate(left, bottom),
                vectorCreate(left, bottom - frameLengthValue),
            ],
        },
    ].map((shape) => {
        shape.strokeWidth = frameSizeValue;
        shape.strokeColor = frameColor;
        return shape;
    });
};
const frameStylePolaroid = ({ x, y, width, height, frameColor = [1, 1, 1] }, { isPreview }) => {
    const size = Math.sqrt(width * height);
    const borderWidth = 0.1 * size;
    let chinHeight = 0.2 * size;
    const borderWidthHalf = 0.5 * borderWidth;
    let strokeWidth = 0.0025 * size;
    if (!isPreview) {
        // borderWidthHalf = Math.round(borderWidthHalf);
        // borderWidth = Math.round(borderWidth);
        chinHeight = Math.ceil(chinHeight);
        strokeWidth = Math.max(2, strokeWidth);
    }
    // always remove opacity
    frameColor.length = 3;
    return [
        // border
        {
            id: 'border',
            x: x - borderWidthHalf,
            y: y - borderWidthHalf,
            width: width + borderWidth,
            height: height + chinHeight,
            frameStyle: 'line',
            frameInset: 0,
            frameOffset: 0,
            frameSize: borderWidth,
            frameColor,
            expandsCanvas: true,
        },
        // chin
        {
            id: 'chin',
            x: x - borderWidthHalf,
            y: height,
            width: width + borderWidth,
            height: chinHeight,
            backgroundColor: frameColor,
            expandsCanvas: true,
        },
        // for preview only
        isPreview && {
            x,
            y,
            width,
            height,
            strokeWidth,
            strokeColor: frameColor,
        },
    ].filter(Boolean);
};
const createFrameStyleProcessor = (styles = {}) => (shape, options) => {
    // handle solid frameStyle
    if (!hasProp(shape, 'frameStyle'))
        return;
    const style = shape.frameStyle;
    // get parser for style
    const process = styles[style];
    if (!process)
        return;
    // remove frameStyle property so we don't get endless looops
    const { frameStyle, ...shapeReadyToParse } = shape;
    return process(shapeReadyToParse, options);
};
// the default frame styles available, can import and extend
const createDefaultFrameStyles = () => ({
    solid: frameStyleSolid,
    hook: frameStyleHook,
    line: frameStyleLine,
    edge: frameStyleEdge,
    polaroid: frameStylePolaroid,
});

// the default lineEnd parser to use
const createDefaultLineEndProcessors = () => createLineEndProcessor(createDefaultLineEndStyles());
const createDefaultFrameStyleProcessor = () => createFrameStyleProcessor(createDefaultFrameStyles());
const createDefaultShapeProcessors = () => [
    createDefaultFrameStyleProcessor(),
    createDefaultLineEndProcessors(),
];
const createShapePreprocessor$1 = (processors) => {
    const processShape = (shape, options = { isPreview: true }) => {
        const res = processors
            .map((process) => {
            const res = process(shape, options);
            // processor wasn't a match?
            if (!res)
                return;
            return res.map((shape) => processShape(shape, options));
        })
            .filter(Boolean)
            .flat();
        return !res.length ? shape : res.flat();
    };
    return processShape;
};

const createDefaultImageReader = createDefaultImageReader$1;
const createDefaultImageWriter = createDefaultImageWriter$1;
const createDefaultImageOrienter = () => ({
    read: getImageOrientationFromFile,
    apply: orientImageData,
});

const markup_editor_defaults = {
    markupEditorToolbar: createToolbar(),
    markupEditorToolStyles: createToolStyles(),
    markupEditorShapeStyleControls: createShapeStyleControls(),
};

const plugin_crop = _plugin_crop;
const plugin_filter = _plugin_filter;
const plugin_finetune = _plugin_finetune;
const plugin_annotate = _plugin_annotate;
const plugin_decorate = _plugin_decorate;
const plugin_sticker = _plugin_sticker;
const plugin_frame = _plugin_frame;
const plugin_resize = _plugin_resize;

const plugin_finetune_defaults = _plugin_finetune_defaults;
const plugin_filter_defaults = _plugin_filter_defaults;
const plugin_frame_defaults = _plugin_frame_defaults;

const locale_en_gb = _locale_en_gb;
const markup_editor_locale_en_gb = MarkupEditor;

const plugin_crop_locale_en_gb = _plugin_crop_locale_en_gb;
const plugin_filter_locale_en_gb = _plugin_filter_locale_en_gb;
const plugin_finetune_locale_en_gb = _plugin_finetune_locale_en_gb;
const plugin_resize_locale_en_gb = _plugin_resize_locale_en_gb;
const plugin_decorate_locale_en_gb = _plugin_decorate_locale_en_gb;
const plugin_annotate_locale_en_gb = _plugin_annotate_locale_en_gb;
const plugin_sticker_locale_en_gb = _plugin_sticker_locale_en_gb;
const plugin_frame_locale_en_gb = _plugin_frame_locale_en_gb;

const appendEditor = _appendEditor;
const openEditor = _openEditor;
const overlayEditor = _overlayEditor;

const getEditorDefaultReadWriteOptions = (options = {}) => {
    // allow passing reader writer options as object
    let readerProps = undefined;
    if (!Array.isArray(options.imageWriter)) {
        readerProps = options.imageWriter;
        delete options.imageReader;
    }

    let writerProps = undefined;
    if (!Array.isArray(options.imageWriter)) {
        writerProps = options.imageWriter;
        delete options.imageWriter;
    }

    return {
        // default handling of images
        imageReader: createDefaultImageReader(readerProps),
        imageWriter: createDefaultImageWriter(writerProps),
        imageOrienter: createDefaultImageOrienter(),
    };
};

const createDefaultShapePreprocessor = () =>
    createShapePreprocessor$1(createDefaultShapeProcessors());

const getEditorDefaults = (options = {}) => {
    // load all plugins
    setEditorViewPlugins(
        ...[
            plugin_crop,
            plugin_filter,
            plugin_finetune,
            plugin_annotate,
            plugin_decorate,
            plugin_sticker,
            plugin_frame,
            plugin_resize,
        ].filter(Boolean)
    );

    // auto hide stickers util if no stickers defined
    const utils = [
        'crop',
        'filter',
        'finetune',
        'annotate',
        'decorate',
        options.stickers && 'sticker',
        'frame',
        'resize',
    ].filter(Boolean);

    // get default read/write options object
    const defaultReadWriteOptions = getEditorDefaultReadWriteOptions(options);

    // locale
    const locale = {
        ...locale_en_gb,
        ...markup_editor_locale_en_gb,
        ...plugin_crop_locale_en_gb,
        ...plugin_filter_locale_en_gb,
        ...plugin_finetune_locale_en_gb,
        ...plugin_frame_locale_en_gb,
        ...plugin_resize_locale_en_gb,
        ...plugin_decorate_locale_en_gb,
        ...plugin_annotate_locale_en_gb,
        ...plugin_sticker_locale_en_gb,
        ...options.locale,
    };
    delete options.locale;

    // create huge config object
    return mergeObjects([
        {
            // set reader / writer / orienter
            ...defaultReadWriteOptions,

            // shape preprocessor
            shapePreprocessor: createDefaultShapePreprocessor(),

            // default utils
            utils,

            // default plugin options
            ...plugin_finetune_defaults,
            ...plugin_filter_defaults,
            ...plugin_frame_defaults,
            ...markup_editor_defaults,

            // stickers stick to image by default
            stickerStickToImage: true,

            // locale
            locale,
        },
        options,
    ]);
};

/* eslint-disable no-param-reassign */
const isEvent = (key) => /^on[A-Z]/.test(key);

const getEventsFromProps = (props) =>
  Object.keys(props).filter(isEvent).map(getEventFromKey);

const getEventFromKey = (key) => key.substr(2).toLowerCase();

const unsub = (component, events = undefined) => {
  (component.unsubs || [])
    // events not supplied, or event is in events list
    .filter(([event]) => !events || events.includes(event))
    .forEach(([, unsubf]) => unsubf());
};

const sub = (component, props) => {
  // unsub existing subscriptions
  unsub(component, getEventsFromProps(props));

  // subscribe
  component.unsubs = Object.keys(props)
    .filter(isEvent)
    .map((key) => {
      const type = getEventFromKey(key);
      return [type, component.editor.on(type, props[key])];
    });
};

class PinturaEditor extends React__default.Component {
  constructor(props) {
    super(props);
    this.elementRef = React__default.createRef();
    this.editor = undefined;
  }

  componentDidMount() {
    if (!this.elementRef.current) return;
    const props = { ...this.props };
    this.editor = appendEditor(this.elementRef.current, props);
    sub(this, props);
  }

  componentDidUpdate() {
    const props = { ...this.props };
    Object.assign(this.editor, props);
    sub(this, props);
  }

  componentWillUnmount() {
    if (!this.editor) return;
    unsub(this);
    this.editor.destroy();
    this.editor = undefined;
  }

  render() {
    return React__default.createElement('div', {
      className: `PinturaRootWrapper ${this.props.className}`.trim(),
      ref: this.elementRef,
    });
  }
}

class PinturaEditorModal extends React__default.Component {
  constructor(props) {
    super(props);
    this.editor = undefined;

    // We'll wrap the module in a container so we can use the container as a CSS module target
    this.el = document.createElement('div');
  }

  componentDidMount() {
    // add the container
    document.body.appendChild(this.el);
    this.el.className = this.props.className;

    // create editor and proxy events
    const props = { ...this.props };
    this.editor = openEditor(props, this.el);
    sub(this, props);
  }

  componentDidUpdate() {
    const props = { ...this.props };
    Object.assign(this.editor, props);
    sub(this, props);
  }

  componentWillUnmount() {
    // remove our modal container
    document.body.removeChild(this.el);
    if (!this.editor) return;
    unsub(this);
    this.editor = undefined;
  }

  show() {
    this.editor.show();
  }

  hide() {
    this.editor.hide();
  }

  render() {
    return null;
  }
}

class PinturaEditorOverlay extends React__default.Component {
  constructor(props) {
    super(props);
    this.elementRef = React__default.createRef();
    this.editor = undefined;
  }

  componentDidMount() {
    if (!this.elementRef.current) return;
    const props = { ...this.props };
    this.editor = overlayEditor(this.elementRef.current, props);
    sub(this, props);
  }

  componentDidUpdate() {
    const props = { ...this.props };
    Object.assign(this.editor, props);
    sub(this, props);
  }

  componentWillUnmount() {
    if (!this.editor) return;
    unsub(this);
    this.editor.destroy();
    this.editor = undefined;
  }

  render() {
    return React__default.createElement('div', {
      className: `PinturaRootWrapper ${this.props.className}`.trim(),
      ref: this.elementRef
    });
  }
}

var ImageEditorStyled = styled$1(motion.label)(templateObject_1$W || (templateObject_1$W = __makeTemplateObject(["\n  display: flex;\n  position: relative;\n  width: 100%;\n  height: 100%;\n\n  background-color: #f6f7fb;\n  font-weight: 500;\n  color: #a5a7ad;\n  cursor: pointer;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n\n  input {\n    opacity: 0;\n    position: absolute;\n    z-index: 1;\n  }\n"], ["\n  display: flex;\n  position: relative;\n  width: 100%;\n  height: 100%;\n\n  background-color: #f6f7fb;\n  font-weight: 500;\n  color: #a5a7ad;\n  cursor: pointer;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n\n  input {\n    opacity: 0;\n    position: absolute;\n    z-index: 1;\n  }\n"])));
var templateObject_1$W;

var InputImageEditor = function (props) {
    var modalCSS = props.modalCSS, wrapperCSS = props.wrapperCSS, onChangeImageEditor = props.onChangeImageEditor, aspectRatio = props.aspectRatio, imagePreview = props.imagePreview;
    var _a = __read(useState(null), 2), blob = _a[0], setBlob = _a[1];
    var _b = __read(useState(imagePreview !== null && imagePreview !== void 0 ? imagePreview : null), 2), image = _b[0], setImage = _b[1];
    var _c = __read(useState(false), 2), isModal = _c[0], setIsModal = _c[1];
    var _d = __read(useState(false), 2), dropActive = _d[0], setDropActive = _d[1];
    var ref = createRef();
    var refInput = useRef(null);
    var handleDrag = function (e) {
        e.preventDefault();
        e.stopPropagation();
    };
    var Drop = function (e) {
        handleDrag(e);
        var files = e.dataTransfer.files;
        if (files.length !== 0) {
            var url = URL === null || URL === void 0 ? void 0 : URL.createObjectURL(files[0]);
            setBlob(url);
            setDropActive(false);
            setIsModal(true);
        }
        else {
            refInput.current.value = null;
            setBlob(null);
            setDropActive(false);
            setIsModal(false);
        }
    };
    var DropInput = function (e) {
        e.preventDefault();
        e.stopPropagation();
        var files = e.currentTarget.files;
        if (files) {
            if (files.length !== 0) {
                var url = URL === null || URL === void 0 ? void 0 : URL.createObjectURL(files[0]);
                setBlob(url);
                setDropActive(false);
                setIsModal(true);
            }
            else {
                refInput.current.value = null;
                setBlob(null);
                setDropActive(false);
            }
        }
    };
    useEffect(function () {
        var handleClickOutside = function (event) {
            if (ref.current &&
                ref.current.elementRef.current &&
                !ref.current.elementRef.current.contains(event.target)) {
                refInput.current.value = null;
                setBlob(null);
                setImage(null);
                setDropActive(false);
                setIsModal(false);
            }
        };
        document.addEventListener("mousedown", handleClickOutside);
        return function () {
            document.removeEventListener("mousedown", handleClickOutside);
        };
    }, [ref]);
    return (jsxs(Fragment$1, { children: [jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_1$V || (templateObject_1$V = __makeTemplateObject(["\n          width: 250px;\n          height: 250px;\n          ", "\n        "], ["\n          width: 250px;\n          height: 250px;\n          ", "\n        "])), wrapperCSS) }, { children: jsxs(ImageEditorStyled, __assign({ htmlFor: "image-editor", onDrop: Drop, onDragOver: function (e) {
                        handleDrag(e);
                        setDropActive(true);
                    }, onDragEnter: function (e) { return handleDrag(e); }, onDragLeave: function (e) {
                        handleDrag(e);
                        setDropActive(false);
                    } }, { children: [image ? (jsx(Image$2, { alt: "Drag and drop Preview", src: image, customCSS: css$1(templateObject_2$H || (templateObject_2$H = __makeTemplateObject(["\n                position: absolute;\n                width: 100%;\n                height: 100%;\n                object-fit: cover;\n              "], ["\n                position: absolute;\n                width: 100%;\n                height: 100%;\n                object-fit: cover;\n              "]))) })) : (jsx(Wrapper$2, __assign({ flexDirection: "row", customCSS: css$1(templateObject_3$y || (templateObject_3$y = __makeTemplateObject(["\n                font-size: 14px;\n                font-family: 'Montserrat', sans-serif;\n                font-weight: 600;\n              "], ["\n                font-size: 14px;\n                font-family: 'Montserrat', sans-serif;\n                font-weight: 600;\n              "]))) }, { children: !dropActive ? (jsxs(Fragment$1, { children: [jsx(Image$2, { alt: "Drag and drop", height: "15px", width: "15px", margin: "0px 10px 0px 0px", src: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/PFS-0001/upload.svg" }), "ARRASTRA Y SUELTA"] })) : (jsx(Fragment$1, { children: "SUELTA" })) }))), jsx("input", { type: "file", id: "image-editor", onChange: DropInput, ref: refInput })] })) })), jsx(AnimatePresence, { children: isModal && (jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_4$o || (templateObject_4$o = __makeTemplateObject(["\n              top: 0;\n              left: 0;\n              z-index: 1000;\n              background-color: #3a3a3a5b;\n              position: fixed;\n              width: 100vw;\n              height: 100vh;\n              overflow: hidden;\n              justify-content: center;\n              align-items: center;\n              .PinturaRootWrapper {\n                width: 90%;\n                max-width: 600px;\n                height: 70%;\n                max-height: 600px;\n              }\n              .PinturaRoot {\n                background-color: #fafafa;\n              }\n              .PinturaButtonExport {\n                background-color: #f1576c;\n                color: #fff;\n                :hover {\n                  background-color: #c5293e;\n                }\n              }\n              ", "\n            "], ["\n              top: 0;\n              left: 0;\n              z-index: 1000;\n              background-color: #3a3a3a5b;\n              position: fixed;\n              width: 100vw;\n              height: 100vh;\n              overflow: hidden;\n              justify-content: center;\n              align-items: center;\n              .PinturaRootWrapper {\n                width: 90%;\n                max-width: 600px;\n                height: 70%;\n                max-height: 600px;\n              }\n              .PinturaRoot {\n                background-color: #fafafa;\n              }\n              .PinturaButtonExport {\n                background-color: #f1576c;\n                color: #fff;\n                :hover {\n                  background-color: #c5293e;\n                }\n              }\n              ", "\n            "])), modalCSS) }, { children: jsx(PinturaEditor, __assign({}, getEditorDefaults(), { src: blob, ref: ref, utils: ['crop', 'filter', 'finetune', 'annotate', 'frame'], enableDropImage: false, imageCropAspectRatio: aspectRatio !== null && aspectRatio !== void 0 ? aspectRatio : 1, cropEnableCenterImageSelection: true, cropImageSelectionCornerStyle: "hook", cropAutoCenterImageSelectionTimeout: 500, 
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        onProcess: function (res) {
                            var FilterAndCrop = URL.createObjectURL(res.dest);
                            onChangeImageEditor === null || onChangeImageEditor === void 0 ? void 0 : onChangeImageEditor({ url: FilterAndCrop, file: res.dest });
                            setImage(FilterAndCrop);
                            setIsModal(false);
                        } })) }), "".concat(isModal))) })] }));
};
var templateObject_1$V, templateObject_2$H, templateObject_3$y, templateObject_4$o;

var AtomTableStyled$1 = styled$1.table(templateObject_1$U || (templateObject_1$U = __makeTemplateObject(["\n  border-collapse: collapse;\n  table-layout: auto;\n  font-family: 'Montserrat', sans-serif;\n  width: ", ";\n  height: ", ";\n  margin: ", ";\n  color: ", ";\n  width: max-content;\n  min-width: 100%;\n  border-radius: ", ";\n  thead {\n    font-family: 'Montserrat', sans-serif;\n    height: fit-content;\n    text-align: center;\n    background-color: white;\n    border-bottom: 1px solid #eeeeee;\n    th {\n      font-family: 'Montserrat', sans-serif;\n      text-align: left;\n      color: #565656;\n      font-size: 14px;\n      font-weight: 700;\n      padding: 15px 30px 15px 30px;\n      span {\n        font-size: 8px;\n      }\n    }\n  }\n  ", ";\n"], ["\n  border-collapse: collapse;\n  table-layout: auto;\n  font-family: 'Montserrat', sans-serif;\n  width: ", ";\n  height: ", ";\n  margin: ", ";\n  color: ", ";\n  width: max-content;\n  min-width: 100%;\n  border-radius: ", ";\n  thead {\n    font-family: 'Montserrat', sans-serif;\n    height: fit-content;\n    text-align: center;\n    background-color: white;\n    border-bottom: 1px solid #eeeeee;\n    th {\n      font-family: 'Montserrat', sans-serif;\n      text-align: left;\n      color: #565656;\n      font-size: 14px;\n      font-weight: 700;\n      padding: 15px 30px 15px 30px;\n      span {\n        font-size: 8px;\n      }\n    }\n  }\n  ", ";\n"])), function (_a) {
    var width = _a.width;
    return width || "100%";
}, function (_a) {
    var height = _a.height;
    return height || "max-content";
}, function (_a) {
    var margin = _a.margin;
    return margin || "0px 0px;";
}, function (_a) {
    var color = _a.color;
    return color || "black";
}, function (_a) {
    var borderRadius = _a.borderRadius;
    return borderRadius || "15px";
}, function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
var AtomTbodyStyled$1 = styled$1.tbody(templateObject_2$G || (templateObject_2$G = __makeTemplateObject(["\n  td {\n    font-family: 'Montserrat', sans-serif;\n    color: #565656;\n    font-size: 14px;\n    padding: 15px 30px;\n    text-align: left;\n    border-bottom: 1px solid #eeeeee;\n  }\n  tr {\n    background-color: #fefefe;\n    transition: all 0.3s ease-in-out;\n  }\n  tr:hover {\n    background-color: #fafafa;\n  }\n"], ["\n  td {\n    font-family: 'Montserrat', sans-serif;\n    color: #565656;\n    font-size: 14px;\n    padding: 15px 30px;\n    text-align: left;\n    border-bottom: 1px solid #eeeeee;\n  }\n  tr {\n    background-color: #fefefe;\n    transition: all 0.3s ease-in-out;\n  }\n  tr:hover {\n    background-color: #fafafa;\n  }\n"])));
var TDStyled$1 = styled$1.td(templateObject_3$x || (templateObject_3$x = __makeTemplateObject(["\n  ", ";\n"], ["\n  ", ";\n"])), function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
var templateObject_1$U, templateObject_2$G, templateObject_3$x;

var AtomTableContainerStyled = styled$1(motion.main)(templateObject_1$T || (templateObject_1$T = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n"], ["\n  display: flex;\n  flex-direction: column;\n"])));
styled$1(motion.section)(templateObject_2$F || (templateObject_2$F = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  overflow-x: auto;\n  ::-webkit-scrollbar {\n    width: 7px;\n    height: 7px;\n  }\n"], ["\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  overflow-x: auto;\n  ::-webkit-scrollbar {\n    width: 7px;\n    height: 7px;\n  }\n"])));
var AtomTableStyled = styled$1(motion.table)(templateObject_3$w || (templateObject_3$w = __makeTemplateObject(["\n  display: flex;\n  flex-direction: column;\n  position: relative;\n  overflow-y: hidden;\n  overflow-x: scroll;\n  font-family: 'Montserrat', sans-serif;\n  height: max-content;\n  border-radius: 4px;\n  outline: 1px solid #eeeeee;\n  color: ", ";\n  ::-webkit-scrollbar {\n    width: 7px;\n    height: 7px;\n  }\n  overflow: auto;\n  tbody {\n    min-width: 100%;\n    position: relative;\n    tr {\n      grid-template-columns: repeat(\n        ", ",\n        minmax(", ", 1fr)\n      );\n    }\n    .head {\n      position: sticky;\n      top: 0;\n      z-index: 100;\n      th {\n        font-family: 'Montserrat', sans-serif;\n        text-align: left;\n        color: #565656;\n        font-size: 14px;\n        font-weight: 700;\n        padding: 15px 30px 15px 30px;\n        span {\n          font-size: 8px;\n        }\n      }\n    }\n  }\n  ", "\n"], ["\n  display: flex;\n  flex-direction: column;\n  position: relative;\n  overflow-y: hidden;\n  overflow-x: scroll;\n  font-family: 'Montserrat', sans-serif;\n  height: max-content;\n  border-radius: 4px;\n  outline: 1px solid #eeeeee;\n  color: ", ";\n  ::-webkit-scrollbar {\n    width: 7px;\n    height: 7px;\n  }\n  overflow: auto;\n  tbody {\n    min-width: 100%;\n    position: relative;\n    tr {\n      grid-template-columns: repeat(\n        ", ",\n        minmax(", ", 1fr)\n      );\n    }\n    .head {\n      position: sticky;\n      top: 0;\n      z-index: 100;\n      th {\n        font-family: 'Montserrat', sans-serif;\n        text-align: left;\n        color: #565656;\n        font-size: 14px;\n        font-weight: 700;\n        padding: 15px 30px 15px 30px;\n        span {\n          font-size: 8px;\n        }\n      }\n    }\n  }\n  ", "\n"])), function (_a) {
    var color = _a.color;
    return color || "black";
}, function (_a) {
    var cl = _a.cl;
    return cl !== null && cl !== void 0 ? cl : 1;
}, function (_a) {
    var min = _a.min;
    return "".concat(min !== null && min !== void 0 ? min : 150, "px");
}, function (_a) {
    var customCSST = _a.customCSST;
    return customCSST;
});
styled$1(motion.thead)(templateObject_4$n || (templateObject_4$n = __makeTemplateObject(["\n  top: 0;\n  position: absolute;\n  display: flex;\n  width: max-content;\n  position: sticky;\n  flex-direction: column;\n  font-family: 'Montserrat', sans-serif;\n  height: fit-content;\n  text-align: center;\n  background-color: white;\n  border-bottom: 1px solid #eeeeee;\n  tr {\n    display: grid;\n    th {\n      position: -webkit-sticky;\n      position: sticky;\n      top: 0;\n      z-index: 2;\n\n      font-family: 'Montserrat', sans-serif;\n      text-align: left;\n      color: #565656;\n      font-size: 14px;\n      font-weight: 700;\n      padding: 15px 30px 15px 30px;\n      span {\n        font-size: 8px;\n      }\n    }\n  }\n  tr {\n    background-color: #ffffff;\n    transition: all 0.3s ease-in-out;\n  }\n  tr:nth-child(odd) {\n    background-color: #fbfbfb;\n  }\n  tr:hover {\n    background-color: #f0f0f0;\n  }\n"], ["\n  top: 0;\n  position: absolute;\n  display: flex;\n  width: max-content;\n  position: sticky;\n  flex-direction: column;\n  font-family: 'Montserrat', sans-serif;\n  height: fit-content;\n  text-align: center;\n  background-color: white;\n  border-bottom: 1px solid #eeeeee;\n  tr {\n    display: grid;\n    th {\n      position: -webkit-sticky;\n      position: sticky;\n      top: 0;\n      z-index: 2;\n\n      font-family: 'Montserrat', sans-serif;\n      text-align: left;\n      color: #565656;\n      font-size: 14px;\n      font-weight: 700;\n      padding: 15px 30px 15px 30px;\n      span {\n        font-size: 8px;\n      }\n    }\n  }\n  tr {\n    background-color: #ffffff;\n    transition: all 0.3s ease-in-out;\n  }\n  tr:nth-child(odd) {\n    background-color: #fbfbfb;\n  }\n  tr:hover {\n    background-color: #f0f0f0;\n  }\n"])));
var AtomTbodyStyled = styled$1(motion.tbody)(templateObject_5$j || (templateObject_5$j = __makeTemplateObject(["\n  display: flex;\n  width: max-content;\n  flex-direction: column;\n\n  tr {\n    display: grid;\n    background-color: #ffffff;\n    transition: all 0.3s ease-in-out;\n  }\n  tr:nth-child(odd) {\n    background-color: #fbfbfb;\n  }\n  tr:hover {\n    background-color: #f0f0f0;\n  }\n"], ["\n  display: flex;\n  width: max-content;\n  flex-direction: column;\n\n  tr {\n    display: grid;\n    background-color: #ffffff;\n    transition: all 0.3s ease-in-out;\n  }\n  tr:nth-child(odd) {\n    background-color: #fbfbfb;\n  }\n  tr:hover {\n    background-color: #f0f0f0;\n  }\n"])));
var TRStyled = styled$1(motion.tr)(templateObject_6$e || (templateObject_6$e = __makeTemplateObject(["\n  ", ";\n"], ["\n  ", ";\n"])), function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
var TDStyled = styled$1(motion.td)(templateObject_7$c || (templateObject_7$c = __makeTemplateObject(["\n  font-family: 'Montserrat', sans-serif;\n  color: #565656;\n  font-size: 12px;\n  font-weight: 500;\n  padding: 15px 30px;\n  text-align: left;\n  border-bottom: 1px solid #eeeeee;\n  ", ";\n"], ["\n  font-family: 'Montserrat', sans-serif;\n  color: #565656;\n  font-size: 12px;\n  font-weight: 500;\n  padding: 15px 30px;\n  text-align: left;\n  border-bottom: 1px solid #eeeeee;\n  ", ";\n"])), function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
var AtomTheaderStyled = styled$1(motion.header)(templateObject_8$7 || (templateObject_8$7 = __makeTemplateObject(["\n  font-family: 'Montserrat', sans-serif;\n  color: #565656;\n  font-size: 14px;\n  padding: 15px 0px;\n  font-weight: 700;\n  text-align: left;\n  border-bottom: 1px solid #eeeeee;\n"], ["\n  font-family: 'Montserrat', sans-serif;\n  color: #565656;\n  font-size: 14px;\n  padding: 15px 0px;\n  font-weight: 700;\n  text-align: left;\n  border-bottom: 1px solid #eeeeee;\n"])));
var AtomTfooterStyled = styled$1(motion.footer)(templateObject_9$5 || (templateObject_9$5 = __makeTemplateObject(["\n  font-family: 'Montserrat', sans-serif;\n  color: #565656;\n  font-size: 14px;\n  padding: 15px 30px;\n  font-weight: 700;\n  text-align: left;\n  border-bottom: 1px solid #eeeeee;\n"], ["\n  font-family: 'Montserrat', sans-serif;\n  color: #565656;\n  font-size: 14px;\n  padding: 15px 30px;\n  font-weight: 700;\n  text-align: left;\n  border-bottom: 1px solid #eeeeee;\n"])));
var templateObject_1$T, templateObject_2$F, templateObject_3$w, templateObject_4$n, templateObject_5$j, templateObject_6$e, templateObject_7$c, templateObject_8$7, templateObject_9$5;

// const Animation = {
//   whileTap: { scale: 0.98, opacity: 0.8 },
// };
// const DefaultAnimation = {
//   whileTap: { scale: 0.98, opacity: 0.8 },
//   transition: {
//     default: { duration: 0.3 },
//   },
//   initial: { opacity: 0 },
//   animate: { opacity: 1 },
//   exit: { opacity: 0 },
// };
var QUERYDEFAULT = gql(templateObject_1$S || (templateObject_1$S = __makeTemplateObject(["\n  query ListUsers(\n    $skip: Int\n    $take: Int\n    $filter: MemberFilterInput\n    $order: [MemberSortInput!]\n  ) {\n    listUsers(skip: $skip, take: $take, filter: $filter, order: $order) {\n      pageInfo {\n        hasNextPage\n        hasPreviousPage\n        __typename\n      }\n      totalCount\n      items {\n        firstTime\n        email\n        id\n        profile {\n          id\n          firstName\n          lastName\n          __typename\n        }\n        groups {\n          id\n          name\n          __typename\n        }\n        memberRoles {\n          companyId\n          roleId\n          role {\n            name\n            codeName\n            description\n            __typename\n          }\n          id\n          createdAt\n          updatedAt\n          __typename\n        }\n        memberProjects {\n          id\n          memberId\n          memberProjectRoleProject {\n            projectRole {\n              id\n              name\n              codeName\n              __typename\n            }\n            __typename\n          }\n          __typename\n        }\n        createdAt\n        lastLogin\n        __typename\n      }\n      __typename\n    }\n  }\n"], ["\n  query ListUsers(\n    $skip: Int\n    $take: Int\n    $filter: MemberFilterInput\n    $order: [MemberSortInput!]\n  ) {\n    listUsers(skip: $skip, take: $take, filter: $filter, order: $order) {\n      pageInfo {\n        hasNextPage\n        hasPreviousPage\n        __typename\n      }\n      totalCount\n      items {\n        firstTime\n        email\n        id\n        profile {\n          id\n          firstName\n          lastName\n          __typename\n        }\n        groups {\n          id\n          name\n          __typename\n        }\n        memberRoles {\n          companyId\n          roleId\n          role {\n            name\n            codeName\n            description\n            __typename\n          }\n          id\n          createdAt\n          updatedAt\n          __typename\n        }\n        memberProjects {\n          id\n          memberId\n          memberProjectRoleProject {\n            projectRole {\n              id\n              name\n              codeName\n              __typename\n            }\n            __typename\n          }\n          __typename\n        }\n        createdAt\n        lastLogin\n        __typename\n      }\n      __typename\n    }\n  }\n"])));
var InputSelectWtihPagination = function (props) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    var onChange = props.onChange, columns = props.columns, placeholder = props.placeholder, onPress = props.onPress;
    var customize = useSelector(function (state) { return state.customize; });
    var labelWidth = props.labelWidth, labelColor = props.labelColor, labelFontFamily = props.labelFontFamily, id = props.id, labelFontSize = props.labelFontSize, labelFontWeight = props.labelFontWeight, formik = props.formik, labelMargin = props.labelMargin, maxHeightBox = props.maxHeightBox, ErrorCustom = props.error, data = props.data, positionBox = props.positionBox, onError = props.onError, labelPadding = props.labelPadding, spanMargin = props.spanMargin, onCompleted = props.onCompleted, QUERY = props.QUERY, customCSS = props.customCSS, label = props.label, options = props.options, defaultText = props.defaultText;
    var _j = __read(useState(0), 2), skip = _j[0], setSkip = _j[1];
    var _k = __read(useState([]), 2), getData = _k[0], setData = _k[1];
    var _l = __read(useState(''), 2), searchData = _l[0], setsearchData = _l[1];
    var _m = __read(useState(false), 2), isOpen = _m[0], setOpen = _m[1];
    var _o = __read(useState({}), 2), getParams = _o[0], setParams = _o[1];
    var scrollRef = useRef();
    var getFilter = useMemo(function () {
        var _a, _b;
        if ((_a = options === null || options === void 0 ? void 0 : options.variables) === null || _a === void 0 ? void 0 : _a.filter) {
            return {
                filter: __assign({}, (_b = options === null || options === void 0 ? void 0 : options.variables) === null || _b === void 0 ? void 0 : _b.filter),
            };
        }
        return null;
    }, [getParams, options]);
    var take = (_b = (_a = options === null || options === void 0 ? void 0 : options.variables) === null || _a === void 0 ? void 0 : _a.take) !== null && _b !== void 0 ? _b : 50;
    var QUERYGET = useQuery(QUERY !== null && QUERY !== void 0 ? QUERY : QUERYDEFAULT, __assign(__assign({}, options), { variables: __assign(__assign(__assign({}, options === null || options === void 0 ? void 0 : options.variables), getFilter), { skip: take * skip, take: take }), onCompleted: function (e) {
            onCompleted === null || onCompleted === void 0 ? void 0 : onCompleted(e);
        }, onError: function (error) {
            onError === null || onError === void 0 ? void 0 : onError(error);
        } }));
    useEffect(function () {
        var _a, _b, _c, _d, _e;
        var get = (_b = Object.values((_a = QUERYGET === null || QUERYGET === void 0 ? void 0 : QUERYGET.data) !== null && _a !== void 0 ? _a : {})) === null || _b === void 0 ? void 0 : _b[0];
        var params = {
            pageInfo: (_c = get === null || get === void 0 ? void 0 : get.pageInfo) !== null && _c !== void 0 ? _c : getParams === null || getParams === void 0 ? void 0 : getParams.pageInfo,
            totalCount: (_d = get === null || get === void 0 ? void 0 : get.totalCount) !== null && _d !== void 0 ? _d : getParams === null || getParams === void 0 ? void 0 : getParams.totalCount,
        };
        var dataTable = (_e = data === null || data === void 0 ? void 0 : data(QUERYGET === null || QUERYGET === void 0 ? void 0 : QUERYGET.data)) !== null && _e !== void 0 ? _e : getData;
        setParams(params);
        setData(dataTable);
    }, [QUERY, options, QUERYGET]);
    return (jsxs(InputSelectPaginationLabelStyled, __assign({ labelWidth: labelWidth, labelColor: labelColor, labelFontFamily: labelFontFamily, labelFontSize: labelFontSize, labelFontWeight: labelFontWeight, labelMargin: labelMargin, labelPadding: labelPadding, customCSS: customCSS }, { children: [label && (jsx(InputTextSpanStyled, __assign({ spanMargin: spanMargin }, { children: label }))), jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_2$E || (templateObject_2$E = __makeTemplateObject(["\n          display: grid;\n          grid-template-columns: 1fr auto;\n        "], ["\n          display: grid;\n          grid-template-columns: 1fr auto;\n        "]))) }, { children: jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_3$v || (templateObject_3$v = __makeTemplateObject(["\n            position: relative;\n            flex-direction: ", ";\n            flex: 1;\n            gap: 8px;\n          "], ["\n            position: relative;\n            flex-direction: ", ";\n            flex: 1;\n            gap: 8px;\n          "])), positionsBox[positionBox]) }, { children: [jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_4$m || (templateObject_4$m = __makeTemplateObject(["\n              display: flex;\n              flex-direction: row;\n              align-items: center;\n              justify-content: space-between;\n              background-color: white;\n              /* padding: 10px; */\n              border: 1px solid #0000003f;\n            "], ["\n              display: flex;\n              flex-direction: row;\n              align-items: center;\n              justify-content: space-between;\n              background-color: white;\n              /* padding: 10px; */\n              border: 1px solid #0000003f;\n            "]))) }, { children: [jsx(Wrapper$2, __assign({ alignItems: "center", justifyContent: "center" }, { children: jsx(Input, { type: "text", value: searchData, placeholder: placeholder, defaultText: defaultText, onChange: function (event) {
                                            var _a, _b, _c, _d;
                                            setsearchData((_a = event.target) === null || _a === void 0 ? void 0 : _a.value);
                                            var result = (_c = (onChange &&
                                                onChange((_b = event.target) === null || _b === void 0 ? void 0 : _b.value, data === null || data === void 0 ? void 0 : data(QUERYGET === null || QUERYGET === void 0 ? void 0 : QUERYGET.data)))) !== null && _c !== void 0 ? _c : data === null || data === void 0 ? void 0 : data(QUERYGET === null || QUERYGET === void 0 ? void 0 : QUERYGET.data);
                                            setData(((_d = event.target) === null || _d === void 0 ? void 0 : _d.value) === '' ? data === null || data === void 0 ? void 0 : data(QUERYGET === null || QUERYGET === void 0 ? void 0 : QUERYGET.data) : result);
                                        }, 
                                        // onClick={() => setOpen(true)}
                                        customCSS: css$1(templateObject_5$i || (templateObject_5$i = __makeTemplateObject(["\n                  width: 100%;\n                  padding: 0px;\n                  padding-left: 10px;\n                  input {\n                    padding: 0px;\n                    background-color: transparent;\n                    box-shadow: transparent;\n                    border: transparent;\n                  }\n                "], ["\n                  width: 100%;\n                  padding: 0px;\n                  padding-left: 10px;\n                  input {\n                    padding: 0px;\n                    background-color: transparent;\n                    box-shadow: transparent;\n                    border: transparent;\n                  }\n                "]))) }) })), jsx(AtomButton, __assign({ width: "auto", onClick: function () {
                                        setOpen(function (prev) { return !prev; });
                                    }, backgroundColor: "transparent", customCSS: css$1(templateObject_6$d || (templateObject_6$d = __makeTemplateObject(["\n                padding: 0px 10px;\n              "], ["\n                padding: 0px 10px;\n              "]))) }, { children: jsx(Wrapper$2, { customCSS: css$1(templateObject_9$4 || (templateObject_9$4 = __makeTemplateObject(["\n                  width: auto;\n                  border: 0.5px solid black;\n                  border-width: 0 2px 2px 0;\n                  display: inline-block;\n                  padding: 5px;\n                  ", "\n                "], ["\n                  width: auto;\n                  border: 0.5px solid black;\n                  border-width: 0 2px 2px 0;\n                  display: inline-block;\n                  padding: 5px;\n                  ", "\n                "])), isOpen
                                            ? css$1(templateObject_7$b || (templateObject_7$b = __makeTemplateObject(["\n                        margin-top: 15px;\n                        transform: rotate(-135deg);\n                        -webkit-transform: rotate(-135deg);\n                      "], ["\n                        margin-top: 15px;\n                        transform: rotate(-135deg);\n                        -webkit-transform: rotate(-135deg);\n                      "]))) : css$1(templateObject_8$6 || (templateObject_8$6 = __makeTemplateObject(["\n                        transform: rotate(45deg);\n                        -webkit-transform: rotate(45deg);\n                      "], ["\n                        transform: rotate(45deg);\n                        -webkit-transform: rotate(45deg);\n                      "])))) }) }))] })), jsx(Wrapper$2, __assign({ position: "relative" }, { children: isOpen && (jsx(Fragment$1, { children: jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_10$4 || (templateObject_10$4 = __makeTemplateObject(["\n                    background-color: white;\n                    ::placeholder {\n                      color: #202124;\n                    }\n                    border: 1px solid #f2f2f2;\n                    position: absolute;\n                    ", "\n                    ::-webkit-scrollbar-thumb {\n                      background: ", ";\n                    }\n                    overflow: ", ";\n                    overflow-x: hidden;\n                    width: 100%;\n                    max-height: ", ";\n                    align-items: center;\n                    justify-content: flex-start;\n                    border: 1px solid #0000003f;\n                  "], ["\n                    background-color: white;\n                    ::placeholder {\n                      color: #202124;\n                    }\n                    border: 1px solid #f2f2f2;\n                    position: absolute;\n                    ", "\n                    ::-webkit-scrollbar-thumb {\n                      background: ", ";\n                    }\n                    overflow: ", ";\n                    overflow-x: hidden;\n                    width: 100%;\n                    max-height: ", ";\n                    align-items: center;\n                    justify-content: flex-start;\n                    border: 1px solid #0000003f;\n                  "])), moveBox[positionBox !== null && positionBox !== void 0 ? positionBox : 'bottom'], ((_c = customize === null || customize === void 0 ? void 0 : customize.colors) === null || _c === void 0 ? void 0 : _c.primary) || '#f0a58b', (QUERYGET === null || QUERYGET === void 0 ? void 0 : QUERYGET.loading) ? 'hidden' : 'scroll', maxHeightBox !== null && maxHeightBox !== void 0 ? maxHeightBox : '420px'), refObject: scrollRef, onScroll: function () {
                                        var _a, _b, _c, _d, _e, _f;
                                        if (scrollRef.current) {
                                            var top_1 = ((_a = scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current) === null || _a === void 0 ? void 0 : _a.scrollTop) === 0;
                                            var bottom = ((_b = scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current) === null || _b === void 0 ? void 0 : _b.scrollTop) +
                                                ((_c = scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current) === null || _c === void 0 ? void 0 : _c.clientHeight) ===
                                                ((_d = scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current) === null || _d === void 0 ? void 0 : _d.scrollHeight);
                                            if (top_1 && !(QUERYGET === null || QUERYGET === void 0 ? void 0 : QUERYGET.loading)) {
                                                setSkip(((_e = getParams === null || getParams === void 0 ? void 0 : getParams.pageInfo) === null || _e === void 0 ? void 0 : _e.hasPreviousPage) ? skip - 1 : skip);
                                            }
                                            if (bottom && !(QUERYGET === null || QUERYGET === void 0 ? void 0 : QUERYGET.loading)) {
                                                setSkip(((_f = getParams === null || getParams === void 0 ? void 0 : getParams.pageInfo) === null || _f === void 0 ? void 0 : _f.hasNextPage) ? skip + 1 : skip);
                                            }
                                        }
                                    } }, { children: (QUERYGET === null || QUERYGET === void 0 ? void 0 : QUERYGET.loading) ? (jsx(Loader, { type: "small", colorLoading: (_d = customize === null || customize === void 0 ? void 0 : customize.colors) === null || _d === void 0 ? void 0 : _d.primary, isLoading: true })) : (jsx(Wrapper$2, __assign({ alignItems: "center", justifyContent: "center" }, { children: jsxs(InputTBodyStyled, { children: [getData === null || getData === void 0 ? void 0 : getData.map(function (e, i) { return (jsx(TRStyled, __assign({ animate: {
                                                        opacity: 1,
                                                    }, initial: { opacity: 0 }, transition: {
                                                        delay: i * 0.03,
                                                        duration: 0,
                                                        ease: 'easeOut',
                                                    } }, { children: columns === null || columns === void 0 ? void 0 : columns.map(function (td, j) {
                                                        var _a;
                                                        return (jsx(TDStyled$1, __assign({}, td, { title: (_a = "".concat(td === null || td === void 0 ? void 0 : td.key, " ").concat(i + 1)) === null || _a === void 0 ? void 0 : _a.toUpperCase(), onClick: function () {
                                                                onPress(e);
                                                                setOpen(false);
                                                            } }, { children: td.view(e) }), "cell ".concat(i + 1, " ").concat(j + 1)));
                                                    }) }), "row".concat(i + 1))); }), (getData === null || getData === void 0 ? void 0 : getData.length) ? null : (jsxs(Text$2, { children: [getData === null || getData === void 0 ? void 0 : getData.length, " Resultados"] }))] }) }))) })) })) }))] })) })), ((_f = (_e = formik === null || formik === void 0 ? void 0 : formik.errors) === null || _e === void 0 ? void 0 : _e[id]) !== null && _f !== void 0 ? _f : ErrorCustom) ? (jsx(InputErrorStyled$1, __assign({}, props, { children: (_h = (_g = formik === null || formik === void 0 ? void 0 : formik.errors) === null || _g === void 0 ? void 0 : _g[id]) !== null && _h !== void 0 ? _h : ErrorCustom }))) : null] })));
};
var moveBox = {
    bottom: css$1(templateObject_11$4 || (templateObject_11$4 = __makeTemplateObject(["\n    top: 0;\n  "], ["\n    top: 0;\n  "]))),
    top: css$1(templateObject_12$4 || (templateObject_12$4 = __makeTemplateObject(["\n    bottom: 0;\n  "], ["\n    bottom: 0;\n  "]))),
};
var positionsBox = {
    bottom: 'column',
    top: 'column-reverse',
};
var templateObject_1$S, templateObject_2$E, templateObject_3$v, templateObject_4$m, templateObject_5$i, templateObject_6$d, templateObject_7$b, templateObject_8$6, templateObject_9$4, templateObject_10$4, templateObject_11$4, templateObject_12$4;

var AtomMapWrapperStyled = styled$1(motion.div)(templateObject_1$R || (templateObject_1$R = __makeTemplateObject(["\n  width: ", ";\n  height: auto;\n\n  svg {\n    width: 100%;\n    height: auto;\n\n    section {\n      width: 100%;\n      height: auto;\n      background-color: red;\n    }\n    path {\n      stroke-width: 2px;\n      transition: all 0.2s ease-in-out;\n      &:hover {\n        fill: ", ";\n        cursor: ", ";\n        transform: ", ";\n      }\n      }\n    }\n  }\n  ", ";\n"], ["\n  width: ", ";\n  height: auto;\n\n  svg {\n    width: 100%;\n    height: auto;\n\n    section {\n      width: 100%;\n      height: auto;\n      background-color: red;\n    }\n    path {\n      stroke-width: 2px;\n      transition: all 0.2s ease-in-out;\n      &:hover {\n        fill: ", ";\n        cursor: ", ";\n        transform: ", ";\n      }\n      }\n    }\n  }\n  ", ";\n"])), function (_a) {
    var width = _a.width;
    return width || "100%";
}, function (_a) {
    var hover = _a.hover, disable = _a.disable;
    return disable === false && hover;
}, function (_a) {
    var disable = _a.disable;
    return disable || "pointer";
}, function (_a) {
    var disable = _a.disable;
    return disable || "scale(1.01)";
}, function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
var ToolTip = styled$1(motion.div)(templateObject_2$D || (templateObject_2$D = __makeTemplateObject(["\n  ", ";\n"], ["\n  ", ";\n"])), function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
var templateObject_1$R, templateObject_2$D;

var Mexico = function (props) {
    var width = props.width, height = props.height, fill = props.fill, border = props.border, hover = props.hover, data = props.data;
    var _a = __read(useState({
        open: false,
        elemntId: "",
        positionX: "",
        positionY: null,
    }), 2), showData = _a[0], setShowData = _a[1];
    /* function changeColor({ elemntId }) {
      data.filter((d) => d.id === elemntId && console.log(d));
    } */
    return (jsxs(AtomMapWrapperStyled, __assign({ fill: fill, width: width, height: height, disable: showData.open, hover: hover, place: "mx", border: border, onMouseLeave: function () {
            return setShowData(__assign(__assign({}, showData), { elemntId: '', open: true, positionY: "", positionX: "" }));
        } }, { children: [!showData.open &&
                (data === null || data === void 0 ? void 0 : data.map(function (d) {
                    return d.id === (showData === null || showData === void 0 ? void 0 : showData.elemntId) && (jsx(ToolTip, __assign({ customCSS: css$1(templateObject_1$Q || (templateObject_1$Q = __makeTemplateObject(["\n                  background-color: #e0d9d9;\n                  position: absolute;\n                  border-radius: 5px;\n                  top: ", "px;\n                  left: ", "px;\n                  filter: drop-shadow(5px 5px 5px rgba(0, 0, 0, 0.25));\n                  max-width: 20%;\n                  display: flex;\n                  flex-direction: column;\n                  padding: 10px;\n                  z-index: 10;\n                "], ["\n                  background-color: #e0d9d9;\n                  position: absolute;\n                  border-radius: 5px;\n                  top: ", "px;\n                  left: ", "px;\n                  filter: drop-shadow(5px 5px 5px rgba(0, 0, 0, 0.25));\n                  max-width: 20%;\n                  display: flex;\n                  flex-direction: column;\n                  padding: 10px;\n                  z-index: 10;\n                "])), showData.positionY, showData.positionX) }, { children: jsx(Fragment$1, { children: jsx("div", { dangerouslySetInnerHTML: { __html: d.data } }) }) })));
                })), jsx(Fragment$1, { children: jsxs("svg", __assign({ version: "1.2", viewBox: "0 0 1000 631", xmlns: "http://www.w3.org/2000/svg" }, { children: [jsx("path", { d: "M901.9 362.5l0 0.2-0.2-0.1-0.3 0.1 0.3-0.2 0.2 0z m2.8 0.4l1.1 0.9 1 1.5 0.5 1.2-0.4 1.8-0.4 1-0.5 0.4-0.4-0.1-0.6-0.3-0.3-0.3 0.1-0.4-0.3-0.6 0.2-0.2 0.5-0.2 0.6-0.6 0.1-0.8-0.6-0.7-0.4-0.5-0.1-0.8-0.8-0.4-0.7-0.3-0.6 0.2-0.2 0.5-0.3-0.1 0.2-0.5 0.3-0.5 0.3-0.5 0.5-0.2 1.2 0.5z", id: "MEX99", name: "" }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Baja California" && (jsx("path", { fill: x.fill, stroke: x.stroke, 
                                // onClick={() => changeColor({ elemntId: 'Baja California' })}
                                onMouseEnter: function (event) {
                                    setShowData(__assign(__assign({}, showData), { elemntId: 'Baja California', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                }, d: "M136.4 173.3l-0.8 0-0.3-0.5-0.3 0.1-0.2-0.2 0.1-0.2 0.4-0.3 0.4 0.3 0.5 0.5 0.2 0.3z m-2.4 0l-1.8 0 0.6-0.8 1-1.4 0.6-0.8 0.5 0 0.2 0.9-0.1 0.6-0.6 0.4-0.3 0.3-0.1 0.3-0.1 0.4 0.1 0.1z m-45.5-11.3l0.1 0.2 0.3-0.1 0.4 0 0.1 0.2-0.4 0-0.1 0.3-0.4 0.1-0.3-0.3-0.1-0.2 0.1-0.2 0.3 0z m12.9 7.9l-0.2 0.3 0.2 0.6-0.2 0.5 0.3 0.6-0.1 0.2 0 0.2-0.2-0.1-0.2-0.1-0.3-0.1-0.4 0.2-0.3 0.1-0.2-0.3-0.4 0.1-0.2-0.2-0.3-1.1-0.6-0.6-0.7-0.3-0.6 0.3-0.4 0.1-0.4 0.5-0.3-0.4 0.2-1.2 0.5-0.3 1.9-2.4 1.1-1.5-0.5-1.1-0.2-1.3 0.2-1 0.2-1.1 0.5-0.4 0.6-0.3 0.7 0.6-0.1 0.7 0.4 1 0.3 0.2-0.1 0.3 0.3 0.5 0.1 0.9-0.3 0.9 0 0.8 0.5 0.7 0.1 0.8-0.2 0.7 0.2 0.4-0.3 0.4-0.4 0.2 0 0.3-0.3 0.3 0.1 0.4z m90.8-10l0.1 0.2-0.5-0.2-0.1-0.3 0.3-0.2 0.3 0.2-0.1 0.3z m-14.5-7.4l-0.4 0.2-0.2-0.2-0.1-0.2-0.2 0-0.2-0.8-0.4-0.3-0.6-0.3-0.4-0.5-0.8-0.1 0-0.3-0.2-0.2-0.1-0.2-0.3-0.3-0.3-0.3 1.1 0.3 1.7 1.2 0.5 0.5 0.2 0.2 0.2 0.3 0.4 0.2 0.2 0.3 0.2 0.2-0.3 0.3z m-4.3-3.9l0 0.2-0.3-0.1-0.4-0.2-0.3-0.1-0.1-0.2 0-0.3 0.4 0.4 0.7 0.1 0 0.2z m-1.5-1.1l-0.4-0.1 0-0.2-0.2-0.1 0.1 0 0.2 0.1 0.1 0 0.2 0.3z m12.2-0.5l0.3 0.2 0.1 0.4 0.1 0.2-0.1 0.4 0 0.5-0.2 0.5-0.6 0.2-0.7-0.2-0.3 0.1 0.1-0.2-0.4-1 0-0.8 0.4-0.1 0.2-0.1 0.7 0.1 0.4-0.2z m-13.2-3.3l0.1 0-0.1 0.2-0.1 0-0.2-0.1 0.2-0.1 0.1 0z m-1.8-2.4l-0.2 0.2 0 0.1-0.1 0-0.1-0.1 0.1 0 0.1-0.1 0.1-0.2 0-0.1 0-0.1 0.1 0.1 0.1 0.1-0.1 0.1z m-13.9-2.8l0 0.1-0.2 0 0-0.1 0-0.2 0.1 0 0.1 0.2z m-1-0.8l-0.1 0.1-0.1-0.1-0.1-0.1 0.2-0.2 0.1 0 0.1 0.2-0.1 0.1z m1.5-0.7l-0.1 0-0.1-0.2-0.1-0.2 0.2 0.1 0.1 0.3z m11.9-1.9l-0.2 0.1-0.2-0.1 0.2-0.2 0.2 0 0 0.2z m-12.9 0.9l0 0.1-0.3 0-0.2-0.1 0.1-0.2-0.3-0.3 0.1-0.2 0-0.1-0.1 0 0-0.3 0-0.2-0.2-0.1-0.1-0.3-0.1-0.2 0.2-0.1 0.3 0 0.2 0.1 0 0.2-0.1 0.1 0 0.2 0.1 0.1 0 0.2-0.1 0.3 0.2 0.2 0 0.2 0.1 0.1 0 0.2 0.2 0.1z m-149.2 4.5l-0.8 1.1-0.6-0.1-0.4 0.3-0.2 0 0 0.4-0.3-0.3 0.1-0.4 0.4-0.2-0.3-0.8-0.2-0.6 0.2-0.6-0.2-0.7-0.5-0.5 0.3-0.6-0.3-1-0.3-0.5-0.3-0.4-0.7-0.6-0.1-0.6-0.1-0.5-0.2-0.6 0.1-0.6 0.3-0.7 0.6-0.5 0.9-0.3 0.4-0.5 0.7-0.1 0.6 0.3-0.5 0.6-0.4 0.5-0.1 0.5 0.2 0.7 0.4 0.7 0.5 0.3 0.7 1 0.3 1.7-0.3 0.7 0.2 1.3-0.1 1.6z m149-22.4l0.7 0.1 0.4 0.5 1 0.9 0.4 1 0.7 0.2 0.1 0.3 0.3 0.3-0.1 0.3 0.4 0.5 0.4 0.7-0.1 0.3 0.5 0.4-0.4 0.3-0.4 0.5-0.1 0.6 0.2 0.3 0 0.9 0.8 0.6 1.2 0.2 0.3 0.3 0.4 0 0.3-0.3 0.4 0 0.2 0.1 0.6-0.1 0.5 0 0.5 0.1 0.7-0.1 0.5 0.5-0.3 0.6 0 0.8 0.2 0.4 0 0.7 0 0.4 0.2 0.2-0.2 0.4-0.1 0.8 0 1 0.1 0.3 0.4 0.7 0.1 0.3-0.1 0.3 0.3 0.6 0.3 0.1 0.5 0.2 0.2 0.1 0.5 0.1-0.5 1 0.1 0.4 0 1.1-0.3-0.1-0.4-0.5-0.3-0.1-0.4-0.5-1-0.4-0.3-0.7-0.5-0.3-0.4-0.1-0.5-0.4-0.2-0.4-0.2-0.2-0.2-0.6-0.4-0.5-0.5-0.6-0.3-0.4-0.4 0-0.2-0.4-0.5-0.2-0.6-0.3-0.2-0.6-0.8-0.4-0.6-0.5-0.8-1.1 0.1-0.4-0.2-0.5-0.5-0.5-1 0.1-0.4-0.3-0.3-0.4 0-0.7-0.2-0.4-0.4-0.2-0.3-0.6-0.2-0.2-0.1-0.4-0.5-0.4-0.1-0.3-0.3-0.4-0.6-0.5-0.1-0.8 0.2-0.9 0.4-0.8 0.3-1-0.1-0.6-0.1-0.6 0.4-0.1 0 0.2 0.3 0.2 0.4-0.2 0.4-0.2 0-0.2 0.4 0 0 0.4 0.4 0.1z m-2.1-0.7l-0.3 0.2-0.2-0.4 0.4-0.2 0.2 0.2-0.1 0.2z m-26.2-14.7l-0.3 0-0.5-0.3 0.2-0.3-0.1-0.4 0.5 0 0.1 0.6 0.1 0.4z m-4.6-4.8l0.2 0.1 0 0.2-0.1 0-0.1-0.2-0.2-0.1-0.1 0-0.1-0.1 0.4 0.1z m-49.2-14.3l-0.4 0-0.2-0.1 0-0.2 0.2-0.2 0.2 0 0.2 0.3 0 0.2z m-35.8-70.5l-0.1 0-0.1-0.4-0.1-0.3-0.1-0.1-0.1-0.4 0.2 0.1 0.1 0.2 0.1 0.3 0.1 0.3 0 0.3z m72.7 17.9l-0.8-0.3-0.3-0.2-0.4 0-0.4-0.1-0.4-0.4-0.2 0-0.1-0.2-0.1-0.5-0.1-0.4-0.3-0.2-0.1 0.2 0 0.4 0.1 0.5 0.5 0.8 0.1 0.2 0.3 0.2 0.2 0.1 0.9 0.2 0.5 0.2 0.5 0.4 0.4 0.4 0.3 0.5 0.8 0.2 0.6 0.6 0.4 0.6 0.2 0.6 0.5 0.2 0.2 0.4 0.4 2.6 0.2 0.8 0.5 0.7 0.4 0.9-0.3 0.7-1.1 1.3-0.5 1.3-0.4 1.5 0 5-0.7 2.3 0.1 2.1-0.4 3.3-0.1 0.7 0.1 1.6 0.7 1.1 0.8 0.8 0.7 0.7 0 0.2-0.6 0.6 0 0.8 0.4 0.6 0.6 0.5 2.1 1 0.5 0.3 0.1 0.2 0.1 0.2 0.1 0.4 0 1.2 0.1 0.4 0.1 0.6-0.2 0.5 0.2 0.4 0.2 0.5-0.1 1.7 0.2 0.5 0.2 0.6-0.2 0.3-0.4 0.9 0.3 0.9 0.2 0.6-0.2 1.2 0.4 1.1 0.7 1.2 0.4 0.8 0 0.3 0.1 0.4 0 0.4 0.2 0.4 0.3 0.6 0 0.6-0.2 0.6 0 0.8 0.2 0.6-0.1 1-0.2 0.8 0.2 0.4-0.3 1.9-0.3 0.6 0 0.3 0.1 0.4 0.3 0.5-0.1 0.5-0.3 0.8-0.1 0.5-0.3 0.5 0.2 0.6 0.2 0.3 0.3 0.8 0.4 0.3 0 0.5 0.2 0.5 0.6 0.3 0.3 0.7 0.5 0.7 0 0.7 0.7 1.3 0.4 0.9 0.4 0.9 1.6 0.7 0.3 1.1 0.4 0.3 1 0.1 0.3 0.6 0.3 0.3-0.2 1 0.4 0.8 0.2 0.2-0.2 0-0.2 0.2 0 0.2 0.3 0.2 0.1 0.2 0 0.3 0.1 0.5 0.4 0.3 0.3 0.2 0.2-0.1 0.3 0.1 0.3 0.4 0 0.2 0.2 0.3 0.5 0.1 0.6 0 0.2 0 0.3-0.2 0-0.2 0.1-0.1-0.2-0.1-0.1-0.1 0-0.2 0.3 0 0.1-0.1 0-0.1 0.1 0.1 0.2 0 0-0.1 0.2 0.1 0.1 0.2 0.1-0.1 0.1 0.2 0.1 0 0.3-0.1 0.2 0.2 0.3 0.3 0.2 0 0 0.1 0.4 0.1 0.2 0.2 0.1 0.4 0.1 0.2 0.2 0.1 0.1 0.2 0.1 0 0.1 0.2 0.2 0.1 0.3 0.2 0.1 0.3 0.1 0.1 0.2-0.2 0.3 0.1 0 0.3 0.3 0.3 0 0.2 0.2 0 0.2 0.3 0.2 0.2 0.1 0.1 0.4 0.2 0.2 0.2 0.3 0.1 0.6 0.4 0.1 0.4 0.1 0.2 0.2 0.3 0.1 0.3 0.5 0 0 0.1 0.1 0.2 0.2 0.1 0 0.1 0.2 0.1 0.3 0.1 0.4 0 0.4 0.3 0.2 0.4 0.3 0.4 0.2 0.2 0.2 0.1 0.3 0.5 0.4 0.1 0.2 0.3 0.4 0.4 0.4 0.6 0.6 0.3 0.4 0.5 0.5 0.2 0.4 0 0.2 0.3 0 0.5 0.2 0.2 0.4 0.1 0.3 0.1 0.2 0.3 0.3 0.1 0.5 0.2 2.8 3.3 1.1 0.8 0.3 0.4 0.2 0.7 0.2 0.2 0.1 0.2-0.5 0.5-0.3 0.4-0.3 0.4 0 0.4 0.3 0.1 0.3 0.2-0.1 0.5 0.3 0.4 0.1-0.1 0.1 0.2 0 0.3 0.3 0 0.2-0.1 0 0.4 0.2 0.5 0.4 0.4 0.3 0.1 0.3 0.4 0.2 0.8 0.5 1 0.4 0.5-0.1 0.4-0.3 0-0.2 0.4-0.2 0.2-0.1 0.3 0.1 0.5 0.4 0.3 0.1 0.6 0 0.6-0.3 0.2-0.1 0.2 0.4 0.5 0.4 1 0.2 0.2 0.1 0.3 0.6 0.1 0.7-0.1 0.2-0.2-0.1-0.1 0.2-0.5-0.3-0.2-0.2-0.4 0.2-0.1 0-0.2 0.1-0.2 0.2-0.1 0.3 0.1 0.4 0.1 0.3-0.3 0.2-0.3 0.3 0.4-0.1 0.5 0.5 0.4 0.2-0.1 0-0.2 0.6-0.3 0.1 0.2-0.1 0.1-0.1 0.1-0.1 0.6 0.8 0.2 0 0.2-0.4 0 0 0.3 0.3 0.2 0.1 0.3 0.3 0.2-0.2 0.2-0.1 0.3 0 0.5-0.1 0.3 0.2 0.5 0.4 0.2-0.1 0.6 0.7 0 0.7 0 0.6-0.6 0.2-0.3 0.5-0.2 0.3-0.3 0.8 0.2 0.5 0.3 0.1 0.3 0.1 0.5 0.3 0.2 0.2 0.2-0.1 0.5 0.3 0.2 0 0.5-0.1 0.6 0.4 1 0.2 0.1 0.1 0.7 0.5 1.3 0.7 0.5 0.2 0.5-0.2 0.9 0.4 0.9 0.1 0.5 0.2 0.7-0.1 0.6 0.3 0.9 0.7 0.4 0 0.2 0.6 0.3 0.7 0.1 0.2 0.3 1 0.4 1 0 1.3-0.4 0.9-0.3 0.5 0.4 0 0.3 0.3 0.2 0 0.2-0.2 0.3 0.1 0.1 0.4 0.1 0.1-0.1 0.2-0.3 0.3 0 0 0.4 0.1 0.3-0.2 0.2-0.2 0.5 0.1 0.2 0.1 0.5-0.1 0.5-0.5 1.4-0.1 0.8 0.1 0.3-0.1 0.6 0.2 0.4 0.4 0.4 0.5 0.3 0 0.3 1 1.2 0.2 0.2 0.3 0.1 0.1 0.2-0.2 0.2-0.1 0.2-0.1 0.6-0.1 0.2-0.1 0.4-0.2 1.1 0.4 1.3 0 0.1 0.3 0.1 0 0.4-0.2 0.4-0.2 0.4-0.1 0.5 0.2 0.5 0.4 0.5 0.6 0 0.1 0.1-5.4 0-5.6 0-5.7 0-5.7 0-11.3 0-5.7 0-1.5 0 0.2-0.2 0.5-0.8 0.1-0.3-0.3 0-0.3-0.2-0.4-0.4-0.5-0.1-0.5 0.1 0-0.6 0-1-0.2-0.5-0.2-0.3 0.2-0.5 0.5-0.8 0.4-0.7 0.3-0.6 0.4-0.5-0.2-0.2-0.1-0.4-0.1-0.5-0.3-0.3-0.3 0-0.3 0.3-0.4-0.1-0.2-0.3-0.3-0.2 0.5-1.1 0.4-0.8 0.5-1.2 0.7-2.3 0.3-1 0.2-0.9-0.2-0.6-0.4-0.1-0.3-0.3 0.1-0.6 0-0.5-0.3-0.2-0.1-0.3-0.1-0.4-0.4-0.3-0.4-0.4-0.5 0-0.7 0-0.4-0.2 0.1-0.5 0.1-0.7-0.1-0.9-0.2-0.8-0.3-0.3-0.3-0.2-0.8 0-0.8 0.1-0.4 0.2-0.8-0.2 0-0.5 0.1-0.1-0.2-0.7-0.7-0.3-0.5-0.8-1.1-0.2 0-0.6 0-0.6-0.4-0.5 0-0.6-0.3-0.6-0.7 0.2-0.5-1.2 0.2-0.7-0.5-0.7-0.6 0.1-0.1-0.7-0.6-0.5-0.5-0.7-0.8-0.1-0.5 0.1-0.2 0.1-0.2 0-0.4-0.3-0.2-0.6-0.3-0.7-0.1-0.4-0.4 0.1-0.6 0.5-0.3-1.2 0-1.2-0.2-0.5-0.3-0.6-0.2-0.7-0.2-0.5-0.9-0.3-0.9-0.3-0.5 0.6-0.6-0.8-0.2-0.9-0.2-0.3-0.1-0.9-0.2-0.4-0.2-0.2-1.1-0.1-1.4-1.3-0.7-1-0.8-1-1.5-1.6-1.5-1.7-4.1-1.5-2.6-0.3-1.5-2.3-1.6-1.4-2.7-1-1.7-1.4-0.9-0.9-0.8-0.2-0.6 0.5-0.7-0.5-0.5-0.3-0.4-0.7-0.8-0.6-0.6-0.8-0.9-0.1-2.4-2.2 0.1-0.8 0.2-0.9 0.1-1-0.3-1.4-0.2-1.1-0.7-0.8-0.2-0.5-0.5-0.5-0.6-0.2-1.4-0.1-0.1-0.4 0.7-2.6 0.2-2-0.2-1.1-0.1-0.2-0.3-0.5-0.1-0.3 0.1-0.4 0.1-1.2 0-1.7-0.3-1.6-0.6-1.2-0.3-1-0.9-0.8-1-0.7-1.1-0.5-1.4 0 0.9-0.8 0.3-0.5 0.1-0.5-0.2-0.5-0.4-0.6-0.6-0.5-0.5-0.2 0.3 0.6 0.3 0.4 0.2 0.5 0.1 0.6-0.4 0.3-0.3 0-0.2-0.3-0.4-0.3-0.3 0.2-0.1 0.3 0 0.4 0.3 0.1 0.3 0.4 0.1 0.8 0.4 1.1-0.8 0-0.2-1.2-0.6-1.8-0.6-1.4 0.6-5.4-0.2-3.8-0.6-1.9-0.1-0.7-0.3-0.4-1.2-0.2-1.4-1.5-0.8-0.1-0.8-1.1-0.5-0.8-0.3-0.5-0.7-1.1-0.6-0.3-1.2 0.4-0.9-0.1-0.2-1.2 0.5-1.4 0.2-2.3 0.3-2.2-1-2.6-3.6-4.4-1.3-2.5-0.4-0.5-0.2-0.1-0.5-0.6-0.2-0.3-0.5-0.2-0.6-0.5-0.4-0.2-0.3-0.2-0.1-0.2-0.1-0.3-0.2-0.4-1.2-1-0.2-0.3-0.7-0.6-0.2-0.5 0.1-0.4 0.3-0.1 0.7 0-0.6-0.8 0.1-0.6 0.2-0.5 0.2-1-0.2-0.7-0.4-0.7-0.2-0.2-0.5-0.3-0.8-0.1-0.8-1-0.3-0.5 1.3 0.3 1 0.7 0.5 0.1 0.6-0.4 0.4-0.7 0.3-0.7 0.2-1.1 0.1-0.8 0-0.7-0.3-0.6-1.2-0.2-0.6-0.2-0.5-0.8-0.8-0.4-0.5-0.1-0.6-0.2-0.1-1 0-1.1-0.4-0.5-1.1 0-1.2-0.3-0.7-1-0.3-0.8-0.1-1.3-0.3-2.3-0.6-1.7-0.5-1.6-0.4-0.5-0.4-0.5-0.6-0.3-1.4-0.4-0.5-0.4-1.5-3.5-0.5-1.3-0.5-1.2-0.4-0.6-0.1-0.7-0.1-0.7 0-0.8 0-0.4 0-0.3 2.5-0.2 7-0.7 6.9-0.6 2.4-0.2 6.9-0.6 2.3-0.2 2.4-0.2 2.3-0.2 2.3-0.2 11.6-1.1 2.3-0.2 4.6-0.4 2.3-0.2 2.4-0.2 2.3-0.2 2.3-0.2 7-0.7 2.3-0.2 2.3-0.2 1.3-0.1 0 0.1-0.3 0.9-0.2 0.6-0.4 0.7-0.2 0.2-0.8 0.7-0.1 0.2-0.5 1 0.3 0.8-0.1 0.8-0.4 1.5-0.4 0.5 0.1 0-0.5 0.3-0.6 0.1-1.7-0.1-0.6 0.3-0.6 0.8-0.5 0.9-0.2 0.8-0.1 0.7 0 0.6 0 0.7-0.4 0.8-0.5 0.7-0.7 0.5-0.5 0.6-0.1 0.6 0.2 0.2 0.8 1.1 0.8 1.1 0.5 1.2 0.4 1.4-0.1 0.8-0.7 1.2 0 0.6 0.2 0.1 0.5 0.4 0.2 0.1 0.3 0.5 0.2 0.4 0 0.5 0.1 0.5-0.1 1 0 0.9 0 0.9 0.1 0.8z", id: "MEX2706", name: "Baja California" }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Baja California Sur" && (jsx("path", { 
                                /*  onClick={() => changeColor({ elemntId: 'Baja California Sur' })} */
                                fill: x.fill, stroke: x.stroke, onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Baja California Sur', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                }, d: "M271.1 308.4l-0.2 0.6-0.3-0.1-0.5-0.1-1-0.2-0.4-0.1 0.1-0.3-0.4-0.6-0.5-0.8-0.4-1.2-0.4-1.1 0.1-0.3 0.2-0.3-0.7-1.4 0.1-1.2 0-0.5 0.2 0 0.3 0.4 0 0.5 0.4 0.4 0.2 0.4 0.2 0.3 0.3 0.7 0.4 0.8 0.4 0.5 0.5 1 0.2 0.2 0.4 0.5 0.5 0.9 0 0.4 0.3 0.6z m-55.6-7.8l0.7 0.2 1 0.3 1.3 1 0.1 0.2-2.2-1-0.9-0.1-1.1-0.1-1.3 0.3-0.8 0.2-0.3-0.3 0.3-0.3 0.2-0.3 0.4 0.2 0.5-0.1 0.9-0.1 0.5 0 0.7-0.1z m-12.9-4.8l0.4 0 1.7 0 0.8 0 0.5-0.1 0.4 0.4 0.4-0.1 0 0.4 0.2 0.5 0.3 0.2 0.1 0.4 0.7 0.2 0.7 0 0.7 0.6 0.9 1.7 0.6 0.6 0.3-0.1 0.1 0.3-0.2 0.5 0.2 0.4-0.3 0.6-0.3 0.4 0.1 0.7-1-1.4-0.6-0.6-1.5-1.1-1.2-1-0.8-0.8-1.2-0.6-0.2-0.3-0.4-0.1-0.4-0.5-1.1-0.5-0.8-0.3-0.2-0.3 0.6-0.4 0.5 0.3z m50.8-1l-0.1 0.5 0.5 0.1 0.7 0.5 0.3 0.4 0.3 0 0.1 0.5 0.2 0.4 0.3 0.3-0.2 0.4-0.4 0-0.2 0.4 0.1 0.5-0.3 0.2-0.1 0.3-0.2 0.6-0.6-0.1-0.1-0.3-0.1-0.2 0.1-0.4-0.2-0.2-0.2-0.1-0.2 0.3-0.1-0.4-0.1-0.2 0.5-0.2 0-0.2-0.2-0.1-0.1-0.1-0.3-0.2-0.2-0.2-0.1-0.3-0.1-0.5 0.1-0.3-0.3-0.2 0.1-0.2 0.4-0.2 0.2-0.2-0.3 0-0.3-0.2 0-0.4-0.3 0.1-0.1-0.3 0.1-0.2-0.3-0.1-0.1-0.3 0.5-0.4 0.1-0.3 0.4 0.1 0.1 0.4 0.2 0.3 0.4 0.3 0.1 0.4z m-6.5-9.7l0.1 0.2 0 0.2-0.2 0 0-0.3-0.2 0-0.2 0.1-0.2-0.3 0.1-0.1 0.5-0.4 0.1 0.1-0.1 0.4 0.1 0.1z m-0.9-7.2l0.1 0.2 0.2 0.2 0.3 0.2 0 0.3 0.2 0.3 0.1 0.6-0.1 0.9 0.3 0.7 0.2 0.3 0.2 0.5 0.4 0.8 0.3 0.3-0.3 0.2-0.6 0.1-0.3-0.1-0.3 0.1-0.2 0.3-0.2-0.1 0.4-0.4 0-0.3-0.4-0.2-0.3-0.3-0.5-0.2 0-0.2-0.3-0.1-0.7 0 0-0.2 0.2-0.2-0.3-0.5-0.3-0.2-0.2-0.5 0-0.3-0.1-0.3-0.3-0.3-0.1-0.8-0.2-0.3-0.4 0-0.3-0.4-0.2 0-0.1-0.3 0-0.5 0.1-0.3 0-0.5 0-0.7 0.1-0.2 0.1-0.1 0.1 0.1 0.2 0.3 0.4 1 0.5 0.4 0.8 0.1 0.9 0.3 0.6 0.3z m-3.3-5.7l-0.1 0.1 0-0.2 0.2-0.2 0 0.2-0.1 0.1z m-46.1 7.3l0 0.4-0.3 0.2-0.2-0.2-0.3 0.5 0 0.3 0 1.1-0.3 0.2 0.2 0.9 0.2 0.3 0.2 0.3-0.1 0.2-0.4 0-0.3 0-0.2 0.4-0.1 0.3 0.1 0.3 0 0.5 0.1 0.2 0.3 0.2 0.3 0.2 0.3 0.4 0.2 0 0 0.1-0.2 0 0.1 0.1 0.3 0.5 0.1 0.5 0.7 0.8 0.3 0.3 0 0.4 0 0.2 0.1 0.2 0.1-0.1 0.3 0.7-0.4 0.5-0.1 0.2-0.3 0.3-0.1 0.3 0.1 0.2 0.1 0.4 1 0.6 0.3 0.3 0.5 0.8 0.3 0 0 0.4 0.2 0.2 0.2 0.5-0.1 0.4-0.2-0.1-0.8-0.3-0.3-0.2 0.1-0.2-0.2-0.7-0.3-0.5-0.4-0.5-0.3-0.2-0.3 0-0.4-0.8-0.4-0.2-0.1-0.2 0.2-0.3 0.1-0.3 0.2-0.1 0.2 0.1 0.2 0 0.2-0.3 0.1-0.6-0.1-0.6-0.2-0.6-0.3-0.4-0.6-0.7-0.5-0.4-0.5-0.3-0.2-0.1-0.4-0.1-0.4 0-0.2 0-0.2 0-0.2 0.2-0.1 0.2 0 0.3 0.1 0.6-0.1 0.1-0.3-0.3-0.1-0.6-1-0.6 0.1-0.4 0-0.1 0.1-0.1 0.3-0.1 0.4-1 0.6-1.5 1.6-4.7 0.5-1.5 0.9-3.3 0.6-2.5 0-0.9 0.2-0.4 0.4 0 0.1 1.6-0.2 0.6-0.5 1.4-0.4 0.8-0.4 2.3-0.3 1 0.2 0.5 0.1 0.4 0 0.4 0.1 0.4 0.1 0.3z m45.7-9.6l-0.2 0.1-0.3 0-0.1-0.2-0.1-0.4 0-0.4 0.6-0.6 0.3 0 0.3 0 0.2-0.2 0 0.1-0.1 0.2-0.3 0.5-0.2 0.6-0.1 0.3z m-44.3-0.7l-0.2 0-0.2-0.2-0.2-0.3 0.1-0.5 0.3-0.6 0.2-1.1 0.1-1.5 0.3-1.4 0.1-0.6-0.1-0.8 0.1-0.2 0.1 0.1 0 0.5 0 0.6 0 0.8-0.1 0.7-0.2 0.7 0 1 0.1 0.7 0 0.6-0.3 0.4-0.1 0.5 0 0.6z m43-11l-0.4 0.1-0.6-0.3-0.6-1.4 0-1.1 0.4-0.7 0.3-0.5 0.3-0.1 0.1 0.6 0.2 0.1-0.1 0.6 0.2 1 0.2 1.7z m-8.9-4.1l0.1 0.4 0.4 0.3 0.2 0.6-0.1 0.3-0.2 0.3-0.2 0.3-0.2 0-0.3-0.4-0.1-0.2 0.1-0.4-0.3-0.5-0.1-0.2-0.1-0.3 0.6 0.1 0-0.2 0.2-0.1z m-6.5-1.8l-0.1 0-0.3-0.2-0.1-0.3 0-0.7-0.1-0.3 0.1-0.1 0.1 0 0 0.4 0.2 0.1-0.1 0.1 0.2 0.3-0.1 0.1 0 0.3 0.2 0.1 0 0.2z m5.8-10.7l-0.4 0.6-0.4 0.9 0.1 1.1 0.3 0 0 0.4 0.2 0.1 0 0.4-0.1 0.2-0.2-0.2-0.2 0-0.2-0.3-0.2-0.2-0.3-0.4-0.3 0-0.2 0.2 0 0.2-0.1 0.4-0.3 0.5-0.3 0.3-0.4 0.7-0.6 0.7-0.3 0.3 0.1 0.2-0.2 0.6 0.1 0.5-0.2 0.3-0.3 0.1-0.2 0.3 0 0.7 0.1 0.6-0.1 0.2-0.3-0.4-0.2-0.1-0.3-0.2 0-0.3-0.1-0.4 0-0.3 0.4-0.7 0-0.4 0.3-1.2 0-0.4 0.3-0.5 0.1-0.4 0.3-0.5 0.4-0.3 0.2-0.3-0.1-0.6 0.1-0.7-0.2-0.4 0-0.3 0.4-0.1 0.9-0.2-0.1-0.4 0.3-0.2 0.2 0.3 0.6 0.2 0.7-0.2 0.2-0.3 0.5-0.1z m-7-1.2l-0.2 0.1 0.2-0.3 0-0.1-0.2-0.2 0-0.2 0.3-0.4 0.3 0 0.1 0.1 0.1 0.3-0.1 0.3-0.1 0.1 0.1 0.1 0 0.2-0.5 0z m-4.6-18.3l-0.1 0.1-0.1-0.3-0.1-0.1 0-0.3 0.2 0.2 0.1 0.2 0 0.2z m-56-3.2l0.2 0.1 0.3-0.3 0.2 0 0.2 0.1 0.4 0.5 0.5 0.7 0.2 0.5 0 0.2-0.2 0-0.3-0.2-0.3-0.2-0.9-0.4-0.9-0.3-0.8-0.2-0.3-0.1-0.2-0.1 0.2-0.4 0.4-0.2 0.5-0.3 0.3 0.1 0.3 0.1 0.2 0.2 0 0.2z m36.3-16.9l-0.5 0.5-0.6-0.1-0.3-1.5-0.4-0.4 0.6-0.8 0.8 0.6 0.6 0.9-0.2 0.8z m6-8.4l-0.6 0.1-0.4 0-0.4-0.3 0.1-0.5 0.7-0.1 0.5 0.2 0.2 0.3-0.1 0.3z m-104.1-15l-0.3 0.1-0.2 0-0.1-0.7-0.3-0.4-0.5-0.2-0.4-0.1 0.1-0.3 0.4 0.2 0.3 0 0.3 0.3 0.5 0.3 0.2 0.2 0.1 0.3-0.1 0.3z m30.2-5.3l1.8 0 0.3 0.4 0.3 0.6 0 0.4 0.7 1.2 0.4-1.1 0.1-0.6-0.1-0.7-0.1-0.2 0.8 0 0.1 0.2 0.2-0.2 1.5 0 5.7 0 11.3 0 5.7 0 5.7 0 5.6 0 5.4 0 0.1 0.1 0 0.5 0.2 0.6-0.1 0.1-0.2 0.9 0.1 0.7 0 0.4 0 0.2 0 0.3-0.2 0.1 0 0.4-0.2 0.6 0.5 0.6 0.5 0.3 0.1 0.3 0.4 0.3 0.1-0.2 0.1 0 0 0.3 0.2 0.4-0.1 0.2 0.1 0.6 0.3 0.3-0.1 0.3 0.1 0.5 0.4 0.4 0.4 0.5 0.3 0.4 0.2 0.1 0.2 0.2 0.3-0.1 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.3 0 0.3 0.7 0.4 0.1 0.5 0.9 0.4 0.8 0 0.5 0.2 0.4 0.3 0.5 0.1 0.4 0.2 0.2 0.2 0.4 0.3 0.3 0.3 1.2 0.2 0.5 0.4 0.9 0.6 0.6 0.6 0.1 0.4 0.6 0.7 0.3 0.7 0.2 1.3-0.1 0.5 0.4 0.8 0.3 0.6-0.1 0.4 0.1 0.5 0.4 0.5 0.5 0.3 0.1 0.6 0.3 0.4 0.5 0.1 0.2 0.4 0.2 0.9 0.3 0.2 0.4 0.8 0.3 0.4-0.2 0.7-0.1 0.2-0.2 0.2 0 0.3 0.6 0.4 0.4 0.5 0.4 0.4 0.1 0.3 0.3 0.1 0.7 0.1 0.6 0.6 0.8 0.4 0.7-0.1 0.1 0.2 0.3 0.2 1.4 0.2 0.5 0.8 1.1 0 0.3 0.1-0.1 0.3 0.2 0.2 0.1 0.3-0.5 0.2-0.4-0.1-0.5 0.4-0.5 0.7-0.3 0.8-0.1 0.5 0 0.7 0.5 1 0.5 0.4 0.3 0.1 0.1 0.3 0.5 0.6 0.1 0.7 0.3 0.2 0.9 0.3 0.1 0.7 1.3 1.1 0.2 0.8 0.1 0.5 0 0.2-0.4 0.3-0.1 0.3 0 0.4-0.4-0.2-0.5 1 0.2 0.7 0.4 0.1 0.7 0.6 0.3 0.6 0.2 0.5 0 0.3 0.2 0.3 0.5 0.2 0.4 0.4 0.5 0.6 0.4 1.4 0.7 0.6 0.8 0.5 0.7-0.4 1.2-1.1-0.1-0.4-0.4-0.3-0.7-0.9-0.9-0.9-0.4-0.2-0.3-0.6-0.9-0.5-0.4-0.9-0.2 0.1-0.1-0.3 0.1-0.3-0.1-0.3 0-1-0.2-0.4 0-0.5-0.2-0.5 0.2-0.5-0.3-0.3-0.2-0.2 0.1-0.3-0.2-0.2-0.1-0.3 0-0.3-0.2-0.3 0-0.2 0.5-0.1 0.3-0.2 0.2-0.3 0.8 0.5 0.1 0.3 0.7 0.4 0.7 0.7 0.5 0.8 0.3 0.5 1.3 1 0.4-0.1 0.1 0.5 0.2 0.3 0.3 0.2 0 0.2 0.7 0.3 0.1 0.2 0.5 0.2-0.1 0.2 0.8 0.4 0.4 0.1 0.1 0.3 0.3 0.1-0.2 0.9 0 0.8 0.1 0.8-0.2 1.7 0.1 0.7 0.5 0.3 0.8 0.3 0.7 0.3 0.6 0.1 0.3-0.1 0-0.1 0.4-0.1 0 0.3 0.2 0.2 0.4 0.2-0.2 0.1-0.2 0.3 0 0.7-0.4 0.7 0 0.9-0.1 0.8 0.3 0.7 0.7 0.5 0.3 0.1 0.2 0.2 0 0.2-0.3 0.1 0 0.2 0.3 0.4 0.5 0.2 0.4 0.5 0.2 0.6 0.1 0.5 0.1 0.8-0.4 0-0.1 0.9 0.3 0.3 0 0.3 0.4 0.8-0.1 0.4 0.1 0.6 0.3 0.2 0.2 0.5 0 0.7 0.3 0.6 0.3 0.5 0.6 0.5-0.1 0.4 0.2 0.4 0 0.4-0.2 0.1-0.1 0.4-0.4 0.4-0.1 0.3 0.2 0.6 0 0.8-0.3 0.5-0.4 0.4 0.1 0.7 0.2 0.6 0.3 0.6 0.1 0.3 0.1 0.6-0.2 0.4 0.2 0.2 0.1 1 0.2 0.2 0.2 0 0.1-0.1 0.2 0.1 0.3 0.4 0 0.2 0.2 0.1-0.1 0.2-0.2 0-0.1-0.2 0-0.2-0.3-0.1 0 0.2 0.1 0.5 0.1 0.4 0 0.4 0.2 0.2 0.4 0.3 0.4 0.5 0.4 0.1 0.3 0.2 0.2 0.3 0.1 0.3 0.3 0.1 0.1-0.1 0.2 0 0.4 0.8-0.1 0.2 0.1 0.4 0.2 0.5 0.2 0.5 0 0.6 0.1 0.3 0.2 0.5 0.2 0.4 0.4 0.3 0.3 0.8 0.4 0.1 0.1 0.1 0.1 0.3 0.2 0.5 0.3 0.1 0.1 0.4 0.3 0.1 0.4 0 0.1-0.1 0.1 0.1 0.6 0.1 0.2-0.3 0.1 0.1-0.2 0.3 0.1 0.1 0.2 0.1 0.2-0.2 0.1 0 0.2 0.2 0.2 0 0.1-0.2 0.1 0 0.1 0.1 0.4 0.1 0.2 0.3-0.3 0.3 0.3 0.5 0 0.2-0.2 0.2 0 0.4-0.2 0.1 0 0.4 0.2 0.2 0.2 0.6 0.3 0.2 0.1 0.9 0.1 0.3 0.5 0.8 0.1 0.6 0.2 0.3 0.5 0.2 0 0.2 0.3 0.3 0.1 0.2-0.1 0.1 0 0.3 0.2 0.1 0.2 0.1-0.1 0.1 0 0.2 0.1 0.2-0.1 0.1-0.2 0-0.1 0.4 0 0.3 0.3 0.3-0.1 0.4 0.3 0.7 0.3 0.1 0.2 0.7 0.2 0.2 0.1 0.1-0.2 0.2 0 0.6 0.2 0.6 0.4 0.4 0.4 0.2 0.2 0.2 0 0.2 0 0.1 0.2 0.2 0 0.2 0.1 0.2 0.1 0.5 0.4 0.2 0.1 0.2 0.5 0.1 0.2 0.2-0.1 0.4 0.1 0.2 0.3 0.3 0.4 0.1 0.2 0 0-0.1 0.1-0.1 0.2 0.1 0.2 0.2 0.7 0.5-0.1 0.2 0.1 0.1-0.1 0.3 0.3 0.1 0 0.2 0 0.5 0.1 0.3 0.4 0.4 0.2 0.4 0.3 0.4 0 0.2 0.2 0.1 0.2 0 0.2 0.2 0 0.1-0.2 0-0.1 0.1 0.1 0.1 0 0.2 0.5 0.3 0 0.2 0.2 0.1-0.1 0.1 0 0.2 0.1 0.3 0 0.3 0.1 0.3 0.2 0.2 0 0.5 0.2 0.2 0.1 0.2 0 0.2 0.1 0.1 0.1 0 0 0.1-0.1 0.2 0 0.3 0 0.1-0.1 0.5 0 0.3-0.5 0.6-0.2 0.6-0.1 0.4 0 0.3-0.1 0.4-0.5 0.1-0.5 0.5-0.1 0.7-0.2 0.8-0.2 0.6 0.1 0.7-0.1 0.5 0.2 0.9-0.1 0.2 0.1 0.4 0.2 0.7 0 0.3 0.2 0.4 1.1 1.3 0.1 0.8-0.3 0.3 0 0.4 0.1 0.2-0.1 0.3 0.2 0.4 0.2 0.2-0.1 0.3 0.2 0.3-0.2 0.4 0.9 1.1 0 0.2 0.5 0.3-0.1 0.2 0.4 0.9 0.5 0.5 0.1 0.5 0.4 0.3 0.5 0.2 0.2 0.5 0.3 0.2 0.1 0.3 0.7 0.3 0.9 0.3 0.8 0.1 1.1 0.3 1.6 0.3 2.2-0.1 0.2 0-0.1 0.3-0.3 0.3-0.5 0.2-0.5 0.1-1.1-0.6-0.9-0.2 0 0.2 0.2 0.3-0.1 0.5 0.3 0.3 0.1 0.3-0.2 0.3 0.2 0.4 0.8 0 0.7-0.2 0.3 0.1 0.3-0.1 0.1-0.7 0-0.2 0.1-0.1 0.6-0.5 0.6-0.7 0.2-1.4-0.4 0 0.1-0.7-0.3-0.1-0.2-0.2 0.1-0.1 0-0.2 0-0.4-0.2 0-0.1 0.3-0.2 0.1 0-0.7 0.1-0.2-0.1-0.2 0.1-0.3-0.1-0.2 0-0.3-0.1-0.2 0.5 0 0.1-0.2-0.2-0.1-0.1-0.1 0.2-0.3 0.5-0.1 0.2-0.2 0.2-0.3 0.6 0.1 0.9 0.2 0.1-0.2 0.4 0.3 0.1 0.2-0.2 0.1 0 0.4 0.2 0.3 0.3 0.1 0.3 0.3 0.3 0.2 0.3 0.2 0.2 0.4 0 0.3 0.3 0.3 0.1 0.3 0.8 0.2 0.4 0.3 0.3 0.3 0.2 0.1 0.6 0.3 0.4 0.1 0.1 0.1 0.2 0.1 0.1 0.3 0.4 0.1 0.1 0.2 0.4 0.2 0.9 0.6 0.3 0.3 0.2 0.8 0.1 0.3 0 0.4 0.1 0.2 0.2 1.5 0 0.7 0.5 0.3 0.6 0 0.7 0.3 1.3-0.3 1.2-0.4 0.5-0.4 0.2-0.1 0.1 0.6 0.2 0.3 0.3 0.2 0.2 0.4 0 0.2-0.2 0.2 0 0.3-0.4 0.4-0.2 0-0.1 0.1 0 0.3-0.2 0.9 0.1 0.5 0.2 0.6 0.2 0.3 0.5 0.3 0.1 0.1 0.6 0.6 0.4 0.1 1 1.2 0.6 0.6 0.3 0.6 0.4 0.4-0.3 0.8-0.1 0.9 0.2 0.8 0.4 1.2-0.1 0.8 0.5 0.6 1.2 0.6 0.2 0.2 0.5 0.1 0.4 0.1 0.7 0.4 0.3 0.3 0.3 0.1 0.8 0.2 0.5 0.1 0.2 0.2 0.1 0.4 0.5 0.2 0.7 0.2 0.3 0.1 0 0.3-0.3 0.3 0 0.5 0.3 0.7 0.8 1 0.5 0.6 0.1 0.6-0.1 0.6 0 0.4 0.4 0.2 0 0.5-0.1 0.3-0.4 0.3 0.1 0.3 0 0.6 0.1 0.4-0.1 0.8 0 0.5-0.2 0.4-0.1 0.2-0.1 0.3 0.1 0.7 0 0.4-0.2 0.3-0.3 0.6-0.1 0.4-0.2 0.2-0.4 0.6-0.6 0.9-0.4 0.2-0.3 0.7-0.3 0.1-0.2 0.5-1.1 0.4-0.3 0.5-1 0-0.6 0.4-1.4 0.5-0.7 0.5-0.6 0.3-0.2 0.5 0.2 0.3-0.6 0.7-0.9 0.1-1.4 1 0 0.7-0.6 0.5-0.4 0.4-0.5 0.3-0.2 0.1-0.8 0-0.6 0.3 0 0.3 0.2 0.2-1.2 0.1-0.6 0-0.4-0.2-0.4-0.1-0.7-0.5-0.8-0.7-0.5-0.6-0.6-0.6-0.5-1-0.4-1.1-0.3-0.2-0.2-1-0.1-1-1.3-5.2-0.3-2.2-0.2-1-0.4-0.3-0.2-0.4-0.8-1.3-0.2-0.5-0.4-0.5-0.2-0.6-1-1.8-0.3-0.4-0.9-1.8-1.5-1.3-1.6-1-3.8-1.7-1.7-0.8-2.2-1.8-3.3-3.6-2-2.4-1.1-1.1-0.6-0.4-0.3-0.1-0.1-0.4-0.4-0.4-1.1-1.3-0.7-0.5-1.1-1-0.7-0.5-0.2-0.4-0.7-0.7-1.4-0.9-0.8-0.6-1-0.5-1.1-0.6-1.6-1.3-1.7-0.9-5.2-2.8-0.1-0.2 0.3 0.1 2.5 1.3-0.5-0.6-1.2-0.6-1-0.5-0.5-0.1-0.5-0.5-0.3-0.6-1.1-1.1-0.6-0.4-0.8-0.1-0.9-0.8-0.8-1-0.3-1.3-0.6-1.1-0.2-0.4 0.3 0.2 0.3 0-0.4-0.5-0.6-0.5-0.4-0.4-0.5 0 0 0.5 0.3 0.5-0.4 0.8-0.9-0.1-0.3-0.3-0.4 0.2-0.5 0.1-0.7-0.1-0.5-0.2 0.7 0.7 0.6 0.4-0.6 0.1-0.3-0.2-0.3 0.2-0.4 0.2-0.2-0.3-0.1-0.7 0.2-1.2-0.6-1.8-0.4-1.1-0.6-0.5-0.6-0.8-0.6-0.8-0.8-0.6-0.4-0.5 0.2-0.1 0.7 0.5 0.1-0.1 0-0.2-0.7-0.5-0.6-0.6-0.5-0.7-0.2-0.5-0.1-0.6-0.2-0.7-0.4-0.7-0.4-0.3 0.3 1 0.1 0.9 0.3 0.8 0.7 0.7-0.2 0.1-0.5 0.3 0.2 0.2 0.3 0.4 0.2 0.1-0.3 0.2-0.3-0.1-0.2-0.2-0.1-0.3-0.6 0.6-0.4-0.5-0.5-1.8 0.2-0.2 0.2-0.3 0-0.3-0.2-0.4-0.5 0.4-0.1 0.4 0.2 1.1 0 0.7 0.2 0.4-0.7 0.1-0.5-0.4-0.3-0.4-0.2-0.4-0.1-0.7 0.1-1-0.1-0.4-0.2-0.2-0.2-0.1-0.2-0.1-0.2-0.6 0.3-0.1 0.6-0.5 0.2-0.3-0.2-0.8-0.2-0.1-0.1-0.2 0-0.3 0.2-0.1 0.4-0.3 0.1-0.3 0-0.2-0.3-0.5-0.1-0.3 0-0.3-0.3-0.3-0.2 0.2-0.3 0.5 0 0.6-0.3 0.4-0.2 0.4 0.2 0.7 0.2 0.6-0.3 0.7-0.4 0.5-0.3 0-0.2-0.6 0.1-0.5 0.2-0.9-0.3-0.2-0.1-0.5 0.2-0.2 0.4-0.1 0.1-0.3-0.2-0.3 0.6-1.1 0.2-1-0.1-0.3 0.2-0.5 0-0.4-0.4 0 0-0.2-0.3-0.2 0.2-0.5 0-0.4-0.1-0.5 0-0.7 0.3-0.9 0.4-1 0.6-0.8 0.5-0.7 0.2-0.6 0.1-2.9 0-1-0.4-0.2 0-0.5 0.2-0.6 0.2-0.3 0.1-0.6 0-0.2-0.4-0.1 0.3-0.5 0.8-0.3 0.5-0.3-0.3-0.1-0.8 0.1-0.4 0.1-0.2-0.3 0.3-0.2 0.4-0.3 0-0.6-0.1-1.3-0.2-0.8 0.3-0.7 0-1.2-0.2-2-0.2-1-0.2-0.3-0.2 0.2 0 0.6 0.1 3.7-0.2 1.5-0.1 1.3-0.3 0.3 0-0.4 0-0.8 0.2-2-0.1-4.7-0.2-1.9-0.7-1.1-0.3-1.5-0.6-1.1-0.6-2.3-0.6-1.4-0.7-0.7-0.6-0.9-0.8-0.5-0.9 0.2-0.5-0.7-0.2-1.2-0.2-1-0.7-1.6-1.1-1.5-0.8-0.7-1.2-0.7-0.4-0.1-0.4 0.1-0.2 0.4-0.3 0.4-0.5 0.1-1.8-1.4 0-0.1 0-0.5-0.1-0.4-0.5 0.3-0.5 0.2-0.5-0.4-0.2-0.6-0.1-0.1-0.6-0.1-1.3 0.1-0.4-0.1-1.2-1.7-0.9-0.6-1-0.6-0.6-0.5-0.8-0.6-1-1-1.3-1-1.5-0.9-0.2-0.8-0.1-0.1-0.2 0-0.6 0-0.5-0.2-0.5-0.5-1.3-1.3 0-0.4 0-0.6 0.1-0.4 0-0.4-0.2-0.2-0.8-1.2-0.5-0.6-0.4-0.3-0.3-0.5-0.3-0.6-0.2-0.4 0-0.4 0.1-0.4 0.4-0.3 0.2-0.1-0.2-0.2-0.3 0-0.4 0.1-0.5 0.2-0.2 0.9-0.4 0.1-0.4 0.1 0.1 0.3 0 0.2-0.4 0.2-0.3-0.2-0.3-0.4-0.1-0.4-0.1-0.5-0.2-0.2 0.2-0.2 0.6 0 0.3-0.2 0.4-0.4 0.3-0.2 0.4-0.4 0.2-0.4 0.5-0.3 0.3-0.4 0.2-0.6 0.2-0.4-0.1-1.8-0.1-0.6-0.5-0.6-0.6-0.1-0.5 0.2-0.4 0.8-0.1 2.2-0.2 1.1-0.9 0.8-0.4-0.3-0.4 0.5-0.2 0.4 0 0.4 0 0.3 0 0.3 0 0.4-0.1 0.5-0.1 0.2-0.5 0.1-1.3-0.9-1.2-0.7-1.1-0.2-0.6-0.2-0.9 0.1-0.7 0-1.1 0.4-0.4 0.8-0.3 0.6-0.5 0.4 0 0.8-0.4 0-0.6 0.5-0.7-0.2-1.3-0.5-0.9-1.6-1.9-1-0.2-0.5-0.1-0.6-0.6-1.1-1.1-2.1-0.8-1-1.1-0.7-0.9-0.5-1-0.4-1.6-0.2-0.4 0.2 0 0.5-0.3 0.1-0.3 0.2-0.4-0.2-1.4-1.5-0.4-1.1-0.7-0.9-0.9-1.1-1.1-0.6-1.1-0.6-0.8-0.1-0.9-0.4-1.2 0.2-0.5 0.1-0.1 0.7-0.8-0.7-1-0.7-1.4-0.6-0.8 0.6-0.4-0.4 0.2-0.4-0.1-0.3 0-0.4-0.4-0.2-0.6-0.3-0.4 0.2-0.4-0.8 0-1.5 0.1-1.5-0.2-1.4-0.5-1.5-0.7-0.8-0.3-0.2-0.8-0.5-0.5-0.1-0.5-0.9-1.1-0.5-1.6-0.6-1.1-0.5-0.6 0-0.5-1.1-0.5-0.6-0.1-0.2-0.4-1-0.7-0.7-0.8-0.3-0.3 0.1-0.1 0.4-0.4-0.2-0.2-0.3-0.4-0.5 0.1-0.2 0.4 0.4 0.3-0.1 0.2-0.6-0.1-0.5-0.2-0.3-0.3-0.3-0.3-0.2-0.5 0-0.1 0.3-0.2 0.3-0.1 0.5-0.4-0.2-0.6-0.2-0.2-0.9-0.4-0.6-0.7-0.2-0.5-0.1-0.4 0.4-0.3-0.5-0.3-0.4-0.4-0.7 0-0.7-0.4-0.6-0.2-0.9-0.1-0.1-0.9-1 0.9-0.3 0.5 0.1 0.5 0.5 0.3 0.5 1.5 0.1 1.4-0.3 1.2 0.2 0.5 0 0.7 0.2 0.2 0.4 0.7 0.1 1-0.2 0.7 0.2 0.8 0.1 0.5 0 0.1 0.4 0.3 0.2 0.6 0.1 0.7 0 1 0.3 1 0.2 1.1-0.3 1.3-0.2 1 0.5 1.1-0.5 0.9-0.5 0.9-0.6 0.4-0.4 0.4-0.2 0.5-0.6 0.9-0.6 0.3-0.2 0.3 0 0.4 0.1 0.2 0.1 0 0.3 0.1 0.3 0.1 0.7-0.1 0.5-0.2 0.6-0.2 0.4-0.2 0.4 0.3 0.5 0.7 1 0.6 0.4 0.7 0.7 0.5 0.3 0.9 0.2 0.6 0.4 0.8 0.4 0.5 0.4 0.3 0.5 0.2 0.3 0 0.4 0.2 0.1 0.3 0 0 0.4 0 0.3 0.3-0.2 0.4-0.2 0.2-0.3 0-0.3 0.6-0.4 0.3-0.4 0.1-0.5-0.2-0.2-0.2 0.1-0.1-0.2-0.1-0.2-0.1-0.1-0.2 0.1-0.2 0 0-0.2 0.1-0.1 0.6-0.2 0.3 0.1 0 0.3 0.1 0.1 0.4-0.1 0.3 0.1 0 0.3 0.3 0.3 0.5 0.2 0.9 0.1 0.5 0 0.3-0.5 0.2-0.3 0.2-0.3 0.4-0.4 0.1-0.4-0.2-0.4-0.3-0.2-0.3-0.1-0.2-0.2-0.4-0.2-0.3-0.1-0.2-0.1-0.1-0.2-0.2-0.2-0.1 0-0.2 0.2-0.3 0-0.6 0.1-0.1-0.1-0.4-0.6-0.2-0.6-0.2-0.3-0.3-0.3-0.2-0.1-0.1 0.2 0.1 0.3 0.3 0.5 0 0.4 0.2 0.2 0.2 0.3 0.2 0.4-0.1 0.3-0.3 0 0 0.2-0.1 0.2-0.1 0-0.2-0.2-0.3 0-0.2 0.2-0.4 0.3-0.4 0.1-0.4 0-0.3-0.2-0.2-0.3-0.3-0.3 0-0.4-0.1-0.5-0.3-0.3-0.2-0.3-0.4-0.5 0-0.6 0-0.4 0-0.4 0.2-0.3 0.2-0.3 0.5-0.7 0.3-0.5 0.1-0.4-0.1-0.2-0.4 0-0.1-0.2 0.5-0.2 0-0.2-0.1-0.2-0.3-0.1-0.2-0.1-0.1-0.3 0.1-0.2 0-0.3-0.2-0.2-0.2 0-0.3 0.2 0 0.2-0.2 0.3-0.2 0.1-0.3 0.2-0.3 0.2-0.4-0.1-0.6 0.3-0.2 0.4-0.3 0.3-0.4 0.2-0.2-0.5 0.1-0.6 0.1-0.5 0.2-0.5 0.3-0.3 0.6-0.5 0.2-0.5 0.5-0.5 0.2-0.2z", id: "MEX2707", name: "Baja California Sur" }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Coahuila" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M586 181.5l-0.9 0.7-0.8 0.7-0.8 0.8-0.8 0.8-1.8 1.7-0.3 0-0.2-0.1-0.5-0.5-5.8-4.9-0.2 0.1-0.4 0.3-0.6 0.5-1.1 0.8-1.2 0.7-1.2 0.9-0.8 0.9-0.5 1.2-0.3 1.4-0.3 1.5-0.3 1.2-0.3 1.5-0.3 2-0.4 1.7-0.7 0.9-0.6 0.3-0.3 0.1-0.3 0-0.2-0.2 0-0.3-0.1-0.3-0.2 0-3.7 1.4-0.4 0.3-0.4 0.4-0.4 0.5-0.4 0.4-2.8 1.8-0.6 0.3-0.5 0.4-0.3 0.4-0.1 0.7 0.5 4.3 0.5 0.2 0.6 0.1 0.4 0.4-0.1 0.9 0.7-0.1 0.5-0.1 0.4-0.3 0.1-0.5-0.1-0.2-0.1-0.2-0.2-0.2 0-0.2 0.2-0.2 0.3 0 0.3 0 0.2-0.1 0.2-0.5 0.1-0.4 0.2 0 0.4 0.6 0.6 0.4 0.9 0.1 0.8 0.1 0.6 0.4 0.2 0.7 0.1 1.1-0.1 1.1 0 0.8 0.1 0.7 0 0.8 0 0.7-0.1 0.7-0.5 1.8-0.5 1.8-0.7 1.7-1.1 1.5-0.5 0.5-0.5 0.5-0.6 0.5-0.5 0.5-1.3-4-1.2 1-2.2 1.8-2.2 1.9-2.1 1.9-2.2 1.9-2.4 2-2.3 2.1 1 0.9 1.2 1.1 1.1 1.2 0.8 1.2 0.1 0.6 0.1 0.6 0.2 0.6 0.3 0.5 0.4 0.6 0.3 0.3 0.4 0.1 0.6 0 0.6 0.2 0.5 0.4 0.5 0.5 0.4 0.5 0.3 1 0.1 0.9 0 1 0.3 0.9 0.7 0.6 0.9 0.4 0.8 0.5 0.1 0.9-0.1 1.3-0.2 1.3 0 1.3 0.2 1.2 0.5 1.3 0.7 1.3 0.8 1.2 0.8 1.1 0.6 0.7 0.6 0.3 0.6 0.1 0.8 0 0.3 0.1 0.3 0.1 0.2 0.2 0.3 0.2 0.2 0.4-0.1 0.3 0 0.4 0 0.3 0.4 0.2 0.9 0 0.4 0.2 0.3 0.4 0.1 0.4 0 0.4 0 0.5-0.9-0.3-1-0.5-1.1-0.3-0.8 0.1-0.2 0.7 1 0.5 1.2 0.5 0.7 0.7 0.2 0.7 0.8 0.8 1.2 0.3 1.2 0.3 0.8 0.7 0 0.3-0.2 0.3 0 0.3 0.3 0.3 0.5 0.1 0.7-0.2 0.6-0.2 0.6-0.1 0.5 0.1 0.6 0.1 0.6 0.1 0.6 0 0.5 0 0.3 0.2 0.8 0.6 0.8 0.5 1 0.6 0.4 0.5-1 0.3-0.3 0.1-0.3 0.1-0.3 0.2-0.1 0.3 0 0.3 0.1 0.8 0 0.3-0.4 0.2-0.7-0.1-0.7 0-0.5 0-0.8 0.3-0.7 0.1-0.7 0.1-0.8-0.3-0.8-0.3-0.8-0.3-0.8-0.2-0.8-0.2-2.1 0-1.9 0.6-1.8 1-1.8 1.2-0.8 0.9-0.8 1.5-0.5 1.3 0.8 0.5 0.6 0.1 0.5 0.5 1 1 0.4 0.7-0.1 0.5-0.5 0.4-0.6 0.4-0.7 0.5-0.1 0.6 0.1 0.6 0.3 1 0.3 0.9 0.2 0.8 0 0.7-0.2 0.9-0.4 1.6-0.5 1.6-0.5 1.7-0.3 1.6-0.6-0.4-0.6-0.4-1.3-0.7-0.6-0.2-0.5 0.1-0.6 0.2-0.6 0.2-1.2-0.1-1.3-0.6-1.2-0.8-0.8-0.9-0.2-0.6-0.2-0.6-0.1-0.6-0.3-0.5-0.3-0.6-0.4-0.6-0.4-0.5-0.4-0.5-1.1-0.7-1.1-0.2-1.1 0.1-1.3 0.3 0-0.2-0.1-0.5 0-0.2-0.6 0.6-0.7 0.7-1.2 1.3-0.6 0.4-0.6 0.1-0.7-0.1-0.7 0-2.6-0.2-0.9 0-0.4-0.3-0.3-0.7-0.3-0.8-0.2-0.6 0.7 0.2 0.6 0.2 0.6 0.2 0.7 0.1-0.1-0.7 0-0.7-0.2-0.7-0.3-0.6-0.4-0.3-0.5-0.3-0.5-0.3-0.5 0-1.2 0-1.3-0.3-1.1-0.7-0.9-0.9-0.4-0.9-0.5-1.2-0.6-1.2-0.6-0.6-9.8-3-0.9-0.1-0.9 0.1-0.9 0.2-0.9 0.1-2.3 0.3-7 0.7-1 0.1-0.6 0.2-0.5 0.4-0.6 0.9-2.8 3.7-0.5 0.7-0.6 0.9-0.8 0.8-0.7 0.2-0.1 5.9-0.7-0.6-0.7-0.5-0.7-0.5-0.7-0.5-1.3-0.6-1.3-0.5-1.3-0.3-1.3-0.3-1.4-0.4-1.4-0.5-1.3-0.8-0.8-1.3-0.2-1.3 0-1.4 0-1.4-0.5-1.1-1.1-0.8-1.3-0.7-1.2-0.8-0.7-1.1-0.4-0.9-0.4-0.7-0.5-0.6-0.6-0.5-0.5-0.3-0.4-0.4-0.2-0.4-0.1-0.6 0.1-1 0.4-0.9 0.4-0.9 0.6-0.8 0.3-0.2 0.7-0.2 0.2-0.2-0.1-0.3-0.2-0.4-0.4-0.4-0.3-0.3-0.5-0.5-0.4-0.5-0.3-0.6 0-0.7 0.2-0.6 0.3-0.4 0.4-0.3 0.5-0.3 0.3-0.3 0.3-0.2 0.4-0.1 0.2-0.3 0.3-0.4 0.2-0.3 0.6-0.6 0.3-0.6 0.2-0.5 0.3-0.4 0.6-0.3 0.3-0.5 0.1-1 0-1.1-0.1-0.9-0.1-1.7-0.1-1-0.1-1-0.1-1-0.2-1.8-0.2-1.8-0.1-1.9 0.2-1.7 0.5-1.7 0.7-1.6 0.8-1.6 0.3-1.8-0.4-1.8-1.3-1.5-1.6-1.4-1.4-1.1-1.2-1.2-1.3-1.1-2.5-2.2-1.5-1.3-1.4-6-0.5-2-1.6-6.8-3.3-13.7-1.6-6.8-0.7-3.3-1.3-5.6-0.2-1.1 1-1.8 1.4-2.5 1.3-2.5 1.3-2.6 1.3-2.5 2-3.8 1.9-3.8 2.6-5 2.6-5 2.6-5.1 2.5-5.1-0.1 0.6 0.4 0.3 1.9-0.1 1.7 0.5 1.3 0.2 0.8-0.4 0.4-1 0.1-1.2 0.3-0.1 0.2 0.1 0.1-0.7 0.2-0.3 0.3-0.3 1.2-0.6 0.3-0.3 0.2-0.3 0.9-1.9 0.6-0.5 0.7 0.4 0.2-0.3 1.4-1.1 0.8-0.2 0.4-0.1-0.3-0.4-0.8-0.5-0.2-0.4 0-0.4 0.4-1.4 0.1-0.7 0-0.4 0.2-0.2 0.4-0.3 0.2-0.1 0.1 0 0.3 0 0.3-0.2-0.1-0.1-0.2-0.6 0-0.2 0.3-0.5 0-0.4-0.1-0.4-0.1-0.4 0.1-0.5 0.2-0.3 0.2-0.4 1-2.6 0.3-0.3 0.1-0.2-0.1-0.5 0.3-0.2 0.1-0.1-0.2-0.5 0.4-0.2 0.2-0.2 0.3-0.6 0-0.1 0.5-1 0.1 0 0.1-0.5 1-1.6 0.1-0.4 0-0.4 0.1-0.2 0.2-0.3 0.2 0 1.2 0 0.6-0.1 1.1-0.6 0.6-0.3 0.1 0.1 0.2 0.4 0.1 0.1 0.2-0.1 0.2-0.2 0.3-0.2 0.3-0.5 0.2-0.1 3.5 0.3 0-0.1 0.8-1.1 0.1-0.4 0-1 0.2-0.3 0.2-0.3 0.4 0 0.3-0.2 0.3-0.7 0.3-0.1 0.6 0.1 0.4 0.4 0.4 0.3 0.6-0.1 0.2 0.7 0.4 0.2 1.1 0.1 1.5 0.8 0.4 0.3 1.1 0.5 3-0.3 0.8 0.2 0.5-0.5 0.5 0.2 0.5 0.3 0.4 0.3 0.3-0.1 0.3 0 0.2-0.1 0.2-0.2 0.3-0.2 0.3 0.1 0.6 0.2 1.1 0 0.4-0.3 0.2 0 0.1 0.4 0.2 0.2 5.1 0.8 1.7-0.3 0.5-0.1 0.3-0.4 0.1-0.7 0.1-0.2 0.3 0.1 0.2 0.3 0.1 0.3-0.1 0.2-0.2 0.6-0.1 0.3 0.6 0.2 0.5-0.3 0.5-0.4 0.6-0.2 0.3 0.1 0.2 0.5 0.3 0.1 0.4 0.1 0.3-0.1 0.3-0.1 0.3-0.1-0.1 0.4 0.1 0.5 0.2 0.4 0.5 0.8 0.2 0.7 0.4 0.9 0.2 0.3 0.3 0.3 0.4 0.2 0.8 0 0.3 0.1-0.1 0.6-0.3 0.2-0.2 0.4-0.1 0.5 0 0.4 0.2 0.3 0.3 0.4 0.4 0.1 0.1-0.2 0.3-0.8 0.7-0.5 0.6-0.2 0.4 0.6-0.1 0.8-0.4 0.9-0.5 0.8-0.4 0.3-0.7 0.1-0.2 0.3 0.1 0.3 0.2 0.3 0.8 0.3 0.6-0.2 1-0.9 0.6-0.1 0.3 0.3 0.1 0.5-0.5 0.8 0 0.1 0.2 0.2 0.6-0.3 1 0.1 0.9 0.3 0.5 0.6 0.4-0.2 0.3 0 0.2 0.1 0.3 0.1 0.4-0.1 0.3-0.3 0.2 0.6 0.1 1.1 0.2 0.5 0.2 0.3 0.2 0.4 0.3 0.3 0.4 0.2 2.3 1.1 0.7 0.6 0.6 0.8 0.3 0.2 1.5 0.8 0.6 0.4 0.4 0.6 0.7 1.2-0.3 0.8 0.2 0.5 1.7 1.3 0.1 0.2 0.2 0.3 0.3 0.1 0.4 0 0.3 0.1 0.3 0.5 0.2 2.1 0.6 1.5 0.2 0.7-0.3 0.8 0.2 0.2 0.1 0.3 0.1 0.4 0 0.5 0.2 0.2 0.4 0.3 0.3 0.4 0.2 0.5 0.1 0.2 0.5 0.2 0.1 0.1 0.1 0.3-0.2 0.5 0.1 0.2 0.2 0.1 0.5 0 0.2 0.2 0.1 0.2 0.2 0.3 0.1 0.2 0.2 0.4 0.8 3.4 0.4 0.8 1.2 1.6-0.1 0.6 0.4 0.2 0.7 0.4 0.3 0.3 0.2 0.3-0.1 0.9 0 0.4 0.5 0.7 0.6 0.4 1.3 0.5-0.9 0.5-0.2 0.3 0.1 0.4 0.2 0.3 0.3 0.2 0.1 0.2 0.1 1.3 0.3 1.3 0.9 1.2 0.5 0.8 0 0.6-0.2 0.6 0.3 0.7 0.6 0.6 0.5 0.4 0.9 0.2 0.2 0 0.1 0.3 0 0.5 0.2 0.5 0.2 0.2 0.5 0.1 3.1 1.6 0.6 0.6 0.2 0.8 0.1 0.5 0.1 0.2 0.4 0.5 0.4 0.4 0.3 0.1-0.1 0.2 0 0.2-0.1 0.2 0.2 0.6 0.3 0.5 0.3 0.4 0.4 0.6 0.5 0.2 0.6 0.1 0.4 0.3-0.3 0.5 0.3 0.5 0.5 0.7 0.5 0.5 0.5 0.3 0.1 0.1-0.1 0.4-0.3 0.5 0.1 0.4 0.3 0.2 0.2 0.2 0.3 0.3 0 0.4-0.1 0.7 0.1 0.4 0.1 0 0.5 0.4 0.3 0.4 0 0.2 0.8 0.1 0.1 0.1z", id: "MEX2708", name: "Coahuila", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Coahuila', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Chihuahua" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M475.5 136.5l-2.5 5.1-2.6 5.1-2.6 5-2.6 5-1.9 3.8-2 3.8-1.3 2.5-1.3 2.6-1.3 2.5-1.4 2.5-1 1.8 0.2 1.1 1.3 5.6 0.7 3.3 1.6 6.8 3.3 13.7 1.6 6.8 0.5 2 1.4 6-5-2.1-4.9-2.1-0.8-0.3-0.7-0.2-0.7 0-0.9 0-1.2 0-1.2 0.1-1.3 0.2-1.1 0.4-1.4 1.2-1.1 1.4-1.1 1.6-1.1 1.6-1.4 1.9-2.8 3.9-1.5 2-1.1 1.1-1.3-0.4-1.3-1.1-1.1-1-1.6-1.2-1.7-0.9-1.7-0.6-2-0.3-0.7-0.2-0.7-0.1-0.8-0.1-0.7 0.1-0.4 0.4-0.4 0.7-0.4 0.5-0.6-0.3-1.1-1.7-0.8-0.9-0.4-0.4-0.9 0.4-2.6 1.4-1.6 0.9-0.9 0.5-0.6 0.1-2.7-1.5-4.5-2.5-0.7-0.5-0.6-0.6-0.6-0.7-0.6-0.6-0.5-0.8-0.4-0.8-0.5-0.5-0.8 0.1-0.8 0.2-0.8 0-0.9-0.1-0.8 0-1.3-0.7-1.2-1-1.2-1-1.2-1-1-0.7-0.5-0.3-0.5-0.4-0.4 0.5-0.1 0.2-0.2 0.3-0.3 0.7-0.7 1.3-0.3 0.6-0.3-0.4-0.4-0.5-0.5-0.2-0.5 0.2-0.4 0.7-0.1 1 0 1.1 0 0.8-0.1 0.9 0 0.5-0.2 0.3-0.5 0.3-0.6 0.5-0.5 0.5-0.1 0.5 0.5 1.5 0.2 0.7 0.3 0.7 0.1 0.7-0.2 0.5-0.4 0.3-0.6 0.2-2.7 0.9-2.8 0.8-0.9 0.7-0.2 1 0.3 1.1 0.5 1.1 0.5 1.2 0.5 1.2 0.2 1.2-0.1 1.3-0.2 0.7-0.2 0.8-0.3 0.7-0.3 0.6-0.5 0.4-0.6 0.1-0.5 0-0.6 0-1 0.6-0.4 1-0.1 1.2 0 1.4-0.2 3.8-0.1 0.6-0.3 0.4-0.4 0.4-0.4 0.4-0.6 0.5-2.4 2.1-0.5 0.6-0.6 0.6-0.6 0.6-0.6 0.3-0.6 0.1-0.7-0.1-0.8-0.1-0.6-0.1-3.5-0.4-0.9-0.8-0.9-0.6-1-0.6-1-0.5-0.6-0.6-0.5-0.7-0.6-0.8-0.5-0.7-0.8-0.7-0.8-0.6-0.8-0.5-0.9-0.5-0.7-0.2-0.2-0.2-0.1-0.5 0-0.5-0.1-0.5-0.1-0.4-0.1-0.5-0.3-0.4-0.3-0.2-0.4-0.1-0.3-0.3-0.1-0.4-0.1-0.5-0.2-0.5-0.1-0.6-0.1-0.5-0.1-0.6-0.3-1-0.5-0.8-0.8-0.6-0.9-0.2-6.4-1.4-2.1-0.5-1.3-0.2-1-0.2-0.6-0.3-0.3-0.5-0.1-1-0.4-3.2-0.4-3.2-0.2-1.9-0.2-2.1-0.2-2.1-0.6-1.6-0.6-0.8-1.3-1.3-0.6-0.8-0.7-1-0.7-1-0.7-1.1-0.5-1.1 0-1.8-0.2-0.8-0.8-0.4-1.5-0.3-1.7-0.4-1.6-0.7-1-1.3-0.4-0.6-0.3-0.6-0.5-0.3-0.7-0.2-0.7 0.1-0.8 0.1-0.7-0.3-0.4-0.7-0.7 1-0.7 0.9-0.7 0.8-0.8 0.8-0.2-0.4-0.2-0.3-0.2-0.4-0.2-0.4-0.2-0.2-0.2-0.1-0.5 0.2-0.6 0.1-0.4-0.1-0.3-0.2-0.4-0.5-0.8-0.9-0.7-1.1-0.6-1.1-0.7-1.1-0.5-0.7-0.3-0.8 0-0.8 0.2-0.8 0.5-0.9 0.5-0.6 0.4-0.7-0.2-1.1-0.2-0.6-0.3-0.6-0.2-0.6 0-0.6 0.1-0.7 0.2-0.7 0.1-0.7 0-0.7 0-0.7-0.2-0.5-0.3-0.5-0.5-0.4-0.9-0.5-0.7-0.6-0.7-0.7-0.7-0.8 0-0.5 0-0.5 0.2-0.5 0.3-0.4-3.4-2.9-0.4-0.7-0.2-0.8-0.1-0.7-0.4-0.6-2.1-1.2-0.9-0.6-0.4-0.3-0.2-0.5-1-2.4-1-2.4-1.9-4.8-0.3-0.8 0.3-0.6 0.6-0.6 0.6-0.5 0.7-0.6 0.5-0.5 0.5-0.2 0.8-0.2 1.7-0.1 1.5 0 1.4 0.1 1.6 0.3 4.4 1.1 1.1 0.3 0.5 0.1 0.4-0.2 1.4-1.4 1.3-1.3 0-0.5-0.2-1-0.4-0.9-0.2-0.7-1.1-3-0.4-1-0.3-1.1-0.7-2.1 0-1 0.3-1.2 0.5-1.3 0.3-1 0-0.4-0.1-0.4-0.1-0.3-0.2-0.3-0.1-0.4 0-0.4-0.1-0.9-0.3-2.9-0.2-1.5-1.1-9.5-0.8-7.1 2.2-0.1 0.5 0 0.2-0.2 0.1-0.4 0-0.7 0.3-3.4 0.5-5.9 0.2-2.9 0.3-2.9 0.2-2.3 0.1-1 0-0.7 0-0.6 0.2-0.6 0.5-1.1 0-0.4 0-0.5 0-0.5-0.2-2.3-0.2-2.3-0.2-2.4-0.2-2.3-0.1-1.4-0.4-4.5-0.1-0.9-0.2-0.6-0.3-0.5-0.6-0.6-0.9-0.7-0.7-0.6-0.8-0.4-1-0.3-0.6-0.2-0.6-0.2-0.6-0.3-0.5-0.3-1.8-1.5-5.4-4.6-0.4-0.5-0.1-0.5 0.1-0.6 0.1-0.8 0.2-1.1 0.4-3.5 0.4-3.1 0.4-3.2 0.4-3.1 0.4-3 22.3 0 1.4 0 0-0.2 0-3.7 0-0.5 0-3.9 0-0.2 0-3.7 0-0.5 0-3.9 3.2 0 0.9 0 8.1 0 0.8 0 4.9 0 1.7 0 3.2 0 3.3 0 0.8 0 2.4 0.1 4.1 0 5.7 0 1.7 0 7.3 0 2.4 0 3 0 0.3 0.1 0.5 0.5 0.6 0.1 1.4-0.1 1.1 0.4 1.1 1.1 0.9 1.3 0.6 1.3 0.8 2.5 0.3 0.6 1.4 1.6 0.3 0.6 0.1 0.4 0 0.2 0.1 0.2 0.2 0.2 1.1 0.6 0.3 0.5 0.7 0.3 1.4 0.4 1 0.6 0.6 0.3 0.8 0.1 0.5 0.2 1.4 0.9 0.4 0.4 0.2 0.3 0.3 0.6 0.2 0.4 0.6 0.3 0.3 0.3 0 0.1 0.6 0.2 0.5 0.5 2.5 2.8 0.2 0.7 0.3 0.5 2.4 1.5 0.5 0.2 0.3 0.2 0.7 0.9 0.7 0.5 0.5 0.3 0.5 0.4 0.4 0.7 0.4 1.3 0.3 0.5 0.8 0.4 1.1 1.3 2.5 2 1.3 1.6 0.3 0.3 1 0.2 1.8 0.9 0.2 0.2 0.1 0.2 0.2 0.2 0.4 0.2 0.1 0 0.1-0.1 0.3-0.3 0.1 0 0.3 0.1 0.2 0 0.3 0.2 0.3 0.5 0.3 0.1 0.3 0 0.2 0.1 0.2 0.3 0 0.4 0.1-0.1 0.2 0.1 0.4 0.5 0.2-0.3 1.5 1.8 0.6 0.2 0.5 0.1 0.7 0.4 0.6 0.5 0.4 0.5 0.1 0.4 0.1 0.4 0.1 0.4 0.2 0.3 0.3 0.1 1 0.2 0.2 0.1 0.2 0.4 0.9 1.1 0.4 0.6 0.1 0.4 0 0.8 0.1 0.4 0.5 0.3 0.1 0.1 0 0.3-0.1 0.4-0.1 0.2 0.1 0.4 0.3 0.5 0.1 0.4-0.1 0.5 0 0.3 0 0.2 0.3 0.4 0.2 0.2 0.4 0.3 0.2 0.2 0.1 0.3 0 0.4 0.1 0.4 0.2 0.2 0.6 0.3 0.4 0.9 0.4 1 0.4 0.8 0.2 0.1 0.6 0.3 0.3 0.3 0.6 1.3 0.4 0.6 0.1 0.8 0 1.3-0.2 0.9-0.4 1.3-0.1 0.7 0.1 0.9 0.6 2 0 0.3-0.1 0.5 0.1 0.4 0.1 0.2 0.4 0.5 0.1 0.2 0.1 0.3 0.6 0.8 0.5 1.7 0.1 0.3 0.6 0.6 0.5 0.5 0.5 0.5 0.2 1.6 0.6 1 0.2 0.5 0.1 0.6 0 0.3 0.1 0.4 0.4 0.5 1.5 1 0.5 0.5 0.1 0.2 0.1 0.3 0.1 0.3 0.2 0.2 0.3 0.1 2.5 1.6 0.4 0.5 0.5-0.3 0.9 0 0.8 0.2 0.5 0.7 0.8 0.5 0.2 0.1 0.2 0.2 0.6 1.3 1 1.2 0.7 0.6 1.1 0.5 1.5 1.7 1.2 0.7 2.9 1 2 0.4 2.2 0.1 0.3 0.1 0.3 0.3 0.2 0.3-0.3 0.8 0.2 0.2 0.4 0.1 0.3 0.2 1.5 1.3 0.9 0.5 2.8 0.7 0.9-0.1 0.2 0.1 0.3 0.2 0.1 0.2 0.1 0.3 0.1 0.3 1.7 1.6 1.3 0.7 0.4 0.2 0.3 0.1 0.9 0.9 0.4 0.2 0.4-0.2 0.3-0.4 0.2 0 0.4 0.6 0.2-0.1 0.5-0.2-0.1 0.2z", id: "MEX2709", name: "Chihuahua", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Chihuahua', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Durango" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M465.6 221.5l1.5 1.3 2.5 2.2 1.3 1.1 1.2 1.2 1.4 1.1 1.6 1.4 1.3 1.5 0.4 1.8-0.3 1.8-0.8 1.6-0.7 1.6-0.5 1.7-0.2 1.7 0.1 1.9 0.2 1.8 0.2 1.8 0.1 1 0.1 1 0.1 1 0.1 1.7 0.1 0.9 0 1.1-0.1 1-0.3 0.5-0.6 0.3-0.3 0.4-0.2 0.5-0.3 0.6-0.6 0.6-0.2 0.3-0.3 0.4-0.2 0.3-0.4 0.1-0.3 0.2-0.3 0.3-0.5 0.3-0.4 0.3-0.3 0.4-0.2 0.6 0 0.7 0.3 0.6 0.4 0.5 0.5 0.5 0.3 0.3 0.4 0.4 0.2 0.4 0.1 0.3-0.2 0.2-0.7 0.2-0.3 0.2-0.6 0.8-0.4 0.9-0.4 0.9-0.1 1 0.1 0.6 0.2 0.4 0.4 0.4 0.5 0.3 0.6 0.5 0.5 0.6 0.4 0.7 0.4 0.9 0.7 1.1 1.2 0.8 1.3 0.7 1.1 0.8 0.5 1.1 0 1.4 0 1.4 0.2 1.3 0.8 1.3 1.3 0.8 1.4 0.5 1.4 0.4 1.3 0.3 1.3 0.3 1.3 0.5 1.3 0.6 0.7 0.5 0.7 0.5 0.7 0.5 0.7 0.6 0.1-5.9 0.7-0.2 0.8-0.8 0.6-0.9 0.5-0.7 2.8-3.7 0.5 1.1 0.6 1 0.7 1 0.7 0.9 0.9 1.1 1 1.2 0.8 1.3 0.4 1.3 0 2.2 0 2.2 0 2.2 0 2.3 0 2.3 0 0.9-0.1 0.5-0.4 0.2-2.2 0.2-1.4 0.3-1.5 0.4-1.4 0.4-1.4 0.3-1.4-0.1-1.4-0.2-1.4-0.2-5.6-1.2-5.6-1.2-1.2 0.3-1.4 0.5-1.3 0.7-0.9 0.8-0.2 0.6 0 0.6 0 0.6-0.3 0.5-0.5 0.2-0.6 0.1-0.7 0-0.5 0-0.5 0.1-0.4 0.2-0.2 0.5 0 0.5-0.2 0.5-0.4 0.2-0.6 0-0.6 0.1-0.4 0.4-0.2 0.4-0.2 0.5-0.2 0.4-0.7 1.1-0.6 0.9-0.6 0.7-1 0.7-0.9 0.4-0.8 0.3-1.4 0.6-1.1 0.7-0.3 0.5 0.2 0.7-0.1 0.7-0.1 0.9 0.2 0.9 0 1.1-1.1 0.4-1 0.3 0.3 0.8 0.5 0.6 0.5 0.5 0.4 0.7 0.1 0.8-0.2 0.5-0.3 0.4-0.2 0.5-0.3 0.4 0.4 0.9 0.8 0.5 0.7 0.6 0.4 0.8-0.1 0.7-0.3 0.9-0.4 0.6-0.6-0.2-0.7-0.8-0.7-0.2-0.7 0.4-0.4 0.9-0.1 0.7-0.1 0.7-0.1 0.6-0.4 0.6-0.9 0.7-0.9 0.7-1 0.6-0.9 0.6-0.7 0.5-0.3 0.3-0.2 0.6-0.1 0.8-0.3 4-0.2 1.3-0.1 1.6-0.1 0.8-0.3 0.5-0.7 0.3-0.4 0.3-0.2 0.4-0.1 0.9-0.2 3.7-0.1 3.7-0.1 3.7-0.1 3.7-0.2 1.4-0.3 1.4-0.5 1.4-0.4 1.3-0.5 1.7-1 3.5-0.5 1.8-0.2-1.3-0.2-1.4-0.3-2.6-1.1 0.5-2.3 0.9-1.1 0.5-0.9 0.1-0.9-0.4-1.7-1.1-0.8-0.8-0.5-1-0.3-1.1-0.4-1.6-0.1-0.5-0.2-0.4-0.2-0.3-0.7-0.4-1-0.7-1-0.5-0.7-0.1-1.9 1.4-1.9 1.4-0.6 0.6-0.9 0.7-0.9 0.5-0.8-0.1-0.2-0.6 0-1.1 0.2-1.9 0.1-0.9 0.2-0.5 0.3-0.5 0.6-0.6 1.2-1.2 0.7-0.7 0.3-0.4-1.5-3.6-0.3-0.7-0.3-0.4-0.4-0.4-0.7-0.4-1.4-0.7-1.5-0.8-1.5-0.8-1.5-0.5-1.6-0.2-1.7 0-1.7 0.1-1.6 0.1-0.2-4-1.2 0.1-1.4 0.1-1.2-0.1-1.1-0.6-0.5-0.5-0.5-0.6-0.6-0.5-0.4-0.4-0.3-0.2-0.1-0.3-0.1-0.3-0.2-0.3-0.4-0.4-0.5-0.3-0.5-0.3-0.3-0.5 0-0.4 0-0.4 0-0.4-0.1-0.4-0.2-0.4-0.3-0.4-0.2-0.3 0.2-0.6 0.1-0.3 0-0.4-0.1-0.3-0.5-0.5 0.1-0.3 0.1-0.3 0.1-0.3-0.4-0.8-0.5-0.7-0.5-0.7-0.2-0.8-0.5-0.1-0.5-0.1-0.5-0.1-0.4-0.2-0.6-0.5-0.3-0.7-0.2-0.9-0.1-0.7-0.3-0.6-0.3-0.6-0.3-0.5-0.2-0.6-0.3-2.4-0.2-1.3-0.2-1.4-0.1-1.4 0.2-1.3 0.5-1.1 0.5-1 0.4-1.1 0.3-1.1-0.7 0.3-0.8 0.1-0.6-0.1-0.6-0.6-0.5-0.8-0.4-0.9-0.7-1.8-0.3-0.9-0.4-1.1-0.4-1-0.6-0.8-2.3-2.1-0.8-0.7-0.3-0.3-0.4-0.2-0.3-0.2-0.4-0.2-1.3-0.2-1.1 0.2-1.2 0.6-1 0.8-0.4 0.5-0.3 0.5-0.4 0.5-0.4 0.4-0.5 0.2-0.5 0.1-0.5 0-0.5 0-0.7 0-0.5 0-0.5-0.2-0.6-0.5-0.5-0.5-0.6-0.5-1.1-1.1-0.3-0.5-0.1-0.5 0-0.5 0-0.6-0.1-0.7-0.1-0.6-0.2-0.6-0.3-0.6-0.4-0.8-0.2-0.4-0.2-0.5-0.2-0.6-0.4-0.4-0.8-0.7-0.7-1.2-0.4-1.3-0.6-1.1-1.1-0.7-0.6-0.3-0.4-0.5-0.3-0.6-0.3-0.6-0.4-0.3-0.5-0.1-0.4 0-0.5 0-0.6-0.1-0.5-0.2-0.3-0.3-0.3-0.6 0-0.5 0-0.5-0.1-0.4-0.2-0.4-0.5-0.3-1.1-0.3-0.4-0.3-0.4-0.5-0.2-0.7-0.2-0.7-0.2-0.6-0.6-1.4-0.4-1.5-0.4-1.5-0.5-1.5-0.3-1.6 0-1.6 0.2-1.7 0.3-1.6 0.2-1.5 0.3-1.6 0.4-1.6 0.6-1.2 0.6-0.7 0.6-0.5 0.5-0.6 0.4-0.7 0.3-0.7 0.5-0.6 1.1-1.1 3.5 0.4 0.6 0.1 0.8 0.1 0.7 0.1 0.6-0.1 0.6-0.3 0.6-0.6 0.6-0.6 0.5-0.6 2.4-2.1 0.6-0.5 0.4-0.4 0.4-0.4 0.3-0.4 0.1-0.6 0.2-3.8 0-1.4 0.1-1.2 0.4-1 1-0.6 0.6 0 0.5 0 0.6-0.1 0.5-0.4 0.3-0.6 0.3-0.7 0.2-0.8 0.2-0.7 0.1-1.3-0.2-1.2-0.5-1.2-0.5-1.2-0.5-1.1-0.3-1.1 0.2-1 0.9-0.7 2.8-0.8 2.7-0.9 0.6-0.2 0.4-0.3 0.2-0.5-0.1-0.7-0.3-0.7-0.2-0.7-0.5-1.5 0.1-0.5 0.5-0.5 0.6-0.5 0.5-0.3 0.2-0.3 0-0.5 0.1-0.9 0-0.8 0-1.1 0.1-1 0.4-0.7 0.5-0.2 0.5 0.2 0.4 0.5 0.3 0.4 0.3-0.6 0.7-1.3 0.3-0.7 0.2-0.3 0.1-0.2 0.4-0.5 0.5 0.4 0.5 0.3 1 0.7 1.2 1 1.2 1 1.2 1 1.3 0.7 0.8 0 0.9 0.1 0.8 0 0.8-0.2 0.8-0.1 0.5 0.5 0.4 0.8 0.5 0.8 0.6 0.6 0.6 0.7 0.6 0.6 0.7 0.5 4.5 2.5 2.7 1.5 0.6-0.1 0.9-0.5 1.6-0.9 2.6-1.4 0.9-0.4 0.4 0.4 0.8 0.9 1.1 1.7 0.6 0.3 0.4-0.5 0.4-0.7 0.4-0.4 0.7-0.1 0.8 0.1 0.7 0.1 0.7 0.2 2 0.3 1.7 0.6 1.7 0.9 1.6 1.2 1.1 1 1.3 1.1 1.3 0.4 1.1-1.1 1.5-2 2.8-3.9 1.4-1.9 1.1-1.6 1.1-1.6 1.1-1.4 1.4-1.2 1.1-0.4 1.3-0.2 1.2-0.1 1.2 0 0.9 0 0.7 0 0.7 0.2 0.8 0.3 4.9 2.1 5 2.1z", id: "MEX2710", name: "Durango", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Durango', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Sinaloa" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M299.9 263.6l1.7 0.6 0.4 0.2 0.6 0.9 0.4 0.3-0.6 0.4-1-0.5-1.1-0.7-0.9-0.4-0.2 0-0.3-0.1-0.2-0.1-0.3 0-2 0-0.4-0.2-0.2-0.5 3.6 0 0.5 0.1z m61.4-6.9l-1.1 1.1-0.5 0.6-0.3 0.7-0.4 0.7-0.5 0.6-0.6 0.5-0.6 0.7-0.6 1.2-0.4 1.6-0.3 1.6-0.2 1.5-0.3 1.6-0.2 1.7 0 1.6 0.3 1.6 0.5 1.5 0.4 1.5 0.4 1.5 0.6 1.4 0.2 0.6 0.2 0.7 0.2 0.7 0.4 0.5 0.4 0.3 1.1 0.3 0.5 0.3 0.2 0.4 0.1 0.4 0 0.5 0 0.5 0.3 0.6 0.3 0.3 0.5 0.2 0.6 0.1 0.5 0 0.4 0 0.5 0.1 0.4 0.3 0.3 0.6 0.3 0.6 0.4 0.5 0.6 0.3 1.1 0.7 0.6 1.1 0.4 1.3 0.7 1.2 0.8 0.7 0.4 0.4 0.2 0.6 0.2 0.5 0.2 0.4 0.4 0.8 0.3 0.6 0.2 0.6 0.1 0.6 0.1 0.7 0 0.6 0 0.5 0.1 0.5 0.3 0.5 1.1 1.1 0.6 0.5 0.5 0.5 0.6 0.5 0.5 0.2 0.5 0 0.7 0 0.5 0 0.5 0 0.5-0.1 0.5-0.2 0.4-0.4 0.4-0.5 0.3-0.5 0.4-0.5 1-0.8 1.2-0.6 1.1-0.2 1.3 0.2 0.4 0.2 0.3 0.2 0.4 0.2 0.3 0.3 0.8 0.7 2.3 2.1 0.6 0.8 0.4 1 0.4 1.1 0.3 0.9 0.7 1.8 0.4 0.9 0.5 0.8 0.6 0.6 0.6 0.1 0.8-0.1 0.7-0.3-0.3 1.1-0.4 1.1-0.5 1-0.5 1.1-0.2 1.3 0.1 1.4 0.2 1.4 0.2 1.3 0.3 2.4 0.2 0.6 0.3 0.5 0.3 0.6 0.3 0.6 0.1 0.7 0.2 0.9 0.3 0.7 0.6 0.5 0.4 0.2 0.5 0.1 0.5 0.1 0.5 0.1 0.2 0.8 0.5 0.7 0.5 0.7 0.4 0.8-0.1 0.3-0.1 0.3-0.1 0.3 0.5 0.5 0.1 0.3 0 0.4-0.1 0.3-0.2 0.6 0.2 0.3 0.3 0.4 0.2 0.4 0.1 0.4 0 0.4 0 0.4 0 0.4 0.3 0.5 0.5 0.3 0.5 0.3 0.4 0.4 0.2 0.3 0.1 0.3 0.1 0.3 0.3 0.2 0.4 0.4 0.6 0.5 0.5 0.6 0.5 0.5 1.1 0.6 1.2 0.1 1.4-0.1 1.2-0.1 0.2 4-0.8-0.1-0.7 0.1-0.5 0.3-0.4 0.6-0.2 0.7-0.1 0.4 0.2 0.4 0.2 0.6 0.5 0.7 0 0.3-0.2 0.5-0.5 0.4-0.6 0.5-0.6 0.5-0.5 0.4-0.5 0.6-0.6 0.6-0.5 0.8-0.2 0.7 0.1 0.3 0.2 0.2 0.2 0.2 0.6 0.4 0.2 0.2 0.2 0.3 0.2 0.5 0.2 0.3 0.3 0.2 0.4 0.1 0.3 0.2 0 0.2-0.2 0.5 0 0.2 0.1 0.1 0.4 0.1 0.1 0.1 0.3 0.8 0.3 0.9 0.2 0.9 0.2 0.8 0 1.2-0.8 0.7-1 0.1-1.1-0.3-0.4-0.4-0.5-0.4-0.4-0.4-0.5-0.3-0.7-0.2-0.7 0.2-0.7 0.2-0.6 0.1 0.3 1.2 0.2 0.7-0.1 0.6-0.5 0.4-0.5-0.5-0.9-1.5 0.2-0.2-0.2-0.5-0.3-0.4-0.3-0.2-0.3 0.4-0.2 0-0.3-1.9-1-1.6-2.6-2.6-1.4-1.8-0.5-0.5-1.3-0.9-0.2-0.2-0.1-0.1-0.1-0.1-0.2-0.1 0-0.3 0.6-0.9-0.4 0.1-0.4 0.2-0.4 0.3-0.3 0.3-5.9-7.6-0.3-0.2-0.6-0.2-0.3-0.2-0.6-0.5-3-3.4-0.5-0.3-0.4 0.1-0.3 0.2-0.3 0.1-0.4-0.1 0-0.3 0-1.3-0.1-0.5-1.1-1.7-0.6-0.4 0-0.3 0.4-0.3-0.1-0.2-0.1-0.2-0.1-0.2-1.2-2.3-0.4-0.4-0.5-0.1-0.6-0.4-1.3-1.2-0.1-0.2-0.2-0.2-0.3-0.8-0.3-0.4-0.8-0.4-0.5-0.6-0.7-1.1-0.9-1-0.6-0.4-1.3-0.5-0.3-0.7-0.3-1.6-0.5-0.7-0.5-0.6-0.5-0.6-0.4-1.5-0.9-1.7-4.3-4.6-1.5-1.2-0.6-0.2-0.4-0.3-1.7-1.6-4.5-3.1-2-1.4-0.4-0.4-0.1-0.8-0.4-0.4-1.2-0.6-1.2-0.8-1.9-1.9-7.3-4.5-0.6-0.6-0.2-0.6 0.1-0.4 0.2 0 0.2 0.2 0.2 0.2 0.1 0.2 0.1 0.1 0 0.4 0 0.1 2.5 1.4 0.3 0.1 4.4 2.8 0.5 0.2 0.4 0.2 0.5 0.3-0.4-0.3-0.9-0.6-0.5-0.3 0.2-0.3 0.6 0.3 1 0.8 0.1-0.4 0.1-0.1-0.3 0-0.2 0 0.4-0.4 0.3-0.3 0.2-0.3 0-0.7-0.1-0.5-1.2-2.7-0.3-0.3-0.5-0.3-0.6 0-0.5 0.1-0.4 0.2-0.3 0.4 0.5 0.1 0.8-0.3 0.2 0.2-0.1 0.3-0.8 0.9-0.3 0.2-1 0.4-0.6-0.4-0.4-0.7-0.6-0.4-0.7 0.4-0.2 0-0.3 0-0.2-0.1-0.6-0.5-0.2-0.3-0.1-0.2 0-0.5-0.1-0.3-0.2-0.1-0.5-0.2-0.2-0.1-1.3-1.4-0.4-0.1-0.4 0.3-0.6-0.6-0.7-0.6-0.8-0.3-0.7-0.2 0.1 0.4 0.2 0.2 0.5 0.4 1 1.1 0.5 0.4 1.4 0.8 0.4 0.5-0.9-0.2-2.4-1.5-2.7-2.4-0.3-0.5-0.1-0.5-0.2-1.3-0.1-0.6-0.3-0.6-0.4-0.5-0.3-0.2-0.2-0.1-0.1-0.3 0-0.2 0.1-0.1 0.3 0 0.3 0.1 0.6 0.4 0.2 0.2 0.5 0.4 0.5 0 0.3-0.8-0.2-0.6-0.3-0.6-0.5-0.5-0.4-0.3 0.4-0.3 0.1-0.6-0.2-1.2 0-0.6 0.2-0.4 0.4-0.9-0.3-0.5-1.3-1.1-0.4-0.1 0 0.7 0.4 1.8 0.1 0.2 0 0.2 0 0.5-0.2 1.1 0 1.2-0.1 0.4-0.2 0.1-0.2 0-0.2-0.1-0.3-0.3-0.2-0.1-0.1 0.2 0 0.2-0.2 0.1-1.2-0.7-0.9-1.4-2.5-5-0.8-1-1.1-1-0.6-0.3-0.3-0.2-0.2-0.4 0.7 0 0.7 0.1 0.6 0.4 0.2 0.6 1.9 2.2 0.4 1 0.1 0.2 0.2 0 0.2-0.1 0.2-0.1 0.6 0.4 0.2 0.1 0.2-0.1 0.1-0.3 0-0.7-0.1-0.5-0.3 0-0.4 0.1-0.3-0.2 0-0.2 0.4-0.6 0.1-0.2 0.2-0.3 0.2 0 0.1 0.1 0.2 0.3 0.6 0.7 0.6 0.3 1.3 0.1 1 0.5 0.3-0.3 0.1-0.4 0-0.3-3.3-3-0.4-0.2-0.5-0.1 0.2 0.3 0 0.2-0.2 0.1-0.4 0.1-0.4 0-0.4-0.3-0.5-0.6-0.7-1.3-0.2-0.2-0.4 0.1-0.4 0.2-0.3 0.2-0.4-0.2-0.5 0.2-0.8 0.1-0.8-0.1-0.6-0.3-0.2-1.1 0.1-0.2 0.2 0 0.7 0.5 0.4 0.2-0.1-0.5 0-1-0.1-0.5-0.3-0.3-0.8-0.4-0.2-0.2-0.8 3.7-0.4 0.6-0.1-0.3 0.2-1.6 0-0.5-0.3-0.7-0.4-0.5-0.5-0.4-0.5-0.3-3.3-1.4-1.9-1.2-1.3-0.4-1.3-0.1-1.1 0 0.7-0.6 1.3 0.1 2.3 0.7-0.7-0.4-1.2-1-1-0.2-1.7 0.5-0.8 0.1-0.4-0.6 1.3-0.1 0.3-0.2-0.4-0.6-0.1-0.3 0-0.2-0.1-0.2-0.3-0.1-0.1 0-0.4 0.4-0.2 0.1 0.3-1.1 0.1-0.5 0-1.7-0.1-0.5-0.2 0-0.2 0.1-0.3 0.1-1.1-0.5-0.1-0.3-0.1-0.1-0.2-0.1-0.1 0-0.3 0.2-0.2 0-0.6-0.1-0.4-0.1-0.2 0.1 0 0.6 0.1 0.4 0.2 0.2 0.1 0.2 0 0.4 0 0.4-0.1 0.3-0.2 0.2-0.2 0.2-0.5 0.4-0.4 0-0.4-0.3-0.3-0.5 0.1 0.1 0.2-0.1 0.1-0.2-0.2-0.3-0.2 0-1.6 0.1-0.4 0.3-0.1 0.3 0.4 0.6-0.9 0-1-0.7-1.6-1.7 0.7-0.4 0.2-0.1 0.2-0.3 0.1-0.4 0.2-0.4 0.4-0.1 1.1 0.4 0.2-0.1 0.4-0.1 0.2 0.3 0.2 0.7 0.3 0.2 0.1 0 0-0.3 0.2-0.4 0.1-0.2-0.1-0.4 0-0.1 0.2-0.2 0.2 0 1.7-1.7 0.3-0.5 0-0.2-0.1-0.3 0.1-0.2 0.1-0.1 0.2-0.1 0.1 0 0.1-0.2-0.1-1.2 0.3-0.7 1.3-1.1 0.2-0.7-0.3-0.5-0.4 0.4-0.7 1.4-0.5 0.7-0.4 1.1-0.5 0.5-0.8 0.3-1.5 0.5-0.7 0.5-1 1.6-0.6 0.5-0.8-0.3-0.8 0.5-0.6 0-0.4-0.4-0.4-0.8-0.2-0.7-0.2-0.4-0.3-0.1-0.4-0.1-1-0.5-0.8-0.6-0.2 0.2 0.1 0.4 0.2 0.4 0.3 0.3 2.1 1.8 0.5 0.8-0.1 0.6-0.7-0.6-0.7-1-0.8-0.9-1.1-0.3-3.5 0-1.2-0.3 0.7-0.5 0.9-0.3 1 0 0.9 0.4-0.1-0.6 0.1-0.6 0.1-0.2 0.2-0.3 0.1-0.1 0-0.3-0.2-0.1 0-0.1-0.3-0.4-0.6-0.5-0.7-0.3-0.5-0.2-0.6 0.1-0.3 0.2-0.2 0.4 0 2-0.1 0.3-0.4-0.5 0.2-0.7 0-0.8-0.1-0.8-0.2-0.4-0.7-0.2-0.1-0.6 0.1-0.8 0.3-1.3 0.2-0.3 0.1 0 0-0.7-0.1-0.5-0.1-0.4-0.2-0.5-0.2-0.8-0.1-0.6 0.1-1.6 0.1-0.5 1.1-2 1.2-1.3 0.6-0.7 0.4-1.4 1.1-2.2 0.3-0.1-0.1 0.5 0 0.7-0.1 0.4-0.1 0.4-0.1 0.4 0.2 0.3 0.3 0.1 0.3-0.3 0.1-0.4 0.2-1.1 1-1.8 0.2-0.1 1.2-0.8 0.6-0.4 0.3-0.3 0 0.5-0.2 0.6-0.4 0.3 0 0.2 0.6 0.3 1.5 1.3 0.5 0.1 0-0.4-0.4-0.8-0.1-0.5 0.3-0.2 0.3-0.1 0.2-0.2-0.1-0.5-0.9 0.1-0.7-1.5 0.3-0.6 0.8-0.7 3.2-2.4 3.1-2.5 3.1-2.5 3.1-2.6 3.1-2.7 3.2-2.6 0.2-0.5 0-0.8 0-0.8 0-0.7 0.2-0.9 0.3-0.9 0.3-0.8 0.3-0.9 0.8-0.8 0.7-0.8 0.7-0.9 0.7-1 0.4 0.7 0.7 0.3 0.8-0.1 0.7-0.1 0.7 0.2 0.5 0.3 0.3 0.6 0.4 0.6 1 1.3 1.6 0.7 1.7 0.4 1.5 0.3 0.8 0.4 0.2 0.8 0 1.8 0.5 1.1 0.7 1.1 0.7 1 0.7 1 0.6 0.8 1.3 1.3 0.6 0.8 0.6 1.6 0.2 2.1 0.2 2.1 0.2 1.9 0.4 3.2 0.4 3.2 0.1 1 0.3 0.5 0.6 0.3 1 0.2 1.3 0.2 2.1 0.5 6.4 1.4 0.9 0.2 0.8 0.6 0.5 0.8 0.3 1 0.1 0.6 0.1 0.5 0.1 0.6 0.2 0.5 0.1 0.5 0.1 0.4 0.3 0.3 0.4 0.1 0.3 0.2 0.3 0.4 0.1 0.5 0.1 0.4 0.1 0.5 0 0.5 0.1 0.5 0.2 0.2 0.7 0.2 0.9 0.5 0.8 0.5 0.8 0.6 0.8 0.7 0.5 0.7 0.6 0.8 0.5 0.7 0.6 0.6 1 0.5 1 0.6 0.9 0.6 0.9 0.8z", id: "MEX2711", name: "Sinaloa", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Sinaloa', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                }, onMouseLeave: function () {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: '', open: false }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Sonora" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M287 235.8l0.1-0.2 0.7-1.2 0.1-0.6 0.1-0.4 0.2 0.1 0.1 0.4-0.3 0.8-0.2 0.2-0.2 0.3-0.2 0.2-0.1 0.3-0.3 0.1z m2-0.9l0.1-0.7 0-1.8 0.3-0.4 0.6 0 0.7 0.2 0.4 0.3 0.2 0.6 0 0.2-0.3 0.3-0.6 0.4-1.2 0.8-0.2 0.1z m-22.3-26.8l-0.3 0-0.7-1-0.7-0.5-0.9-0.4-0.5-0.1-0.3-0.3 0.3-0.1 0.6 0.2 1 0.5 0.9 0.6 0.6 1.1z m-18.7-9.9l-0.1 0.6-1.7-0.7-0.5-0.5-0.1-1.4 0.1-0.9 0.2-0.8 0.1-0.4-0.1 1.4 0.1 1.6 0.6 0.7 1.4 0.4z m-26.5-23.8l0.2 0.6-0.5-0.2-0.2-0.4-0.2-0.3 0.2-0.4 0.5 0.7z m-28.8-26.7l0 0.2-0.2-0.1 0-0.3-0.2-0.3 0.1-0.2 0.1 0.3 0.1 0.2 0 0.1 0.1 0.1z m0.1-18.4l0.2 0.6 0.3 0.4 0.1 0.2-0.1 0.3-0.1 0.3-0.1 0.4 0.1 0.4-0.1 0.6 1.2 1.5 1.2 2.7-0.5 1.2-0.1 1.2-0.4 1.8-0.5 0.5 0.2 0.5-0.5 0.7-0.2 0.7-0.3 0.5-0.2 0.6 0.1 0.8 0.4 0.1 0.2 0.5-0.3 0.2-0.3-0.2-0.5 0.2-0.7 0.6-0.5-0.6-0.6-0.1-0.4 0.2-0.3-0.5-0.4 0-0.6-0.7-0.4-0.3-0.4 0.2-0.3-0.2-0.6 0-0.4-0.2 0-0.5-0.9-0.1 0-0.3-0.8-0.5-0.9-0.4-0.4-0.4-0.3 0-0.4-0.3 0.9-0.6 0.9-0.6 0.5-0.7 0.2-0.1 0.2-0.3 0.1-0.4 0.1-0.3 0.2-0.4-0.1-0.4-0.4-0.3-0.1-1.5 0.1-1.6 0.3-1.5 0.4-1.4 0.2-0.4 0.3-0.5 0.3-0.4 0.5-0.4 0.5 0.5 0.7 0 1.2-1 0.6-0.1 0.8 0 0.6-0.1 0.4-0.4 0.2-0.3 0.5-0.2-0.1 0.3-0.5 0.5z m-5.5-1.5l-0.1 0-0.1-0.2 0.1-0.1 0.1 0.2 0 0.1z m-69.7-89.8l0.5 1.1-0.4 0-0.4-0.1-0.3-0.3-0.2-0.3-0.7 0.5-1.5-0.7-1.1-1.5 0.4-1.8 1 0.2 1.4 1.3 1.3 1.6z m179.7 14.5l-0.4 3-0.4 3.1-0.4 3.2-0.4 3.1-0.4 3.5-0.2 1.1-0.1 0.8-0.1 0.6 0.1 0.5 0.4 0.5 5.4 4.6 1.8 1.5 0.5 0.3 0.6 0.3 0.6 0.2 0.6 0.2 1 0.3 0.8 0.4 0.7 0.6 0.9 0.7 0.6 0.6 0.3 0.5 0.2 0.6 0.1 0.9 0.4 4.5 0.1 1.4 0.2 2.3 0.2 2.4 0.2 2.3 0.2 2.3 0 0.5 0 0.5 0 0.4-0.5 1.1-0.2 0.6 0 0.6 0 0.7-0.1 1-0.2 2.3-0.3 2.9-0.2 2.9-0.5 5.9-0.3 3.4 0 0.7-0.1 0.4-0.2 0.2-0.5 0-2.2 0.1 0.8 7.1 1.1 9.5 0.2 1.5 0.3 2.9 0.1 0.9 0 0.4 0.1 0.4 0.2 0.3 0.1 0.3 0.1 0.4 0 0.4-0.3 1-0.5 1.3-0.3 1.2 0 1 0.7 2.1 0.3 1.1 0.4 1 1.1 3 0.2 0.7 0.4 0.9 0.2 1 0 0.5-1.3 1.3-1.4 1.4-0.4 0.2-0.5-0.1-1.1-0.3-4.4-1.1-1.6-0.3-1.4-0.1-1.5 0-1.7 0.1-0.8 0.2-0.5 0.2-0.5 0.5-0.7 0.6-0.6 0.5-0.6 0.6-0.3 0.6 0.3 0.8 1.9 4.8 1 2.4 1 2.4 0.2 0.5 0.4 0.3 0.9 0.6 2.1 1.2 0.4 0.6 0.1 0.7 0.2 0.8 0.4 0.7 3.4 2.9-0.3 0.4-0.2 0.5 0 0.5 0 0.5 0.7 0.8 0.7 0.7 0.7 0.6 0.9 0.5 0.5 0.4 0.3 0.5 0.2 0.5 0 0.7 0 0.7-0.1 0.7-0.2 0.7-0.1 0.7 0 0.6 0.2 0.6 0.3 0.6 0.2 0.6 0.2 1.1-0.4 0.7-0.5 0.6-0.5 0.9-0.2 0.8 0 0.8 0.3 0.8 0.5 0.7 0.7 1.1 0.6 1.1 0.7 1.1 0.8 0.9 0.4 0.5 0.3 0.2 0.4 0.1 0.6-0.1 0.5-0.2 0.2 0.1 0.2 0.2 0.2 0.4 0.2 0.4 0.2 0.3 0.2 0.4-0.3 0.9-0.3 0.8-0.3 0.9-0.2 0.9 0 0.7 0 0.8 0 0.8-0.2 0.5-3.2 2.6-3.1 2.7-3.1 2.6-3.1 2.5-3.1 2.5-3.2 2.4-0.8 0.7-0.3 0.6-0.6-1.2-0.7-0.4 0.1 0.2 0.1 0.2 0.1 0.2-0.7-0.2-0.3 0-0.3 0-0.9 1-0.3 0.1-0.1-0.5 0.4-2.5-0.2-1.4-0.3-1.4-0.7-0.8-1.1-1.7-1.4-1-0.9-1.4-1-0.9-0.9-0.3-0.9-0.1-0.3-0.3 0.4-0.1 0.6 0.2 0.7 0.3-0.1-0.7-0.3-0.1 0.2-0.3-0.2-0.4-0.5-0.1-0.5 0-0.2-0.4-0.1-0.5-0.4 0.2-0.3 0.3-0.2-0.7-0.5-0.1-0.4 0.4-0.3 0.4-0.1 0.4 0.3 0.2 0.4 0 0.3 0.1 0.1 0.2-0.1 0.2 0 0.3 0.6 0.3 0.3 0.1 0 0.3-1.2-0.6-2.3-0.4-1.4 0.1-0.4 0.3-0.1 0.4-0.9-0.1-1-0.5-1.4-0.5-0.5-0.5-1.5-1.6-0.7-1.3-0.3-1.2-0.2-1.3-0.5-0.7-0.4-1.1-0.1-0.5-0.3-0.5-1-1.6 0.1-0.4 0.3 0.5 0.9 1.4 0.6 0.5-0.8-2 0-0.7-0.2-1.5-1.2-1.4-0.4-0.4-0.5-0.2-0.5-0.1-0.6 0-0.2 0-0.3 0.2-0.2 0.2-0.2 0.2-0.2 0.4-0.3 0.3-0.9-0.8-1.9-0.5-1.3-0.4-0.8-0.2-0.8-0.1-0.7-0.2-0.7-0.2-1.1-0.6-0.5-0.2-1.1-1.3-1-1.3-1.4-1-0.5-0.4-1.1-0.2-0.7 0-0.1-0.4 1 0.1 0.8 0.1 0.9 0.1 0.4-0.3-0.6-0.6-0.8-1-0.3-0.4 0.1-0.2 0.1-0.2 0-0.3-0.4-0.1-0.2-0.2-0.2-0.3-0.6 0.5-0.4 0.2-0.3 0.1-0.3-0.2-0.1-0.3 0-0.9-0.2-0.8-0.9-0.6 0-2.2-0.3-1.1-0.9-2.3 0-1.2 0.3-0.6 0.6-0.2 0.6-0.1 0.3-0.5 0-0.6-0.4-0.1-0.4 0.3-0.3 0.4 0.3-1.2 0.2-0.3 0.4-0.2 0.4 0 0.3-0.1 0.2-0.4-1.1-0.1-0.6-0.2 0-0.6 0.4-0.8-0.5-0.1-0.3-0.3-0.1-0.4 0.2-0.4 0.2 0.3 0.2 0.1 0.2-0.2 0.2-0.7 0.2 0 0.2 0 1.6-0.2 0.4-0.4-0.1-0.7-0.7 0.3-1.8-0.8-0.8 0.1 0.4 0.4-0.2 0.1-0.4 0-1-0.7-0.5-0.2-2.2-0.6-1.1-0.1-1.2 0.1-1.1 0.3 0-0.3 0.3-0.1 1-0.4-0.3-0.5-0.1-0.3-0.1-0.3 0-0.5-0.1-0.4-0.4-0.2-0.4 0-0.1 0.4-0.1 1-0.1 0.5-0.3 0.6-0.6 0.7 0.4-0.1 0.3 0.1 0.1 0.4 0 0.4-0.1 0.5-0.3 0.6-0.3 0.3-0.1-0.4-0.2-0.1-0.7-1-0.2 0-0.5-0.1-0.2-0.1-0.1-0.2-0.1-0.2-0.2-0.2-0.2-0.1 0.4-0.4 0.2-0.1 0.3 0-0.6-0.6-0.6-0.6-0.8-0.4-0.6 0.1-0.7 0.2-0.5 0.7-0.9 0-0.6 0 0.1-0.3 0.2-0.3-0.3-0.3-0.4-0.3-0.3 0-0.5-0.5-0.9-0.2-0.4-0.6-0.4-0.6-0.7-0.8-1-0.2-0.4-0.8-0.6-0.6-0.5-1.4-1.1-1.1-0.2-1.6-0.3-0.4-0.1 0-0.4 0-0.2-0.1-0.1-0.1-0.1-0.2-0.2-0.5-0.1-0.8-0.2-0.4-1.4-1.2-0.4-0.6-0.2-0.8 0.2-0.4 0.3-0.4 0.1-0.6-1.1 0.2-1.3-0.5-2.3-0.7-1.9-1.1-0.8-0.3-0.8-0.2-0.3 0-0.5-1.5-0.6-1.4-0.5-1.6-5.1-4.9-0.6-0.9-0.3-0.4 0.1-0.2 0.4 0 0.4-0.2 0.5-0.4 0.3-0.1 0.3 0.4 0.1 0.4 0.2 0.2 0.3 0.2 0.2-0.2 0.1-0.3 0-0.4 0-0.4-0.3-0.7-0.5 0-0.6 0.1-0.7 0-0.9-0.9-0.5-0.5-1.1-0.5-0.8-0.3-0.2-0.7-0.4-0.2 0-0.3-0.4-0.5-0.7-0.5-0.3-0.5-0.2-0.5-0.2-0.2-0.3-0.2-0.5-0.1-0.6 0.1-0.5-0.2-0.2-0.2 0.3-0.3 0.3-0.2-0.1-0.3-0.1-0.4-0.4-1.5 0-0.8-0.5-0.2 0.1-0.3 0.3-0.5 0.3-0.4 0-0.4-0.4-0.7-0.5-0.6 0.1-0.4-0.6-0.5-0.5-0.3 0.4-1.4 0-0.9-0.4-1-0.4-1.3-0.8-0.5-1.6 0-0.3 0.1-0.2 0.2-0.1 0.2 0.1 0.3-0.1 0.4-0.2-0.1-0.5-0.7-1.2-0.5-0.6-0.4-0.2-1.1 0.4-1.1 0.7-1.4 0.2-0.7 0-0.8-0.3-0.5-0.7-0.1-0.3-0.3-0.4-0.4 0.1-0.7-0.1-0.8-1.1-0.8-1.2-1.2-0.8-2.1-0.2-0.5-0.2-0.3-0.6 0-0.6-0.7-0.2-0.6-0.3-1.4-0.4-0.7-0.5-0.7-0.4-0.6-0.6-2.1-0.4-0.5-0.5-0.3-0.2 0.1-0.5-0.2-0.7 0.2-0.5-0.2-0.2-0.5 0.4-0.7-0.2-0.6 0.3-1.1 0.2-0.9-0.2-0.5-0.3-0.5-0.4-0.7 0-0.6 0.2-1.9 0-2.1-0.4-0.9-0.5-0.7-0.5-0.6-0.4-0.4-0.6-0.4-0.3 0-0.3-0.1-0.2 0.3-0.2-0.2 0.4-0.7 0-1.1 0-1.6-0.3-1.4-0.4-1-1.4-1.7-2.3-2.1-1.7-2.8-1.2-2.3-1.1-4.1-0.5-1.1 0.6-1.1 0.3-2.4 0.1-1.4-0.1-1.2-0.9-2.7 0-0.5 0.2-0.1 0.2 0.4 0.2 0.4 0.2 0.8 0.5 1.2 0.2 0.1 0.2-0.3 0.6-1.2 0.1-1.8 0-1.6 0.2-1.3-0.7-0.5-0.7-1.1-0.8-0.6-0.9-0.1 0.1 0.4 0.4 0.2 0.4 0.2-0.1 0.3-0.6-0.2-0.5-0.3-1.3-0.8-0.4-0.9-0.4-0.4-0.3-1-0.5 0-0.5 0.3-0.4 0 0.4 0.6 0.4 0.3 0.4 0.1 0.3 0.3-0.4 0.1-1.2-0.3-4.9-1-1.5-0.4-2.1-0.3-0.3-0.7-0.9-0.3-1.1-0.1-0.7-0.6 0.2-0.2 0.6 0.1 0.3-0.3-0.3-1.1-0.5-1.9 0-1.2-0.8-1.2-1.7-1.2-1.4-0.7-0.5-0.5-0.9 0-1.5-0.8-0.8-0.4-0.3-0.7-0.9 0.4-0.4 0.1-0.4 0-0.6-0.5-0.1-1.5-0.5-0.3-0.1 0.5 0 2 0 0.3 0.2 0.3 0.2 0.1 0.2 0 0-0.1 0.3 0.4-0.1 0.1-0.3 0.1-0.5 0.7-0.1 0.5-0.3 0.2-0.4 0-0.1 0.4-0.2 0.2-0.1 0.2-0.3 0.5-1.4 0-1.4-0.1-1.3 0-1.6-0.7-0.7-0.7-0.9-0.3-0.9-0.5-0.3-0.3-0.5-0.6-0.4-0.2 0-0.4-1.1-0.6-1.6-0.9-0.6-0.5-0.5-0.1-0.5-0.6-1-0.4-1.5-1.5-1.3-1.6-0.7-0.2-2.3 0.1-0.3-0.1-0.3-0.2-0.5-0.6-0.1-0.2-0.3-0.1-0.7-0.5-0.3-0.2-1.1-0.1-0.3-0.1-0.5-0.4-0.8-1.1-0.4-0.3-0.6-0.2-1.8-1.3-0.1-0.8 0-0.9 0-0.9 0.1-1-0.1-0.5 0-0.5-0.2-0.4-0.3-0.5-0.2-0.1-0.5-0.4-0.2-0.1 0-0.6 0.7-1.2 0.1-0.8-0.4-1.4-0.5-1.2-0.8-1.1-0.8-1.1-0.2-0.2 0.1-0.6 0.5-0.6 0.7-0.5 0.5-0.7 0.4-0.8 0-0.7 0-0.6 0.1-0.7 0.2-0.8 0.5-0.9 0.6-0.8 0.6-0.3 1.7 0.1 0.6-0.1 0.5-0.3 14.1 5.2 12.9 4.7 12.9 4.7 12.9 4.7 12.9 4.7 12.9 4.7 12.9 4.7 12.9 4.7 1.6 0.6 3.2 1.2 4.9 1.9 3.2 1.2 0.9 0.3 1.9 0.2 3.2 0 29.6 0 2.7 0 20.2 0 1.3 0 7.3 0z", id: "MEX2712", name: "Sonora", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Sonora', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Zacatecas" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M553.8 294.2l-0.4 1.4-0.4 1.1-0.5 0.9-1.2 0.6-1.1 0.7-0.9 0.9-0.8 1.1-0.7 1.1-1.5 2.7-1.6 2.7-1.6 2.7-1.4 2.7-0.5 0.8-0.6 0.4-0.7 0.1-0.8 0.2-0.7 0.5-0.6 0.6-0.6 0.7-0.5 0.7-1.2 1.4-1.3 1.3-1.4 1.1-1.5 1-1.3 0.7-1.3 0.7-1.2 0.8-1 1-0.3 0.5-0.2 0.6-0.2 0.5-0.4 0.5-0.4 0.2-0.6 0.1-0.5 0-0.5 0.2-1.1 0.7-1.1 1-0.8 1.1-0.8 1.2-0.8 1.1-0.9 1-1 0.9-1.1 0.8-0.6 0.4-0.6 0.3-0.7 0.3-0.6 0.1-0.6-0.3 0-0.5 0.1-0.5 0.1-0.5-0.4-0.3-0.5-0.1-0.6 0.1-0.5 0-0.3 0.4-0.2 0.6-0.3 1.3-0.1 0.6-0.2 0.8-0.2 0.7-0.4 0.4-0.5 0-0.5-0.2-0.5 0.1-0.3 0.6 0 0.7 0.3 0.3 0.4 0.3 0.4 0.3 0.4 0.5 0.2 0.7 0.3 1.4 0.3 1 0.1 0.7-0.2 0.8-0.5 0.8-0.3 0.9 0.1 0.8 0.4 0.8 0.4 0.8 0.4 0.8 0.3 0.7 0.4 0.9 0.3 0.8 0.9 1.6 1.2 1.3 1.3 1.2 1.4 1.3 0.2 0.3 0.3 0.2 0.4 0.1 0.4 0 1.1 0.7 1 1.3 0.9 1.4 0.7 1.3 0.7 0.9 0.5 0.7 0.6 0.6 0.8 0.4 0.9 0.1 0.7-0.3 0.7-0.5 0.7-0.5 0.3-0.1 0.2 0 0.2 0 0.3 0 1-0.2 0.6-0.9 0.4-1.1 0.5-1 0.9-0.6 1.3-0.2 1.4 0 1.1 0 0.7 0 0.7 0 0.7 0.1 0.5 0.5 0.4 0.9 0.4 1 0.8 1.9 0.1 0.7-0.4 0.4-0.5 0.3-0.6 0.3-0.5 0.5-0.4 0.5-0.2 0.6 0 0.8 0.3 1.1 0.8 2.3 0.3 1.2 0.3 3.1 0.1 1.1-0.1 0.5-0.3 0.5-0.3 0.4-0.3 0.4-2.6 3.5-1.3 1.8-1.3 1.7-0.1-0.7-0.2-0.5-0.4-0.1-0.6 0.1-0.5-0.1-0.5-0.5-0.5-0.7-0.5-0.5-0.4-0.3-0.4-0.3-0.5-0.3-0.4-0.2-0.5 0-0.5 0.1-0.4 0-0.5 0.1-0.8-0.2-0.7-0.5-0.7-0.6-0.7-0.5-0.5-0.3-0.4-0.6-0.4-0.6-0.5-0.5-0.5-0.5-0.8-0.5-0.9-0.4-0.7-0.4-0.4-0.9 0.1-1 0.1-1.3-0.1-1.2-0.3-0.8-0.6-0.3-1.3 0-0.6-0.3-0.4-0.4-0.3-0.4-0.4-0.3-0.6 0.1-0.4-0.4-0.3-1-0.4-0.4-0.2 0.1-0.2 0.1-0.2 0.1-0.2 0.2-0.6 0.2-0.6-0.5-0.4-0.8-0.3-0.7-0.3-0.7-0.4-0.8-0.5-0.3-0.6 0.6-0.3 0.6-0.4 0.7-0.4 0.4-0.6 0-0.4 0.2-0.3 0.3-0.3 0.4-0.3 0.3-0.3 0-0.3 0-0.3 0-0.3 0-0.2 0-0.2 0.1-0.3 0.3-0.2 0.8-0.2 0.4-0.5 0.3-0.6 0-0.6 0-0.5 0-1.1-0.1-1.2 0.1-1.1 0.5-0.7 1.1 0.1 0.5 0.5 0.5 0.3 0.6-0.1 0.9-0.4 0.8-0.6 0.8-0.7 0.7-0.6 0.7-0.6 0.7-0.5 0.8-0.5 0.9-0.4 0.8-0.5 0.6-0.4 0.6-0.4 0.6-0.4 0.6-0.2 0.7-0.2 0.7 0 0.7 0 0.7 0.3 1.3 0.7 0.9 0.9 0.6 1.1 0.7-0.3 1.5-0.2 0.8-0.2 0.9-0.1 0.9 0.3 0.7 0.6 0.1 0.5 0.3 0.4 0.3 0.6 0.3 0.5 0.1 0.6 0 0.6-0.1 0.5 0.3 0.2 1.2-0.4 1.5-0.7 1.6-0.5 1.2-0.1 0.2-0.1 0.2-0.3 0.3-0.3 0.1-0.4 0.1-0.4 0.1-0.2 0.2-0.3 0.5-0.2 0.2-0.4 0.4 0 0.6-0.1 0.5-0.4 0.4-0.7 0-0.1-0.3 0.2-0.5 0.1-0.4-0.4-0.4-0.6 0.1-0.5 0.4-0.4 0.4-0.8 0.7-0.9 0.4-1 0.2-0.9-0.1-0.7-0.2-0.8-0.2-0.7 0.1-0.3 0.7 0 2.3 0.1 1.1 0.2 1.6-0.1 1.5-0.3 1-0.8 0.1-0.8-0.5-0.9-0.6-0.7 0-1.1 0.2-1.2-0.3-1.1-0.7-1-0.6-0.9-0.5-1.1-0.6-0.6-0.3-0.6-0.2-0.5 0.1-0.5 0-0.5 0.1-0.5-0.1-0.5-0.4-0.4-0.5-0.5-0.3-0.6-0.1-0.6 0.1-0.7 0.1-0.7 0-0.6-0.2-0.5-0.3-0.1-0.5 0-0.5-0.2-0.6-0.6-0.3-0.6 0.1-0.7 0.4-0.6 0.4-0.7 0.4-0.3-0.1-0.1-0.4 0.1-0.8 0-0.7 0-0.4 0.2-0.3 0.5-0.4 0.3-0.4 0.2-0.6 0.1-0.7 0-0.6-0.1-1.2-0.2-1.2-0.3-1.1-0.3-1.2 0.7 0.3 0.7 0.5 0.7 0.4 0.7 0.1 0.6-0.4 0.4-0.7 0.7-1.4 0.7-0.5 0.9-0.4 0.7-0.5 0.1-0.8-0.1-1.1 0-1.4-0.1-1.3-0.4-0.9-0.3-0.9 0.5-0.9 0.9-0.9 0.7-0.7 1.2-1.1 0.6-0.6 0.6-0.5 0.4-0.2 0.4-0.1 0.3-0.1 0.4 0 0.4 0 0.4-0.1 0.3-0.2 0.3-0.4 0.6-0.9 0.8-0.1 0.9 0.3 1 0.1 0.6-0.1 0.5-0.2 0.4-0.4 0.3-0.6 0.3-0.9 0.3-0.5 0.4-0.3 0.8-0.3 0.2-0.4 0-0.4 0-0.5-0.1-0.4-0.5-0.3-0.5-0.1-0.3-0.1-0.1-0.8 0.1-0.4 0.4-0.1 0.4 0 0.4-0.2 0.3-0.3 0.4-0.5 0.2-0.6 0.3-0.5 0.2-0.4 0.2-0.6 0-0.6-0.2-0.5-0.3-0.2-0.4 0.1-0.4 0.1-0.4 0.1-0.1-0.5-0.1-0.3-0.1-0.3-0.4-0.3-0.5 0-0.6 0.2-0.7 0.2-0.5 0.2 0.1-0.5 0.1-0.6 0-0.6-0.1-0.3-0.5-0.3-0.5-0.3-0.9-0.7-1-0.8-1-0.8-1-0.9-1-0.9-0.2 0.3-0.1 0.3-0.4 0.5-0.3 0.6-0.5 1.3-0.2 0.4 0 0.3 0.2 0.1 0.4 0.2 0.3 0.2 0.1 0.3 0.1 0.3 0.3 0.2 0.4 0 0.3 0.1 0.1 0.3-0.1 0.4-0.2 0.1-0.5 0.4-0.3 0.1-0.3 0.8 0 0.9-0.2 0.7-0.6 0.3-0.7 0.3-0.4 0.9-0.3 1-0.3 0.8-0.3 0.9-0.3 0.4-0.1-0.3-0.2-0.3-0.4-0.1-0.4 0-1.1-0.2-0.3 0.1-0.5 0.6-0.3 0.2-0.4 0.2-0.8 0.2-0.5-0.1-0.6-0.7 0-1 0.1-0.6 0.3-1.3 0-0.6-0.1-0.7-0.1-0.6-0.2-0.6-0.2-0.5 0-0.4 0.1-0.4 0.2-0.6 0.3-1.1 0.4-1.8 0.6-1.5 0.7-0.5 0.1-0.7 0-0.3-0.1-0.3-0.2-0.1-0.4-0.1-0.3 0-0.2-0.2 0-0.4 0.1-0.4 0.1-0.4-0.2-0.3-0.4-0.1-0.6 0-0.7 0-0.4 0-0.2-0.2-0.1-0.2-0.2-0.1-0.3 0.2-0.7 1.4-0.5 1.6-0.3 1.8-0.3 1.5-1.7 7.4-0.1 0.6-0.3-0.3-0.3-0.6-0.3-0.8-0.1-0.6-0.1-0.7-0.1-0.6-0.1-0.6 0-0.7 0.1-0.7 0.2-0.5 0.3-0.5 0.2-0.6 0-0.6-0.1-0.5-0.3-0.5-0.2-0.5 0-0.5 0.3-0.3 0.4-0.2 0.3-0.3 0.2-0.5 0-0.5 0-0.5-0.1-0.5 0-0.6 0.3-0.4 0.4-0.3 0.6-0.4 0.5-0.8 0.2-1.3 0.2-1.4 0.1-1.1-1.6-0.3-3.2-0.7-1.6-0.3-0.2 4.9-0.1 1.1 0 0.8 0.2 0.6 0.7 0.6 0.8 0.6 0.3 0.5 0.1 0.5-0.2 1-0.5 2.8-0.2 0.4-0.2 0.1-0.6 0.2-1.6 0.3-1.6 0.1-1.6 0.1-1.6 0.5-1.1 0.6-1.2 0.5-1.2 0.5-1.2 0.6 0.4-0.9 0.1-0.5 0.1-0.4 0.5-1.8 1-3.5 0.5-1.7 0.4-1.3 0.5-1.4 0.3-1.4 0.2-1.4 0.1-3.7 0.1-3.7 0.1-3.7 0.2-3.7 0.1-0.9 0.2-0.4 0.4-0.3 0.7-0.3 0.3-0.5 0.1-0.8 0.1-1.6 0.2-1.3 0.3-4 0.1-0.8 0.2-0.6 0.3-0.3 0.7-0.5 0.9-0.6 1-0.6 0.9-0.7 0.9-0.7 0.4-0.6 0.1-0.6 0.1-0.7 0.1-0.7 0.4-0.9 0.7-0.4 0.7 0.2 0.7 0.8 0.6 0.2 0.4-0.6 0.3-0.9 0.1-0.7-0.4-0.8-0.7-0.6-0.8-0.5-0.4-0.9 0.3-0.4 0.2-0.5 0.3-0.4 0.2-0.5-0.1-0.8-0.4-0.7-0.5-0.5-0.5-0.6-0.3-0.8 1-0.3 1.1-0.4 0-1.1-0.2-0.9 0.1-0.9 0.1-0.7-0.2-0.7 0.3-0.5 1.1-0.7 1.4-0.6 0.8-0.3 0.9-0.4 1-0.7 0.6-0.7 0.6-0.9 0.7-1.1 0.2-0.4 0.2-0.5 0.2-0.4 0.4-0.4 0.6-0.1 0.6 0 0.4-0.2 0.2-0.5 0-0.5 0.2-0.5 0.4-0.2 0.5-0.1 0.5 0 0.7 0 0.6-0.1 0.5-0.2 0.3-0.5 0-0.6 0-0.6 0.2-0.6 0.9-0.8 1.3-0.7 1.4-0.5 1.2-0.3 5.6 1.2 5.6 1.2 1.4 0.2 1.4 0.2 1.4 0.1 1.4-0.3 1.4-0.4 1.5-0.4 1.4-0.3 2.2-0.2 0.4-0.2 0.1-0.5 0-0.9 0-2.3 0-2.3 0-2.2 0-2.2 0-2.2-0.4-1.3-0.8-1.3-1-1.2-0.9-1.1-0.7-0.9-0.7-1-0.6-1-0.5-1.1 0.6-0.9 0.5-0.4 0.6-0.2 1-0.1 7-0.7 2.3-0.3 0.9-0.1 0.9-0.2 0.9-0.1 0.9 0.1 9.8 3 0.6 0.6 0.6 1.2 0.5 1.2 0.4 0.9 0.9 0.9 1.1 0.7 1.3 0.3 1.2 0 0.5 0 0.5 0.3 0.5 0.3 0.4 0.3 0.3 0.6 0.2 0.7 0 0.7 0.1 0.7-0.7-0.1-0.6-0.2-0.6-0.2-0.7-0.2 0.2 0.6 0.3 0.8 0.3 0.7 0.4 0.3 0.9 0 2.6 0.2 0.7 0 0.7 0.1 0.6-0.1 0.6-0.4 1.2-1.3 0.7-0.7 0.6-0.6 0 0.2 0.1 0.5 0 0.2 1.3-0.3 1.1-0.1 1.1 0.2 1.1 0.7 0.4 0.5 0.4 0.5 0.4 0.6 0.3 0.6 0.3 0.5 0.1 0.6 0.2 0.6 0.2 0.6 0.8 0.9 1.2 0.8 1.3 0.6 1.2 0.1 0.6-0.2 0.6-0.2 0.5-0.1 0.6 0.2 1.3 0.7 0.6 0.4 0.6 0.4z", id: "MEX2713", name: "Zacatecas", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Zacatecas', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Nuevo Le\u00F3n" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M586 181.5l0.3 0.3 0.3 0.5 0.4 0.4 0.3 0.2 0.5 0.2 0.3 0.1 0.1 0.3 0.1 0.5 0.1 0.3 0.2 0.2 0.4 0.6-1.7 0.8-1.6 0.8-1.5 0.9-1.5 1-0.1 0.5 0 0.8 0.1 0.9 0.2 0.3 4 0.7 0.7 1.1 0.5 2.4 0.3 2.6 0.2 1.6 0.2 1.5 0.2 0.8 0.2 0.5 0.7 0.6 0.2 0.5-0.1 0.7-0.3 1-0.6 1.7-0.7 2.3-0.1 2.2 1 1.2 0.4 0 0.2 0.1 0.2 0.1 0.2 0.1 0.6 0.1 0.5 0.1 0.1 0 0.4 0.3 0.3 0.2 0.4 0.2 0.4 0.2 0.1 0.2 0.1 0.3 0.2 0.2 0.3 0.1-0.5 0.6-0.5 0.7-0.4 0.6-0.1 0.8 0 0.9-0.3 0.6-0.5 0.5-0.6 0.7 0.7 0 0.6 0 0.7-0.1 0.6 0 0.4 0 0.5 0.2 0.5 0.3 0.4 0.2 1 0.4 1.1 0.4 1.1 0.7 0.7 0.9 0.2 1 0 1-0.3 1-0.4 0.9-0.4 0.5-0.1 0.3-0.1 0.5 0 0.7 0 0.6 0.2 0.5 0.3 0.6 0.5 0.6 0.8-0.4 0.7-0.6 0.4-0.1 0.2 0.5 0.3 0.5 0.3 0.4 0.3 0.4 1.4 1.8 0.4 0.2 0.5 0 1-0.1 0.4 0.1 0.2 0.3 0.2 1 0.2 1.7 0.1 2.2 0.2 2 0.6 0.9 0.2-0.2 0.3-0.4 0.3-0.2 0.2 0 0.4 0.1 0.3 0 0.1-0.1 0.3-0.5 0.2-0.1 0.7-0.1 0.6 0.3 0.4 0.4 0.5 0.6 0.8 0.8 0.8 0.9 0.8 0.8 0.8 0.7 0.4-0.7 0.4-1 0.5-0.8 0.5-0.6 0.7 0 0.9 0.2 0.8 0.3 0.7 0.3 2 0.5 3.2 0.9 0.4 0.9 0.1 1.9-0.1 1.9 0 1.3 0 7.2 0 1-0.2 1.6 0 1.5 0.2 0.9 0.5 0.2 0.8 0 1.3-0.1 0.5 0.1 0.2 0.1 0.1 0.3 0.1 1.3-0.4 0.5-0.6 0.4-0.5 0.4-1.1 0.9-3.3 2.8-3.4 2.9-1.7 1.4-1.7 1.5-0.7 0.5-0.6 0.5-0.6 0.2-0.7 0.1-0.8 0.2-0.8 0-0.7-0.3-0.5-0.7-0.5-0.7-0.4 0.1-0.4 0.6-0.4 0.7-0.6 0.2-0.2 0.4-0.3 0.5-0.6 0-0.6-0.2-0.2 0.3 0.1 0.5 0.2 0.6-0.5-0.1-0.5 0.1-0.4 0.2 0.1 0.4 0.3 0.4 0.4 0.5 0.4 0.5 0.2 0.3-0.2 0.4-0.3 0.5-0.4 0.4-0.3 0.4-0.4 0.7 0 0.8 0.3 0.8 0.4 0.7 0.1 0.3 0.1 0.3 0 0.3 0 0.4-0.7-0.2-0.9-0.3-0.8-0.3-0.7-0.4-0.6-0.5-0.4-0.1-0.3 0.2-0.4 0.5-0.3 0.3-0.3 0.3-0.3 0.1-0.4 0.1-0.7 0.1-0.6-0.1-0.5 0.1-0.5 0.5-0.1 0.2-0.1 0.2-0.1 0.1-0.3 0.2-0.2 0-0.5 0.1-0.2 0.1-0.4 0.4-0.1 0.4 0 0.5-0.1 0.6-0.1 0.4-0.2 0.1-0.2 0.1-0.4 0.1-0.2 0.2-0.2 0.3-0.3 0.2-0.2 0-0.3 0-0.2-0.3-0.3-0.1-0.2-0.1-0.6 0.2-0.7 0.2-0.7 0.3-0.5 0.4-0.6 0.5-0.5 0.5-1.1 1 0 0.7 0.2 0.9 0.6 1.8 3.3-1.4 0.4 1.8 0.4 2 0.1 0.8 0.1 0.6 0 0.6-0.2 0.7-0.3 0.9-0.2 0.9-0.2 0.9-0.3 0.9-0.1 1.2 0 1.7 0.2 1.5 0.5 1 0.5 0.4 1 1 0.5 0.5 0.6 0.4 0.6 0.4 0.5 0.5 0.4 0.5 0.2 0.7 0.1 0.8 0.1 0.5 0 0.3-0.4 0-0.4-0.1-0.5-0.1-0.3 0.2-2.6 3.7-0.5 0.6-0.9 0.1-0.9 0-0.9 0.1-0.8 0.2-1 0.1-0.9 0-0.9 0-0.7 0.1-0.3 0.1-0.3 0.2-0.4 0.4-0.4 0.7-0.3 0.7-0.3 0.6-0.4 0.8-0.4 0.9-0.4 0.8-0.3 0.9-0.4 0.7-0.2 0.4 0 0.4 0.4 1.3 0.3 1.3 0.7 2.6-0.8-0.2-0.8-0.2-0.9-0.4-0.7-0.3-1.1-0.2-0.9 0.4-0.8 0.8-0.9 0.8 0.7 0.4 0.8 0.5 0.7 0.5 0.3 0.6-0.3 1.9-2.1-0.3-2.2-0.1-2.1 0-2.1 0 0 0.9 0 0.9-0.1 0.3-0.3 0.1-0.9-0.2-1-0.2-0.7-0.3-0.6-0.6-0.3-1-0.2-0.8 0-0.6 0-0.2 0-1.2 0-0.6 0-0.6-0.1-0.5-0.2-0.5-0.2-0.5 0-0.6 0.1-0.5 0.2-0.6 0.2-0.6 0.1-0.6-0.1-0.4-0.1-0.5-0.3-0.9-0.3-1.2-0.3-1.3-0.2-1.2 0.2-1.2 0.2-1.1 0.1-1-0.1-1.1-0.2-1.1-1-1.3-1-1.2-0.9-1.3-0.5-1.5-0.3-1.8 0-1.9 0-1.8 0-1.8 0-1.1-0.1-1.1-0.1-1.2-0.2-0.9-0.4-0.7-0.6-0.7-0.6-0.6-0.5-0.7-1.1-1.5-1.1-1.6-1.1-1.6-1.2-1.4 0.3-1.6 0.5-1.7 0.5-1.6 0.4-1.6 0.2-0.9 0-0.7-0.2-0.8-0.3-0.9-0.3-1-0.1-0.6 0.1-0.6 0.7-0.5 0.6-0.4 0.5-0.4 0.1-0.5-0.4-0.7-1-1-0.5-0.5-0.6-0.1-0.8-0.5 0.5-1.3 0.8-1.5 0.8-0.9 1.8-1.2 1.8-1 1.9-0.6 2.1 0 0.8 0.2 0.8 0.2 0.8 0.3 0.8 0.3 0.8 0.3 0.7-0.1 0.7-0.1 0.8-0.3 0.5 0 0.7 0 0.7 0.1 0.4-0.2 0-0.3-0.1-0.8 0-0.3 0.1-0.3 0.3-0.2 0.3-0.1 0.3-0.1 1-0.3-0.4-0.5-1-0.6-0.8-0.5-0.8-0.6-0.3-0.2-0.5 0-0.6 0-0.6-0.1-0.6-0.1-0.5-0.1-0.6 0.1-0.6 0.2-0.7 0.2-0.5-0.1-0.3-0.3 0-0.3 0.2-0.3 0-0.3-0.8-0.7-1.2-0.3-1.2-0.3-0.8-0.8-0.2-0.7-0.7-0.7-1.2-0.5-1-0.5 0.2-0.7 0.8-0.1 1.1 0.3 1 0.5 0.9 0.3 0-0.5 0-0.4-0.1-0.4-0.3-0.4-0.4-0.2-0.9 0-0.4-0.2 0-0.3 0-0.4 0.1-0.3-0.2-0.4-0.3-0.2-0.2-0.2-0.3-0.1-0.3-0.1-0.8 0-0.6-0.1-0.6-0.3-0.6-0.7-0.8-1.1-0.8-1.2-0.7-1.3-0.5-1.3-0.2-1.2 0-1.3 0.2-1.3 0.1-1.3-0.1-0.9-0.8-0.5-0.9-0.4-0.7-0.6-0.3-0.9 0-1-0.1-0.9-0.3-1-0.4-0.5-0.5-0.5-0.5-0.4-0.6-0.2-0.6 0-0.4-0.1-0.3-0.3-0.4-0.6-0.3-0.5-0.2-0.6-0.1-0.6-0.1-0.6-0.8-1.2-1.1-1.2-1.2-1.1-1-0.9 2.3-2.1 2.4-2 2.2-1.9 2.1-1.9 2.2-1.9 2.2-1.8 1.2-1 1.3 4 0.5-0.5 0.6-0.5 0.5-0.5 0.5-0.5 1.1-1.5 0.7-1.7 0.5-1.8 0.5-1.8 0.1-0.7 0-0.7 0-0.8-0.1-0.7 0-0.8 0.1-1.1-0.1-1.1-0.2-0.7-0.6-0.4-0.8-0.1-0.9-0.1-0.6-0.4-0.4-0.6-0.2 0-0.1 0.4-0.2 0.5-0.2 0.1-0.3 0-0.3 0-0.2 0.2 0 0.2 0.2 0.2 0.1 0.2 0.1 0.2-0.1 0.5-0.4 0.3-0.5 0.1-0.7 0.1 0.1-0.9-0.4-0.4-0.6-0.1-0.5-0.2-0.5-4.3 0.1-0.7 0.3-0.4 0.5-0.4 0.6-0.3 2.8-1.8 0.4-0.4 0.4-0.5 0.4-0.4 0.4-0.3 3.7-1.4 0.2 0 0.1 0.3 0 0.3 0.2 0.2 0.3 0 0.3-0.1 0.6-0.3 0.7-0.9 0.4-1.7 0.3-2 0.3-1.5 0.3-1.2 0.3-1.5 0.3-1.4 0.5-1.2 0.8-0.9 1.2-0.9 1.2-0.7 1.1-0.8 0.6-0.5 0.4-0.3 0.2-0.1 5.8 4.9 0.5 0.5 0.2 0.1 0.3 0 1.8-1.7 0.8-0.8 0.8-0.8 0.8-0.7 0.9-0.7z", id: "MEX2714", name: "Nuevo Le\u00F3n", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Nuevo León', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "San Luis Potos\u00ED" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M578.1 339.8l-0.2 1.1-0.6 2-0.2 1.1 0.5-0.5 0.8-0.7 0.8-0.5 0.5 0.1 0.1 0.7 0 0.6 0.1 0.6 0.3 0.6 0.8 0.9 0.9 0.8 0.7 0.9 0.2 1.1-0.1 0.5-0.2 0.5-0.2 0.4-0.3 0.3-0.7 0.5-0.7 0.3-0.8 0.2-0.7 0.5-0.4 0.4-0.1 0.4 0.2 0.4 0.3 0.5 0.3 0.4 0.1 0.4 0.1 0.4 0.1 0.6 0.2 0.2 0.4 0.2 0.5 0.2 0.4 0.1 0.7 0.3 1.5 0.7 0.7 0.3 1.6 0.6 1.7 0.7 1.7 0.7 1.6 0.7 0.6 0.2 0.6 0.2 1.2 0.4 0.8 0.3 0.6 0.1 0.3-0.3 0-0.9-0.1-0.5-0.3-0.9-0.1-0.5-0.1-0.4-0.1-0.2 0-0.1 0.3-0.1 0.3 0.1 0.4 0.3 0.6 0.5 0.4 0.6 0.6 0.7 0.5 0.7 0.6 0.4 0.5-0.2 0.4-0.4 0.7-1.1 0.3 0.4 0.1 0.2 0.1 0.2 0.5 0.9 1.1 1.9 0.4 1 0.4 0.8 0.3 0.8 0.4 0.8 0.6 0.7 0.6 0.5 0.7 0.2 0.7 0.1 0.8 0.1 0.9 0.2 0.9 0.2 0.9 0.3 0.9 0.2 0.3 0.1 1.1 0.4 0.9 0.4 1 0.3 1.1 0.1 0.6 0.1 0.9 0.2 0.8 0 0.6-0.1 0.4-0.4 0.3-0.4 0.3-0.4 0.5-0.3 0.9-0.1 1.1-0.1 0.9-0.3 0.5-0.7 0.3 0.2 0.3 0.2 0.3 0.2 0.4 0.2 0.2 0.1 0.5 0.4 0.7 0.4 0.6 0.5 0.6 0.5 0.6 0.5 0.9 0.5 1.9 1.1 0.9 0.6 0.7 0.6 0.6 0.7 0.2 0.8 0 1-0.4 1.3-0.6 1.4-1.4 2.4-0.3 0.5-0.2 0.5-0.3 1.1-0.2 0.1-0.3-0.3-0.3 0.4-0.3 0-0.3-0.1-0.4-0.1-0.4 0-0.4 0.2-0.2 0.1-1.2-0.2-0.3-0.1-0.1 0 0.1 1 0.5 0 0.8-0.2 0.6-0.1 0 0.3-0.4 0.3-0.3 0.4 0.2 0.7-0.7 0.2 0.1 0.7 0.5 0.8 0.4 0.4 1.3-0.2 0.2 0.4 0 0.4 0 0.4 0.3 0.1 0.5 0.2 0.1 0.4-0.1 0.5-0.2 0.3-0.3 0.4-0.4 0.3-0.8 0.5-0.1 0.1-0.1 0.3-0.1 0.1-0.2-0.1-0.4-0.2-0.2 0-0.3 0.2-0.2 0.2 0 0.3 0.3 0.2-0.5 0.5-1.2-0.2-0.5 0.4-0.1 0.9 0.1 0.6 0 0.5-0.4 0.4-0.1 0.2 0.3 0.7 0.4 0.5 0.6 0.4 1.6 0.8 0.6 0.5 0.3 0.7 0.1 1 0 0.7 0.1 0.6 0 0.6 0 0.6-0.5 0.2-0.5 0.1-0.9 0.3-0.3 0.2-0.2 0.2 0 0.3 0.1 1.5 0.1 1.2-0.1 1.2-0.2 1.2-0.3-0.2-0.3 0-0.3 0.1-0.2 0.2-0.2 0.2-0.3 0-0.2 0-0.3 0-0.5-0.2-0.4-0.1-0.8 0.1-0.8 0.3-0.8 0.3-0.7 0.4-0.6 0.1-0.5 0-0.6-0.3-0.5-0.3-0.8-0.3-0.4-0.2-0.3-0.3-0.2-0.3-0.1-0.5-0.1-0.4-0.2-0.7-0.2-0.2-0.1-0.2-0.2-0.2-0.8-0.2-1 0-0.9 0.3-0.6 0.7-0.4-0.4-0.6-0.3-0.6-0.1-0.5 0 0.1-0.6 0.3-2 0-0.5-0.3-0.5-0.5-1-0.3-0.9-0.3-0.8-0.3-0.9-0.3-0.8-0.2-0.9-0.9-3.1-0.1 0.7-0.5 0.6-0.8 0.4-0.5 0.5 0 0.4 0 0.4 0 0.3-0.3 0.3-0.3 0.2-0.3 0.1-0.2 0-0.6-0.3-0.1 0-0.2 0.1-0.2 0.1-0.2 0.3-0.1 1-0.2 0.2-0.2 0.2-0.1 0.3-0.3 0.5-0.3 0.5-0.1 0.2-0.2 0.2-0.4 0.1-0.4-0.1-0.4-0.1-0.4 0.1-0.5 0.1-0.3 0.1-0.2 0.1-0.4 0.6-0.8 0.1-0.9 0-0.7 0-0.2 0.1-0.2 0.1-0.2 0.2-0.4-0.1-0.3-0.2-0.4-0.5-0.3-0.2-0.4-0.2-0.1-0.4-0.2-0.4-0.2-0.4-0.2-0.2-0.2-0.1-0.2-0.2-0.2-0.2-0.3-0.3-0.4-0.3-0.5-0.3-0.4-0.2-0.9 0.3-0.5 0.9-0.4 1.1-0.4 1-1-0.5-0.8-0.5-1-0.3-1.2 0-1.3-0.1-1.3-1-1.2-1.3-1.2-0.9-0.3-0.2-1.1-0.3-1-0.4-1-0.3-1.1-0.3-0.4-0.1-0.4-0.1-0.3-0.2-0.4-0.2-0.6-0.3-0.6-0.2-0.6-0.3-0.5-0.3-0.4-0.2-0.3-0.1-0.3-0.1-0.4-0.1-0.2-0.2-0.2-0.2-0.3-0.1-0.4 0-0.3 0.2-0.4 0.2-0.3 0.3-0.2 0.3-0.2 0.4-0.2 0.4-0.2 0.5-0.1 0.4-0.2 0.7-0.1 0.8-0.1 0.7-0.3 0.7-0.7 0.5-1.1 0.2-1.1 0-1.1 0-0.7-0.5-0.6-0.5-0.7-0.6-0.6-0.6-1.5-1.1-1.5-1.2-1.5-1.2-1.4-1.2-1-1-0.5-0.5-0.5-0.4-1-0.3-1-0.3-1.1-0.1-1 0-1.1 0.1-1.2 0.3-1.2 0.2-1.1-0.1-0.4-0.2-0.3-0.3-0.4-0.3-0.2-0.3-0.2-0.5-0.1-0.5 0.1-0.5-0.1-0.5-0.5-0.6-0.7-0.2-0.8 0.1-0.7 0.3-0.3 0.1-1.2 0.8-0.9 0.4-1 0-1.2-0.7 1.3-1.7 1.3-1.8 2.6-3.5 0.3-0.4 0.3-0.4 0.3-0.5 0.1-0.5-0.1-1.1-0.3-3.1-0.3-1.2-0.8-2.3-0.3-1.1 0-0.8 0.2-0.6 0.4-0.5 0.5-0.5 0.6-0.3 0.5-0.3 0.4-0.4-0.1-0.7-0.8-1.9-0.4-1-0.4-0.9-0.5-0.5-0.7-0.1-0.7 0-0.7 0-1.1 0-1.4 0-1.3 0.2-0.9 0.6-0.5 1-0.4 1.1-0.6 0.9-1 0.2-0.3 0-0.2 0-0.2 0-0.3 0.1-0.7 0.5-0.7 0.5-0.7 0.3-0.9-0.1-0.8-0.4-0.6-0.6-0.5-0.7-0.7-0.9-0.7-1.3-0.9-1.4-1-1.3-1.1-0.7-0.4 0-0.4-0.1-0.3-0.2-0.2-0.3-1.4-1.3-1.3-1.2-1.2-1.3-0.9-1.6-0.3-0.8-0.4-0.9-0.3-0.7-0.4-0.8-0.4-0.8-0.4-0.8-0.1-0.8 0.3-0.9 0.5-0.8 0.2-0.8-0.1-0.7-0.3-1-0.3-1.4-0.2-0.7-0.4-0.5-0.4-0.3-0.4-0.3-0.3-0.3 0-0.7 0.3-0.6 0.5-0.1 0.5 0.2 0.5 0 0.4-0.4 0.2-0.7 0.2-0.8 0.1-0.6 0.3-1.3 0.2-0.6 0.3-0.4 0.5 0 0.6-0.1 0.5 0.1 0.4 0.3-0.1 0.5-0.1 0.5 0 0.5 0.6 0.3 0.6-0.1 0.7-0.3 0.6-0.3 0.6-0.4 1.1-0.8 1-0.9 0.9-1 0.8-1.1 0.8-1.2 0.8-1.1 1.1-1 1.1-0.7 0.5-0.2 0.5 0 0.6-0.1 0.4-0.2 0.4-0.5 0.2-0.5 0.2-0.6 0.3-0.5 1-1 1.2-0.8 1.3-0.7 1.3-0.7 1.5-1 1.4-1.1 1.3-1.3 1.2-1.4 0.5-0.7 0.6-0.7 0.6-0.6 0.7-0.5 0.8-0.2 0.7-0.1 0.6-0.4 0.5-0.8 1.4-2.7 1.6-2.7 1.6-2.7 1.5-2.7 0.7-1.1 0.8-1.1 0.9-0.9 1.1-0.7 1.2-0.6 0.5-0.9 0.4-1.1 0.4-1.4 1.2 1.4 1.1 1.6 1.1 1.6 1.1 1.5 0.5 0.7 0.6 0.6 0.6 0.7 0.4 0.7 0.2 0.9 0.1 1.2 0.1 1.1 0 1.1 0 1.8 0 1.8 0 1.9 0.3 1.8 0.5 1.5 0.9 1.3 1 1.2 1 1.3 0.2 1.1 0.1 1.1-0.1 1-0.2 1.1-0.2 1.2 0.2 1.2 0.3 1.3 0.3 1.2 0.3 0.9 0.1 0.5 0.1 0.4-0.1 0.6-0.2 0.6-0.2 0.6-0.1 0.5 0 0.6 0.2 0.5 0.2 0.5 0.1 0.5 0 0.6 0 0.6 0 1.2 0 0.2 0 0.6 0.2 0.8 0.3 1 0.6 0.6 0.7 0.3 1 0.2 0.9 0.2 0.3-0.1 0.1-0.3 0-0.9 0-0.9 2.1 0 2.1 0 2.2 0.1 2.1 0.3z", id: "MEX2715", name: "San Luis Potos\u00ED", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'San Luis Potosí', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Tamaulipas" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M648.7 358.5l-0.9 0.4 0.2-0.4 0.5-0.5 0.2-0.3 0.6-1.5 0.3-0.4 0.1 0.7-0.4 1.1-0.6 0.9z m1.1 14.4l-0.2 0.2-0.9 0.6-0.3 0.1-0.3 0.2-0.2 0.4-0.3 0.3-0.4 0.1-0.3-0.4-0.3-0.4-0.3-0.3-0.6-0.6-0.1-0.5 0.4-0.4 0.2-0.4-0.4-0.4-0.5-0.3-0.6-0.4-0.6-0.4-0.5-0.1-0.8 0-0.8-0.3-0.8-0.3-0.7 0-0.5-0.1-0.5-0.4-0.6-0.5-0.5-0.4-0.6-0.5-0.3-0.9-0.2-0.7-0.6-0.2-0.4 0.1-0.3 0.2-0.3 0.2-0.3 0.1-0.4 0.1-0.1 0-0.2-0.1-0.4-0.2-0.5 0-0.2 0.7 0 0.8-0.1 0.6-0.3 0.2-0.5 0-0.4-0.1-0.4-0.2-0.5 0.3-0.2-0.4-0.2-0.5-0.3 0.1-0.5 0.4-0.3-0.1-0.3-0.3-0.5-0.3-0.2 0.1-0.1 0.1-0.1 0.1-0.5-0.4-0.2 0-0.1 0.1-0.2 0-1-0.1-1 0.2-1.1 0.2-1.1 0.2-0.4-0.2-0.3-0.2-0.3-0.2-0.3-0.2-0.5 0.7-0.9 0.3-1.1 0.1-0.9 0.1-0.5 0.3-0.3 0.4-0.3 0.4-0.4 0.4-0.6 0.1-0.8 0-0.9-0.2-0.6-0.1-1.1-0.1-1-0.3-0.9-0.4-1.1-0.4-0.3-0.1-0.9-0.2-0.9-0.3-0.9-0.2-0.9-0.2-0.8-0.1-0.7-0.1-0.7-0.2-0.6-0.5-0.6-0.7-0.4-0.8-0.3-0.8-0.4-0.8-0.4-1-1.1-1.9-0.5-0.9-0.1-0.2-0.1-0.2-0.3-0.4-0.7 1.1-0.4 0.4-0.5 0.2-0.6-0.4-0.5-0.7-0.6-0.7-0.4-0.6-0.6-0.5-0.4-0.3-0.3-0.1-0.3 0.1 0 0.1 0.1 0.2 0.1 0.4 0.1 0.5 0.3 0.9 0.1 0.5 0 0.9-0.3 0.3-0.6-0.1-0.8-0.3-1.2-0.4-0.6-0.2-0.6-0.2-1.6-0.7-1.7-0.7-1.7-0.7-1.6-0.6-0.7-0.3-1.5-0.7-0.7-0.3-0.4-0.1-0.5-0.2-0.4-0.2-0.2-0.2-0.1-0.6-0.1-0.4-0.1-0.4-0.3-0.4-0.3-0.5-0.2-0.4 0.1-0.4 0.4-0.4 0.7-0.5 0.8-0.2 0.7-0.3 0.7-0.5 0.3-0.3 0.2-0.4 0.2-0.5 0.1-0.5-0.2-1.1-0.7-0.9-0.9-0.8-0.8-0.9-0.3-0.6-0.1-0.6 0-0.6-0.1-0.7-0.5-0.1-0.8 0.5-0.8 0.7-0.5 0.5 0.2-1.1 0.6-2 0.2-1.1 0.3-1.9-0.3-0.6-0.7-0.5-0.8-0.5-0.7-0.4 0.9-0.8 0.8-0.8 0.9-0.4 1.1 0.2 0.7 0.3 0.9 0.4 0.8 0.2 0.8 0.2-0.7-2.6-0.3-1.3-0.4-1.3 0-0.4 0.2-0.4 0.4-0.7 0.3-0.9 0.4-0.8 0.4-0.9 0.4-0.8 0.3-0.6 0.3-0.7 0.4-0.7 0.4-0.4 0.3-0.2 0.3-0.1 0.7-0.1 0.9 0 0.9 0 1-0.1 0.8-0.2 0.9-0.1 0.9 0 0.9-0.1 0.5-0.6 2.6-3.7 0.3-0.2 0.5 0.1 0.4 0.1 0.4 0 0-0.3-0.1-0.5-0.1-0.8-0.2-0.7-0.4-0.5-0.5-0.5-0.6-0.4-0.6-0.4-0.5-0.5-1-1-0.5-0.4-0.5-1-0.2-1.5 0-1.7 0.1-1.2 0.3-0.9 0.2-0.9 0.2-0.9 0.3-0.9 0.2-0.7 0-0.6-0.1-0.6-0.1-0.8-0.4-2-0.4-1.8-3.3 1.4-0.6-1.8-0.2-0.9 0-0.7 1.1-1 0.5-0.5 0.6-0.5 0.5-0.4 0.7-0.3 0.7-0.2 0.6-0.2 0.2 0.1 0.3 0.1 0.2 0.3 0.3 0 0.2 0 0.3-0.2 0.2-0.3 0.2-0.2 0.4-0.1 0.2-0.1 0.2-0.1 0.1-0.4 0.1-0.6 0-0.5 0.1-0.4 0.4-0.4 0.2-0.1 0.5-0.1 0.2 0 0.3-0.2 0.1-0.1 0.1-0.2 0.1-0.2 0.5-0.5 0.5-0.1 0.6 0.1 0.7-0.1 0.4-0.1 0.3-0.1 0.3-0.3 0.3-0.3 0.4-0.5 0.3-0.2 0.4 0.1 0.6 0.5 0.7 0.4 0.8 0.3 0.9 0.3 0.7 0.2 0-0.4 0-0.3-0.1-0.3-0.1-0.3-0.4-0.7-0.3-0.8 0-0.8 0.4-0.7 0.3-0.4 0.4-0.4 0.3-0.5 0.2-0.4-0.2-0.3-0.4-0.5-0.4-0.5-0.3-0.4-0.1-0.4 0.4-0.2 0.5-0.1 0.5 0.1-0.2-0.6-0.1-0.5 0.2-0.3 0.6 0.2 0.6 0 0.3-0.5 0.2-0.4 0.6-0.2 0.4-0.7 0.4-0.6 0.4-0.1 0.5 0.7 0.5 0.7 0.7 0.3 0.8 0 0.8-0.2 0.7-0.1 0.6-0.2 0.6-0.5 0.7-0.5 1.7-1.5 1.7-1.4 3.4-2.9 3.3-2.8 1.1-0.9 0.5-0.4 0.6-0.4 0.4-0.5-0.1-1.3-0.1-0.3-0.2-0.1-0.5-0.1-1.3 0.1-0.8 0-0.5-0.2-0.2-0.9 0-1.5 0.2-1.6 0-1 0-7.2 0-1.3 0.1-1.9-0.1-1.9-0.4-0.9-3.2-0.9-2-0.5-0.7-0.3-0.8-0.3-0.9-0.2-0.7 0-0.5 0.6-0.5 0.8-0.4 1-0.4 0.7-0.8-0.7-0.8-0.8-0.8-0.9-0.8-0.8-0.5-0.6-0.4-0.4-0.6-0.3-0.7 0.1-0.2 0.1-0.3 0.5-0.1 0.1-0.3 0-0.4-0.1-0.2 0-0.3 0.2-0.3 0.4-0.2 0.2-0.6-0.9-0.2-2-0.1-2.2-0.2-1.7-0.2-1-0.2-0.3-0.4-0.1-1 0.1-0.5 0-0.4-0.2-1.4-1.8-0.3-0.4-0.3-0.4-0.3-0.5-0.2-0.5-0.4 0.1-0.7 0.6-0.8 0.4-0.5-0.6-0.3-0.6-0.2-0.5 0-0.6 0-0.7 0.1-0.5 0.1-0.3 0.4-0.5 0.4-0.9 0.3-1 0-1-0.2-1-0.7-0.9-1.1-0.7-1.1-0.4-1-0.4-0.4-0.2-0.5-0.3-0.5-0.2-0.4 0-0.6 0-0.7 0.1-0.6 0-0.7 0 0.6-0.7 0.5-0.5 0.3-0.6 0-0.9 0.1-0.8 0.4-0.6 0.5-0.7 0.5-0.6-0.3-0.1-0.2-0.2-0.1-0.3-0.1-0.2-0.4-0.2-0.4-0.2-0.3-0.2-0.4-0.3-0.1 0-0.5-0.1-0.6-0.1-0.2-0.1-0.2-0.1-0.2-0.1-0.4 0-1-1.2 0.1-2.2 0.7-2.3 0.6-1.7 0.3-1 0.1-0.7-0.2-0.5-0.7-0.6-0.2-0.5-0.2-0.8-0.2-1.5-0.2-1.6-0.3-2.6-0.5-2.4-0.7-1.1-4-0.7-0.2-0.3-0.1-0.9 0-0.8 0.1-0.5 1.5-1 1.5-0.9 1.6-0.8 1.7-0.8 0.2 0.2 0.1 0.2 1.1 0 0.2 0.2 0.4 0.6 0.1 0.1 0.3 0 0.7-0.4 0.4-0.1 0.3 0.2 0.4 0.7 0.2 0.1 0.5 0.2 0.6 0.3 0.7 0.6 0.2 0.5 0 1.5-0.1 0.8 0 0.3 0.2 0.2 0.5 0 0.3 0.2 0.1 0.3 0.1 0.5 0 0.1 0 1.3-0.1 0.5-0.3 0.8-0.1 0.7-0.1 0.5-0.1 0.3-0.1 0.4-0.5 0.6-0.2 0.3 0.9 0.4 0.2 0.1 0 0.1 0.1 0.3 0.1 0.1 0.3 0.2 0.1 0.1 0.5 0.5 0.3 0.6 0.2 0.6 0.1 0.7-0.1 0.7-0.5 1.5-0.1 0.8 0.1 0.1 0.1 0.2 0.2 0.3 0 0.3 0 0.3-0.7 1.2-0.1 0.3 0 0.3 0.3 0.5 0.1 0.2 0.4 0.2 0.7 0.2 0.6 0.3-0.1 0.5-0.4 0.7 0.4 0.5 1.2 0.6 0.3 0.5 0.2 0.7 0.2 1.6-0.1 0.5-0.2 0.4-0.2 0.3-0.2 0.4 0.2 0.7-0.1 0.3-0.3-0.1-0.1-0.2 0-0.5-0.1-0.4-0.2-0.3-0.4 0-0.3 0.2-0.2 0.4 0 0.4 0.6 0 0.4 0.7 0.4 0.5 0.9-0.4 0.2-0.3 0.1-0.3 0.1-0.3 0.1-0.4 0.2-0.4 0.3-0.3 0.6-0.5 0.5 0.4 0.1 0.2 0.1 0.3 0.1 0.2 0.2 0 0.1 0.1 0 0.4 0 1.4 0 0.5 0.4 1.1 0 0.6-0.1 1.6 0.1 0.4-0.4-0.2-0.4-0.3-0.3-0.1-0.2 0.3 0.1 0.4 0.6 0.8 0.2 0.4 0.3 0.8 1 0.4 1.3 0.1 0 0.1 0.2 0.8 0.8 0.3 0.8 0.2 0.3 0.5 0.4 1 0.1 0.5-0.2 0.4-0.2 0.4-0.2 0.5 0 0.3 0.7 0.6 0.6 0.1 0.6-0.1 0.6 0 0.2 0.1 0.2 0.4 0.2 0 0.2 0 0.5-0.2 0.8 0 0.2 0.2 0.3 0.5 0.5-0.5 1.2 0.9 0.7-0.2 0.3 0.2 0.3 0.1 0.3 0 0.2-0.3 0.3 0.2 0.3 0 0.2-0.2 0.3 0 0.1 0.2 0.5 0.6 1.1 0.6 0.3 0.5-0.1 0.6 0.4-0.1 0.4 0.1 0.4 0.1 0.3 0.3-0.4 0.5 0.1 0.2 0.3 0 0.2 0.1 0.7 0.6 0.3 0.2 0.4 0.1 1.9-0.7 0.9 0.5 1 0.3 0.9 0.3 0.6 0.8 0.5-0.6 0.9 0.3 1 0.6 0.9 0.2-0.3 0.7 0 0.4 0.4 0.1 0.8 0 0.2 0.2 0.7 1.2 0.3 0.3 2.5 1.3 1.2 0.3 1.1 0.1 1.5-0.4 0.6 0.1 0.2 0.9 0.3 0.1 0.7-0.2 1-0.5 0.4 0 1.8 0.2 2-0.2 2.4 0 0.7 0.2 0 0.5 0.5 0.1 2.7 0.2 0.6 0.1 0.6 0.3 0.6 0.5 0.3 0.5 0.3 0.5 0.3 0.5 0.9 0.4 1.4 1.5 0.6 0.4 0.5 0.2 0.5 0.1 0.7 0 0.2 0.3 0.2 0.5 0.3 0.5 0.7 0.1 0.1-0.1 0-0.2 0.1-0.2 0.2 0 0.2 0.2 0.1 0.3 0.2 0.2 0.3 0.1 0.6-0.3 0-0.7-0.2-0.8-0.1-0.6 0.2-0.2 0.7-0.5 0.5 0.3 0.8-0.2 0.5-0.5 0.1-0.6 0.4-0.1 1.6 0.1 2-0.2-0.9 4.8 0.4 1.4-0.3 0.7 0 1.6-0.3 0.7-0.3 0.6-0.4 1.4-2 5.1-1.8 3.9-4.4 7.3-3.1 11.6-3 11.5-1.8 14.9-0.1 1.2-0.2 1.4-0.2 7-0.3 0.6-0.5 0.2-2.3-0.2 0 0.2 0.9 0 0.7 0.1 0.4 0.4 0.2 0.9-0.2 3.1 0.2 0 0.2-0.9 0.1-2.3 0.3-1 0.4 1.2-0.7 7-0.5 3.3-0.3 6.2 0.8 9.9-0.3 4.2 0-2 0-0.6-0.4 0.4-0.9 3.6-0.3 0.5-1 1.1-0.1 0.2 0 0.5-0.2 0.2-0.2 0.1-0.8-0.3 0.6 0.7 0.1 0.7-1.1 2.5-0.1 0.5 0 0.5 0.3 0.3 0.4 0 0.4-0.2 0.2-0.3 0.1-0.4-0.2-1 0.1-0.5 0.4-0.4 0.1 0 0.1 0.3 0.1 0.6 0 0.9-0.7 2.8 1 3.5-0.1 1 0.2 0.4 0.2 1.8 0.1 0.3 0.2 0.4 0.6 1.5z m8.5-107.6l-0.6 1-0.3 0.5 0.1 0.5 0 0.5 0 0.3 0.5-0.1 0 0.4-0.2 0.5-0.3 0.3-0.4 0-0.2-0.3-0.1-0.6-0.3-0.3-1 0.2-0.3 0-0.4-0.1-0.4-0.1 0-0.2 0.4-0.2-0.5-0.3 0.4-0.1 0.2-0.3 0.1-0.3-0.2-0.3-0.2 0-0.4 0-0.7 0-0.2-0.1-0.4-0.1-0.3 0.1 0 0.2 0.2 0.4-0.1 1.3-0.2 0.1-0.2 0.2-0.2 0.5-0.1 0.5 0 0.4-0.2 0.2-0.5-0.2-0.7-0.3-0.4 0-0.3 0.2-0.5 0.4 0.5-0.2 0.2 0 0.5 0.1 0.4 0.3 0.5 0.1 0.4-0.1 0.3 0.2 0.3 1 0.3 1.2 0 0.8-0.1 0.4-0.5 0.7-0.3 3.5-0.4 0.8-0.5 0.8-0.2 0.2 0.5-0.2 0.5-0.1 0.2 0 0 0.3 0.2 0.2 0.3 0.3 0.2 0 0.4 0.1 0.4 0.2 0.5 0.2 0.6 0.4 0.1 0.2 0.1 0.3 0 0.6-0.4-0.3-0.3 0-0.2 0.3 0.2 0.4-0.4 0.7-0.2 0.2-0.4 0.1-1.6 0-0.1 0.3 0 0.6 0.2 0.5 0.3 0.2 0.4 0.1 0 0.2-0.2 0.2-0.1 0.4 0.5 1.4 0.2 0.9-0.4 0.4-0.3 0.4 0.3 0.8 0.5 0.2 0.2-0.9 0.2 0 0 0.7-0.2 1.9-1.1 3.6-0.2 1.3-0.1 0.2-0.3-0.1-0.4-0.3-0.2-0.1-0.3-0.8-0.3-0.3-0.1 0 0.1-0.2 0.2-0.2-0.1-0.3 0-0.3-0.1-0.2-0.3-0.1-0.3 0.3-0.4 0.1-0.4-0.2-0.4-0.2 0.2 0.5-0.2 0.3-0.4 0.2-0.3 0.3 0.1 0.5 0.2 0.3 0.3 0 0.3-0.3-0.4 1.4 0 0.7 0.2 0.6 0.4 0.3 0.6 0.1 0.6 0 0.5-0.3 0.4-0.5 0.5-0.4 0.5-0.1 0.2 0.7-0.1 0.6-0.3 1.2-0.4 6.4-0.3 1.3-0.1 1.9-0.2 0.6-0.2 0.5-0.1-0.2-0.1-0.2-0.1-0.3-0.1-0.3-0.2 0-0.1 1 0.2 0.7 0.3 0.3 0.2-0.5 0.3 0.8-0.1 1-0.2 1-0.4 0.7 0.5 0.7 0.2 1.5 0.2 3 0.2-0.4 1-14.8 0.7-4.7 0.7-5.9 1.5-5.7 0.7-4.5 0.4-1.2 0.2-0.4 0.2-0.4 0.1-0.3 0.1-1.3 0.1-0.3 0.7-1.1 0-0.7-0.1-0.8 0-0.7 1-1.9-0.1-0.3 0.6-2.8 0.2 0 0 0.7 1.4-2.4 0.6-1.4 0-1.1-0.1-0.3 0-0.4 0-0.5 0.1-0.2-0.1-0.3-0.2-0.3-0.1-0.4 0.2-0.1 0.7-0.2 0.1-0.5-0.3-0.4-1.2-0.2-0.3-0.2-0.2-0.2-0.2-0.2-1.3-0.7-0.7 0.4 0 0.7 0.5 0.6 0.6 0.2-0.3 0.6z", id: "MEX2716", name: "Tamaulipas", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Tamaulipas', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Aguascalientes" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M521.7 381.6l-0.2 0.4-0.1 0.1-0.6 0.9-0.5 0.7-0.7 0.5-1 0.4-0.7 0.3-0.5 0.6-0.5 0.6-0.8 0.2-0.8 0.5-0.3 0.8-0.1 0.9-0.2 0.9-0.4 0.7-0.6 0.3-0.7 0.2-0.7 0.3-0.7 0.6-0.6 0.6-0.7 0.6-0.7 0.5-0.9 0.2-0.9 0-0.8-0.1-1-0.1-0.9-0.1-2-0.4-1-0.1-1.5-0.4-1.2-0.7-1.1-0.9-1.3-0.6-1-0.2-1.1 0.2-1.1 0.4-0.9 0.4-1.1-0.7-0.9-0.6-0.7-0.9-0.3-1.3 0-0.7 0-0.7 0.2-0.7 0.2-0.7 0.4-0.6 0.4-0.6 0.4-0.6 0.5-0.6 0.4-0.8 0.5-0.9 0.5-0.8 0.6-0.7 0.6-0.7 0.7-0.7 0.6-0.8 0.4-0.8 0.1-0.9-0.3-0.6-0.5-0.5-0.1-0.5 0.7-1.1 1.1-0.5 1.2-0.1 1.1 0.1 0.5 0 0.6 0 0.6 0 0.5-0.3 0.2-0.4 0.2-0.8 0.3-0.3 0.2-0.1 0.2 0 0.3 0 0.3 0 0.3 0 0.3 0 0.3-0.3 0.3-0.4 0.3-0.3 0.4-0.2 0.6 0 0.4-0.4 0.4-0.7 0.3-0.6 0.6-0.6 0.5 0.3 0.4 0.8 0.3 0.7 0.3 0.7 0.4 0.8 0.6 0.5 0.6-0.2 0.2-0.2 0.2-0.1 0.2-0.1 0.2-0.1 0.4 0.4 0.3 1 0.4 0.4 0.6-0.1 0.4 0.3 0.3 0.4 0.4 0.4 0.6 0.3 1.3 0 0.6 0.3 0.3 0.8 0.1 1.2-0.1 1.3-0.1 1 0.4 0.9 0.7 0.4 0.9 0.4 0.8 0.5 0.5 0.5 0.5 0.5 0.4 0.6 0.4 0.6z", id: "MEX2717", name: "Aguascalientes", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Aguascalientes', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Colima" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M115.5 505.6l-0.2 0-0.2 0-1.1 0.1-0.5-0.2 0-0.4 0.7-0.4 1.7 0 0.1 0.1 0 0.2-0.1 0.3-0.1 0.1-0.3 0.2z m120.1-13.3l-0.5 0.1-0.7 0-0.5 0.3-0.5-0.5-0.4-0.4-0.5-0.2-1.4-0.6 0-0.3 0.2-0.5 0.2-0.8 0.5-0.7 1.2-1 0.7 0.2 0.7 0.6 0.5 0.7-0.2 0.7 0.5 0.2 0.4 0.5 0.2 0.6 0 0.6-0.4 0.5z m3-18.2l-0.1-0.1-0.1-0.2 0-0.3 0.1-0.3 0.4-0.8 0.2-0.3 0-0.5 0.2 0.2 0.3 0.3 0.3 0.7-0.8 0.6-0.3 0.3-0.2 0.4z m231.7 10.3l-0.4-0.1-0.2 0.3-0.1 0.3-0.1 0.4-0.2 0.1-0.4 0-0.1 0.1-0.1 0.1 0.1 0.4 0 0.1-0.2 0.1-0.4 0.2-0.4 0.2-0.3 0.2-0.4 0.3-0.2 0.1-0.3-0.1-0.4-0.2-0.1 0.1-0.1 0.1-0.1 0.2 0 0.2 0.1 0.3 0 0.3-0.2 0.4-0.1 0.5 0 0.4-0.1 0.4-0.4 0.4-0.4 0.2-0.4 0-0.5 0.2-0.3 0.3-0.2 0.4-0.1 0.4-0.1 0.5-0.2 0.5-0.3 0.4-0.7 0.5-1.7-1.7-5-3.6-0.8-0.9-3.5-1.7-2.9-1.5-1.9-0.7-1.7-0.6-0.6-0.2-0.5-0.2 0.1-1 0.7-0.1 0.2-0.3-0.2-0.6-0.7-0.6-0.4 0-0.3 0.3-0.2-0.1 0.1-0.6-0.5-0.2-0.5 0.1-0.3 0.2 0.1 0.5-0.2 0.1-0.3-0.3-0.3-0.2-0.3 0.5-0.4 0.3-0.4-0.7-1.1-0.5-0.6-0.4-2.8-0.6 0.1-0.8 0.3-0.4 0.5-0.4 0.5-0.5 0.3-0.8 0.1-0.4 0.4-0.2 0.8 0.1 0.2 0.2 0.3 0.3 0.2 0.2 0.3-0.1 0.1-0.3 0-0.5 0-0.2 0.2-0.2 0.3-0.1 0.2-0.2 0.3-0.1 0.4-0.3 0.2 0.1 0.3 0.3 0.3 0.2 0.3 0 0.4-0.1 0.5-0.1 0.3-0.1 0.4-0.1 0.3 0 0.3-0.1 0.3-0.2 0.5-0.4 0.5-0.4 0.6-0.1 0.7 0 0.6 0 0.3-0.4 0.2-0.6 0.2-0.7 0.4-0.4 0.4-0.3 0.4-0.2 0.2-0.7 0.1-0.8 0.3-0.5 0.4-0.5 0.9-1 1.2-1.2 0.1 0.4 0.1 0.4 0 0.1 0 0.1-0.1 0.2 0.8 0.5 0.9 0.4 0.8 0.5 0.8 0.5 0.5 0.3 0.6 0.3 0.7 0.3 0.5 0.2 0.7 0.3 0.6 0.2 0.5-0.1 0.5-0.7 0.4-0.2 0.5 0 0.4 0 0.5 0 0.8-0.5 0.7-0.8 0.7-0.8 0.8-0.4 0.4 0.5 0.3 0.7 0.5 1.4 0.3 0.5 0.6 0.4 0.5 0.3 0.4 0.6 0.1 0.4 0.2 0.3 0.2 0.3 0.3 0.3 0.3 0.1 0.3 0.2 0.4 0.2 0.2 0.2-0.1 0.4-0.1 0.3-0.2 0.3-0.1 0.4 0 0.6 0.1 0.6 0.1 0.7 0.1 0.5-0.2 1-0.4 1.3-0.3 1.2 0.1 0.8 0.6 0.8 0.3 0.8 0.3 0.9 0.2 0.9z", id: "MEX2718", name: "Colima", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Colima', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Jalisco" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M492.9 390.8l0.9-0.4 1.1-0.4 1.1-0.2 1 0.2 1.3 0.6 1.1 0.9 1.2 0.7 1.5 0.4 1 0.1 2 0.4 0.9 0.1 1 0.1 0.8 0.1 0.9 0 0.9-0.2 0.7-0.5 0.7-0.6 0.6-0.6 0.7-0.6 0.7-0.3 0.7-0.2 0.6-0.3 0.4-0.7 0.2-0.9 0.1-0.9 0.3-0.8 0.8-0.5 0.8-0.2 0.5-0.6 0.5-0.6 0.7-0.3 1-0.4 0.7-0.5 0.5-0.7 0.6-0.9 0.1-0.1 0.2-0.4 0.5 0.3 0.7 0.5 0.7 0.6 0.7 0.5 0.8 0.2 0.5-0.1 0.4 0 0.5-0.1 0.5 0 0.4 0.2 0.5 0.3 0.4 0.3 0.4 0.3 0.5 0.5 0.5 0.7 0.5 0.5 0.5 0.1 0.6-0.1 0.4 0.1 0.2 0.5 0.1 0.7-1.3 1.4-0.6 0.8-0.2 0.8 0.2 0.8 0.5 0.7 0.5 0.7 0.5 0.7-0.2 1.1-1.1 0.9-1.3 0.8-0.8 1.1 0.1 1.3 0.6 1 0.7 1 0.7 1.1 0.2 0.6 0 0.7 0 0.6-0.2 0.7-0.5 1-0.7 0.8-0.8 0.7-0.8 0.7-0.4 0.3-0.4 0.3-0.4 0.1-0.5 0-0.5 0-0.7 0-0.6 0.1-0.4 0.2-0.2 0.4-0.4 0.8-0.3 0.4-0.4 0.3-0.4 0.3-0.5 0.3-0.3 0.5-0.2 0.6-0.2 0.3-0.2 0.3-1.1 1.3-0.9 1.3-0.9 1.4-0.9 1.4-1.3 2.2-0.4 0.8-0.5 1-0.4 1-0.2 1.1 0.3 1 0.7 0.8 0.9 0.7 0.8 0.7 0.8 0.8 0.2 0.4 0.3 1.4-0.4 1-0.9 1-0.9 0.9-0.8 1.1-0.6 1-0.5 1.2-0.1 0.5-0.6 0.1-2 1-0.6 0.1-0.5 0.1-0.5 0.2-0.3 0.1-0.6-0.4-0.8-0.3-0.3-0.1-0.6 0.1-1.2 0.3-1.5 0.1-0.6 0.2-2.5 0.9-0.4 0.4-0.1 0.5-0.4 0.2-2 0.5-1.1 1.1-0.7 0.4-0.9 0.2-1.6 0-0.8 0.2-0.5 0.4-0.4 0.4-0.9 0.2-5.2 1.4-0.3 0.1-0.9 0.2-1.1 0.4-0.9 0.5-0.3 0.8 0.1 0.8 0.1 1 0.2 1 0.5 0.4 0.3 0.1 0.2 0.1 0.1 0.2 0.1 0.1 0.4 0 0.5 0 0.8-0.3 0.8-0.2 0.7-0.2 0.5 0.3 0.4 0.4 0.6 0.3 0.8 0 0.4 0 0.3 0 0.5 0 1.1 0.2 0.5-0.1 0.2 0.1 0.1 0.1 0.1 0.2 0 0.1 0 0.5 0 0.5 0 0.5 0.1 0.3 0.4 0.2 0.4 0.2 0.4 0.2 0.4 0.3-0.2 0.3-0.1 0.2-0.2 0.1-0.2 0.2-0.9 0.3-0.9 0.1-0.8 0.2-0.2 1 0 0.7 0.1 0.7 0.1 0.6 0.2 0.6 0.2 0.8 0.2 0.4 0.3 0.3 0.5 0.3 0.1 0.2 0.2 0.4 0 0.3 0.1 0.3 0.2 0.4 0.3 0.5 0 0.5-0.1 0.6-0.1 0.5-0.1 1 0.1 1.5 1.2 0.2 1.6-0.3 1.3-0.4 0.2 0 0.2 0.1 0.1 0.2 0.3 1.3 0.2 0.6 0.2 0.4 0.4 0.1 0.4 0.1 0.2 0.2-0.1 0.4-0.4 0.4-0.5 0.3-0.4 0.4-0.3 0.5 0 0.2 0.1 0.5 0 0.2-0.7 1-0.8 1.1-0.5 0.6-0.4 0.3-0.2 0-0.1-0.2-0.1-0.2-0.1-0.2-0.6-0.3-0.7-0.2-0.7-0.1-0.7 0.2-0.1 0.2-0.3 0.6-0.2 0.1-0.4 0-0.4 0.1-0.4 0.1-0.4 0.1-0.7 0.2-0.6 0.3-0.6 0.4-0.5 0.4-0.6 0.9-0.3 0.9-0.2 0.9-0.4 0.8-0.7 0.5-0.8 0.4-0.9 0.2-0.9 0.3-0.4 0.2-0.4 0.2-0.8 0.5-0.1 0.2-0.1 0.3 0 0.4-0.1 0.3-0.6 0.5-0.5-0.3-0.5-0.7-0.4-0.7-0.5-0.3-0.5 0-0.5 0-0.4-0.5-0.4-0.6-0.4-0.2-0.5 0.2-0.5 0.5-0.2 0.4-0.3 0.6-0.3 0.5-0.3 0.3-0.5 0.1-0.6 0-0.7 0-0.6 0-0.9 0-0.4 0.1-0.4 0.2-0.2-0.9-0.3-0.9-0.3-0.8-0.6-0.8-0.1-0.8 0.3-1.2 0.4-1.3 0.2-1-0.1-0.5-0.1-0.7-0.1-0.6 0-0.6 0.1-0.4 0.2-0.3 0.1-0.3 0.1-0.4-0.2-0.2-0.4-0.2-0.3-0.2-0.3-0.1-0.3-0.3-0.2-0.3-0.2-0.3-0.1-0.4-0.4-0.6-0.5-0.3-0.6-0.4-0.3-0.5-0.5-1.4-0.3-0.7-0.4-0.5-0.8 0.4-0.7 0.8-0.7 0.8-0.8 0.5-0.5 0-0.4 0-0.5 0-0.4 0.2-0.5 0.7-0.5 0.1-0.6-0.2-0.7-0.3-0.5-0.2-0.7-0.3-0.6-0.3-0.5-0.3-0.8-0.5-0.8-0.5-0.9-0.4-0.8-0.5 0.1-0.2 0-0.1 0-0.1-0.1-0.4-0.1-0.4-1.2 1.2-0.9 1-0.4 0.5-0.3 0.5-0.1 0.8-0.2 0.7-0.4 0.2-0.4 0.3-0.4 0.4-0.2 0.7-0.2 0.6-0.3 0.4-0.6 0-0.7 0-0.6 0.1-0.5 0.4-0.5 0.4-0.3 0.2-0.3 0.1-0.3 0-0.4 0.1-0.3 0.1-0.5 0.1-0.4 0.1-0.3 0-0.3-0.2-0.3-0.3-0.2-0.1-0.4 0.3-0.3 0.1-0.2 0.2-0.3 0.1-0.2 0.2 0 0.2 0 0.5-0.1 0.3-0.3 0.1-0.2-0.2-0.3-0.3-0.2-0.2-0.8-0.1-0.4 0.2-0.1 0.4-0.3 0.8-0.5 0.5-0.5 0.4-0.3 0.4-0.1 0.8-1.3-0.4-1.2-0.5-0.3-0.3-0.2-0.3-0.1-0.5-0.2-0.1-0.4 0.1-0.4-0.1-0.2-0.2 0-0.2-0.1-0.2-0.3-0.1-0.2 0-0.9 0.2-0.7 0.1-0.2-0.2 0.1-0.9 0.1-0.9 0-0.4-0.5-0.1-0.3 0-0.5 0.3-0.2 0.1-0.4-0.1-0.2 0-0.2 0-0.2 0.3-2.5-1.3-1.1-0.8-0.7-0.8-0.4-1.6-0.3-0.7-1-0.4 0-0.3 0.1-0.6 0-0.4-0.2-0.2-0.2-0.2-0.2-0.2-0.1-1.9-0.9-0.8-0.4 0-0.4 0.1-0.3-0.1-0.6-0.6-0.6-0.4-1.9-1.7-1.5-1.8-1.7-2.8-0.9-1-0.2-0.6-0.4-0.5-0.9-0.8-0.4-0.6-0.8-1.4-1.9-2.8-0.1-0.6-0.1-0.4-0.3-0.6-0.1-0.4 0-1.5-0.2-2.2-0.2-0.5-0.3-0.3-0.5-0.4-0.3-0.2-0.5-1-0.6-0.9-0.9-0.4-0.6-1.3-0.4-1.1-0.3-0.8 0.5-0.5 3.4-2.2 1.4-0.2 2.2 0 0.5-0.1 0.5-0.3 2.2-0.2 0.9-0.1 0.9-0.6 0.5-0.6 0.6-0.2 0.4-0.5 0.3-0.4 0.2-0.7 0.1-1.1-0.6-0.7-0.9-0.4-0.3-0.5 0.4-0.2 0.4-0.3 0.6-1.1 0.8-1 0.8-1 0.7-1.1 0.7-1.2 0.8-1.1 1-0.9 1.2-0.6 0.4 0 0.2 0.2 0 0.3 0.2 0.1 0.1 0.1 0.2-0.1 0.3-0.2 0.3-0.1 0.3 0 0.6 0.1 1.6-0.2 1.4-0.9 1.3-1.2 1.3-0.9 0.3 0 0.3-0.1 0.3 0.1 0.3 0 0.6 0.2 0.4 0.1 0.3 0.2 0.4 0.4 0.8 0.7 0.3 0.3 0.5 0.5 0.5 0.5 0.6 0.3 0.7 0.1 0.9 0 0.8 0.1 0.6 0.4 0.7 0.9 0.4 0.6 0.4 0.6 0.4 0.5 0.7 0.4 0.7 0.4 0.7 0.4 0.6 0.5 0.4 0.7 0.4 0.5 0.7 0.4 0.8 0.4 0.6 0.4 0.1-0.2 0-0.3 0.1-0.2-0.1-0.8 0-0.5 0-1.1 0.1-1.1 0.3-1 0.3-0.9 0.5-1 0.4-0.6 0.6-1.2 0.2-0.7 0.1-1.5 0-0.5-0.1-1.3-0.1-0.7-0.1-0.6-0.3-0.8 0-0.6 0.7-1 0.1 0 1.2-0.2 2.4 0 0.8-0.1 0.6-0.4 1.8-1.7 0.4-0.6 0.2-0.6 0-1.4 0.2-0.6 0.4-0.4-0.3-0.1-1.9-1-2.1-1.2-2-1.3-2.1-1.2 0.7-0.9 0.5-0.8 0.4-1 0.3-1.1 0.1-0.5 0.1-0.6 0.3-1.1 0.2-0.6 0.4-1 0.4-1 0.1-0.4-0.9-1.2-0.9-1.1-0.9-1.1-1-1.1-1.2-1.2-1.2-1.1-1.2-1.2-1.3-1.1-0.7-0.6-0.1-0.6 0.1-0.6 0.4-1 0.8-2.2 0.8-2.3 1.2-0.6 1.2-0.5 1.2-0.5 1.1-0.6 1.6-0.5 1.6-0.1 1.6-0.1 1.6-0.3 0.6-0.2 0.2-0.1 0.2-0.4 0.5-2.8 0.2-1-0.1-0.5-0.3-0.5-0.8-0.6-0.7-0.6-0.2-0.6 0-0.8 0.1-1.1 0.2-4.9 1.6 0.3 3.2 0.7 1.6 0.3-0.1 1.1-0.2 1.4-0.2 1.3-0.5 0.8-0.6 0.4-0.4 0.3-0.3 0.4 0 0.6 0.1 0.5 0 0.5 0 0.5-0.2 0.5-0.3 0.3-0.4 0.2-0.3 0.3 0 0.5 0.2 0.5 0.3 0.5 0.1 0.5 0 0.6-0.2 0.6-0.3 0.5-0.2 0.5-0.1 0.7 0 0.7 0.1 0.6 0.1 0.6 0.1 0.7 0.1 0.6 0.3 0.8 0.3 0.6 0.3 0.3 0.1-0.6 1.7-7.4 0.3-1.5 0.3-1.8 0.5-1.6 0.7-1.4 0.3-0.2 0.2 0.1 0.1 0.2 0.2 0.2 0.4 0 0.7 0 0.6 0 0.4 0.1 0.2 0.3-0.1 0.4-0.1 0.4 0 0.4 0.2 0.2 0.3 0 0.4 0.1 0.2 0.1 0.1 0.3 0 0.3-0.1 0.7-0.7 0.5-0.6 1.5-0.4 1.8-0.3 1.1-0.2 0.6-0.1 0.4 0 0.4 0.2 0.5 0.2 0.6 0.1 0.6 0.1 0.7 0 0.6-0.3 1.3-0.1 0.6 0 1 0.6 0.7 0.5 0.1 0.8-0.2 0.4-0.2 0.3-0.2 0.5-0.6 0.3-0.1 1.1 0.2 0.4 0 0.4 0.1 0.2 0.3 0.1 0.3 0.3-0.4 0.3-0.9 0.3-0.8 0.3-1 0.4-0.9 0.7-0.3 0.6-0.3 0.2-0.7 0-0.9 0.3-0.8 0.3-0.1 0.5-0.4 0.2-0.1 0.1-0.4-0.1-0.3-0.3-0.1-0.4 0-0.3-0.2-0.1-0.3-0.1-0.3-0.3-0.2-0.4-0.2-0.2-0.1 0-0.3 0.2-0.4 0.5-1.3 0.3-0.6 0.4-0.5 0.1-0.3 0.2-0.3 1 0.9 1 0.9 1 0.8 1 0.8 0.9 0.7 0.5 0.3 0.5 0.3 0.1 0.3 0 0.6-0.1 0.6-0.1 0.5 0.5-0.2 0.7-0.2 0.6-0.2 0.5 0 0.4 0.3 0.1 0.3 0.1 0.3 0.1 0.5 0.4-0.1 0.4-0.1 0.4-0.1 0.3 0.2 0.2 0.5 0 0.6-0.2 0.6-0.2 0.4-0.3 0.5-0.2 0.6-0.4 0.5-0.3 0.3-0.4 0.2-0.4 0-0.4 0.1-0.1 0.4 0.1 0.8 0.3 0.1 0.5 0.1 0.5 0.3 0.1 0.4 0 0.5 0 0.4-0.2 0.4-0.8 0.3-0.4 0.3-0.3 0.5-0.3 0.9-0.3 0.6-0.4 0.4-0.5 0.2-0.6 0.1-1-0.1-0.9-0.3-0.8 0.1-0.6 0.9-0.3 0.4-0.3 0.2-0.4 0.1-0.4 0-0.4 0-0.3 0.1-0.4 0.1-0.4 0.2-0.6 0.5-0.6 0.6-1.2 1.1-0.7 0.7-0.9 0.9-0.5 0.9 0.3 0.9 0.4 0.9 0.1 1.3 0 1.4 0.1 1.1-0.1 0.8-0.7 0.5-0.9 0.4-0.7 0.5-0.7 1.4-0.4 0.7-0.6 0.4-0.7-0.1-0.7-0.4-0.7-0.5-0.7-0.3 0.3 1.2 0.3 1.1 0.2 1.2 0.1 1.2 0 0.6-0.1 0.7-0.2 0.6-0.3 0.4-0.5 0.4-0.2 0.3 0 0.4 0 0.7-0.1 0.8 0.1 0.4 0.3 0.1 0.7-0.4 0.6-0.4 0.7-0.4 0.6-0.1 0.6 0.3 0.2 0.6 0 0.5 0.1 0.5 0.5 0.3 0.6 0.2 0.7 0 0.7-0.1 0.6-0.1 0.6 0.1 0.5 0.3 0.4 0.5 0.5 0.4 0.5 0.1 0.5-0.1 0.5 0 0.5-0.1 0.6 0.2 0.6 0.3 1.1 0.6 0.9 0.5 1 0.6 1.1 0.7 1.2 0.3 1.1-0.2 0.7 0 0.9 0.6 0.8 0.5 0.8-0.1 0.3-1 0.1-1.5-0.2-1.6-0.1-1.1 0-2.3 0.3-0.7 0.7-0.1 0.8 0.2 0.7 0.2 0.9 0.1 1-0.2 0.9-0.4 0.8-0.7 0.4-0.4 0.5-0.4 0.6-0.1 0.4 0.4-0.1 0.4-0.2 0.5 0.1 0.3 0.7 0 0.4-0.4 0.1-0.5 0-0.6 0.4-0.4 0.2-0.2 0.3-0.5 0.2-0.2 0.4-0.1 0.4-0.1 0.3-0.1 0.3-0.3 0.1-0.2 0.1-0.2 0.5-1.2 0.7-1.6 0.4-1.5-0.2-1.2-0.5-0.3-0.6 0.1-0.6 0-0.5-0.1-0.6-0.3-0.4-0.3-0.5-0.3-0.6-0.1-0.3-0.7 0.1-0.9 0.2-0.9 0.2-0.8 0.3-1.5z", id: "MEX2719", name: "Jalisco", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Jalisco', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Michoac\u00E1n" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M570.9 442.6l1.6 0.8 1.1 1.6 0.7 1.9 0 1.9 0 0.8 0 0.9 0.4 0.6 0.6 0.5 0.7 0.3-0.1 0.8-0.1 0.5-0.1 0.4-0.6 2.2-0.6 2.2 0 0.4 0.2 0.8 0 0.3-0.6 1.5-0.3 1.1-0.5 1.7-0.2 0.6 0.1 0.3 0.2 0.6 0.3 0.7 0.4 1.2 0.3 0.6 0.4 0.4 0.5 0.5-0.4 0.5-0.8 0.5-0.5 0.3-3.3 1.9-0.8 0.6 0.9 1.4 0.2 0.4-0.1 0.3-0.3 0.3-0.3 0.4-1.6 2.1-1.3 1.7-1 1.4-0.3 0.4-0.7 0.8-0.3 0.4-0.3 0.3-0.5 0.3-0.3 0.4-0.2 0.5 0 0.4 0 0.5-0.1 0.4-0.4 0.3-0.4 0.2-0.4 0.2-0.4 0.4-0.3 0.4-0.1 0.2-0.2 0.1-0.1-0.1-0.2 0.1-0.2 0.2-0.1 0.2 0 0.3-0.3 0.2-0.6 0.6-0.2 0.3-0.1 0.6-0.3 0.4-0.4 0.4-0.3 0.2-0.2-0.7-0.2-0.8-0.5-0.5-0.7-0.1-0.5 0.3-0.4 0.6-0.4 0.5-0.4 0.5 0 0.6 0.5 0.5 0.6 0.6 0.3 0.5-0.2 0.7-0.4 0.5-0.2 0.5 0.1 0.8 0.3 0.7 0.2 0.7 0.2 0.7 0 0.8 0 0.9 0.1 0.7 0.3 0.6 0.6 0.5 0.9 0.6 0.8 0.6 0.8 0.6 0.8 0.6 0.3 0.6-0.2 0.7-0.4 0.7-0.5 0.7-0.2-0.5-0.4-0.2-0.1 0.1-1 1-0.7-0.7-0.3-0.5 0-0.5 0.2-0.4 0.3-0.3 0.3-0.3 0-0.3-0.1-0.5-0.1-0.3-0.1-0.2-0.1 0-0.3-0.1-0.1-0.1 0 0.1-0.2 0.5 0 0.1-0.5-0.2-0.5-0.3-0.4-0.3-1.1-1.2-0.4-0.2-3.4-0.1 0.4 0.5-0.2 0.3-1.1 0.3-0.2-0.8-0.1-0.4-0.2-0.1-0.4 0-0.3 0.1 0 0.1-0.2-0.2 0-0.6-0.1-0.1-0.7-0.4-0.7 0-1.6 0.4-5-0.3-0.8 0.3-1.6 0.5-1.7 0.4-1.6 0.5-1.7 0.3-0.8-0.1-0.7-0.2-0.6-0.3-0.6-0.4-0.5-0.4-0.3-0.5-0.2-0.4-0.3-0.5-0.4-0.4-0.5-0.2-0.5-0.1-0.5-0.1-2.6-0.2-1.3 0.1-1.2 0.4-1.3 1.8-0.4 2.1 0.2 2.3 0.4 2.3-0.1 0.8-0.3 0.8-0.6 0.7-0.4 0.6-0.2 0.3 0 0.3-0.2 0.2-0.3 0.1-0.3 0-0.6-0.1-0.3 0-0.5 0.3-0.4 0.1-0.5-0.1-0.5 0-0.5 0.1-0.5 0.2-0.5 0.1-0.6 0-0.5 0-0.3 0-0.3 0.2-0.3 0.3-0.3 0.3-0.1 0.3-0.2 0.6-0.2 0.9-0.1 1 0 1 0 0.9 0.2 0.6 0.6 1 0.1 0.5-0.1 0.3-0.2 0.3-0.3 0.6-0.2 0.2-0.5 0-1.2-0.6-1.8-0.9-4.2-1.2-1.7-0.7-1.2-0.1-2.7-0.9-2.9-0.3-1.6-0.3-4.4-1.8-2.9-1.5-1.6-0.6-1.1-0.1-1.7-0.2-0.4-0.4-0.5 0.1-2.5-1.1-0.6 0.1-1.7-0.6-0.5-0.3-1.1-0.4-0.6 0.2-0.5-0.4-1.4-0.8-2.4-1.1-0.8-1.4-1.6-3.8-1.1-1.3-0.3-0.2-0.3-0.4-0.5-0.3-0.5-0.4-1-0.6-0.4-0.1-0.1-0.4 0.7-0.9-0.4-0.8-1.1-1-0.2-0.2 0.7-0.5 0.3-0.4 0.2-0.5 0.1-0.5 0.1-0.4 0.2-0.4 0.3-0.3 0.5-0.2 0.4 0 0.4-0.2 0.4-0.4 0.1-0.4 0-0.4 0.1-0.5 0.2-0.4 0-0.3-0.1-0.3 0-0.2 0.1-0.2 0.1-0.1 0.1-0.1 0.4 0.2 0.3 0.1 0.2-0.1 0.4-0.3 0.3-0.2 0.4-0.2 0.4-0.2 0.2-0.1 0-0.1-0.1-0.4 0.1-0.1 0.1-0.1 0.4 0 0.2-0.1 0.1-0.4 0.1-0.3 0.2-0.3 0.4 0.1 0.4-0.2 0.4-0.1 0.9 0 0.6 0 0.7 0 0.6 0 0.5-0.1 0.3-0.3 0.3-0.5 0.3-0.6 0.2-0.4 0.5-0.5 0.5-0.2 0.4 0.2 0.4 0.6 0.4 0.5 0.5 0 0.5 0 0.5 0.3 0.4 0.7 0.5 0.7 0.5 0.3 0.6-0.5 0.1-0.3 0-0.4 0.1-0.3 0.1-0.2 0.8-0.5 0.4-0.2 0.4-0.2 0.9-0.3 0.9-0.2 0.8-0.4 0.7-0.5 0.4-0.8 0.2-0.9 0.3-0.9 0.6-0.9 0.5-0.4 0.6-0.4 0.6-0.3 0.7-0.2 0.4-0.1 0.4-0.1 0.4-0.1 0.4 0 0.2-0.1 0.3-0.6 0.1-0.2 0.7-0.2 0.7 0.1 0.7 0.2 0.6 0.3 0.1 0.2 0.1 0.2 0.1 0.2 0.2 0 0.4-0.3 0.5-0.6 0.8-1.1 0.7-1 0-0.2-0.1-0.5 0-0.2 0.3-0.5 0.4-0.4 0.5-0.3 0.4-0.4 0.1-0.4-0.2-0.2-0.4-0.1-0.4-0.1-0.2-0.4-0.2-0.6-0.3-1.3-0.1-0.2-0.2-0.1-0.2 0-1.3 0.4-1.6 0.3-1.2-0.2-0.1-1.5 0.1-1 0.1-0.5 0.1-0.6 0-0.5-0.3-0.5-0.2-0.4-0.1-0.3 0-0.3-0.2-0.4-0.1-0.2-0.5-0.3-0.3-0.3-0.2-0.4-0.2-0.8-0.2-0.6-0.1-0.6-0.1-0.7 0-0.7 0.2-1 0.8-0.2 0.9-0.1 0.9-0.3 0.2-0.2 0.2-0.1 0.1-0.2 0.2-0.3-0.4-0.3-0.4-0.2-0.4-0.2-0.4-0.2-0.1-0.3 0-0.5 0-0.5 0-0.5 0-0.1-0.1-0.2-0.1-0.1-0.2-0.1-0.5 0.1-1.1-0.2-0.5 0-0.3 0-0.4 0-0.8 0-0.6-0.3-0.4-0.4-0.5-0.3-0.7 0.2-0.8 0.2-0.8 0.3-0.5 0-0.4 0-0.1-0.1-0.1-0.2-0.2-0.1-0.3-0.1-0.5-0.4-0.2-1-0.1-1-0.1-0.8 0.3-0.8 0.9-0.5 1.1-0.4 0.9-0.2 0.3-0.1 5.2-1.4 0.9-0.2 0.4-0.4 0.5-0.4 0.8-0.2 1.6 0 0.9-0.2 0.7-0.4 1.1-1.1 2-0.5 0.4-0.2 0.1-0.5 0.4-0.4 2.5-0.9 0.6-0.2 1.5-0.1 1.2-0.3 0.6-0.1 0.3 0.1 0.8 0.3 0.6 0.4 0.3-0.1 0.5-0.2 0.5-0.1 0.6-0.1 2-1 0.6-0.1 3.3-0.5-0.5 1.2-0.2 0.7 0.4 0.4 0.4-0.3 0.3-0.9 0.6-0.2 0.4 0.3 0.3 0.8 0.3 3 0.1 0.2 0.2 0.1 0.1 0.2 0.2 0.8 0.2 0.4 0.4 0.1 0.8 0 0.3 0 0.4-0.3 0.3-0.1 0.3 0.1 0.5 0.3 0.1 0 0.3 0 0.3-0.3 0.3-0.1 0.3 0 0.9 0.2 1.1 0 0.5 0.1 0.5 0.4 0.3-0.5 0.8-1 0.2-0.5 0.1-0.2 0.3-0.5 0.1-0.3 0-0.3-0.1-0.4 0.1-0.3 0.1-0.3 0.2-0.1 1.1 0 0.2-0.1 0.7-0.3 0.3 0 0.6-0.1 1.1 0.2 0.6-0.1-0.1 0.4 0.1 0.3 0.2 0.2 0.4 0 0.6 0.1 0.7 0.2 0.6 0.4 0.2 0.5-0.3 0.5-1.2 0.6-0.3 0.5 0.1 0.3 0.2 0.1 0.2 0.1 0.2 0.3 0 0.2-0.1 0.2 0 0.2-0.1 0.2-0.1 0.2-0.1 0.1 0 0.1 0.2 0.3 0.2 0.2 0 0.2 0.1 0.2-0.1 1-0.3 1 0 0.8 0.9 0.5 0.3-0.1 0.3-0.2 0.3-0.1 0.3-0.1 0.2 0 0.5 0.4 0.2 0 0.5 0 0.4-0.1 0.3-0.1 0.5 0.1 0.5 0.3 0.7 0.2 0.6 0 0.6-0.2 0.5-0.6 0.2-0.9 0.3-0.7 0.8-0.2 0.3 0.3 0.3 0.3 0.4 0.1 0.5-0.1 0.7-0.3 0.7 0 0.8 0 0.7 0.3 0.1 0.2 0 0.3 0 0.2-0.1 0.3 0.1 0.2 0.4 0.4-0.1 0.6-0.6 0.3-0.7 0.3-0.6 0.5 0.2 0.8 0.7 0.5 0.9 0.4 0.8 0.3 0.5 0.2 0.5 0 0.6 0 0.5-0.1 0.7-0.2 0.5-0.3 0.5-0.5 0.4-0.6 0.3 0.4 0.6 0.5 0.2 0.4 0.3 0.6 0.4 0.3 0.5 0.1 0.8 0 0-0.7 0.2-0.3 0.3-0.1 0.6 0 0.6 0 1.7-0.1 1.3-0.1 0.7 0 0.5 0.1 0.1 0.4-0.1 0.4 0.1 0.3 0.3 0.2 0.5-0.1 0.2-0.5 0.2-0.6 0.4-0.4 0.7-0.2 0.8-0.1 1.5-0.1 0.5-0.4 0-1-0.2-1.2-0.4-0.7 0-0.4 0.1-0.3 0.3-0.6 0-0.1-0.1-0.1 0-0.2 0.1-0.2 0.2 0 0.2 0 0.5 0.1 0.3-0.2 0.3-0.4 0.3-0.5 0.1-0.3 0.3-0.6 0.2-0.4 0.3-0.4 0.5-0.5z", id: "MEX2720", name: "Michoac\u00E1n", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Michoacán', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Nayarit" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M383.5 404.8l0.1 0.1 0.1 0.1 0 0.7-0.1 0.6-0.3-0.1-0.3 0.1-0.7-0.3-0.3-0.5 0.6-0.7 0.6 0.1 0.3-0.1z m-6.5-5.4l0.4 0.2 0.7 0.2 0.9 0 0.1 0.4 0.3 0.2 0 0.3-0.6 0.3-0.1 0.5-0.1 0.4-0.5-0.1-0.8-0.4-0.5 0-0.5-0.4-0.6-0.1-0.4-0.6 0.6-0.5 0.4-0.4 0.4 0.1 0.3-0.1z m-6.4-6.9l0.6 0.3 0.7-0.1 0.4 0.3 1.2 0.5 0.5 0.4-0.2 0.7 0.4 0.4 0.2 0.3 0.2 0.2 0.3 0.2-0.3 0.2-0.1 0.3 0.1 0.3 0.1 0.3-0.3 0.1 0 0.2-0.4 0.4 0 0.3-0.1-0.1-0.2 0 0-0.1 0.1-0.3-0.2-0.2-0.2 0-1.2-0.5-1.3-0.8 0.1-0.3 0-0.2-0.2-0.4-0.2-0.4-0.5-0.7 0.2-0.1 0-0.3 0-0.4-0.3-0.3 0.6-0.2z m-0.7-2.7l0 0.3 0.2 0.1 0 0.4-0.2 0.2 0.2 0.3-0.7 0.4-0.3-0.7 0.1-0.4 0.2-0.5 0.2 0.1 0.3-0.2z m74.1-18.4l-0.1 0.4-0.1 0.5-0.4 0.9-0.8 2.3-0.8 2.2-0.4 1-0.1 0.6 0.1 0.6 0.7 0.6 1.3 1.1 1.2 1.2 1.2 1.1 1.2 1.2 1 1.1 0.9 1.1 0.9 1.1 0.9 1.2-0.1 0.4-0.4 1-0.4 1-0.2 0.6-0.3 1.1-0.1 0.6-0.1 0.5-0.3 1.1-0.4 1-0.5 0.8-0.7 0.9 2.1 1.2 2 1.3 2.1 1.2 1.9 1 0.3 0.1-0.4 0.4-0.2 0.6 0 1.4-0.2 0.6-0.4 0.6-1.8 1.7-0.6 0.4-0.8 0.1-2.4 0-1.2 0.2-0.1 0-0.7 1 0 0.6 0.3 0.8 0.1 0.6 0.1 0.7 0.1 1.3 0 0.5-0.1 1.5-0.2 0.7-0.6 1.2-0.4 0.6-0.5 1-0.3 0.9-0.3 1-0.1 1.1 0 1.1 0 0.5 0.1 0.8-0.1 0.2 0 0.3-0.1 0.2-0.6-0.4-0.8-0.4-0.7-0.4-0.4-0.5-0.4-0.7-0.6-0.5-0.7-0.4-0.7-0.4-0.7-0.4-0.4-0.5-0.4-0.6-0.4-0.6-0.7-0.9-0.6-0.4-0.8-0.1-0.9 0-0.7-0.1-0.6-0.3-0.5-0.5-0.5-0.5-0.3-0.3-0.8-0.7-0.4-0.4-0.3-0.2-0.4-0.1-0.6-0.2-0.3 0-0.3-0.1-0.3 0.1-0.3 0-1.3 0.9-1.3 1.2-1.4 0.9-1.6 0.2-0.6-0.1-0.3 0-0.3 0.1-0.3 0.2-0.2 0.1-0.1-0.1-0.2-0.1 0-0.3-0.2-0.2-0.4 0-1.2 0.6-1 0.9-0.8 1.1-0.7 1.2-0.7 1.1-0.8 1-0.8 1-0.6 1.1-0.4 0.3-0.4 0.2-0.6-1.5-1-0.9-0.6-0.3-0.2 0.3-0.6 0.5-0.7 0.2-1-0.5-1.2-0.1-1.1-0.6-0.6 0.5-0.4-0.4 0.3-0.4 0.4-0.4 0.3 0.1 0.3 0.1 0.6-0.4 0.3-0.8 0.3-0.5 0.2-0.7 0.2-0.4 0.2-0.2 0.2 0.1 0.5-0.6 0.7-1.4 1-0.8 0.4-0.1 0.2-0.5 0.6-0.5 0.5-1.1 0.2-0.4 0.4-0.1 0.2 0.2 0.7 0.1 0.6-0.6 0.5-0.6 0.1-1 0-0.9-0.2-0.5 0.3-0.8-0.1-0.9 0.5-0.8-0.3-2.7-0.6-1.9 0.4-1.6 0.4-0.6 0.5-1 0.6-0.3-0.1-0.3-0.3-0.7-0.1-0.6-0.2-0.5-0.3-0.4-0.4-0.2-0.5-0.1-0.2 0.4-0.4 0.1-0.5-0.5-1.3-0.6-2.2-1.5-0.7-0.4-1.1-1-0.5-1.4-2.7-5.4-2.6-4.3-0.5-1.2-0.3-1.9 0.3-4.8-0.2-2.3-0.9-3.1-0.7-2.5-0.5-1.8-0.4-1 0.3-0.2 0.9 1.5 0.5 0.5 0.5-0.4 0.1-0.6-0.2-0.7-0.3-1.2 0.6-0.1 0.7-0.2 0.7-0.2 0.7 0.2 0.5 0.3 0.4 0.4 0.5 0.4 0.4 0.4 1.1 0.3 1-0.1 0.8-0.7 0-1.2-0.2-0.8-0.2-0.9-0.3-0.9-0.3-0.8-0.1-0.1-0.4-0.1-0.1-0.1 0-0.2 0.2-0.5 0-0.2-0.3-0.2-0.4-0.1-0.3-0.2-0.2-0.3-0.2-0.5-0.2-0.3-0.2-0.2-0.6-0.4-0.2-0.2-0.2-0.2-0.1-0.3 0.2-0.7 0.5-0.8 0.6-0.6 0.5-0.6 0.5-0.4 0.6-0.5 0.6-0.5 0.5-0.4 0.2-0.5 0-0.3-0.5-0.7-0.2-0.6-0.2-0.4 0.1-0.4 0.2-0.7 0.4-0.6 0.5-0.3 0.7-0.1 0.8 0.1 1.6-0.1 1.7-0.1 1.7 0 1.6 0.2 1.5 0.5 1.5 0.8 1.5 0.8 1.4 0.7 0.7 0.4 0.4 0.4 0.3 0.4 0.3 0.7 1.5 3.6-0.3 0.4-0.7 0.7-1.2 1.2-0.6 0.6-0.3 0.5-0.2 0.5-0.1 0.9-0.2 1.9 0 1.1 0.2 0.6 0.8 0.1 0.9-0.5 0.9-0.7 0.6-0.6 1.9-1.4 1.9-1.4 0.7 0.1 1 0.5 1 0.7 0.7 0.4 0.2 0.3 0.2 0.4 0.1 0.5 0.4 1.6 0.3 1.1 0.5 1 0.8 0.8 1.7 1.1 0.9 0.4 0.9-0.1 1.1-0.5 2.3-0.9 1.1-0.5 0.3 2.6 0.2 1.4 0.2 1.3z", id: "MEX2721", name: "Nayarit", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Nayarit', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Campeche" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M847 491l0 0.5-0.2-0.1-0.1-0.1-0.6 0.5-0.4 0.1-0.4 0.1 0.1-0.3 0.2-0.2 0.2-0.1 0.3-0.1-0.6 0.1-1.1 0.4-0.5 0-1.2 1.7-0.9 0.8-1.1 0.2 0.7-1.2-1.7 1.1-1 0.4-0.9 0.2-0.6 0-0.2-0.1 0.1-0.3 0.5-0.5 0.3-0.2 1.4-0.6 0.9-0.2 1.7-0.9 1.2-0.8 1.5-0.5 1.4-0.7 0.5 0 0.2 0.2 0.2 0.3 0.1 0.3z m66.4-29.5l1.4 1.9 1.7 1.5 2 1.4 3.8 3.4 3.1 3.9 0.7 2.4-0.3 2.1 0.1 2.4-0.1 0.5 0.1 1.1-0.5 0.9-1.5 1.5 0.2 2.5-1 6.6 0.2 1.9 1.1 1.4 0.3 1.8-0.4 0.5-0.2 0.5 0.5 0.2 0.5 0.3 0 0.7-0.3 0.8-0.2 0.7 0.6 3 0.2 2.3 0 2.1-0.7 1.9-2.7 3.3-0.3 0.5 0.2 2.6-0.2 0.4-0.2 1.3 0 2.9-13.9 0-6.9-0.1-6.9 0-7 0-6.9 0-13.8 0-1.4 0-0.7 0.2-0.2 0.3 0-1.7 0-3.8-1.9-0.1-1.8-0.1-0.5-0.1-0.2-0.2-0.3-0.3-0.3-0.3-0.6-0.2-0.6-0.1-1.3 0.1-0.5-0.1-0.6-0.4-0.6-0.4-0.5-0.4-0.6-0.4-0.5-0.3-0.5-0.2-0.7 0-0.6-0.1-0.5-0.2-0.5-0.1-1-0.4-0.4-0.1-0.3-0.1-0.4 0-0.7 0-0.9-0.1-0.9 0.1-0.7 0.2-0.2 0.4-0.2 0.6 0 0.3 0 0.4 0.1 0.4 0 0.2-0.1 0.6-0.3 0.8-0.4 0.8-0.2 0.3-1.6 0-3 0-1.6 0-1 0-1-0.5-0.9-0.6-0.9-0.5-0.5-0.3-0.2-0.5-0.1-0.6-0.6-0.3-0.5-0.2-0.4-0.2-0.4-0.2-0.4-0.3-0.7-0.5-0.7-0.6-0.8-0.6-0.8-0.5-0.4-0.8-0.1-1.3 0.1-1.3 0.1-1 0-3.1 0.1-3-1.4 0-1.5 0.1-1.5 0-1.4-0.2-0.3 0-0.2 0.2-0.3 0-0.3-0.1-0.3-0.2-0.5-0.4-0.2-0.2-0.5-0.6-0.3-0.8-0.1-0.8-0.3-0.8-0.4-0.6-0.4-0.6-0.4-0.7-0.1-0.6 2.3-0.7 3.6-0.2 3.3-0.3 4-0.5 2.5 0.1 1 0.2 0.9 1 1.7 1.1 0.2 0.3 0 0.4-0.2 0.3-0.3 0.3-0.4 0.1 0.2-0.2 0-0.3-0.3 0.2-0.4 0.1-0.9 0-0.3-0.2 0.1-0.3 0.1-0.4-0.2-0.3-0.2 0-0.2 0.1-0.7 0.5-0.1 0-0.1-0.1-0.3 0-0.5 0.1-0.1 0.1 0.2 0.2 0.5 0 0 0.3-0.4 0.1-0.4 0-0.4-0.1-0.3-0.3 0 0.2 0.1 0.3 0.1 0.2-0.3 0.2-0.2 0.3-0.1 0.3-0.1 0.4 0.2-0.2 0.5-0.3 0.6 0.5 0.3 0.1 0.4 0.1 0.7-0.2 0.4-0.1 0.2 0.2 0.2 0.4 0.5 0.4 0.6 0.3 0.6 0.1-0.8-0.6-0.9-0.6-0.7-0.7-0.2-1 0.7 0.3 0.3 0.3 0.4 0.1 0.8-0.3-0.4 0.7 0.4 0.2 0.4 0.2 0.3 0.3 0.2 0.5-0.5-0.3 0 0.3-0.2 0 0.6 0.3 1.2 0.4 0.4 0.4-0.1 0.5-0.8 0.9-0.2 0.5 0.2 0.5 0.6 0.5 0.6 0.5 0.4 0.1 0.3-0.5-0.1-0.5-0.3-0.5-0.2-0.6 0.3 0.2 0.3 0.2 0.3 0.1 0.4-0.1-0.3-0.4-0.5-0.4-0.3-0.5 0.2-0.5 0.9 0.4 1.9 0.5 0.9 0.5 0.6-0.2 1.4 0.3 0.8 0.1 1.6-0.2 0.7-0.2 0.5-0.3 0.1 0.5 0.2 0.3 0.3 0.1 0.3-0.2 0-0.4-0.2-1 0-0.4-0.2 0-0.1 0.1-0.1 0.3-0.1 0.3-0.3 0-0.8 0.3-0.2-0.1 0.2-0.4 0.7-0.8 0.2-0.2 0.8-0.4 1.8-0.7 0.9-0.5 0.5 0.2 0.5-0.1 0.5-0.3 0.4-0.2 0.3-0.4 0.5-1 0.2-0.2 1.1 0 0.5 0 0.2-0.2 0.3-0.3 1.2-0.4 0.5-0.3-0.6-0.2-0.4 0-0.8 0.5-1.5 0.4-0.4 0.2 1-2.5 0-1-0.6-1-0.5-0.5-0.3-0.2-0.4 0-0.3 0.1-0.1 0.2-0.1 0.2-0.2 0.2-0.7-0.2-0.9-1.2-0.6-0.2 0.5-0.8 0.6-0.8 0.7-0.5 1.5-0.5 1-0.7 0.8-0.8 0.5-0.7-0.7 0.1-2.1 1.7-2 1.1-0.8 0.7 0 0.7-0.3 0.2-0.1-0.2-0.7 0.5-0.4 0.2-0.6 0-0.7-0.1 0-0.2 0.7-0.9 1.6-1.2 2-1.2 2.7-1.7 3.8-1.7 2.6-2.4 0.6-0.3 1.5-0.5 2.4-1.7 2.5-3.2 0.7-0.4 1-0.4 1.1-0.9 0.8-1.1 0.4-1.1 0.5-6.5 0.3-1.4 0.1-0.7-0.1-0.7-0.1-0.6 0-0.5 0.2-0.8 0.6-1.4 0.6-1 1.8-1.3 2.8-2 1.3-1.4 0.3-1.4 0.1-0.5 0-0.6-0.1-0.5-1-1.9 0-0.4 0-0.3 0-0.6 0.1-2.6 0.3-1.7-0.1-1.8 0-0.8 0.4-1.9 0.1-1.3-0.5-2.8 0-1.5 0.7-2.8 0.2-3.3 0.4-0.9 1.7-2.1 0.4-0.6 0.1 0.9-0.4 8.4 0.5 1 1.5 0.1 1.6 0 1.3 0.2 0.8 0.9 0.5 1.2 0.8 0.7 0.6-0.3 0.6-0.2 0.6 0.5 0.6 0.6 0.9-0.2 0.6-1.2 0.8-0.6 1.3 1.8 0.5 0.9 0 0.8 0.6 1.3 0.5 0.6 1.8 1.3 1.1 2 0.8 2.4 1.6 1.7 2.2 0.8 1.9 1.5 2.3 4.3 1.7 1.8 1.5 2 0.4 2.4 0.8 1.8z", id: "MEX2722", name: "Campeche", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Campeche', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Oaxaca" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M773 544.6l0.2 0.9 0 0.9-0.1 1.8 0 0.3 0 0.7-0.8-0.2-0.4 0.6 0 0.9 0 0.8 0 1.2 0 0.6-0.1 0.4-1.9 1.2-0.5 0.3-0.7 0.3-0.6 0.4-0.4 0.5-0.1 0.6 0 0.9 0.2 0.9 0.1 0.7 0 0.7 0 0.7-0.2 0.6-0.3 0.7-0.7 1.1-1 1.3-0.7 1.4 0.3 1.3 0.3 0.5 0.3 0.6 0.5 1.3 0.4 0.9 0.5 1 0.4 1.1 0.1 1-0.1 0.6-0.1 0.7-0.1 0.6-0.2 0.6-0.2 0.4-0.6 0.8-0.2 0.4-0.6-0.5-0.4-0.5-0.2-0.4-0.2-1-0.4-0.2-0.6 0.3-0.7 0.3-1.3 0.2-1.3-0.4-1.3-0.7-1.1-0.9-0.7-0.7-0.4-0.3-0.7-0.1-0.6 0.2 0 0.5 0.1 0.5-0.1 0.6-0.2 0-0.3-0.2-0.1 0.1 0.1 0.2 0.2 0.1 0.4 0.1 0 0.2-0.3 0.1-0.4 0.1 2.9 1.9 1.6 0.7 0.9-0.2-2.4-0.9 0-0.2 0.8 0.1 1.3 0.4 0.6 0.2 0.8-0.1 0.3 0.1 0.5 0.2 1.1 0.7 0 0.2-0.4 0 0 0.2 2.2 0.5 0.6 0.2-0.7 1.4-7.2-3-0.4-0.3-1.1-0.7-1.5-0.3-2.9 0-1.5-0.1-0.8-0.1-0.6-0.3-0.5 0.3-0.6 0-1.3 0-0.7-0.2-0.2-0.3 0.1-0.4 0.4-0.3 2.8-0.8 1.2-0.9 0.2-1.4-0.4-0.4-1.2-0.4-0.5-0.2-0.3-0.3-0.2 0-0.3 0-0.2 0.1-0.1 0.5-0.1 0.2-0.1 0.1-0.4 0.1-0.1 0-0.4 0.4-0.2 0.2 0 0.1-0.8 0.5-0.5 0.1-0.5 0.9-0.4 0.3-0.4-0.6-0.1-0.3 0-0.4 0.4-0.3 0.4-0.3 0.3-0.4-0.3-0.5-0.5-0.5-0.1-0.4 0-0.3-0.2-0.5-0.2-0.3-0.4-0.3-0.4-0.4-0.4-0.1-0.8 0.1-0.8 0.4-0.6 0.6-1.3 2-0.4 0.3-1.8 0 0.2 0.5-0.3 0.2-0.3 0.1-0.2 0.2-0.4 0.5 0 0.4 0.7 0.2 1.4 0.3 1.1 0.1 1 0 0.9-0.1 0.4 0 0.7-0.2 0.3-0.2 0.5-0.6 0.3-0.1 0.2 0.5-1 0.5-1.3 0.3-1 0.1 1.1 0.3 2.9-0.1 0.9 0.3 0.5 0.8-0.2 0.2-1.6-0.5-2.5 0-1.6 0.4-1.4 0.1-0.8 0.2-1.5 0.2-1.2 0-0.6-0.1-0.4 0-0.5 0-0.2 0.2 0.1 0.2 0.1 0.3-0.3 0.1-0.9-0.1-0.3 0.3-1.1 0-0.4 0.3-0.1 0.5-0.6 0.2-0.4 0.3 0 0.3-0.1 0.2-0.4 0-0.3 0.3-1 0.2-0.5 0.3-0.8 1 0.2 0.7-0.4 0.2-0.4 0.4-0.9 0.3 0 0.5-0.2 0.3-1.9 0-0.1 0.3-2.4 0.3-0.3 0.4-0.8 0.1-0.2 0.4-1.5 0.6-1.4 0.1-0.8 0.1-0.7 0.2-0.5 0.3-0.3 0.2 0 0.3-0.7 0.1-0.7 0.2-0.8 0.2-0.9 0.3-0.3 0.2-2.3 0.5-0.3 0.4-1.1 0.3-0.8 0.5-0.7 0.1-0.8 0.6-0.4 0.1-0.2 0.2-0.3 0.1-0.3-0.1-0.4 0.3 0.1 0.5-2.5 1.1-1 0.7-1.6-0.1-2.4 0-1.2-0.2-1-0.2-0.4 0.5-0.8 0.3-0.5 0.4-0.6 0.1-0.7-0.1-0.7-0.1-0.2 0.2-1.8-0.7-2.1-1-3.9-0.7-1.3-0.1-2.7-1.6-1.9-0.6-1-0.2-0.8-0.7 0.1-0.1-0.5-0.9-0.5 0.1-0.8-0.4-1.8-1.2-1.5-0.5-1.9-0.5-0.6 0-1.9-0.3-0.7 0.3-2.9-0.3-2.2-0.8-0.8 0.2-1.9-0.4-1.4-0.1-0.4 0.3-0.3 0.2-1.1-0.2-1.7-0.4-0.6-0.2-0.6-0.5-0.8-0.3-0.3-0.2-0.3-0.3-0.2-0.1-0.5-0.3-2.1-1.6-1.2-0.7-3.3-1.8-1.1-0.4-1.1-0.5-0.5-0.6 1.8 0.5 1 0.2 0.4-0.5-0.4 0.1-0.5-0.3-0.4-0.3-0.4 0.3-0.6-0.3-0.7-0.1-0.1-0.3-0.1-0.1-0.2-0.1 0 0.1-0.2 0.1-0.2 0.2-0.2 0.1-0.6-0.1-3.1-1-4.1-0.8-2-0.7-0.8-0.3-0.4-0.1-0.2-0.1-0.1-0.1 0.1-0.1 0.5-0.5 0.5-0.4 0.7-0.3 0.8-0.2 0.9-0.1 0.8 0 0.8-0.1 0.8-0.5 0.8-0.8 0.7-0.9 0.2-1-0.5-1.1-0.5-0.8 0-0.7 0.4-0.6 0.8-0.4 0.6 0 0.5 0.2 0.5 0 0.7-0.2 0.2-0.4 0.3-0.9-0.1-1-0.3-0.9-0.3-0.9 0.4-0.2 0.4 0 0.4 0 0.4 0.1 0.5 0.1 0.4-0.1 0.4-0.2 0.5-0.2 0.2-0.1 0.2-0.1 0.3-0.3 0.1-0.2 0.2-0.3 0.4-0.3 0.3-0.3 0.2-0.4 0.1-0.6 0.1-0.6 0.2-1.2 0-0.6 0.1-0.4 0-0.3-0.1-0.3 0.2-0.4 0.3-0.4 0.3-0.4 0.3-0.4 0.2-0.5 0.2-0.3 0.1-0.3 0.1-0.4 0.1-0.3 0.1-0.4-0.1-0.4-0.1-0.3-0.2-0.3-0.9-1.3-1-1.3-0.9-1.3-1.1-1.2-0.4-0.5-0.4-0.1-0.4-0.1-0.9 0.1-0.8-0.2-0.5-0.7-0.4-0.9-0.5-0.7-1.2-0.5-0.4-0.3-0.2-0.6 0.1-0.7 0.2-0.7 0.1-0.6-0.3-0.7-0.2-0.2 0.3-0.9 0-0.5-0.1-0.4-0.4-0.5-0.4-0.5-0.7-0.6-0.1-0.5-0.1-0.5 0.1-0.4 0.3-0.3 0.2-0.2 0-0.2-0.1-0.2-0.2-0.1-0.5-0.6 0-0.8 0.1-0.8 0.2-1.3 0.3-0.8 0.1-0.5 0.1-0.6 0.2-0.6 0.1-0.7 0.2-0.6 0.4-0.7 0.2-0.6-0.1-0.5-0.6-0.6 0.7-0.5 0.5-0.5 0.6 0.2 0.5 0.2 1.1-0.1 0.8-0.8 0.7-1.2 0.4-1.1 0.3-0.4 0.3-0.2 0.4-0.1 0.5 0 1.1 0.1 2 0.1 0.6 0 0.6-0.1 0.6-0.1 0.6-0.1 0.3-0.1 0.4 0 0.4-0.1 0.3 0.2 0.2 0.3 0.1 0.4 0.1 0.5 0 0.7 0.1 0.5 0.3 0.7 0.2 0.4 0.3 0.3 0.5 0 0.8-0.3 0.8-0.3 0.3-0.3 0.4-0.3 0.3-0.3 0.3-0.3 0.3-0.3 0.3-0.2 0.2-0.3 0.2-0.3 0-0.4 0-0.3-0.1-0.3-0.1-0.3-0.2-0.4-0.3-0.4-0.3-0.4-0.5-0.4-0.2-0.1-0.5-0.4-0.3-0.5-0.2-0.5 0.2-0.6 0.2-0.4 0.5-0.8 0.2-0.4 0.3-0.5 0.6-1.1 0.4-0.6 0.2-0.5 0.4-0.6 0.4-0.4 0.4 0.1 0.8-0.3 1.2-0.9 0.9-0.4 0 1.3-0.3 1.1-0.5 1.4-0.3 1.4 0 1.1 0.4 0.4 0.5 0.4 1 0.5 0.3 0.3 0.3 0.1 0.5 0.4 0.3 0.4 0.1 0.4 0 0.5 0.1 0.5 0.2 0.4 0.5 0.7 0.2 0.4 0.3 0.4 0.4 0.3 0.4 0.2 0.4 0 0.5-0.1 0.4-0.3 0.2-0.4 0.2-0.4 0.8-1.7 1-1.5 1.3-1.1 1.7-0.7 0.3-0.1 1.4-0.3 0.6 0.1 0.7 0.2 0.5 0.3 0.5 0.3 0.5 0.2 0.6 0.1 0.2 0 1.1 0.4 1 0.3 1-0.1 0.9-0.7 0.3-0.4 0.2-0.6 0.7-0.9 0.6-0.6 0.2-0.2 0.1-0.2 0.6-0.4 0.4-0.2 0.6-0.1 0.5-0.2 0.2-0.1 0.4-0.2 0.1-0.1 0.7-0.4 0.3-0.5 0.3-0.7 0.3-0.6 0.3-0.7 0.3-0.5 0.3-0.5 0.1-0.7 0.5-0.5 1.5-1.7 0.6-0.9 0.4-1.1-0.1-1.1-0.4-1.2-0.3-1.1-0.2-1 1 0.9 1.1 1 1.1 0.6 1.2 0.5 1.4 0.3 1 0.2 0.7 0.3 0.5 0.5 0.3 0.9 0.3 1.3 0.4 1.5 0.7 1.4 0.8 1 0.3 0.2 0.4 0.3 0.3 0.1 0.5 0.4 0.4 0.4 0.3 0.5 0.3 0.5 0.3 0.8 0.2 1 0.2 0.9 0.3 0.3 0.1 0 0.4 0.3 0.4-0.1 0.4 0 0.3 0.1 0.1 0.2-0.1 0.3 0 0.3 0.3 0.3 0.3 0.2 0.5 0.1 0.4 0.1 0.4-0.1 0.2-0.2 0.4-0.6 0.2-0.2 0.4 0 0.7 0.1 0.4 0.2 0.4 0 0.5 0 0.4 0.1 0.2-0.1 0.4-0.1 0.3 0 0.3 0.1 0.3 0.1 0.4 0.2 0.3 0.2 0.4 0.1 0.3 0.1 0.9 0.2 0.2 0 0.5 0.3 0.5 0.2 0.5 0.9 0.5 1.1 0.4 1.2 0.5 1-0.6 1.6-0.8 1.3-1 1.2-1.1 1.2-0.2 0.3-0.2 0.4-0.3 1 0 0.9 0.4 0.9 0.5 1 0.6 1.3 2 4 0.4 0.5 0.5 0.2 0.5 0.2 0.6 0.2 0.1 0.1 0.3 0 0.8-0.3 0.5-0.3 0.6-0.2 0.7 0 0.9 0.4 0.3-0.1 0.5-0.5 0.2 0 0.3 0 0.3-0.1 0-0.2 0-0.2 0.1-0.2 0.1-0.1 0.6-0.3 0.5-0.4 0.5-0.2 0.4-0.1 0.4-0.1 0.3-0.4 0.3-0.4 0.2-0.3 0.7-0.4 0.6-0.2 0.7 0 0.8 0 0-0.2 0-0.2 0.2-0.2 0.9-0.1 0.6-0.3 0.5-0.6 0.3-0.7 0.2-0.2 0.4 0.1 0.4 0.2 0.3 0.2 0.2-0.2-0.3-0.5 0.2-0.2 0.2 0 0.6-0.1 0.2 0 0.3 0.3 0.1 0.4-0.1 0.5-0.1 0.6-0.1 0.8 0 0.2-0.3 0.1-0.6 0.3-0.3 0.2-0.2 0.4-0.1 0.4 0 0.3-0.1 0.4 1 1.2 0.9 1.1 1 1.1 1 1 0.5 0.5 0.4 0.4 0.5 0.5 0.4 0.6 0.7 0.2 0.9 0.3 0.8 0.5 0.4 0.6 0.2 0.7 0 0.3-0.1 0.1-0.2 0.1-0.1 0.2 0.6 2.1 1.1 0.6 2 0.3 2.3 0.1 1.5 0 3.2 0.2 2.1 0.2 0.9 0.1 1.9 0.1 4.9 0.3 4.9 0.3 9.9 0.6z", id: "MEX2723", name: "Oaxaca", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Oaxaca', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Puebla" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M683 502.9l-0.1 0.7-0.3 0.5-0.3 0.5-0.3 0.7-0.3 0.6-0.3 0.7-0.3 0.5-0.7 0.4-0.1 0.1-0.4 0.2-0.2 0.1-0.5 0.2-0.6 0.1-0.4 0.2-0.6 0.4-0.1 0.2-0.2 0.2-0.6 0.6-0.7 0.9-0.2 0.6-0.3 0.4-0.9 0.7-1 0.1-1-0.3-1.1-0.4-0.2 0-0.6-0.1-0.5-0.2-0.5-0.3-0.5-0.3-0.7-0.2-0.6-0.1-1.4 0.3-0.3 0.1-1.7 0.7-1.3 1.1-1 1.5-0.8 1.7-0.2 0.4-0.2 0.4-0.4 0.3-0.5 0.1-0.4 0-0.4-0.2-0.4-0.3-0.3-0.4-0.2-0.4-0.5-0.7-0.2-0.4-0.1-0.5 0-0.5-0.1-0.4-0.3-0.4-0.5-0.4-0.3-0.1-0.3-0.3-1-0.5-0.5-0.4-0.4-0.4 0-1.1 0.3-1.4 0.5-1.4 0.3-1.1 0-1.3-0.9 0.4-1.2 0.9-0.8 0.3-0.4-0.1-0.4 0.4-0.4 0.6-0.2 0.5-0.4 0.6-0.6 1.1-0.3 0.5-0.2 0.4-0.5 0.8-0.2 0.4-0.2 0.6 0.2 0.5 0.3 0.5 0.5 0.4 0.2 0.1 0.5 0.4 0.3 0.4 0.3 0.4 0.2 0.4 0.1 0.3 0.1 0.3 0 0.3 0 0.4-0.2 0.3-0.2 0.3-0.3 0.2-0.3 0.3-0.3 0.3-0.3 0.3-0.4 0.3-0.3 0.3-0.8 0.3-0.8 0.3-0.5 0-0.3-0.3-0.2-0.4-0.3-0.7-0.1-0.5 0-0.7-0.1-0.5-0.1-0.4-0.2-0.3-0.3-0.2-0.4 0.1-0.4 0-0.3 0.1-0.6 0.1-0.6 0.1-0.6 0.1-0.6 0-2-0.1-1.1-0.1-0.5 0-0.4 0.1-0.3 0.2-0.3 0.4-0.4 1.1-0.7 1.2-0.8 0.8-1.1 0.1-0.5-0.2-0.6-0.2-0.5 0.5-0.7 0.5-1.7-1.9-0.4-0.4-0.4-0.1-0.3 0-0.6 0.2-1 0.2-1 0.1-1.1-0.1-1-0.2-0.3-0.1-0.3-0.1-0.3-0.1-0.3-0.2-0.6-0.1-0.6-0.2-0.7-0.1-0.6-0.2-1.4-0.6-1.2-0.8-0.9-1.2-0.4-1.5-0.4-0.2-0.7-0.2-0.8-0.1-0.5 0-0.5-0.3-0.2-0.6-0.1-1.3-0.4-0.1-0.4 0.2-0.4 0.3-0.6-0.4-0.3-0.3-0.1-0.4-0.1-0.4 0-0.4-0.9 0.1 0-0.5-0.1-0.4-0.2-0.3-0.2-0.5 0-0.5 0-0.5 0-0.5-0.1-0.5 0.7-0.5 0.7-0.4 0.7-0.3 0.8-0.2 0.6-0.4 0.2-0.5 0.1-0.6 0.5-0.4 0.5-0.2 0.2-0.3 0.2-0.3 0.2-0.2 0.4-0.2 0.4-0.1 0.5-0.1 0.4-0.1 0.6 0 0.6 0.2 0.5 0.3 0.5 0.4 0.5 0.5 0.7 0.6 0.7 0.4 0.6-0.2 0-0.4-0.1-0.6-0.2-0.7-0.3-1.3-0.2-0.8-0.3-0.7-0.5-0.6-0.1-0.3-0.1-0.5-0.1-0.6-0.1-0.5-0.1-0.4-0.1-0.4 0-0.3-0.1-0.7 1.2 0.3 0.6 0 0.6 0 0.1-0.2 0.1-0.1 0-0.1 0-0.2-0.1-0.5-0.2-0.5-0.3-0.4-0.3-0.4-0.4-0.3-0.1-0.2-0.1-0.2 0-0.2 0.1-0.2 0-0.4-0.2 0-0.2-0.1-0.3-0.3 0.5-0.5 0.3-0.6 0.5-0.6 0.5-0.5 0.6-0.4-0.2-0.5-0.4-0.5 0-0.7 0.2-0.2 0.3 0.1 0.2 0 0.1-0.5 0.1-2.1 0.1-0.5 0.1-0.3 0-0.3-0.1-0.2-0.2-0.3-0.1-0.4 0-0.4 0-1 0.1-1.5 0.1-0.3 0.3-0.2 0.2-0.2-0.2-1.6-0.3-1.9-0.1-0.3-0.5-1.9-0.2-1 0.2-0.8 0.2-0.4 0.1-0.4 0.2-0.4 0.3-0.4 0.9 0.3 1 0.3 1 0.2 0.9 0 0.5-0.4 0.4-0.1 0.3 0.1 0.5 0.4 0.1 0.2 0 0.3 0.1 0.4 0.1 0.4 0.2 0.4 0.2 0.3 0.2 0.4 0.1 0.4 0.1 0.4 0.2 0.2 0.4 0.2 0.5 0.4 0.4 0.4 0.3 0.5 0.2 0.5 0.2 0.5 0.3 0.7 0.1 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.3 0.1 0.2 0.2 0.3 0.2 0.6 0.4 0.9 0.8 0.4 0.5 0.4 0.8 0.3 0.3 0.7 0.2 0.6-0.2 0.7-0.3 0.6-0.2 0.8-0.2 0.7-0.8 0.6-0.9 0.5-0.8 0.3 0.1 0.3 0.1 1.8 0.8 0.7 0.4 0.7 0.3 0.8 0.1 0.6-0.4 0.8-0.7 0.3-0.2 0.1-0.6-0.3-0.6-0.6-0.5-0.2-0.6 0-0.2 0.2-0.3 0.3-0.2 0.3-0.2 0.4-0.1 0.1-0.2 0.1-0.2 0.2-0.1 0.1-0.1 0.8 0.2 0.9 0.3 0.9 0 0.5-0.3 0.1 0.1 0.1 0.1 0.8 0.5 1 0 0.8-0.5 0.7-0.7 0.2-0.9-0.3-0.6-0.6-0.3-0.8 0.1-0.4-0.1-0.4-0.3-0.4-0.3-0.3-0.3-0.3-0.4-0.4-0.4-0.3-0.4-0.4-0.4-0.6-0.3-0.5 0-0.6 0.2-0.5 0.4-0.5 0.1-0.2-0.4-0.2-0.6-0.2-0.4-0.3-0.1-0.1-0.1-0.2-0.3 0-0.3 0.1-0.3 0.3-0.1 0.3 0 0.3-0.1 0.3-0.9-1-0.5-1.3-0.4-0.8-0.3-0.5-0.4-0.4-0.5-0.4-0.5-0.6-0.3-0.6 0-0.5-0.2-0.2-0.3 0.4-0.6 0-1-0.5-0.9-0.6-0.4-0.3 0.5 0.1 0.6 0 0.4-0.1 0.3-0.5 0.2-0.4 0-0.4 0-0.9 0-0.9-1.1-0.8-1.4-0.7-1.4-0.8-1.3-0.2-0.7 0.2-0.8 0.4-0.7 0.5-0.8 0.2-0.2 0.2-0.2 0.2-0.4 0.5-0.7 0.3-0.4 0.2-0.9 0.2-0.9 0.5-0.8 0.8-0.6 0.5-0.6 0-0.5-0.3-0.6-0.3-0.6 0-0.3-0.1-0.9-0.4-1.3-0.8-0.4-1 0.2-1.1 0.5-0.3 0.1-0.2-0.1-0.3-0.1-0.1-0.3-0.4-0.2-0.2-0.4 0-0.3 0.2-0.4 0.3-0.5 0.1-0.6 0.2-0.6 0.5-0.4 0.5-0.1 1-0.1 0.5-0.1 0.4-0.2 0.7-1.2 0.3-0.4 0.3-0.5 0.7-0.4 0.7-0.4 0.7-0.4 0.3-0.4 0.4-0.4 0.9-1.1 0.4-0.3 0.4-0.3 0.3-0.4 0.2-0.5 0.3-0.7 0.1-0.7 0.1-0.7 0-0.7-0.1-0.7 0-0.4-0.1-0.3-0.5-0.6 0-0.3 0.7-0.3 0.2-0.4 0-1 0.2-0.3 0.4-0.2 0.4-0.1 0.3-0.3 0-0.5 0-0.6 0-0.5 0.3-0.5 0.3-0.2 0.4 0.1 0.3 0.1 0.4 0.2 0.8 0 0.6-0.1 0.6 0.1 0.7 0.6 0.4 0.6 0.1 0.7 0 0.7 0 0.8 0.2 0.7 0.3 0.5 0.4 0.5 0.3 0.6-0.3 0.5-0.3 0.3 0 0.4 0.5 0.2 0.3 0 0.7-0.1 0.4 0 0.4 0.1 0.4 0.1 0.8 0.2 0.7 0.4 0.5 0.9 0.4 0.9 0 0.9-0.1 0.1-0.1 0.2-0.1 0.1-0.1 0.1-0.4 0.5-0.4 0.7-0.4 0.6-0.4 0.4-0.5 0.2-0.5-0.2-0.7-1-0.5-0.5-0.3 0.1-0.3 0.4-0.5 0.4-0.4 0.1-0.5-0.1-0.4 0.1-0.3 0.3 0.2 0.5 0.1 0.5 0.1 0.6-0.1 0.6 0 0.2 0.1 0.3 0.1 0.2 0.1 0.2-0.1 0.4-0.1 0.4-0.4 0.8 0.1 0.5 0.5 0.4 0.6 0.3 0.6 0.3 0.2 0.2 0.3 0.3 0.1 0.3 0.1 0.6 0.3 0.5 0.4 0.3 0.5 0 0.3-0.1 0.9-0.4 0.5 0.2 0.3 0.6 0 1 0.1 0.2 0.1 0.2 0.1 0.1 0.2 0.2 0.2 0 0.1 0 0.3-0.2 0.2-0.1 0.4-0.3 0.3-0.3 0.4-0.4 0.3-0.4 0.7-1 0.3-0.7 0.3-0.6 0.7-0.4 0.5-0.1 0.9-0.2 0.7 0.1 0.7 0.3 0.7 0.6 0.6 0.4 0.5 0.4 0.6 0.3 0.6 0.3 0.3 0.1 0.5 0.3 0.3 0.2 1.2 0.3 1.2 0.5 0.6 0.8-0.6 1.4-0.4 0.5-0.4 0.4-0.5 0.4-0.4 0.5-0.7 0.8-0.3 0.3-0.5 0.5-0.4 0.6-0.4 0.6-0.4 0.7-0.3 0.5-0.1 0.2-0.1 0.2-0.1 0.2 0 0.5 0.1 0.5 0.1 0.3 0.1 1.5-0.2 1.9-0.5 1.8-1 1-0.5 0-0.4 0.6-0.1 0.8-0.1 0.7 0 0.9 0.3 0.3 0.4 0.2 0.4 0.4 0 0.2-0.1 0.3 0 0.3 0.1 0.3 0.4 0.2 0.2 0.2 0.2 0.2 0.3 0.6-0.3 0.5-0.5 0.3-0.6 0.2-0.5-0.1-0.5 0.1-0.3 0.2 0.2 0.5 0.4 0.2 0.5 0.1 0.5 0 0.5 0.1 0.2 0.2 0.3 0.6 0.2 0.2 0.4-0.1 0.4-0.2 0.3-0.1 0.4 0 0.5 0.6 0.4 0.8 0.5 0.7 0.5 0.3 0.6 0 0.8 0.2 0.9 0.4 0.8 0.2 0.6-0.1 0.2-0.1 0.5-0.2 0.3-0.1 0.4 0.1 0.8 0.3 0.5 0.2 0.4 0.2 0.4 0.2 0 0.3-0.1 0.2-0.1 0.2-0.4 0.3-0.1 0.1-0.2 0.2-0.1 0.2-0.8 0.9-0.2 0.2-0.2 0.1-0.2 0-0.2 0-0.3 0-0.3 0-0.2 0.1-0.1 0.3-0.1 0.3-0.4 0.3-0.6-0.1-0.6-0.3-0.6-0.1-0.5 0.1-0.7 0.5-0.5 0.2-0.3 0.1-0.4 0-0.4 0.1-0.3 0.1-0.2 0.8 0 1 0.2 1.1 0.2 0.8 0.2 0.8 0.1 0.3 0 0.4 0 0.3 0.1 0.4 0 0.4 0.1 0.4 0.1 0.4 0.3 0.8 0.1 0.3 0 0.7-0.3 0.3-0.5 0.1-0.6 0.2-0.4 0.2-0.1 0.4-0.2 0.4-0.2 0.3-0.2 0.2-0.3 0.2-0.5 0.5-0.3 0.9 0 1 0.4 1 0.5 1.3 0.2 0.3 0.3 0.2 0.3 0.2 0.5 0.1 0.5-0.1 1.1-0.4 0.4 0 0.6 0.4 0.4 0.1 0.7 0.1 0.3 0.1 0.2 0.1 0.2 0.2 0.1 0.3 0.1 0.2 0 0.2 0 0.3 0.1 0.7 0.4 0.5 0.4 0.4 0.1 0.5-0.2 0.5-0.2 0.6-0.1 0.6 0.3 0.5 0.4 0.1 0.5 0 0.5-0.1 0.5 0.2 0.4-0.1 0.4-0.4 0.4-0.3 0.4-0.3 0.4-0.2 0.9-0.1 1.2-0.4 0.8-0.1 0.8-0.2 0.9-0.2 0.1 0 0.8-0.1 0.3 0.7 0.1 0.9 0.1 0.8 0.4 0.7 1.1 1.1 0.3 0.5z", id: "MEX2724", name: "Puebla", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Puebla', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Tabasco" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M863.8 523.1l0 18.2-13.9-0.1-0.1-0.1-0.2-0.5 0.1-0.5 0.1-0.5 0.2-0.3 0.4-0.2 0.4 0 0.4 0 0.1-0.5-0.1-0.1-0.8-1.3-0.2-0.3-0.3-0.2-0.7 0.1-0.4-0.1-0.4-0.1-0.4-0.3-0.2-0.3 0.2-1 0-0.5-0.3-0.2-0.3-0.2-0.2-0.2-0.6-0.2-0.7-0.2-0.6-0.2-0.4-0.2-0.5-0.2-0.7-0.3-0.5-0.4-0.2-0.5 0-0.7 0-0.3 0-0.3-0.2-1.1-0.3-1.2-0.4-1.2-0.6-0.9-0.6-0.2-0.7-0.1-0.6 0.1-0.7 0-0.4-0.3 0.1-0.6 0.3-0.6 0.2-0.3-0.2-1-0.1-0.3 0-0.2 0-0.7 0-0.2-0.5-0.8-0.6-0.5-0.7-0.1-0.6 0.5-0.8-0.4-0.5-0.1-0.4 0-0.4 0.2-0.2 0.3-0.1 0.3-0.2 0.4-0.4-0.5 0.1-1.1-0.5-0.3-0.2 0-0.7 0.2-0.9 0.6-0.9 0.9-0.8 0.9 0.6 1-0.7 0.5-1.1 0.1-1-0.2-0.6 0.5-0.7 0.5-0.8 0.4-0.8 0.3-1 0.2-1.1 0.3-1.1 0.3-0.8 0.6-0.3 1 0.1 0.8-0.3 0.6-1.1 0.3-0.7 0.2-0.6 0.5-1 1.1-2.8 2.4-1.2 1.2-1.9 1.8-0.5 0.4-0.9 0.6-1 0.1-1-0.4-0.9-0.5-0.4-0.4-0.4-0.5-0.4-0.5-0.3-0.5-0.6-1-0.4-0.9-0.5-0.7-1-0.2-0.8 0-0.5-0.3-0.2-0.7-0.1-0.8 0-1.4-0.6-2.6 0-1.4 0.2-0.5 0.3-1 0.2-0.5 0-0.6 0-0.6-0.1-0.6 0-0.6 0-0.2-0.1-0.7-0.1-0.8-0.4 0.7-0.6-0.1-0.7 0.7-1.1-0.2-1-0.7-0.7-0.9-0.8-0.4-0.6-0.4-0.3-0.2-1.1-0.2-0.8-0.2-0.5-0.1-0.3 0.2-0.4 0.5-0.2 0.2-0.4 0.1-0.1 0.7-0.7 1.9-0.6 2-0.6 2-0.5 1.9-0.2 0.6-0.1 0.6-0.2 0.6-0.2 0.5-0.4 0.4-0.5 0.3-0.4 0.3-0.4 0.4 0 0.2-0.1 0.6-0.1 0-0.1 0-0.3 0.3-0.6 0.3-0.1 0.2-0.2 0.4-0.2 0.2-0.4 1.3-0.8 1.9-0.9 1.9-0.6-0.2-0.5-0.3-0.4-0.4-0.2-0.6 0-0.3 0.3-0.7 0-0.4 0.1-0.3 0.2-1 0.2-0.8 0.1-0.7-0.2-0.5-1-0.4-0.4-0.4-0.7-0.7-0.7-0.8-0.7-1.3-0.8-0.6-0.9-0.3-0.9-0.3-0.3 0-0.4 0-0.3-0.1-0.1-0.2-0.1-0.6-0.3-0.3-0.5-0.1-0.6 0-1.2-0.4-0.3-0.8-0.1-0.9-0.7-0.7-0.4-0.2-0.5 0-0.4-0.1-0.4-0.2 0-0.1-0.2-0.4-0.1-0.1-0.2-0.1-0.5 0-0.2 0-0.5-0.5 0-0.7 0.2-1.6 0.1-0.5 0.3-0.4 0.3-0.5-0.3-0.4-0.3-0.3 0-0.3 0-0.4-0.1-0.4-0.2-0.2-0.3-0.4-0.1-0.2 0.1-0.2 0.2-0.1 0.1-0.3-0.2-0.2-0.3-0.3-0.1-0.4 0.1-0.5 0-0.4-0.1-0.4-0.2-0.2-0.4 0-0.3-0.1-0.2-0.3 0-0.8-0.2-0.3 0.1 0 0.7-0.4 0.9-0.4 2.4-0.5 0.5-0.5 0.6-0.3 3.5-1.2-0.2 0.4-0.3 0.3-0.2 0.4-0.1 0.4 0.3 0.2 2.5-0.4 0.6-0.1 0.4-0.3 0.3-0.4 0-0.3-0.2-0.2-0.1-0.2 0.1-0.3 0.2-0.2 0.4-0.2 0.2-0.2 0.4 0.1 0.5-0.1 0.4-0.2 0.4-0.3 0.2 0.6 0.7 0.2 2-0.4 0.4-0.4 0.4-1.1-0.3-0.8-0.1-0.1-0.3 0-0.4 0.2-0.4 0.2-0.2 0.2-0.4 0.3-2.2 0.7-0.2 0.2-0.3 0.3-0.2 0.2-1.4 0.2-1 0.8-0.4 0.2-0.3 0-0.4 0-0.3 0.4 0.2-0.7 0.6-0.3 0.6-0.2 0.3-0.3 0.3-0.3 5.9-2.2 1.4-0.3 3.4-0.5 4.4 0.2 4.7-0.2 0 0.2-0.3 0.5-0.3 0.3-0.3 0.1 0.2 0.3 0 0.8 0.2 0.3 0.3 0 0.5-0.2 0.5-0.3 0.2-0.2 0 0.5-0.3 0.6-0.1 0.5 0.2 0 0.5-0.7 0.2-0.2-0.2-0.2 0.6-0.1 0.2-0.5-0.2-0.6-0.7-0.2-0.7-0.1 0-0.3 0.5-0.3 0.7-0.2 5.1-0.1 2.6-0.7 1.6-0.9 1.5-1.4 0.6-0.9 0.3-0.5 0.1-0.3 0.3-0.2 0.3 0.1 0.1 0.2 0.4 1.1 0.3 3.2 0.4 0.9 0.2-1-0.2-0.5 0-0.7 0.2-1.4-0.2-0.7-0.7-1.5-0.1-0.4 0.4-0.3 0.8 0 1.4 0.1 0.7-0.1 3.3-0.8 0.2-0.1 0.1 0.6 0.4 0.7 0.4 0.6 0.4 0.6 0.3 0.8 0.1 0.8 0.3 0.8 0.5 0.6 0.2 0.2 0.5 0.4 0.3 0.2 0.3 0.1 0.3 0 0.2-0.2 0.3 0 1.4 0.2 1.5 0 1.5-0.1 1.4 0-0.1 3 0 3.1-0.1 1-0.1 1.3 0.1 1.3 0.4 0.8 0.8 0.5 0.8 0.6 0.7 0.6 0.7 0.5 0.4 0.3 0.4 0.2 0.4 0.2 0.5 0.2 0.6 0.3 0.1 0.6 0.2 0.5 0.5 0.3 0.9 0.5 0.9 0.6 1 0.5 1 0 1.6 0 3 0 1.6 0 0.2-0.3 0.4-0.8 0.3-0.8 0.1-0.6 0-0.2-0.1-0.4 0-0.4 0-0.3 0.2-0.6 0.2-0.4 0.7-0.2 0.9-0.1 0.9 0.1 0.7 0 0.4 0 0.3 0.1 0.4 0.1 1 0.4 0.5 0.1 0.5 0.2 0.6 0.1 0.7 0 0.5 0.2 0.5 0.3 0.6 0.4 0.5 0.4 0.6 0.4 0.6 0.4 0.5 0.1 1.3-0.1 0.6 0.1 0.6 0.2 0.3 0.3 0.3 0.3 0.2 0.2 0.5 0.1 1.8 0.1 1.9 0.1 0 3.8 0 1.7z", id: "MEX2725", name: "Tabasco", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Tabasco', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Tlaxcala" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M622.7 467.8l-0.1-0.8 0-0.5-0.1-0.4-1-0.3-0.5-0.3-0.2-0.7-0.2-1 0.4 0 0.7-0.1 0.4 0 0.4-0.1 0.2-0.1 0.1-0.3 0.2-0.4 0.3 0.2 0.4-0.2 0.7-0.6 0.5-0.1 0.4 0.3 0.4 0.3 0.5 0 0.4-0.3 0.5-0.5 0.5-0.2 0.6 0.6 0.1 0.1 0.6 0.2 0.7 0 0.7 0.1 0.6 0.1 0.4 0.2 0.7 0.4 0.5-0.4 0.4-0.8 0.3-0.8 0.2-0.4 0.3-0.3 0.2-0.4 0.3-0.3 0.2-0.3 0-0.2 0.1-0.1 0.5-0.2 0.1 0 0.2 0.4 0.1 0.1 0.7 0.5 0.7 0.4 0.8 0.2 0.8 0 0.9 0 0.4 0 0.4 0 0.5-0.2 0.1-0.3 0-0.4-0.1-0.6 0.3-0.5 0.6 0.4 0.5 0.9 0 1-0.4 0.6 0.2 0.3 0.5 0.2 0.6 0 0.6 0.3 0.4 0.5 0.4 0.5 0.5 0.4 0.8 0.3 1.3 0.4 1 0.5-0.3 0.9-0.3 0.1-0.3 0-0.3 0.1-0.1 0.3 0 0.3 0.2 0.3 0.1 0.1 0.3 0.1 0.2 0.4 0.2 0.6 0.2 0.4 0.5-0.1 0.5-0.4 0.6-0.2 0.5 0 0.6 0.3 0.4 0.4 0.3 0.4 0.4 0.4 0.3 0.4 0.3 0.3 0.4 0.3 0.4 0.3 0.4 0.1 0.8-0.1 0.6 0.3 0.3 0.6-0.2 0.9-0.7 0.7-0.8 0.5-1 0-0.8-0.5-0.1-0.1-0.1-0.1-0.5 0.3-0.9 0-0.9-0.3-0.8-0.2-0.1 0.1-0.2 0.1-0.1 0.2-0.1 0.2-0.4 0.1-0.3 0.2-0.3 0.2-0.2 0.3 0 0.2 0.2 0.6 0.6 0.5 0.3 0.6-0.1 0.6-0.3 0.2-0.8 0.7-0.6 0.4-0.8-0.1-0.7-0.3-0.7-0.4-1.8-0.8-0.3-0.1-0.3-0.1-0.5 0.8-0.6 0.9-0.7 0.8-0.8 0.2-0.6 0.2-0.7 0.3-0.6 0.2-0.7-0.2-0.3-0.3-0.4-0.8-0.4-0.5-0.9-0.8-0.6-0.4-0.3-0.2-0.2-0.2-0.3-0.1-0.2-0.2-0.2-0.2-0.2-0.2-0.2-0.2-0.1-0.2-0.3-0.7-0.2-0.5-0.2-0.5-0.3-0.5-0.4-0.4-0.5-0.4-0.4-0.2-0.2-0.2-0.1-0.4-0.1-0.4-0.2-0.4-0.2-0.3-0.2-0.4-0.1-0.4-0.1-0.4 0-0.3-0.1-0.2-0.5-0.4-0.3-0.1-0.4 0.1-0.5 0.4-0.9 0-1-0.2-1-0.3-0.9-0.3z", id: "MEX2726", name: "Tlaxcala", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Tlaxcala', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "CDMX" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M612.5 480.3l-0.4 0-0.4 0-0.5 0-0.4 0.1-0.2 0.3-0.3 0.4-0.3 0.2-0.3-0.1-0.6-0.4-0.6-0.4-0.6-0.2-0.6-0.1-1-0.1-1-0.2-1.1-0.2-1.1-0.4-0.7-0.7-0.2-0.2-0.2-0.2-0.3-0.5-0.1-0.5-0.1-0.6 0.1-0.7 0-0.1-0.1-0.1-0.1-0.1-0.2 0-0.3-0.2-0.1-0.3 0.2-0.3 0.2-0.3 0-0.1 0-0.1-0.2-0.2-0.1-0.7 0.2-0.7 0.4-0.7 0.1-0.7 0.6 0.1 0.6 0.1 0.4-0.2 0.3-0.6 0.1-0.3 0.3-0.5 0.4-0.6 0.4-0.5 0.4-0.5 0.5-0.7 0.1-0.2 0.2-0.1 0.2-0.1 0.2-0.1 0.3-0.2 0.1-0.2-0.2-0.3-0.3-0.1 0.3-0.3 0-0.3 0-0.4 0.3-0.3 0.3-0.3 0.4-0.4 0.3 0.2 0.2 0.2 0.2 0.3 0.1 0.2 0 0.3 0 0.2 0.1 0.5 0.2 0.4 0.2 0.2 0.4 0.2 0.1 0.3 0.1 0.3 0.1 0.2 0.3 0.5 0.2 0.5 0.2 0.3-0.1 0.3-0.2 0.2-0.3 0.2 0.1 0.2 0.3 0.3-0.5 0.5 0.5 0.4 0.5 0.3 0.7 0.3 0.5 0.3 0.2 0.2 0.3 0.5 0.2 0.3 0.2 0.7 0.1 0.4 0 0.4 0 0.5-0.2 0.8 0 0.7 0.1 0.6 0.5 1 0.2 0.5 0 0.2-0.1 0.4-0.2 0.4-0.5 0.7z", id: "MEX2727", name: "CDMX", onMouseEnter: function () {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'CDMX', open: x.disable }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Guanajuato" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M586.5 402l0 0.4-0.2 0.5-0.1 0.4 0.2 0.4 0.1 0.5 0 0.3-0.1 0.3-0.1 0.4 0.1 1.1 0.6 0.5 0.8 0.1 0.9 0.1 0.4 0.3 0 0.5-0.2 0.4-0.4 0.4-0.8 0.3-0.3 0.1-0.3 0.3-0.2 0.4-0.2 0.3-0.1 0.3-0.5 0.2-0.8 0.3-0.9 0.1-0.9-0.2-0.5-0.6-0.4-0.3-0.5-0.2-0.5-0.2-0.5-0.1-0.8 0.1-0.8 0.2-0.8 0.5-0.5 0.7-0.4 1.1-0.2 1.2-0.1 1.3-0.1 1.2 0 0.8-0.1 0.8-0.2 0.8-0.3 0.7-0.3 0.2-0.2 0.1-0.3 0.1-0.3 0.1-0.2 0.2-0.2 0.3-0.2 0.3-0.3 0.2-0.7 0-0.5-0.4-0.4-0.6-0.4-0.5-0.1-0.2-0.2 0-0.6-0.1-0.6 0.3-0.5 0.4-0.5 0.3-0.6 0.2-0.6 0-0.6-0.1-0.7-0.1-0.9-0.3-0.3-0.6-0.1-0.8-0.5-0.5-0.6 0-0.5 0.6-0.3 0.8-0.3 0.6-0.5 0.4-0.2 0.6 0 1.2-0.1 0.5-0.2 0.6-0.3 0.5-0.3 0.5-0.6 1.4-0.1 1.4 0.3 1.4 0.6 1.4 0.4 0.6 0.4 0.6 0.4 0.6 0.3 0.6 0.1 1.3 0 1.2 0.1 1.2 0.5 1.1 0.5 0.6 0.6 0.7 0.7 0.7 0.5 0.7 0.3 0.9 0.4 0.8 0.6 0.3 0.5 0.3 0.4 0.7 0.3 0.2 0.4 0.1 0.3 0.1 0.3 0.2-0.5 0.5-0.3 0.4-0.2 0.4-0.3 0.6-0.1 0.3-0.3 0.5-0.3 0.4-0.3 0.2-0.5-0.1-0.2 0-0.2 0-0.1 0.2 0 0.2 0.1 0.1 0 0.1-0.3 0.6-0.1 0.3 0 0.4 0.4 0.7 0.2 1.2 0 1-0.5 0.4-1.5 0.1-0.8 0.1-0.7 0.2-0.4 0.4-0.2 0.6-0.2 0.5-0.5 0.1-0.3-0.2-0.1-0.3 0.1-0.4-0.1-0.4-0.5-0.1-0.7 0-1.3 0.1-1.7 0.1-0.6 0-0.6 0-0.3 0.1-0.2 0.3 0 0.7-0.8 0-0.5-0.1-0.4-0.3-0.3-0.6-0.2-0.4-0.6-0.5-0.3-0.4-0.4 0.6-0.5 0.5-0.5 0.3-0.7 0.2-0.5 0.1-0.6 0-0.5 0-0.5-0.2-0.8-0.3-0.9-0.4-0.7-0.5-0.2-0.8 0.6-0.5 0.7-0.3 0.6-0.3 0.1-0.6-0.4-0.4-0.1-0.2 0.1-0.3 0-0.2 0-0.3-0.1-0.2-0.7-0.3-0.8 0-0.7 0-0.7 0.3-0.5 0.1-0.4-0.1-0.3-0.3-0.3-0.3-0.8 0.2-0.3 0.7-0.2 0.9-0.5 0.6-0.6 0.2-0.6 0-0.7-0.2-0.5-0.3-0.5-0.1-0.3 0.1-0.4 0.1-0.5 0-0.2 0-0.5-0.4-0.2 0-0.3 0.1-0.3 0.1-0.3 0.2-0.3 0.1-0.9-0.5 0-0.8 0.3-1 0.1-1-0.1-0.2 0-0.2-0.2-0.2-0.2-0.3 0-0.1 0.1-0.1 0.1-0.2 0.1-0.2 0-0.2 0.1-0.2 0-0.2-0.2-0.3-0.2-0.1-0.2-0.1-0.1-0.3 0.3-0.5 1.2-0.6 0.3-0.5-0.2-0.5-0.6-0.4-0.7-0.2-0.6-0.1-0.4 0-0.2-0.2-0.1-0.3 0.1-0.4-0.6 0.1-1.1-0.2-0.6 0.1-0.3 0-0.7 0.3-0.2 0.1-1.1 0-0.2 0.1-0.1 0.3-0.1 0.3 0.1 0.4 0 0.3-0.1 0.3-0.3 0.5-0.1 0.2-0.2 0.5-0.8 1-0.3 0.5-0.5-0.4-0.5-0.1-1.1 0-0.9-0.2-0.3 0-0.3 0.1-0.3 0.3-0.3 0-0.1 0-0.5-0.3-0.3-0.1-0.3 0.1-0.4 0.3-0.3 0-0.8 0-0.4-0.1-0.2-0.4-0.2-0.8-0.1-0.2-0.2-0.1-0.1-0.2-0.3-3-0.3-0.8-0.4-0.3-0.6 0.2-0.3 0.9-0.4 0.3-0.4-0.4 0.2-0.7 0.5-1.2-3.3 0.5 0.1-0.5 0.5-1.2 0.6-1 0.8-1.1 0.9-0.9 0.9-1 0.4-1-0.3-1.4-0.2-0.4-0.8-0.8-0.8-0.7-0.9-0.7-0.7-0.8-0.3-1 0.2-1.1 0.4-1 0.5-1 0.4-0.8 1.3-2.2 0.9-1.4 0.9-1.4 0.9-1.3 1.1-1.3 0.2-0.3 0.2-0.3 0.2-0.6 0.3-0.5 0.5-0.3 0.4-0.3 0.4-0.3 0.3-0.4 0.4-0.8 0.2-0.4 0.4-0.2 0.6-0.1 0.7 0 0.5 0 0.5 0 0.4-0.1 0.4-0.3 0.4-0.3 0.8-0.7 0.8-0.7 0.7-0.8 0.5-1 0.2-0.7 0-0.6 0-0.7-0.2-0.6-0.7-1.1-0.7-1-0.6-1-0.1-1.3 0.8-1.1 1.3-0.8 1.1-0.9 0.2-1.1-0.5-0.7-0.5-0.7-0.5-0.7-0.2-0.8 0.2-0.8 0.6-0.8 1.3-1.4 1.2 0.7 1 0 0.9-0.4 1.2-0.8 0.3-0.1 0.7-0.3 0.8-0.1 0.7 0.2 0.5 0.6 0.1 0.5-0.1 0.5 0.1 0.5 0.2 0.5 0.2 0.3 0.4 0.3 0.3 0.3 0.4 0.2 1.1 0.1 1.2-0.2 1.2-0.3 1.1-0.1 1 0 1.1 0.1 1 0.3 1 0.3 0.5 0.4 0.5 0.5 1 1 1.4 1.2 1.5 1.2 1.5 1.2 1.5 1.1 0.6 0.6 0.7 0.6 0.6 0.5 0.7 0.5 1.1 0 1.1 0 1.1-0.2 0.7-0.5 0.3-0.7 0.1-0.7 0.1-0.8 0.2-0.7 0.1-0.4 0.2-0.5 0.2-0.4 0.2-0.4 0.2-0.3 0.3-0.3 0.4-0.2 0.3-0.2 0.4 0 0.3 0.1 0.2 0.2 0.2 0.2 0.4 0.1 0.3 0.1 0.3 0.1 0.4 0.2 0.5 0.3 0.6 0.3 0.6 0.2 0.6 0.3 0.4 0.2 0.3 0.2 0.4 0.1 0.4 0.1 1.1 0.3 1 0.3 1 0.4 1.1 0.3 0.3 0.2 1.2 0.9 1.2 1.3 1.3 1 1.3 0.1 1.2 0 1 0.3 0.8 0.5 1 0.5z", id: "MEX2728", name: "Guanajuato", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Guanajuato', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Guerrero" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M595.8 494.1l-0.3 0.6-0.2 0.6 0.1 0.5 0.7 0.2 0.6 0.1 0.1 0.5 0.2 0.6 0.6 0.2 0.2 0.4 0.5 0.8 0.2 0.4 0.3 0.4 0.3 0.3 0.4 0.2 0.4 0 0.6 0.1 0.2 0.5 0 0.7 0.3 0.3 0.6 0 0.7 0 0.7 0 0.7-0.1 0.1-0.3 0.1-0.4 0.1-0.9 0.2-0.8 0.4-0.6 0.6-0.4 0.8 0.1 0.3 0.1 0.2 0.1 0.2 0.2 0 0.3 0.1 0.4 0 0.5 0.1 0.3 0.3 0.3 0.2 0.3 0.2 0.2 0.1 0.2 0.1 0.4 0.4 0.9 0.7 0.7 0.6 0.7 0.3 1.2 0.1 0.5 0 0.5 0 0.5 0 0.5 0.2 0.5 0.2 0.3 0.1 0.4 0 0.5 0.9-0.1 0 0.4 0.1 0.4 0.1 0.4 0.3 0.3 0.6 0.4 0.4-0.3 0.4-0.2 0.4 0.1 0.1 1.3 0.2 0.6 0.5 0.3 0.5 0 0.8 0.1 0.7 0.2 0.4 0.2 0.4 1.5 0.9 1.2 1.2 0.8 1.4 0.6 0.6 0.2 0.7 0.1 0.6 0.2 0.6 0.1 0.3 0.2 0.3 0.1 0.3 0.1 0.3 0.1 1 0.2 1.1 0.1 1-0.1 1-0.2 0.6-0.2 0.3 0 0.4 0.1 0.4 0.4 1.7 1.9 0.6 0.6 0.1 0.5-0.2 0.6-0.4 0.7-0.2 0.6-0.1 0.7-0.2 0.6-0.1 0.6-0.1 0.5-0.3 0.8-0.2 1.3-0.1 0.8 0 0.8 0.5 0.6 0.2 0.1 0.1 0.2 0 0.2-0.2 0.2-0.3 0.3-0.1 0.4 0.1 0.5 0.1 0.5 0.7 0.6 0.4 0.5 0.4 0.5 0.1 0.4 0 0.5-0.3 0.9 0.2 0.2 0.3 0.7-0.1 0.6-0.2 0.7-0.1 0.7 0.2 0.6 0.4 0.3 1.2 0.5 0.5 0.7 0.4 0.9 0.5 0.7 0.8 0.2 0.9-0.1 0.4 0.1 0.4 0.1 0.4 0.5 1.1 1.2 0.9 1.3 1 1.3 0.9 1.3 0.2 0.3 0.1 0.3 0.1 0.4-0.1 0.4-0.1 0.3-0.1 0.4-0.1 0.3-0.2 0.3-0.2 0.5-0.3 0.4-0.3 0.4-0.3 0.4-0.2 0.4 0.1 0.3 0 0.3-0.1 0.4 0 0.6-0.2 1.2-0.1 0.6-0.1 0.6-0.2 0.4-0.3 0.3-0.4 0.3-0.2 0.3-0.1 0.2-0.3 0.3-0.2 0.1-0.2 0.1-0.5 0.2-0.4 0.2-0.4 0.1-0.5-0.1-0.4-0.1-0.4 0-0.4 0-0.4 0.2 0.3 0.9 0.3 0.9 0.1 1-0.3 0.9-0.2 0.4-0.7 0.2-0.5 0-0.5-0.2-0.6 0-0.8 0.4-0.4 0.6 0 0.7 0.5 0.8 0.5 1.1-0.2 1-0.7 0.9-0.8 0.8-0.8 0.5-0.8 0.1-0.8 0-0.9 0.1-0.8 0.2-0.7 0.3-0.5 0.4-0.5 0.5-0.1 0.1-0.4-0.2 0-0.1 0.1-0.1 0-0.3-0.5-0.7-1.2-1-2.5-2.3-1.2-1.7-0.9-1-0.1-0.2-0.3-0.2-0.4 0.1-0.5-0.2-0.2 0.2-0.3 0-0.3 0.1-0.5 0.1-0.1 0.2-0.2 0.4-1-0.2-0.6 0-1.2-0.5-6.2-2-5.2-1.4-2.1-0.5-3.8-0.6-2 0-1.5 0.1-1-0.2-0.8-0.3-0.8-0.3-1.7-0.7-1.7-1.4-0.8-0.6-0.2 0-0.2 0.3-0.3-0.2-0.1-0.2-0.3-0.1 0.2-0.1 0.4 0.2 0.1-0.3-0.2-0.2-0.2-0.1-0.2 0.2-0.3-0.1-0.2 0-0.2-0.2 0.2-0.1 0-0.3 0.2-0.3 0.2 0.1 0.2-0.1 0-0.2-0.3-0.3-0.2-0.2-0.5-0.1-0.5 0.2-0.3 0.3 0 0.2 0.3-0.1 0.2 0.1-0.3 0.3-0.4 0.1-0.2-0.2-0.2-0.8-0.2-0.1-0.7-0.8-0.1-0.3-1.1-0.5-2.3-0.9-1.6-0.4-1.6-0.6-2.1-0.8-2.7-1.1-7.7-2.7-2.8-0.9-1.9-0.6-2.1-1-1.7-0.6-2.1-0.6-1.7-0.6-1.7-0.6-1.1-0.5-0.5 0.2-0.2-0.4 0.4-0.2-0.1-0.7-0.5-0.6-1-1-2.1-1.3-0.4-0.7-2.5-1.5-2.7-0.9-1.4-0.7-2-0.7 0-0.4 0.4 0 0.1-0.6-0.3-0.5-0.3-0.4-1.2-1-0.9-0.1-0.9 0.2-0.1-0.5-0.4 0-0.3-0.3-0.5 0-0.1-0.6-0.5-0.2-0.9-0.3-0.1-1.2-0.8-1.2-0.8-0.5-1.5-1.2-0.4-0.8-0.4-0.4-0.1-0.7-1.2-1.3-1.4-0.7-0.5-0.2-1.9-1.1-1.8-0.8-1.5-0.6-2 0.3-0.3 0.6-0.6 0.4-0.5 0.6-0.6 0.3-0.2 0.1 0.3-0.6 0.2-0.3 0.1-0.3-0.1-0.5-0.6-1-0.2-0.6 0-0.9 0-1 0.1-1 0.2-0.9 0.2-0.6 0.1-0.3 0.3-0.3 0.3-0.3 0.3-0.2 0.3 0 0.5 0 0.6 0 0.5-0.1 0.5-0.2 0.5-0.1 0.5 0 0.5 0.1 0.4-0.1 0.5-0.3 0.3 0 0.6 0.1 0.3 0 0.3-0.1 0.2-0.2 0-0.3 0.2-0.3 0.4-0.6 0.6-0.7 0.3-0.8 0.1-0.8-0.4-2.3-0.2-2.3 0.4-2.1 1.3-1.8 1.2-0.4 1.3-0.1 2.6 0.2 0.5 0.1 0.5 0.1 0.5 0.2 0.4 0.4 0.3 0.5 0.2 0.4 0.3 0.5 0.5 0.4 0.6 0.4 0.6 0.3 0.7 0.2 0.8 0.1 1.7-0.3 1.6-0.5 1.7-0.4 1.6-0.5 0.8-0.3 5 0.3 1.6-0.4 0.7 0 0.7 0.4 0.1 0.1 0 0.6 0.2 0.2 0-0.1 0.3-0.1 0.4 0 0.2 0.1 0.1 0.4 0.2 0.8 1.1-0.3 0.2-0.3-0.4-0.5 3.4 0.1 0.4 0.2 1.1 1.2 0.4 0.3 0.5 0.3 0.5 0.2 0-0.1 0.2-0.5 0-0.1 0.1 0.1 0.3 0.1 0.1 0 0.1 0.2 0.1 0.3 0.1 0.5 0 0.3-0.3 0.3-0.3 0.3-0.2 0.4 0 0.5 0.3 0.5 0.7 0.7 1-1 0.1-0.1 0.4 0.2 0.2 0.5 0.5-0.7 0.4-0.7 0.2-0.7-0.3-0.6-0.8-0.6-0.8-0.6-0.8-0.6-0.9-0.6-0.6-0.5-0.3-0.6-0.1-0.7 0-0.9 0-0.8-0.2-0.7-0.2-0.7-0.3-0.7-0.1-0.8 0.2-0.5 0.4-0.5 0.2-0.7-0.3-0.5-0.6-0.6-0.5-0.5 0-0.6 0.4-0.5 0.4-0.5 0.4-0.6 0.5-0.3 0.7 0.1 0.5 0.5 0.2 0.8 0.2 0.7 0.3-0.2 0.4-0.4 0.3-0.4 0.1-0.6 0.2-0.3 0.6-0.6 1.2 0.4 1.2 0.3 1.2 0.2 1.3 0 0.4 0 0.3 0.1 0.1 0.4 0 0.5 0.1 0.4 0.2 0.2 0.2 0.3 0 0.4-0.3 0.6-0.3 0.6 0 0.7 0.3 0.7 0.2 0.4 0 0.4 0 0.4-0.1 0.4 0.1 0.4 0.2 0.3 0.3 0.3 0.2 0.3 1.2 1.1 0.5 0.7 0.2 0.7-0.1 0.9-0.3 0.9-0.2 0.8 0.3 0.6 0.3 0.3 0.2 0.3 0.5 0.5 0.3 0.3 0.4 0.2 0.5 0 0.4-0.1 0.4-0.3 0.2-0.3 0.2-0.3 0.4-0.1 0.7-0.6 0.7-0.5 0.7-0.6 0.7-0.6 0.7-0.8 0.6-0.8 0.4-0.9 0.6-1.2 0.1-0.2 0.7-0.1 0.6-0.1 0.6-0.2 0.7-0.2 0.6-0.2 0.6-0.2 0.7-0.2 0.6-0.2 0.4-0.1 0.3-0.1 0.7-0.2 0.5 0 0.5 0.1 0.5 0.4 0.4 0.5 0.3 0.3 0.4 0.1 0.5-0.5 0.3-0.4 0.1-0.3 0-0.4 0-0.4 0.2-0.4 0.3-0.2 0.3-0.2 0.9-0.8 0.5-0.5 0.8-0.7 0.6 0.3 0.6 0.7 0.6 0.6 0.4 0.1 0.2 0.2 0.3 0.7 0.4 0.4 0.8 0.1 0.7 0.1 0.6-0.2z", id: "MEX2729", name: "Guerrero", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Guerrero', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Hidalgo" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M642.9 433.5l-0.9 1.1-0.4 0.4-0.3 0.4-0.7 0.4-0.7 0.4-0.7 0.4-0.3 0.5-0.3 0.4-0.7 1.2-0.4 0.2-0.5 0.1-1 0.1-0.5 0.1-0.5 0.4-0.2 0.6-0.1 0.6-0.3 0.5-0.2 0.4 0 0.3 0.2 0.4 0.4 0.2 0.1 0.3 0.3 0.1 0.2 0.1 0.3-0.1 1.1-0.5 1-0.2 0.8 0.4 0.4 1.3 0.1 0.9 0 0.3 0.3 0.6 0.3 0.6 0 0.5-0.5 0.6-0.8 0.6-0.5 0.8-0.2 0.9-0.2 0.9-0.3 0.4-0.5 0.7-0.2 0.4-0.2 0.2-0.2 0.2-0.5 0.8-0.4 0.7-0.2 0.8 0.2 0.7 0.8 1.3 0.7 1.4 0.8 1.4 0.9 1.1-0.8 0-0.8-0.2-0.7-0.4-0.7-0.5-0.1-0.1-0.2-0.4-0.1 0-0.5 0.2-0.1 0.1 0 0.2-0.2 0.3-0.3 0.3-0.2 0.4-0.3 0.3-0.2 0.4-0.3 0.8-0.4 0.8-0.5 0.4-0.7-0.4-0.4-0.2-0.6-0.1-0.7-0.1-0.7 0-0.6-0.2-0.1-0.1-0.6-0.6-0.5 0.2-0.5 0.5-0.4 0.3-0.5 0-0.4-0.3-0.4-0.3-0.5 0.1-0.7 0.6-0.4 0.2-0.3-0.2-0.2 0.4-0.1 0.3-0.2 0.1-0.4 0.1 0.1-0.2 0.3-0.6 0.3-0.6 0.3-0.5 0.3-0.6 0.1-0.4 0.3-0.4 0.2-0.5 0.1-0.3 0-0.5-0.1-0.3-0.2-0.3-0.3-0.5-0.6-0.9-0.1-0.2-0.3-0.4-0.1-0.2-1-1-0.2-0.3-0.3-0.2-0.3 0-0.3 0.1-0.9 0.3-0.6-0.1-0.6-0.3-0.5-0.8-1.1-0.4-1.2 1.4-1.3 1.4-1.4-0.2-0.1-0.1-0.1-0.3 0-0.3 0-0.3 0.2-0.6 0.1-0.7 0.3-0.6 0.5-1.2-0.1 0-0.3-0.1-0.1 0 0.1-0.3 0.1-0.4 0-0.3 0-0.4-0.1-0.5-0.2-0.4-0.2-0.3-0.3-0.4-0.3-0.2-0.3-0.2-0.5-0.1-0.6-0.1-0.5 0-0.5 0.2-0.6 0.4-0.7 0.4-0.7 0.4-0.7 0.2-0.6 0.1-0.5 0-0.5 0.1-0.5 0.3-0.2 0.6-0.1 0.6 0 0.7-0.1 0.6-0.2 0.3-0.3 0.1-0.3 0-0.3-0.1-0.7 0.5-0.1 1.1-0.4 0.9-1-0.1-0.8 0.6-0.7 1.1-0.6 0.6-0.3-1.1 0-0.7-0.1-0.4-0.2-0.2-0.2-0.2-0.3-0.1-0.1-0.2 0-0.3 0-0.9-0.2-0.7-0.5-0.4-0.7-0.2-0.8-0.3-0.5-0.3-0.2-0.6 0.1-1 0.3-0.7 0.2-0.6 0.2-0.6 0.2-0.7-1.2-1.9-0.4-0.7-0.2-0.3-0.2-0.4-0.4-0.2-0.7-0.1-0.8 0.1-0.5 0.2-0.2 0.3-0.1 0.4-0.2 0.3-0.5-0.3-0.9-0.7-1-0.9-0.9-0.9-0.7-0.9-0.2-0.3-0.1-0.2-0.2-0.6-0.3-0.4-0.5-0.3-1.1-0.6 0.3-2.3 0.3-2.3 0.1-0.7 0.1-0.8 0-0.7 1-0.5 1.2-0.5 1.1-0.4 1.1-0.2 0.1-0.2 0.5 0.2 0.5-0.1 0.4-0.3 0.3-0.3 0.1-0.3 0.2-0.3 0.2-0.3 0.3-0.2 0.1 0 0.3 0.3 0.2 0 0.1-0.2 0.2-0.2 0.1-0.3 0.1-0.2 0.1-0.1 0.5-0.1 0.2-0.1 0.3-0.2 0.3-0.3 0.4-0.2 0.5 0-0.1-0.2-0.2-0.2-0.4-0.5-0.3-0.6-0.1-0.7 0.1-0.3 0.5-2.3 0.4-1.1 0.6-0.9 1.8-1.2 0.3-0.2 0.3-0.4 0.2-0.5 0.1-1.3 0.1-0.6 0.7-0.9 0.2-0.5 0-0.5-0.8-1.3 0-0.5 0.5-0.5 0.3-0.1 0.6-0.1 0.3-0.2 0.5-0.7 0.3-0.1 0.6 0 1.1 0.7 0.6 0.2 1-0.2 1.4-1.2 0.9-0.4 0.8 0.1 0.3 0 0.2-0.1 0.3-0.2 0.2-0.1 0.5 0.2 0.3 0-0.1-0.8-0.1-1.5 0.1-0.4 0-0.4 0.6-0.7 0.9-0.3 1 0 0.8 0.2 0.2 0.2 0.1 0.2 0.2 0.2 0.2 0.7 0.1 0.4 0.1 0.5 0.2 0.3 0.3 0.3 0.4 0.2 0.8 0.3 0.5 0.3 0.6 0.3 0.5 0 0.6-0.1 0.7-0.4 0.8-0.3 0.8-0.3 0.8-0.1 0.4 0.1 0.5 0.2 0.3 0 0.2 0 0.3 0 0.2-0.2 0.2-0.2 0.3-0.1 0.3 0 0.3 0.2 0.2-1.2 0.1-1.2-0.1-1.2-0.1-1.5 0-0.3 0.2-0.2 0.3-0.2 0.9-0.3 0.5-0.1 0.5-0.2 0.2 0.1 0.5 0.4 0.5 0.3 1.1 0.8-0.6 0.7-0.6 0.6-0.3 0.8-0.1 0.9 0 0.3 0.1 0.2 0.1 0.2 0.2 0.1 0.6 0.2 0.6 0.6 0.5 0.7 0.5 0.6 0.4 0.3 0.3 0.3 0.4 0.2 0.5 0 0.6-0.5 0.8-0.6 0.6-0.7 0-0.7-0.1-0.5 0.4-0.1 0.4 0.3 0.2 0.5 0 0.9-0.4 0.9-0.3 0.9 0.4 0.6 0.9 0.1 0.6-0.7 0.5-0.3 0.7 1 0.3 0.2 0.3 0.1 0.2 0.3 0.2 0.4 0.2 0.2 0.3 0 0.2 0.2 0.2 0.3 0 0.3-0.2 0.5-0.2 0.5-0.2 0.3-0.2 0.1-0.2 0-0.2 0-0.1 0.1-0.2 0.3-0.2 0.2-0.2 0.3-0.2 0.3-0.2 0.3-0.3 0.3-0.2 0.3-0.4 0.7-0.2 1.1 0 1.2 0.3 0.9 0.1 0.2 0 0.1-0.1 0.1-0.2 0.1-0.8 0-0.7-0.2-0.7-0.4-0.7-0.5-0.4-0.1-0.4-0.2-0.4-0.1-0.4-0.1-0.5 0-0.5 0-0.5 0.3-0.2 0.3 0.1 0.4 0.2 0.3 0.2 0.3 0.1 0.4-0.1 0.4 0 0.3-0.1 0.3-0.4 0.2-0.4 0.1-0.4 0-0.4 0.1-0.4 0.1-0.4 0.5 0.1 0.5 0.3 0.4 0.6 0.1 0.4-0.2 0.4-0.3 0.3-0.2 0.4 0.1 0.1 0.6-0.2 0.6-0.3 0.6-0.3 0.5-0.6 0.7-0.9 0.5-0.7 0.6-0.4 0.7-0.1 0.6 0 0.6-0.1 0.7-0.2 0.5-0.3 0.4-0.3 0.3-0.3 0.3-0.3 0.3 0.1 0.7 0.5 0.8 0.6 0.8 0.4 0.7 0.6 1.4 1 0.3 1.1-0.6 0.9-1.2 0.1-0.5 0.2-0.6 0.2-0.5 0.4-0.3 0.5 0.4 0.4 0.5 0.4 0.1 0.6-0.7 0.3-0.5 0.9-0.8 0.4-0.5 0.5-0.7 0.5-0.6 0.5-0.6 0.5-0.5 0.8-1.1 1-1.4 1.1-1.1 1-0.3 0.2 0.1 0.1 0.1 0.3 0.5 0.4 0.1 0.5 0 0.3 0.4 0 0.3 0 0.4-0.1 0.4 0.1 0.3 0.1 0.2 0.4 0.4 0.1 0.2 0.1 0.5-0.3 0.4-0.3 0.5-0.2 0.4 0 0.6 0.2 0.5 0.3 0.4 0.3 0.4z", id: "MEX2730", name: "Hidalgo", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Hidalgo', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Estado de M\u00E9xico" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M622.1 463.7l-0.4 0-0.7 0.1-0.4 0 0.2 1 0.2 0.7 0.5 0.3 1 0.3 0.1 0.4 0 0.5 0.1 0.8-0.3 0.4-0.2 0.4-0.1 0.4-0.2 0.4-0.2 0.8 0.2 1 0.5 1.9 0.1 0.3 0.3 1.9 0.2 1.6-0.2 0.2-0.3 0.2-0.1 0.3-0.1 1.5 0 1 0 0.4 0.1 0.4 0.2 0.3 0.1 0.2 0 0.3-0.1 0.3-0.1 0.5-0.5 0.2-0.4 0.3-0.4 0.2-0.3 0.2-0.2 0.5-0.2 0.4-0.3 0.1-0.4 0.1-0.5 0.1-0.4 0-0.7-0.2-0.4 0-0.2 0-0.2-0.1-0.2-0.2 0-0.3-0.2-0.5-0.2-0.6-0.2-0.7-0.2-0.2-0.1 0-0.3 0.1-0.2-0.1-0.3-0.2-0.2-0.2-0.5-0.6-0.3-0.1-0.5-0.1-1-0.2-0.5-0.1 0.5-0.7 0.2-0.4 0.1-0.4 0-0.2-0.2-0.5-0.5-1-0.1-0.6 0-0.7 0.2-0.8 0-0.5 0-0.4-0.1-0.4-0.2-0.7-0.2-0.3-0.3-0.5-0.2-0.2-0.5-0.3-0.7-0.3-0.5-0.3-0.5-0.4 0.5-0.5-0.3-0.3-0.1-0.2 0.3-0.2 0.2-0.2 0.1-0.3-0.2-0.3-0.2-0.5-0.3-0.5-0.1-0.2-0.1-0.3-0.1-0.3-0.4-0.2-0.2-0.2-0.2-0.4-0.1-0.5 0-0.2 0-0.3-0.1-0.2-0.2-0.3-0.2-0.2-0.3-0.2-0.4 0.4-0.3 0.3-0.3 0.3 0 0.4 0 0.3-0.3 0.3 0.3 0.1 0.2 0.3-0.1 0.2-0.3 0.2-0.2 0.1-0.2 0.1-0.2 0.1-0.1 0.2-0.5 0.7-0.4 0.5-0.4 0.5-0.4 0.6-0.3 0.5-0.1 0.3-0.3 0.6-0.4 0.2-0.6-0.1-0.6-0.1-0.1 0.7-0.4 0.7-0.2 0.7 0.1 0.7 0.2 0.2 0 0.1 0 0.1-0.2 0.3-0.2 0.3 0.1 0.3 0.3 0.2 0.2 0 0.1 0.1 0.1 0.1 0 0.1-0.1 0.7 0.1 0.6 0.1 0.5 0.3 0.5 0.2 0.2 0.2 0.2-0.2 0.3-0.3 0.4-0.4 0.3-0.3 0.3-0.3 0.5 0.1 0.5 0.4 0.4 0.3 0.5-0.4 0.3-0.4 0.3-0.1 0.4 0.2 0.6 0.7 0.7 0.2 0.9-0.2 0.5-0.5 0.4-0.7 0.4-0.4 0.1-0.3 0.1-0.4 0.2-0.3 0.1-0.4 0.4-0.3 0.5-0.3 0.6-0.2 0.5-0.3 0.4-0.4 0.3-0.4 0.2-0.3 0.3 0 0.2-0.1 1-0.1 0.9-0.3 1-0.2 1 0 0.1-0.6 0.2-0.7-0.1-0.8-0.1-0.4-0.4-0.3-0.7-0.2-0.2-0.4-0.1-0.6-0.6-0.6-0.7-0.6-0.3-0.8 0.7-0.5 0.5-0.9 0.8-0.3 0.2-0.3 0.2-0.2 0.4 0 0.4 0 0.4-0.1 0.3-0.3 0.4-0.5 0.5-0.4-0.1-0.3-0.3-0.4-0.5-0.5-0.4-0.5-0.1-0.5 0-0.7 0.2-0.3 0.1-0.4 0.1-0.6 0.2-0.7 0.2-0.6 0.2-0.6 0.2-0.7 0.2-0.6 0.2-0.6 0.1-0.7 0.1-0.1 0.2-0.6 1.2-0.4 0.9-0.6 0.8-0.7 0.8-0.7 0.6-0.7 0.6-0.7 0.5-0.7 0.6-0.4 0.1-0.2 0.3-0.2 0.3-0.4 0.3-0.4 0.1-0.5 0-0.4-0.2-0.3-0.3-0.5-0.5-0.2-0.3-0.3-0.3-0.3-0.6 0.2-0.8 0.3-0.9 0.1-0.9-0.2-0.7-0.5-0.7-1.2-1.1-0.2-0.3-0.3-0.3-0.2-0.3-0.1-0.4 0.1-0.4 0-0.4 0-0.4-0.2-0.4-0.3-0.7 0-0.7 0.3-0.6 0.3-0.6 0-0.4-0.2-0.3-0.2-0.2-0.1-0.4 0-0.5-0.1-0.4-0.3-0.1-0.4 0-1.3 0-1.2-0.2-1.2-0.3-1.2-0.4 0.3-0.2 0-0.3 0.1-0.2 0.2-0.2 0.2-0.1 0.1 0.1 0.2-0.1 0.1-0.2 0.3-0.4 0.4-0.4 0.4-0.2 0.4-0.2 0.4-0.3 0.1-0.4 0-0.5 0-0.4 0.2-0.5 0.3-0.4 0.5-0.3 0.3-0.3 0.3-0.4 0.7-0.8 0.3-0.4 1-1.4 1.3-1.7 1.6-2.1 0.3-0.4 0.3-0.3 0.1-0.3-0.2-0.4-0.9-1.4 0.8-0.6 3.3-1.9 0.5-0.3 0.8-0.5 0.4-0.5-0.5-0.5-0.4-0.4-0.3-0.6-0.4-1.2-0.3-0.7-0.2-0.6-0.1-0.3 0.2-0.6 0.5-1.7 0.3-1.1 0.6-1.5 0-0.3-0.2-0.8 0-0.4 0.6-2.2 0.6-2.2 0.1-0.4 0.1-0.5 0.1-0.8 0.3-0.5 0.3-0.6 0.3-0.5 0.3-0.5 0.2-0.2 0.6-0.8 0.5-0.7 0.5-0.8 0.4-0.8 1.4-1.7 0.6-0.7 0.5-0.5 0.6-0.2 0.9 0-0.4-0.5-0.4-0.6-0.3-0.5-0.5-0.5 3-1.9 1.1 0.6 0.5 0.3 0.3 0.4 0.2 0.6 0.1 0.2 0.2 0.3 0.7 0.9 0.9 0.9 1 0.9 0.9 0.7 0.5 0.3 0.2-0.3 0.1-0.4 0.2-0.3 0.5-0.2 0.8-0.1 0.7 0.1 0.4 0.2 0.2 0.4 0.2 0.3 0.4 0.7 1.2 1.9-0.2 0.7-0.2 0.6-0.2 0.6-0.3 0.7-0.1 1 0.2 0.6 0.5 0.3 0.8 0.3 0.7 0.2 0.5 0.4 0.2 0.7 0 0.9 0 0.3 0.1 0.2 0.3 0.1 0.2 0.2 0.2 0.2 0.1 0.4 0 0.7 0.3 1.1 0.6-0.6 0.7-1.1 0.8-0.6 1 0.1 0.4-0.9 0.1-1.1 0.7-0.5 0.3 0.1 0.3 0 0.3-0.1 0.2-0.3 0.1-0.6 0-0.7 0.1-0.6 0.2-0.6 0.5-0.3 0.5-0.1 0.5 0 0.6-0.1 0.7-0.2 0.7-0.4 0.7-0.4 0.6-0.4 0.5-0.2 0.5 0 0.6 0.1 0.5 0.1 0.3 0.2 0.3 0.2 0.3 0.4 0.2 0.3 0.2 0.4 0.1 0.5 0 0.4 0 0.3-0.1 0.4-0.1 0.3 0.1 0 0.3 0.1 0.1 0-0.5 1.2-0.3 0.6-0.1 0.7-0.2 0.6 0 0.3 0 0.3 0.1 0.3 0.1 0.1 1.4 0.2 1.3-1.4 1.2-1.4 1.1 0.4 0.5 0.8 0.6 0.3 0.6 0.1 0.9-0.3 0.3-0.1 0.3 0 0.3 0.2 0.2 0.3 1 1 0.1 0.2 0.3 0.4 0.1 0.2 0.6 0.9 0.3 0.5 0.2 0.3 0.1 0.3 0 0.5-0.1 0.3-0.2 0.5-0.3 0.4-0.1 0.4-0.3 0.6-0.3 0.5-0.3 0.6-0.3 0.6-0.1 0.2z", id: "MEX2731", name: "Estado de M\u00E9xico", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Estado de México', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Morelos" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M612.5 480.3l0.5 0.1 1 0.2 0.5 0.1 0.3 0.1 0.5 0.6 0.2 0.2 0.3 0.2 0.2 0.1 0.3-0.1 0.1 0 0.2 0.2 0.2 0.7 0.2 0.6 0.2 0.5 0 0.3 0.2 0.2 0.2 0.1 0.2 0 0.4 0 0.7 0.2 0.4 0 0.5-0.1 0.4-0.1 0.3-0.1 0.2-0.4 0.2-0.5 0.3-0.2 0.4-0.2 0.4-0.3 0.5-0.2-0.1 2.1-0.1 0.5-0.2 0-0.3-0.1-0.2 0.2 0 0.7 0.4 0.5 0.2 0.5-0.6 0.4-0.5 0.5-0.5 0.6-0.3 0.6-0.5 0.5 0.3 0.3 0.2 0.1 0.2 0 0 0.4-0.1 0.2 0 0.2 0.1 0.2 0.1 0.2 0.4 0.3 0.3 0.4 0.3 0.4 0.2 0.5 0.1 0.5 0 0.2 0 0.1-0.1 0.1-0.1 0.2-0.6 0-0.6 0-1.2-0.3 0.1 0.7 0 0.3 0.1 0.4 0.1 0.4 0.1 0.5 0.1 0.6 0.1 0.5 0.1 0.3 0.5 0.6 0.3 0.7 0.2 0.8 0.3 1.3 0.2 0.7 0.1 0.6 0 0.4-0.6 0.2-0.7-0.4-0.7-0.6-0.5-0.5-0.5-0.4-0.5-0.3-0.6-0.2-0.6 0-0.4 0.1-0.5 0.1-0.4 0.1-0.4 0.2-0.2 0.2-0.2 0.3-0.2 0.3-0.5 0.2-0.5 0.4-0.1 0.6-0.2 0.5-0.6 0.4-0.8 0.2-0.7 0.3-0.7 0.4-0.7 0.5-0.3-1.2-0.6-0.7-0.7-0.7-0.4-0.9-0.1-0.4-0.1-0.2-0.2-0.2-0.2-0.3-0.3-0.3-0.1-0.3 0-0.5-0.1-0.4 0-0.3-0.2-0.2-0.2-0.1-0.3-0.1-0.8-0.1-0.6 0.4-0.4 0.6-0.2 0.8-0.1 0.9-0.1 0.4-0.1 0.3-0.7 0.1-0.7 0-0.7 0-0.6 0-0.3-0.3 0-0.7-0.2-0.5-0.6-0.1-0.4 0-0.4-0.2-0.3-0.3-0.3-0.4-0.2-0.4-0.5-0.8-0.2-0.4-0.6-0.2-0.2-0.6-0.1-0.5-0.6-0.1-0.7-0.2-0.1-0.5 0.2-0.6 0.3-0.6 0-0.1 0.2-1 0.3-1 0.1-0.9 0.1-1 0-0.2 0.3-0.3 0.4-0.2 0.4-0.3 0.3-0.4 0.2-0.5 0.3-0.6 0.3-0.5 0.4-0.4 0.3-0.1 0.4-0.2 0.3-0.1 0.4-0.1 0.7-0.4 0.5-0.4 0.2-0.5-0.2-0.9-0.7-0.7-0.2-0.6 0.1-0.4 0.4-0.3 0.4-0.3-0.3-0.5-0.4-0.4-0.1-0.5 0.3-0.5 0.3-0.3 0.4-0.3 0.3-0.4 0.2-0.3 0.7 0.7 1.1 0.4 1.1 0.2 1 0.2 1 0.1 0.6 0.1 0.6 0.2 0.6 0.4 0.6 0.4 0.3 0.1 0.3-0.2 0.3-0.4 0.2-0.3 0.4-0.1 0.5 0 0.4 0 0.4 0z", id: "MEX2732", name: "Morelos", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Morelos', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Quer\u00E9taro" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M610 407.1l0 0.4-0.1 0.4 0.1 1.5 0.1 0.8-0.3 0-0.5-0.2-0.2 0.1-0.3 0.2-0.2 0.1-0.3 0-0.8-0.1-0.9 0.4-1.4 1.2-1 0.2-0.6-0.2-1.1-0.7-0.6 0-0.3 0.1-0.5 0.7-0.3 0.2-0.6 0.1-0.3 0.1-0.5 0.5 0 0.5 0.8 1.3 0 0.5-0.2 0.5-0.7 0.9-0.1 0.6-0.1 1.3-0.2 0.5-0.3 0.4-0.3 0.2-1.8 1.2-0.6 0.9-0.4 1.1-0.5 2.3-0.1 0.3 0.1 0.7 0.3 0.6 0.4 0.5 0.2 0.2 0.1 0.2-0.5 0-0.4 0.2-0.3 0.3-0.3 0.2-0.2 0.1-0.5 0.1-0.1 0.1-0.1 0.2-0.1 0.3-0.2 0.2-0.1 0.2-0.2 0-0.3-0.3-0.1 0-0.3 0.2-0.2 0.3-0.2 0.3-0.1 0.3-0.3 0.3-0.4 0.3-0.5 0.1-0.5-0.2-0.1 0.2-1.1 0.2-1.1 0.4-1.2 0.5-1 0.5 0 0.7-0.1 0.8-0.1 0.7-0.3 2.3-0.3 2.3-3 1.9 0.5 0.5 0.3 0.5 0.4 0.6 0.4 0.5-0.9 0-0.6 0.2-0.5 0.5-0.6 0.7-1.4 1.7-0.4 0.8-0.5 0.8-0.5 0.7-0.6 0.8-0.2 0.2-0.3 0.5-0.3 0.5-0.3 0.6-0.3 0.5-0.7-0.3-0.6-0.5-0.4-0.6 0-0.9 0-0.8 0-1.9-0.7-1.9-1.1-1.6-1.6-0.8-0.3-0.2-0.3-0.1-0.4-0.1-0.3-0.2-0.4-0.7-0.5-0.3-0.6-0.3-0.4-0.8-0.3-0.9-0.5-0.7-0.7-0.7-0.6-0.7-0.5-0.6-0.5-1.1-0.1-1.2 0-1.2-0.1-1.3-0.3-0.6-0.4-0.6-0.4-0.6-0.4-0.6-0.6-1.4-0.3-1.4 0.1-1.4 0.6-1.4 0.3-0.5 0.3-0.5 0.2-0.6 0.1-0.5 0-1.2 0.2-0.6 0.5-0.4 0.3-0.6 0.3-0.8 0.5-0.6 0.6 0 0.5 0.5 0.1 0.8 0.3 0.6 0.9 0.3 0.7 0.1 0.6 0.1 0.6 0 0.6-0.2 0.5-0.3 0.5-0.4 0.6-0.3 0.6 0.1 0.2 0 0.1 0.2 0.4 0.5 0.4 0.6 0.5 0.4 0.7 0 0.3-0.2 0.2-0.3 0.2-0.3 0.2-0.2 0.3-0.1 0.3-0.1 0.2-0.1 0.3-0.2 0.3-0.7 0.2-0.8 0.1-0.8 0-0.8 0.1-1.2 0.1-1.3 0.2-1.2 0.4-1.1 0.5-0.7 0.8-0.5 0.8-0.2 0.8-0.1 0.5 0.1 0.5 0.2 0.5 0.2 0.4 0.3 0.5 0.6 0.9 0.2 0.9-0.1 0.8-0.3 0.5-0.2 0.1-0.3 0.2-0.3 0.2-0.4 0.3-0.3 0.3-0.1 0.8-0.3 0.4-0.4 0.2-0.4 0-0.5-0.4-0.3-0.9-0.1-0.8-0.1-0.6-0.5-0.1-1.1 0.1-0.4 0.1-0.3 0-0.3-0.1-0.5-0.2-0.4 0.1-0.4 0.2-0.5 0-0.4 0.4-1 0.4-1.1 0.5-0.9 0.9-0.3 0.4 0.2 0.5 0.3 0.4 0.3 0.3 0.3 0.2 0.2 0.2 0.2 0.2 0.1 0.2 0.2 0.2 0.4 0.2 0.4 0.1 0.4 0.4 0.2 0.3 0.2 0.4 0.5 0.3 0.2 0.4 0.1 0.2-0.2 0.2-0.1 0.2-0.1 0.7 0 0.9 0 0.8-0.1 0.4-0.6 0.2-0.1 0.3-0.1 0.5-0.1 0.4-0.1 0.4 0.1 0.4 0.1 0.4-0.1 0.2-0.2 0.1-0.2 0.3-0.5 0.3-0.5 0.1-0.3 0.2-0.2 0.2-0.2 0.1-1 0.2-0.3 0.2-0.1 0.2-0.1 0.1 0 0.6 0.3 0.2 0 0.3-0.1 0.3-0.2 0.3-0.3 0-0.3 0-0.4 0-0.4 0.5-0.5 0.8-0.4 0.5-0.6 0.1-0.7 0.9 3.1 0.2 0.9 0.3 0.8 0.3 0.9 0.3 0.8 0.3 0.9 0.5 1 0.3 0.5 0 0.5-0.3 2-0.1 0.6 0.5 0 0.6 0.1 0.6 0.3 0.4 0.4z", id: "MEX2733", name: "Quer\u00E9taro", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Querétaro', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Veracruz" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M655.5 390.7l-0.3 0.4-0.9-0.2-0.8-1.1-0.5-1.6-0.2-1.3 0.5 0.5 0.2 0.6 0.1 0.8 0.3 0.6 1.1 0.8 0.5 0.5z m-5.7-17.8l0.2 0.7 0.1 4.2 0.4 1.2 4.7 8.8 3.2 3.9 0.6 0.3 1.7 1.6 0.3 0.2 0.4 0.4 2.2 1.5 0.9 1.5-0.1 1.3-0.5 1.5-0.3 1.4-0.1 0.6-0.9 1.5-0.4 0.5-0.3 0.6-0.2 0.8-0.2 1.5-0.3 0-0.4-2.3-0.8-1.7-0.2-1.1-0.2-0.2-0.1-0.3 0.6-0.6 0.5-0.4 0.6-0.3 0.6-0.1 0.3 0.2 0.3-0.5 0.2-0.5 0.1-0.6 0.1-0.6-0.3-0.5-0.7-0.6-1.2-0.8-1.5-1.4-0.5-0.8-1.7-1.8-1.5-2.2-0.7-0.6-0.1-0.3-0.1-0.4-0.5-2.3-0.3-0.8-0.9-0.6-2.6-4.7-0.4-1.1 0.1 0.8 0.6 1.2 0.2 0.4 0.3 0.6 0.7 1.9 0.3 1.4 0.1 2.8 0.6 2.3 0.5 2.9 0.5 1.3 2.5 4.6 0.5 0.5 0.5 0.3 0.5 0 0.5-0.2 0.4-0.3 0.4 0.4 0 0.6-0.4 1.4 0.2 0.7 2.1 4.3 0 0.4 0.5 0.2 0.3 0.5 0.2 1.2 1.9 5.1 2.2 4.3 2.2 3.9 0.3 1.2 0.3 0.6-0.2 0.1-0.1 0.1-0.3 0.4 1.5 3.1 3.6 4.5 1.1 1 1.3 0.7 0.6 0.5 0.5 1.3 0.4 0.6 0.9 0.8 2.2 2.6 1.9 1.7 0.6 0.7 0.4 0.9 0.3 0.4 0.3 0.3 0.2 0.1 0.4 0.1 0.2 0.3 1.1 1.9 2.1 2.5 2.1 3.3 1.7 2 0.5 1 1.1 3.3 0.3 2.9 1.1 3.9 0.3 0.6 1.1 1.3 0.2 0.6-0.4 0.8 0.1 0.5 0.4 1.1 0.2 1.2 0.3 0.8 0.4 0.6 0.7 0.4 2.6 2.2 0.5 0.3 0.8-0.3 0.3 0.4 0.1 0.8 0.2 0.6 0.3 0.5 0.4 1.7 0.4 0.7 0.5 0.5 0.6 0.5 0.8 0.1 0.8 0 0.5 0.1 0.2 0.4 0.4 2.4 0.5 1.2 0.5 1 0.7 0.9 1.1 1.1 0.7 0.5 0.7 0.2 0.5 0.1 0.7 0.2 0.6 0.3 0.4 0.3 0.1 0.3-0.1 0.9-0.8-0.5-1.4-1.1-1.8-0.5-1.1-1.2-0.7-0.1-0.7 0.3 0.7 0.6 1.2 0.6 0.5 0.2 0.3 0.6 0.7 0.6 1.4 0.9 0 0.3-0.5-0.1-0.9-0.3-0.5-0.1-0.3 0.2 0.1 0.5 0.4 0.5 0.3 0.2 0.5 0 0.4-0.1 0.7-0.4 0.1-0.1 0-0.2 0.1-0.1 0.4 0 0.2 0 3.4 1 0.7 0.1 0.5 0.3 0.7 0.7 0.7 0.4 0.5-0.5-1.2-0.8-2.1-0.7-1.7-0.9-0.1-1.5 2.1 1.7 2.6 0.9 2.7 0.5 4.2 0.1 2.8-0.2 2.1 0.1 0.6 0.1 0.5 0.3 1.1 1 2.7 1.8 0.4 0.5 0.2 0.6 0.3 0.5 0.7 0.3 4.1 0.6 0.5 0.3 1.5 0.1 0.7 0.4 0.5 1 1 2.5 0.6 1.1 2.1 2 0.8 0.9 1.5 3.2 0.1 0.1 1 0.7 0.4 0.2 1 0.1 1 0.4 0.9-0.1 0.9-0.2 0.7 0 1.1-0.5 4.6-0.7 2.2-0.6 0.2 0.3 0 0.8 0.2 0.3 0.3 0.1 0.4 0 0.2 0.2 0.1 0.4 0 0.4-0.1 0.5 0.1 0.4 0.3 0.3 0.2 0.2-0.1 0.3-0.2 0.1-0.1 0.2 0.1 0.2 0.3 0.4 0.2 0.2 0.1 0.4 0 0.4 0 0.3 0.3 0.3 0.3 0.4-0.3 0.5-0.3 0.4-0.1 0.5-0.2 1.6 0 0.7 0.5 0.5 0.2 0 0.5 0 0.2 0.1 0.1 0.1 0.2 0.4 0 0.1 0.4 0.2 0.4 0.1 0.5 0 0.4 0.2 0.7 0.7 0.1 0.9 0.3 0.8 1.2 0.4 0.6 0 0.5 0.1 0.3 0.3 0.1 0.6 0.1 0.2 0.3 0.1 0.4 0 0.3 0 0.9 0.3 0.9 0.3 0.8 0.6 0.7 1.3 0.7 0.8 0.7 0.7 0.4 0.4 1 0.4 0.2 0.5-0.1 0.7-0.2 0.8-0.2 1-0.1 0.3 0 0.4-0.3 0.7 0 0.3 0.2 0.6 0.4 0.4 0.5 0.3 0.6 0.2-0.5 1.3-0.4 0.6-0.6 0.6-0.6 0.4-0.7 0.4-4.6 3.2-0.7 0.6-0.4 0.2-0.4 0.1-9.9-0.6-4.9-0.3-4.9-0.3-1.9-0.1-0.9-0.1-2.1-0.2-3.2-0.2-1.5 0-2.3-0.1-2-0.3-1.1-0.6-0.6-2.1 0.1-0.2 0.2-0.1 0.1-0.1 0-0.3-0.2-0.7-0.4-0.6-0.8-0.5-0.9-0.3-0.7-0.2-0.4-0.6-0.5-0.5-0.4-0.4-0.5-0.5-1-1-1-1.1-0.9-1.1-1-1.2 0.1-0.4 0-0.3 0.1-0.4 0.2-0.4 0.3-0.2 0.6-0.3 0.3-0.1 0-0.2 0.1-0.8 0.1-0.6 0.1-0.5-0.1-0.4-0.3-0.3-0.2 0-0.6 0.1-0.2 0-0.2 0.2 0.3 0.5-0.2 0.2-0.3-0.2-0.4-0.2-0.4-0.1-0.2 0.2-0.3 0.7-0.5 0.6-0.6 0.3-0.9 0.1-0.2 0.2 0 0.2 0 0.2-0.8 0-0.7 0-0.6 0.2-0.7 0.4-0.2 0.3-0.3 0.4-0.3 0.4-0.4 0.1-0.4 0.1-0.5 0.2-0.5 0.4-0.6 0.3-0.1 0.1-0.1 0.2 0 0.2 0 0.2-0.3 0.1-0.3 0-0.2 0-0.5 0.5-0.3 0.1-0.9-0.4-0.7 0-0.6 0.2-0.5 0.3-0.8 0.3-0.3 0-0.1-0.1-0.6-0.2-0.5-0.2-0.5-0.2-0.4-0.5-2-4-0.6-1.3-0.5-1-0.4-0.9 0-0.9 0.3-1 0.2-0.4 0.2-0.3 1.1-1.2 1-1.2 0.8-1.3 0.6-1.6-0.5-1-0.4-1.2-0.5-1.1-0.5-0.9-0.5-0.2-0.5-0.3-0.2 0-0.9-0.2-0.3-0.1-0.4-0.1-0.3-0.2-0.4-0.2-0.3-0.1-0.3-0.1-0.3 0-0.4 0.1-0.2 0.1-0.4-0.1-0.5 0-0.4 0-0.4-0.2-0.7-0.1-0.4 0-0.2 0.2-0.4 0.6-0.2 0.2-0.4 0.1-0.4-0.1-0.5-0.1-0.3-0.2-0.3-0.3 0-0.3 0.1-0.3-0.1-0.2-0.3-0.1-0.4 0-0.4 0.1-0.4-0.3-0.1 0-0.3-0.3-0.2-0.9-0.2-1-0.3-0.8-0.3-0.5-0.3-0.5-0.4-0.4-0.5-0.4-0.3-0.1-0.4-0.3-0.3-0.2-0.8-1-0.7-1.4-0.4-1.5-0.3-1.3-0.3-0.9-0.5-0.5-0.7-0.3-1-0.2-1.4-0.3-1.2-0.5-1.1-0.6-1.1-1-1-0.9 0.2 1 0.3 1.1 0.4 1.2 0.1 1.1-0.4 1.1-0.6 0.9-1.5 1.7-0.5 0.5-0.3-0.5-1.1-1.1-0.4-0.7-0.1-0.8-0.1-0.9-0.3-0.7-0.8 0.1-0.1 0-0.9 0.2-0.8 0.2-0.8 0.1-1.2 0.4-0.9 0.1-0.4 0.2-0.4 0.3-0.4 0.3-0.4 0.4-0.4 0.1-0.5-0.2-0.5 0.1-0.5 0-0.4-0.1-0.3-0.5 0.1-0.6 0.2-0.6 0.2-0.5-0.1-0.5-0.4-0.4-0.4-0.5-0.1-0.7 0-0.3 0-0.2-0.1-0.2-0.1-0.3-0.2-0.2-0.2-0.1-0.3-0.1-0.7-0.1-0.4-0.1-0.6-0.4-0.4 0-1.1 0.4-0.5 0.1-0.5-0.1-0.3-0.2-0.3-0.2-0.2-0.3-0.5-1.3-0.4-1 0-1 0.3-0.9 0.5-0.5 0.3-0.2 0.2-0.2 0.2-0.3 0.2-0.4 0.1-0.4 0.4-0.2 0.6-0.2 0.5-0.1 0.3-0.3 0-0.7-0.1-0.3-0.3-0.8-0.1-0.4-0.1-0.4 0-0.4-0.1-0.4 0-0.3 0-0.4-0.1-0.3-0.2-0.8-0.2-0.8-0.2-1.1 0-1 0.2-0.8 0.3-0.1 0.4-0.1 0.4 0 0.3-0.1 0.5-0.2 0.7-0.5 0.5-0.1 0.6 0.1 0.6 0.3 0.6 0.1 0.4-0.3 0.1-0.3 0.1-0.3 0.2-0.1 0.3 0 0.3 0 0.2 0 0.2 0 0.2-0.1 0.2-0.2 0.8-0.9 0.1-0.2 0.2-0.2 0.1-0.1 0.4-0.3 0.1-0.2 0.1-0.2 0-0.3-0.4-0.2-0.4-0.2-0.5-0.2-0.8-0.3-0.4-0.1-0.3 0.1-0.5 0.2-0.2 0.1-0.6 0.1-0.8-0.2-0.9-0.4-0.8-0.2-0.6 0-0.5-0.3-0.5-0.7-0.4-0.8-0.5-0.6-0.4 0-0.3 0.1-0.4 0.2-0.4 0.1-0.2-0.2-0.3-0.6-0.2-0.2-0.5-0.1-0.5 0-0.5-0.1-0.4-0.2-0.2-0.5 0.3-0.2 0.5-0.1 0.5 0.1 0.6-0.2 0.5-0.3 0.3-0.5-0.3-0.6-0.2-0.2-0.2-0.2-0.4-0.2-0.1-0.3 0-0.3 0.1-0.3 0-0.2-0.4-0.4-0.4-0.2-0.3-0.3 0-0.9 0.1-0.7 0.1-0.8 0.4-0.6 0.5 0 1-1 0.5-1.8 0.2-1.9-0.1-1.5-0.1-0.3-0.1-0.5 0-0.5 0.1-0.2 0.1-0.2 0.1-0.2 0.3-0.5 0.4-0.7 0.4-0.6 0.4-0.6 0.5-0.5 0.3-0.3 0.7-0.8 0.4-0.5 0.5-0.4 0.4-0.4 0.4-0.5 0.6-1.4-0.6-0.8-1.2-0.5-1.2-0.3-0.3-0.2-0.5-0.3-0.3-0.1-0.6-0.3-0.6-0.3-0.5-0.4-0.6-0.4-0.7-0.6-0.7-0.3-0.7-0.1-0.9 0.2-0.5 0.1-0.7 0.4-0.3 0.6-0.3 0.7-0.7 1-0.3 0.4-0.4 0.4-0.3 0.3-0.4 0.3-0.2 0.1-0.3 0.2-0.1 0-0.2 0-0.2-0.2-0.1-0.1-0.1-0.2-0.1-0.2 0-1-0.3-0.6-0.5-0.2-0.9 0.4-0.3 0.1-0.5 0-0.4-0.3-0.3-0.5-0.1-0.6-0.1-0.3-0.3-0.3-0.2-0.2-0.6-0.3-0.6-0.3-0.5-0.4-0.1-0.5 0.4-0.8 0.1-0.4 0.1-0.4-0.1-0.2-0.1-0.2-0.1-0.3 0-0.2 0.1-0.6-0.1-0.6-0.1-0.5-0.2-0.5 0.3-0.3 0.4-0.1 0.5 0.1 0.4-0.1 0.5-0.4 0.3-0.4 0.3-0.1 0.5 0.5 0.7 1 0.5 0.2 0.5-0.2 0.4-0.4 0.4-0.6 0.4-0.7 0.4-0.5 0.1-0.1 0.1-0.1 0.1-0.2 0.1-0.1 0-0.9-0.4-0.9-0.5-0.9-0.7-0.4-0.8-0.2-0.4-0.1-0.4-0.1-0.4 0-0.7 0.1-0.3 0-0.5-0.2 0-0.4 0.3-0.3 0.3-0.5-0.3-0.6-0.4-0.5-0.3-0.5-0.2-0.7 0-0.8 0-0.7-0.1-0.7-0.4-0.6-0.7-0.6-0.6-0.1-0.6 0.1-0.8 0-0.4-0.2-0.3-0.1-0.4-0.1-0.3 0.2-0.3 0.5 0 0.5 0 0.6 0 0.5-0.3 0.3-0.4 0.1-0.4 0.2-0.2 0.3 0 1-0.2 0.4-0.7 0.3 0 0.3 0.5 0.6 0.1 0.3 0 0.4 0.1 0.7 0 0.7-0.1 0.7-0.1 0.7-0.3 0.7-0.2 0.5-0.3 0.4-0.4 0.3-0.4 0.3-0.3-0.4-0.3-0.4-0.2-0.5 0-0.6 0.2-0.4 0.3-0.5 0.3-0.4-0.1-0.5-0.1-0.2-0.4-0.4-0.1-0.2-0.1-0.3 0.1-0.4 0-0.4 0-0.3-0.3-0.4-0.5 0-0.4-0.1-0.3-0.5-0.1-0.1-0.2-0.1-1 0.3-1.1 1.1-1 1.4-0.8 1.1-0.5 0.5-0.5 0.6-0.5 0.6-0.5 0.7-0.4 0.5-0.9 0.8-0.3 0.5-0.6 0.7-0.4-0.1-0.4-0.5-0.5-0.4-0.4 0.3-0.2 0.5-0.2 0.6-0.1 0.5-0.9 1.2-1.1 0.6-1-0.3-0.6-1.4-0.4-0.7-0.6-0.8-0.5-0.8-0.1-0.7 0.3-0.3 0.3-0.3 0.3-0.3 0.3-0.4 0.2-0.5 0.1-0.7 0-0.6 0.1-0.6 0.4-0.7 0.7-0.6 0.9-0.5 0.6-0.7 0.3-0.5 0.3-0.6 0.2-0.6-0.1-0.6-0.4-0.1-0.3 0.2-0.4 0.3-0.4 0.2-0.6-0.1-0.3-0.4-0.1-0.5 0.4-0.5 0.4-0.1 0.4-0.1 0.4 0 0.4-0.1 0.4-0.2 0.1-0.3 0-0.3 0.1-0.4-0.1-0.4-0.2-0.3-0.2-0.3-0.1-0.4 0.2-0.3 0.5-0.3 0.5 0 0.5 0 0.4 0.1 0.4 0.1 0.4 0.2 0.4 0.1 0.7 0.5 0.7 0.4 0.7 0.2 0.8 0 0.2-0.1 0.1-0.1 0-0.1-0.1-0.2-0.3-0.9 0-1.2 0.2-1.1 0.4-0.7 0.2-0.3 0.3-0.3 0.2-0.3 0.2-0.3 0.2-0.3 0.2-0.2 0.2-0.3 0.1-0.1 0.2 0 0.2 0 0.2-0.1 0.2-0.3 0.2-0.5 0.2-0.5 0-0.3-0.2-0.3-0.2-0.2-0.3 0-0.2-0.2-0.2-0.4-0.2-0.3-0.3-0.1-0.3-0.2-0.7-1-0.5 0.3-0.6 0.7-0.9-0.1-0.4-0.6 0.3-0.9 0.4-0.9 0-0.9-0.2-0.5-0.4-0.3-0.4 0.1 0.1 0.5 0 0.7-0.6 0.7-0.8 0.6-0.6 0.5-0.5 0-0.4-0.2-0.3-0.3-0.4-0.3-0.5-0.6-0.5-0.7-0.6-0.6-0.6-0.2-0.2-0.1-0.1-0.2-0.1-0.2 0-0.3 0.1-0.9 0.3-0.8 0.6-0.6 0.6-0.7-1.1-0.8-0.5-0.3-0.5-0.4-0.2-0.1 0-0.6 0-0.6-0.1-0.6 0-0.7-0.1-1-0.3-0.7-0.6-0.5-1.6-0.8-0.6-0.4-0.4-0.5-0.3-0.7 0.1-0.2 0.4-0.4 0-0.5-0.1-0.6 0.1-0.9 0.5-0.4 1.2 0.2 0.5-0.5-0.3-0.2 0-0.3 0.2-0.2 0.3-0.2 0.2 0 0.4 0.2 0.2 0.1 0.1-0.1 0.1-0.3 0.1-0.1 0.8-0.5 0.4-0.3 0.3-0.4 0.2-0.3 0.1-0.5-0.1-0.4-0.5-0.2-0.3-0.1 0-0.4 0-0.4-0.2-0.4-1.3 0.2-0.4-0.4-0.5-0.8-0.1-0.7 0.7-0.2-0.2-0.7 0.3-0.4 0.4-0.3 0-0.3-0.6 0.1-0.8 0.2-0.5 0-0.1-1 0.1 0 0.3 0.1 1.2 0.2 0.2-0.1 0.4-0.2 0.4 0 0.4 0.1 0.3 0.1 0.3 0 0.3-0.4 0.3 0.3 0.2-0.1 0.3-1.1 0.2-0.5 0.3-0.5 1.4-2.4 0.6-1.4 0.4-1.3 0-1-0.2-0.8-0.6-0.7-0.7-0.6-0.9-0.6-1.9-1.1-0.9-0.5-0.6-0.5-0.6-0.5-0.6-0.5-0.7-0.4-0.5-0.4-0.2-0.1 1.1-0.2 1.1-0.2 1-0.2 1 0.1 0.2 0 0.1-0.1 0.2 0 0.5 0.4 0.1-0.1 0.1-0.1 0.2-0.1 0.5 0.3 0.3 0.3 0.3 0.1 0.5-0.4 0.3-0.1 0.2 0.5 0.2 0.4 0.5-0.3 0.4 0.2 0.4 0.1 0.5 0 0.3-0.2 0.1-0.6 0-0.8 0.2-0.7 0.5 0 0.4 0.2 0.2 0.1 0.1 0 0.4-0.1 0.3-0.1 0.3-0.2 0.3-0.2 0.4-0.1 0.6 0.2 0.2 0.7 0.3 0.9 0.6 0.5 0.5 0.4 0.6 0.5 0.5 0.4 0.5 0.1 0.7 0 0.8 0.3 0.8 0.3 0.8 0 0.5 0.1 0.6 0.4 0.6 0.4 0.5 0.3 0.4 0.4-0.2 0.4-0.4 0.4 0.1 0.5 0.6 0.6 0.3 0.3 0.3 0.4 0.3 0.4 0.4-0.1 0.3-0.3 0.2-0.4 0.3-0.2 0.3-0.1 0.9-0.6 0.2-0.2z", id: "MEX2734", name: "Veracruz", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Veracruz', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Chiapas" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M765.3 580.6l0.7-1.4 0.4 0.2 0.8 0.6 0.8 1.2 0.4 0.3 1 0.4 0.5 0.3 0.2 0.4-4.8-2z m84.6-39.4l-0.2 0-0.1 0.5 0.7 0.4 1 0.2 0.5 0.2 0.2 0.8 0.6 0.1 0.9-0.1 0.9 0 0.3 0.3 0.3 0.6 0.2 0.6 0 0.5 0.1 0.2 0.7 0.2 0.3 0.1 0.1 0.3 0.2 0.5 0.1 0.4 0.3 0.4 1.1 1.3 0.3 0.1 0.8-0.1 0.3 0.1 0.2 0.2 0.1 0.6 0.2 0.3 1.1 1.3 0.2 0.4 0.1 0.7 0.4 0.3 1.2 0.5 0.2 0.1 0.4 0.4 0.1 0.1 0.3-0.1 0-0.3-0.1-0.3 0-0.2 0.6 0 0.4 0.1 0.1 0.3-0.5 0.5 0.6 0.3 1 1 0.5 0.3 2.2 0.7 0.4 0 0.3-0.3 0.4 0.3 0 0.2-0.1 0.4 0.5 0.4 1.1 0.6 0.4 0.3 2.2 3.1 0.4 1.2-0.4 0.8 0 0.2 0.3-0.1 0.1 0 0.1-0.1 0.1-0.2 0.4 0.2-0.1 0.5-0.2 0.5 0.2 0.6-0.3 0.5 0.3 0.1 0.5 0 0.3 0.3 0 0.3-0.2 0.2-0.3 0.3-0.1 0.3 0.4-0.1 0.5 0 0.4 0.1 0.2 0.1 0.2-0.1 0.8-0.2 0.3 0 0.1 0.7 0.2 0.3 0.8-0.4 0.3 0.1 0.3 0.2 0.2 0.2 0.2 0.4-0.1 0.2 0.1 0.2 1 0.2 0.3 0.1 0.3 0.2 0.2 0 0.3 0 0.3-0.1 0.2 0 0 0.5 0 0.4 0.1 0.2 0.4 0.6-0.5-0.1-0.5-0.1-0.3 0.2 0 0.5 0.2 0 0-0.3 0.2 0 0.3 0.5-0.2 0.5-0.5 0.4-0.6 0.2-0.2 0.1 0.3 0.3 0.5 0.2 0.2-0.1 0 0.3-0.2 0.1-0.3-0.1-0.2-0.1 0 0.2-0.2 0 0.1 0.2 0.2 0.3 0.1 0.2-0.4 0-0.1-0.1-0.1-0.1-0.4 0.4 0.1 0.3 0.3 0.2 0.4 0.2-0.3 0.2-0.4 0.3-0.3 0.4 0.2 0.7 0.9 0.5 0.2 0.3-0.7 0.3 0 0.2 0.4 0.4-0.8 0.6 0.2 0.6 0.2 0 0.1-0.1 0.3-0.1-0.1 0.2-0.2 0.5-0.1 0.2-0.6 0.2-0.6 0.1-2.8 0-4.4 0-4.3 0-4.3 0-4.4 0-4.3 0-4.4 0-4.3 0-5.8 0-0.5 0.3-0.4 0.5-2.8 4.9-2.2 3.8-2.5 4.3-2.5 4.3-4.3 7.4-0.2 0.6 0 0.6 0.3 0.6 4.1 5.3-0.7 1.4-0.3 0.4-0.4 0.2-0.4 0-0.4 0.2-0.4 0.3-0.1 1.1 0.1 2-0.3 1-0.7 0.8-0.1 0.4 0 0.7 0 0.2 0.3 0.8 0.1 0.3-0.1 0.5 0 0.2 0.6 1.6 0 0.6-0.1 0.5-0.7 1.3-0.7 1.9-0.5 0.7-0.7 0.1-0.1-0.1-1.7-2.1-2.4-2.3-4-4-6.1-6.3-3.9-4.4-0.5-0.9 0-0.6 0.5 0.3 1.4 0.4 0.3 0.3 0 0.6 0.2 0.6 0.4 0.5 0.5 0.2-0.4-0.7-0.2-1.3-0.4-0.6-0.5-0.3-0.6-0.2-0.7-0.2-0.5 0.1-0.1-0.5-0.3-0.1-0.2 0.2 0.4 0.4-0.5 0-1.9-1.5-1.3-0.6-0.6-0.4-0.5-0.9-2.5-1.8-2.9-3.3-0.5-0.9-0.4-0.4-0.9-0.4-7.7-6.5-0.5-0.3-5.3-4.3-3.2-2.1-5.9-3.5 0.4-0.2 0.8 0.1 0.4-0.1 0.2 0.4 0.3 0 0.4-0.2 0.4-0.4-0.7-0.8-0.3-0.7-0.4-0.6-0.8-0.4-3.8-0.8-1-0.6-0.3-0.2 0.2-0.4 0.6-0.8 0.2-0.4 0.2-0.6 0.1-0.6 0.1-0.7 0.1-0.6-0.1-1-0.4-1.1-0.5-1-0.4-0.9-0.5-1.3-0.3-0.6-0.3-0.5-0.3-1.3 0.7-1.4 1-1.3 0.7-1.1 0.3-0.7 0.2-0.6 0-0.7 0-0.7-0.1-0.7-0.2-0.9 0-0.9 0.1-0.6 0.4-0.5 0.6-0.4 0.7-0.3 0.5-0.3 1.9-1.2 0.1-0.4 0-0.6 0-1.2 0-0.8 0-0.9 0.4-0.6 0.8 0.2 0-0.7 0-0.3 0.1-1.8 0-0.9-0.2-0.9 0.4-0.1 0.4-0.2 0.7-0.6 4.6-3.2 0.7-0.4 0.6-0.4 0.6-0.6 0.4-0.6 0.5-1.3 0.9-1.9 0.8-1.9 0.4-1.3 0.2-0.2 0.2-0.4 0.1-0.2 0.6-0.3 0.3-0.3 0.1 0 0.1 0 0.1-0.6 0-0.2 0.4-0.4 0.4-0.3 0.5-0.3 0.4-0.4 0.2-0.5 0.2-0.6 0.1-0.6 0.2-0.6 0.5-1.9 0.6-2 0.6-2 0.7-1.9 0.1-0.7 0.4-0.1 0.2-0.2 0.4-0.5 0.3-0.2 0.5 0.1 0.8 0.2 1.1 0.2 0.3 0.2 0.6 0.4 0.8 0.4 0.7 0.9 1 0.7 1.1 0.2 0.7-0.7 0.6 0.1 0.4-0.7 0.1 0.8 0.1 0.7 0 0.2 0 0.6 0.1 0.6 0 0.6 0 0.6-0.2 0.5-0.3 1-0.2 0.5 0 1.4 0.6 2.6 0 1.4 0.1 0.8 0.2 0.7 0.5 0.3 0.8 0 1 0.2 0.5 0.7 0.4 0.9 0.6 1 0.3 0.5 0.4 0.5 0.4 0.5 0.4 0.4 0.9 0.5 1 0.4 1-0.1 0.9-0.6 0.5-0.4 1.9-1.8 1.2-1.2 2.8-2.4 1-1.1 0.6-0.5 0.7-0.2 1.1-0.3 0.3-0.6-0.1-0.8 0.3-1 0.8-0.6 1.1-0.3 1.1-0.3 1-0.2 0.8-0.3 0.8-0.4 0.7-0.5 0.6-0.5 1 0.2 1.1-0.1 0.7-0.5-0.6-1 0.8-0.9 0.9-0.9 0.9-0.6 0.7-0.2 0.2 0 0.5 0.3-0.1 1.1 0.4 0.5 0.2-0.4 0.1-0.3 0.2-0.3 0.4-0.2 0.4 0 0.5 0.1 0.8 0.4 0.6-0.5 0.7 0.1 0.6 0.5 0.5 0.8 0 0.2 0 0.7 0 0.2 0.1 0.3 0.2 1-0.2 0.3-0.3 0.6-0.1 0.6 0.4 0.3 0.7 0 0.6-0.1 0.7 0.1 0.6 0.2 0.6 0.9 0.4 1.2 0.3 1.2 0.2 1.1 0 0.3 0 0.3 0 0.7 0.2 0.5 0.5 0.4 0.7 0.3 0.5 0.2 0.4 0.2 0.6 0.2 0.7 0.2 0.6 0.2 0.2 0.2 0.3 0.2 0.3 0.2 0 0.5-0.2 1 0.2 0.3 0.4 0.3 0.4 0.1 0.4 0.1 0.7-0.1 0.3 0.2 0.2 0.3 0.8 1.3 0.1 0.1-0.1 0.5-0.4 0-0.4 0-0.4 0.2-0.2 0.3-0.1 0.5-0.1 0.5 0.2 0.5 0.1 0.1z", id: "MEX2735", name: "Chiapas", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Chiapas', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Quintana Roo" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M977.8 503.2l-0.2 0 0.1-0.3 0.6-0.6 0.3-0.5 0.1-0.3 0.2-0.8 0.2-1.9 0.1-0.3 0.1-0.2 0.2-0.3 0.3-0.3-0.6 1.1 0.2 1.5-0.4 1.1-1.2 1.8z m3.9-8.3l-0.4 0.7 0.1-0.9-0.3-2.7 0.4 0.4 0.2 1.6 0 0.9z m15.8-64.2l-1.1 2-0.4 1.1-0.6 0.5-0.9 0.8-0.4 0.6-0.8 1.5-0.1 0.5-0.2 0.2-0.3 0.2-0.3 0.2-0.1 0.4-0.1 0.2-0.3 0.4-1.7 1.5-0.5 0.2-0.2-0.3-0.1-0.6-0.4-1.5-0.2-0.7 0.1-1.5 0.4-1.3 1.3-2.3 1-1.4 0.2-0.1 0.5-0.4 0.2-0.2 0.3 0 0.2 0.1 0.3 0.1 0.3 0.1 0.8 0.3 0.3 0.1 0.4-0.1 0.7-0.4 0.4 0.1 0.6-0.2 0.5-0.4 0.2-0.5 0-0.1 0.2 0 0.1 0.1 0.1 0.2-0.1 0.1-0.3 0.5z m0.7-22.8l0.8 1.5-0.6-0.5-0.6-1-0.4-1 0.3-0.5 0.1 0.7 0.4 0.8z m-2.1-8.4l0.1 1-0.1-0.2-0.2-0.6-0.1-0.4 0-0.2-0.1-0.4 0-0.4 0-0.2 0.1 0.2 0.1 0.3 0.2 0.9z m-74.2 118.6l-0.2-2.6 0.3-0.5 2.7-3.3 0.7-1.9 0-2.1-0.2-2.3-0.6-3 0.2-0.7 0.3-0.8 0-0.7-0.5-0.3-0.5-0.2 0.2-0.5 0.4-0.5-0.3-1.8-1.1-1.4-0.2-1.9 1-6.6-0.2-2.5 1.5-1.5 0.5-0.9-0.1-1.1 0.1-0.5-0.1-2.4 0.3-2.1-0.7-2.4-3.1-3.9-3.8-3.4-2-1.4-1.7-1.5-1.4-1.9 0.7-1.2 0.5-1.2 0.3-1.1 0.1-1-0.1-1.2 0.8-0.3 1.1 0.1 3.4-0.5 0.8-0.8 0.8-0.9 2-0.7 1-0.6 3.5-0.1 0.5-0.2 0.5-0.3 0.3-0.3 2-1.9 0.8 0.5 0.7 0.6 0.3-0.5-0.2-0.7 0.7-0.9 1.9-1.2 0.9-0.5 1-0.6 1-0.4 1.8-0.4 1.7-1.1 1.8-0.5 1.4-1.7 0.9-2.2 0.8-0.6 1.1 0.1 0.6 0.8 0.3 0.9 0.7 0.1 0.1-1.3-0.4-1.4 0.4-1.1 0.7-1 0.6-0.9 0.7-0.7 1.1-0.2 0.8 0.6 0.9 0.4 1-0.3 1.9 0.1 0.8-0.3 2.7-1.4 2.6-2.3 1-0.6 1.7-1.4 1.9-1.2 1-2 0.4-1.2 0.7-1.1 0.3-1.1 0.1-1.1 1.9-3.9-0.1-2.1-1.5-3.1 0.1-1.3 0.4-2.1 1.3-1.8 0.1-1.2-0.4-6.3 0-0.5 0.9 0 0.2 0 0.2 0.2 0.1 0.2 0.2 0.2 0.4 0.1-0.2 0.1-0.2 0.1-0.2 0-0.1-0.2-0.2 0 0.3 0.4 0.6 0 1.4-0.2 0.7 0.1 1.8 0.6 1.9 0 0.6 0.2 0.5 0.2 0.6-0.1 2.2-1 0.4-0.3 0.4-0.6 0.2-0.3 0.2-0.3-0.1-0.3-0.1-0.3-0.1-0.3 0.1-0.3 0-0.2-0.1-0.1-0.5-0.2-0.7 0-0.7 0.2-0.7 0.4-0.5 0.4-0.6 0.4-0.8 0-0.7-0.2-0.7-0.3-0.2 0.3-0.1-0.5-0.1-0.2-0.5 0.2-0.8 0.7-0.6 0.2 0 0.2 0.2 0.1-0.3 0.1-0.3-0.1-0.1-0.3 0-0.4 1-0.9 0.3-0.3 0.3-0.2 0.2 0 0.7 0 1 0.2 0.3 0.1 0.7 0.2 0.9-0.3 3.4-1.7 0.8-0.2 2.1 0.8 0.5 0.3 0.9 0.9 1.7 2.5 0.1 0.3 0.3 0.3 0.1 0.3 0.1 0.6 0.2 0.3 0.3 0.1 0.4 0.1 0.1-0.4 0.3 0 0.6 0.2 0.8 0 0.4 0.2 0.5 1.7 0 0.4 0 0.5-0.3 0.9-0.1 0.4 0 1.6 0.3 2.2 0.8 1.6 1.5-0.2-0.1 0.3-0.2 0.4-0.7 1.5-0.1 0.2-0.4 0.9 0 0.3 0.2 0.3 0 0.1 0 0.3-0.1 0-0.2 0-0.1 0.1-0.2 0.1-0.5 0.2-0.2 0.2-0.1 0.2-0.1 0.3 0 0.7-0.1 0.4-0.5 1.8-0.8 1.8 0 0.3-2.1 3.2-3 3.3-0.6 1.1-0.4 0.4-1.7 1.1-0.5 0.5-1.3 0.8-1.7 1.8-3.8 5.6-0.3 1.1-0.5 0.1-0.2 0.3 0 0.3 0.2 0.2-1 0.7-0.6 0.9-0.4 1-0.7 2.7-0.2 1.4 0.1 2.8 0.3 0.8 0.7 1.3 0.1 0.8 0 0.3-0.3 1.2-0.1 0.2-0.3 0-0.2 0.2-0.4 1.5-0.2 0.4 0-1.3 0-0.4 0.1-0.2 0.3 0 0.3-0.2 0.2-0.1 0.2-0.4 0-0.4 0.1-1.3-0.6-0.5-0.1-0.3-0.1-0.6-0.1-0.2-0.2-0.1-0.2 0.1-0.1 0.2 0 0.3 0.3 0.3 0.1 0.2 0.1 1.1 0 0.5-0.1 0.3 0.2-0.2 0.1-0.1 0.3-0.2-1.3 2-0.3 0.3-0.1 0.1-0.2 0.3-0.3 0.2-0.2 0-0.3-0.3-0.3-0.2-0.2 0.1-0.2 0.5-0.5 0-0.7 1-0.5 1.1-0.3 1-0.6 1-0.4 1.1-0.3 0.4-0.4-0.1 0.4-0.2 0.3-0.4 0.1-0.6-0.1-0.4-0.4 0.1-1.7 0-0.3-0.1-0.2 0.4-0.1 0.7 0 0.7 0.1 0.5 0.3 0.5 0.9 0.6 0.1 0.3 0.2 0.1 0.3 0.1 0.4 0 0.4 0-0.2 0.5-0.1 1-0.2 0.6 0.6-0.1 0.4-0.3 0.4-0.5 0.4-0.5 0.3-0.2 0.9-0.3 0.5-0.2 0.9 0.2 0.6 0.5 0.2 0 0.2-0.1 0.1-0.2 0-0.2 0.1-0.2 0.3 0 0.2 0.2 0.2 0 0.2-0.2 0.3 0.2 0.1 0-0.4 0.2 0 0.3 0.9-0.2 0.4-0.7 0-0.6-0.4-0.1 0.2 0.3 0 0.3-0.3 0.1-1 0-0.9-0.2-0.4-0.1-0.4-0.2 0.6 0 2 0.3 0-0.3-0.1-0.2 0.3-0.8 0-0.6 0.6 1.2 0.3 0.8-0.2 0.3-0.2 0.3-0.3 2.2-0.3 0.7-0.5 0.6-0.5 0.4-0.5 0.2-0.2 0.1-0.9 0.9-0.3 0.1-1.1 0.2 0.6-0.2 0.2-0.3 0.1-0.4 0.2-0.4-1.2 0.3-1.4 0.7-1.2 1.1-0.4 1.3 0.3 0-0.3 0.4-0.2 0.4 0.5 0.1-0.7 1.4-0.2 0.8 0.3 0.3 0.6 0.2 0.3 0.2 0.3 0 0.7-0.6 0.8-1 0.3-0.6 0.2-0.6 0.3-0.4 0.8-0.3 1.4-0.1-0.6 1.4 0.4-0.3 0.3-0.5 0.4-0.3 0.6 0 0 0.2-0.6 0.3-0.5 0.5-0.8 1.2-0.3 0.8-0.4 1.8-0.4 0.6 0.3 0.8-1.1 2.7-0.7 1.1-0.7 4.3-1.1 4.1-0.6 1-0.7 0.9-0.6 1-0.5 1.2-0.1 1.4 0.1 1.5 0 0.7-0.4 0.7-0.2 0.5-0.2 2.4-0.2 0.7-1.6 2.3-0.1 0.5-0.1 0.5-0.5 1-0.1 0.5 0 2.2-0.2 0 0-0.9-0.2-0.7-0.5 0.6-0.4-0.1-0.1-0.5 0.3-0.2 0.2-0.4 0.2-0.8 0.1-0.9 0-0.5-0.1 0.4-0.2 0.3-0.2 0.3-0.1 0.2-0.2-0.4 0.1-0.3 0.2-0.4 0.1-0.5-0.1 0-0.5-0.6 0-0.1 0-0.3 0-0.3-0.1-0.3-0.9-0.2-0.2-0.2 0-0.2 0.2-0.3 0.1 0-0.2-0.5-0.1-0.4-0.3-0.2-0.6 0-0.9-0.3-1.6-0.9-0.8-0.2-0.3-0.2-0.1-0.6 0.1-0.5 0-0.2 1.1-1.2-0.2-0.8 0.3-0.7 0.5-0.6 0.2-0.6 0.1-0.3 0.3-0.5 0.1-0.4-0.1-0.1-0.1-0.1-0.2-0.2-0.1-0.2 0.1-0.2 0.1-0.2 0.1-0.2 0.1-1.3 0-0.7-0.3-0.6-0.3-0.5-0.2-0.5-0.2-1.4-0.7 0.6-0.8 0.9-0.6 0.9-0.3 0.9 0 0.5-0.2 0.6-0.3 0.5-0.2 0.1-0.3-0.2 0.1-0.6 0.1-0.4-0.4 0.4-0.5 0.1-0.8 0.1-0.2 0.1-1.4 1.2-0.2 0.3-0.1 0.3-0.1 0.3 0.6-0.2 0.6-0.5 0.6-0.7 0.4-0.6 0.1 0.6-0.1 0.4-0.2 0.4-0.1 0.6 0.2-0.2 0.2-0.3 0.4-0.3 0.3-0.1 0.3 0.2-0.2 0.3-0.4 0.2-0.1 0-0.8 1.6-0.7 1-0.9 1.6-0.1 0.6-0.7 1-0.3 0.6-0.4 0.1-0.1 0-0.1 0.1 0 0.1-0.2 0-2 0-0.2 0.1-0.2 0.1-0.2 0-0.2-0.1-0.3-0.3-0.2-0.1-0.2 0.1-0.3 0.2-0.7 0.2-0.2 0-0.4-0.1-0.3-0.1-0.3-0.1-0.9 0.8-0.3 0.2-0.1 0.4-0.2 1-0.3 0.8-0.1 0.8-0.1 0.4-0.4 0.6-1 1.2-0.3 0.5-0.1 0.6-0.1 0.5-0.1 0.5-0.3 0.5-0.4 0.3-0.9 0.4-0.9 0.7 0.1 0.1 0.1 0.5-0.1 0.3-0.8 1.4-0.1 0.3-0.1 0.7 0 0.4-0.4 0.5-0.3 0.3-0.5 0.2-0.4 0.4-0.2 0.3-0.4 1.3-0.3 0.4-1.6 1.2-0.2 0.2-0.1 0.8-0.2 0.2-0.3 0.1-1.3-0.7-0.4-0.3-0.4-1-0.3 0-0.4 0-0.3 0-0.6-0.4-0.4-0.5-0.5-0.5-0.7-0.3-2.6 1-0.5 0.6z m46.9-46.1l0.2-0.6 0.2 0-0.3 0.5-0.1 0.1z", id: "MEX2736", name: "Quintana Roo", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Quintana Roo', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), data === null || data === void 0 ? void 0 : data.map(function (x) {
                            return x.id === "Yucat\u00E1n" && (jsx("path", { fill: x.fill, stroke: x.stroke, d: "M972.6 399.2l0 0.5 0.4 6.3-0.1 1.2-1.3 1.8-0.4 2.1-0.1 1.3 1.5 3.1 0.1 2.1-1.9 3.9-0.1 1.1-0.3 1.1-0.7 1.1-0.4 1.2-1 2-1.9 1.2-1.7 1.4-1 0.6-2.6 2.3-2.7 1.4-0.8 0.3-1.9-0.1-1 0.3-0.9-0.4-0.8-0.6-1.1 0.2-0.7 0.7-0.6 0.9-0.7 1-0.4 1.1 0.4 1.4-0.1 1.3-0.7-0.1-0.3-0.9-0.6-0.8-1.1-0.1-0.8 0.6-0.9 2.2-1.4 1.7-1.8 0.5-1.7 1.1-1.8 0.4-1 0.4-1 0.6-0.9 0.5-1.9 1.2-0.7 0.9 0.2 0.7-0.3 0.5-0.7-0.6-0.8-0.5-2 1.9-0.3 0.3-0.5 0.3-0.5 0.2-3.5 0.1-1 0.6-2 0.7-0.8 0.9-0.8 0.8-3.4 0.5-1.1-0.1-0.8 0.3 0.1 1.2-0.1 1-0.3 1.1-0.5 1.2-0.7 1.2-0.8-1.8-0.4-2.4-1.5-2-1.7-1.8-2.3-4.3-1.9-1.5-2.2-0.8-1.6-1.7-0.8-2.4-1.1-2-1.8-1.3-0.5-0.6-0.6-1.3 0-0.8-0.5-0.9-1.3-1.8-0.8 0.6-0.6 1.2-0.9 0.2-0.6-0.6-0.6-0.5-0.6 0.2-0.6 0.3-0.8-0.7-0.5-1.2-0.8-0.9-1.3-0.2-1.6 0-1.5-0.1-0.5-1 0.4-8.4-0.1-0.9 0.1-0.1 0.4-1.9 0.7-1.9 0.1-1.1-0.2 0-0.4 1.8-0.6 1.3-0.1 0.2-0.1 0.8-0.4 1-0.6 0.8-0.8 0.3 0-0.2 0.6-0.9 2-6.1 0.3-0.5 0.5-0.6 3.6-2.2 0.6-0.5 2.1-0.8 1.1-0.9 0.7-0.3 0.3-0.2 1-0.1 1.7-0.6 1.9-1.4 0.5-0.2 0.6-0.1 3.2-1.2 3.4-0.6 2.5 0 4.4-0.8 6-0.6 2.5-0.7 1.3-0.2 0.8 0.2 0.3 0.1 0.3-0.1 0.7-0.3 0.2-0.1 2.7-0.5 2.1-0.6 1.4-0.1 0.6-0.2 1.1-0.5 3.8-0.9 1.1-0.7 2-1.8 0.6-0.3 2-0.2 0.6-0.2 1.1-0.6 0.6-0.1 2.5 0 0.5 0.1 1.1 0.5 0.6 0.1 0.5-0.1 1.1-0.3 1.7-0.2 0.6-0.2 0.4-0.3 0.4-0.2 2.1 0.1-0.6-0.3-0.8-0.1-0.7 0-1.1 0.6-1.3 0.3-0.3 0 0.2-0.3 0.6-0.3 0.7-0.3 0.9-0.1 0.7-0.3 0.3-0.1 0.4 0 1.4 0.4 2.7 0 0.7 0.1 2 0.9 1.3 0.3 2.8 0.4 1.9 0.6 0.1 0.1-0.3 0.2-0.3 0.1-0.4 0.1-0.4-0.1-0.3-0.2-0.4-0.2-2.3-0.4-0.6-0.2 0.7 0.6 1 0.5 1 0.4 1.1 0.1 2.1 0 1 0.2 0.6 0 0.5-0.2-1.4-0.1-0.6-0.1-0.5-0.4 0.2-0.2 2.1 0.3 1.7 0.7 0.8 0z", id: "MEX2737", name: "Yucat\u00E1n", onMouseEnter: function (event) {
                                    return setShowData(__assign(__assign({}, showData), { elemntId: 'Yucatán', open: x.disable, positionX: "".concat(event.clientX), positionY: "".concat(event.clientY) }));
                                } }));
                        }), jsx("circle", { cx: "832.1", cy: "533.4", id: "0" }), jsx("circle", { cx: "832.6", cy: "533.3", id: "1" }), jsx("circle", { cx: "832.6", cy: "533.5", id: "2" })] })) })] })));
};
var templateObject_1$Q;

var Maps = function (props) {
    var place = props.place;
    switch (place) {
        case "mx":
            return jsx(Mexico, __assign({}, props));
        case "co":
            return jsx("p", { children: "Mapa de Colombia" });
        case "us":
            return jsx("p", { children: "Mapa de US" });
        default:
            return jsx(Mexico, __assign({}, props));
    }
};

var AtomModal = function (props) {
    var isOpen = props.isOpen, component = props.component, componentProps = props.componentProps, key = props.key;
    return isOpen ? (jsx(Container, __assign({ customCSS: css$1(templateObject_1$P || (templateObject_1$P = __makeTemplateObject(["\n        position: fixed;\n        width: 100vw;\n        height: 100vh;\n        left: 0;\n        top: 0;\n        background-color: #00000010;\n        backdrop-filter: blur(12px);\n        z-index: 9999;\n      "], ["\n        position: fixed;\n        width: 100vw;\n        height: 100vh;\n        left: 0;\n        top: 0;\n        background-color: #00000010;\n        backdrop-filter: blur(12px);\n        z-index: 9999;\n      "]))) }, componentProps === null || componentProps === void 0 ? void 0 : componentProps.containerProps, { children: jsx(Wrapper$2, __assign({ backgroundColor: "white", flexDirection: "column", alignItems: "center", justifyContent: "center", width: "50%", height: "60%", borderRadius: "4px" }, componentProps === null || componentProps === void 0 ? void 0 : componentProps.wrapperProps, { children: component })) }), key)) : null;
};
var templateObject_1$P;

var AtomModalBox = function (props) {
    var _a, _b, _c, _d, _e;
    var isOpen = props.isOpen, children = props.children, onClose = props.onClose;
    var ref = useRef(null);
    useEffect(function () {
        var handleClickOutside = function (event) {
            if (ref.current && !ref.current.contains(event.target)) {
                onClose();
            }
        };
        document.addEventListener("mousedown", handleClickOutside);
        return function () {
            document.removeEventListener("mousedown", handleClickOutside);
        };
    }, [ref]);
    return (jsx(AtomModal, { isOpen: isOpen, componentProps: __assign({ wrapperProps: __assign(__assign({}, ((_b = (_a = props === null || props === void 0 ? void 0 : props.componentProps) === null || _a === void 0 ? void 0 : _a.wrapperProps) !== null && _b !== void 0 ? _b : {})), { refObject: ref }) }, ((_d = (_c = props === null || props === void 0 ? void 0 : props.componentProps) === null || _c === void 0 ? void 0 : _c.containerProps) !== null && _d !== void 0 ? _d : {})), component: jsx(Fragment$1, { children: children }) }, (_e = props.key) !== null && _e !== void 0 ? _e : ''));
};

var spring$1 = {
    x: { type: "spring", damping: 20, stiffness: 180, when: "afterChildren" },
    default: { duration: 0.45 },
};
var animation$1 = {
    transition: spring$1,
    initial: { opacity: 0 },
    animate: { opacity: 1 },
    exit: { opacity: 0 },
};
var AtomModalImage = function (props) {
    var images = props.images, selected = props.selected, setSelected = props.setSelected, state = props.state, setState = props.setState;
    var ref = useRef(null);
    useEffect(function () {
        var handleClickOutside = function (event) {
            if (ref.current && !ref.current.contains(event.target)) {
                setState === null || setState === void 0 ? void 0 : setState(false);
            }
        };
        document.addEventListener("mousedown", handleClickOutside);
        return function () {
            document.removeEventListener("mousedown", handleClickOutside);
        };
    }, [ref]);
    return (jsx(AtomModal, { isOpen: state, componentProps: {
            containerProps: {
                customCSS: css$1(templateObject_1$O || (templateObject_1$O = __makeTemplateObject(["\n            position: fixed;\n            width: 100vw;\n            height: 100vh;\n            left: 0;\n            top: 0;\n            background-color: #0000008a;\n            backdrop-filter: blur(12px);\n            z-index: 9999;\n          "], ["\n            position: fixed;\n            width: 100vw;\n            height: 100vh;\n            left: 0;\n            top: 0;\n            background-color: #0000008a;\n            backdrop-filter: blur(12px);\n            z-index: 9999;\n          "]))),
            },
            wrapperProps: {
                width: 'max-content',
                height: 'max-content',
                refObject: ref,
                backgroundColor: 'transparent',
            },
        }, component: jsxs(Wrapper$2, __assign({ alignItems: "flex-end" }, { children: [jsx(AtomButton, __assign({ backgroundColor: "transparent", fontSize: "30px", onClick: function () { return setState(false); } }, { children: "X" })), jsxs(Wrapper$2, __assign({ maxWidth: "100%", alignItems: "center", justifyContent: "center", flexDirection: "row" }, { children: [jsx(AtomButton, __assign({ padding: "0px 0px", backgroundColor: "transparent", customCSS: css$1(templateObject_2$C || (templateObject_2$C = __makeTemplateObject(["\n                margin-right: 22px;\n              "], ["\n                margin-right: 22px;\n              "]))), onClick: function () {
                                var _a;
                                var newSelected = (selected !== null && selected !== void 0 ? selected : 0) - 1;
                                var length = ((_a = images === null || images === void 0 ? void 0 : images.length) !== null && _a !== void 0 ? _a : 0) - 1;
                                setSelected === null || setSelected === void 0 ? void 0 : setSelected(newSelected < 0 ? length : newSelected);
                            } }, { children: jsx(Icon$1, { height: "30px", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-commons/frontend-library/icons/arrowleft.svg", color: "white", customCSS: css$1(templateObject_3$u || (templateObject_3$u = __makeTemplateObject(["\n                  transform: rotate(180deg);\n                "], ["\n                  transform: rotate(180deg);\n                "]))) }) })), (images === null || images === void 0 ? void 0 : images.find(function (_, idx) { return idx === selected; })) && (createElement(Image$2, __assign({}, animation$1, { key: selected, height: "70vh", width: "60vw", alt: "image", src: "".concat(images === null || images === void 0 ? void 0 : images.find(function (_, idx) { return idx === selected; })), customCSS: css$1(templateObject_4$l || (templateObject_4$l = __makeTemplateObject(["\n                  img {\n                    object-fit: contain;\n                  }\n                "], ["\n                  img {\n                    object-fit: contain;\n                  }\n                "]))) }))), jsx(AtomButton, __assign({ padding: "0px 0px", backgroundColor: "transparent", customCSS: css$1(templateObject_5$h || (templateObject_5$h = __makeTemplateObject(["\n                margin-left: 22px;\n              "], ["\n                margin-left: 22px;\n              "]))), onClick: function () {
                                var _a;
                                var newSelected = (selected !== null && selected !== void 0 ? selected : 0) + 1;
                                var length = ((_a = images === null || images === void 0 ? void 0 : images.length) !== null && _a !== void 0 ? _a : 0) - 1;
                                setSelected === null || setSelected === void 0 ? void 0 : setSelected(newSelected > length ? 0 : newSelected);
                            } }, { children: jsx(Icon$1, { height: "30px", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-commons/frontend-library/icons/arrowleft.svg", color: "white" }) }))] }))] })) }));
};
var templateObject_1$O, templateObject_2$C, templateObject_3$u, templateObject_4$l, templateObject_5$h;

var reactIs$1 = {exports: {}};

var reactIs_production_min = {};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1="function"===typeof Symbol&&Symbol.for,c=b$1?Symbol.for("react.element"):60103,d=b$1?Symbol.for("react.portal"):60106,e=b$1?Symbol.for("react.fragment"):60107,f=b$1?Symbol.for("react.strict_mode"):60108,g$1=b$1?Symbol.for("react.profiler"):60114,h=b$1?Symbol.for("react.provider"):60109,k$1=b$1?Symbol.for("react.context"):60110,l=b$1?Symbol.for("react.async_mode"):60111,m=b$1?Symbol.for("react.concurrent_mode"):60111,n=b$1?Symbol.for("react.forward_ref"):60112,p=b$1?Symbol.for("react.suspense"):60113,q$1=b$1?
Symbol.for("react.suspense_list"):60120,r=b$1?Symbol.for("react.memo"):60115,t=b$1?Symbol.for("react.lazy"):60116,v$1=b$1?Symbol.for("react.block"):60121,w$1=b$1?Symbol.for("react.fundamental"):60117,x$1=b$1?Symbol.for("react.responder"):60118,y=b$1?Symbol.for("react.scope"):60119;
function z$1(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g$1:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k$1:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A$1(a){return z$1(a)===m}reactIs_production_min.AsyncMode=l;reactIs_production_min.ConcurrentMode=m;reactIs_production_min.ContextConsumer=k$1;reactIs_production_min.ContextProvider=h;reactIs_production_min.Element=c;reactIs_production_min.ForwardRef=n;reactIs_production_min.Fragment=e;reactIs_production_min.Lazy=t;reactIs_production_min.Memo=r;reactIs_production_min.Portal=d;
reactIs_production_min.Profiler=g$1;reactIs_production_min.StrictMode=f;reactIs_production_min.Suspense=p;reactIs_production_min.isAsyncMode=function(a){return A$1(a)||z$1(a)===l};reactIs_production_min.isConcurrentMode=A$1;reactIs_production_min.isContextConsumer=function(a){return z$1(a)===k$1};reactIs_production_min.isContextProvider=function(a){return z$1(a)===h};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};reactIs_production_min.isForwardRef=function(a){return z$1(a)===n};reactIs_production_min.isFragment=function(a){return z$1(a)===e};reactIs_production_min.isLazy=function(a){return z$1(a)===t};
reactIs_production_min.isMemo=function(a){return z$1(a)===r};reactIs_production_min.isPortal=function(a){return z$1(a)===d};reactIs_production_min.isProfiler=function(a){return z$1(a)===g$1};reactIs_production_min.isStrictMode=function(a){return z$1(a)===f};reactIs_production_min.isSuspense=function(a){return z$1(a)===p};
reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g$1||a===f||a===p||a===q$1||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k$1||a.$$typeof===n||a.$$typeof===w$1||a.$$typeof===x$1||a.$$typeof===y||a.$$typeof===v$1)};reactIs_production_min.typeOf=z$1;

var reactIs_development = {};

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (process.env.NODE_ENV !== "production") {
  (function() {

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

reactIs_development.AsyncMode = AsyncMode;
reactIs_development.ConcurrentMode = ConcurrentMode;
reactIs_development.ContextConsumer = ContextConsumer;
reactIs_development.ContextProvider = ContextProvider;
reactIs_development.Element = Element;
reactIs_development.ForwardRef = ForwardRef;
reactIs_development.Fragment = Fragment;
reactIs_development.Lazy = Lazy;
reactIs_development.Memo = Memo;
reactIs_development.Portal = Portal;
reactIs_development.Profiler = Profiler;
reactIs_development.StrictMode = StrictMode;
reactIs_development.Suspense = Suspense;
reactIs_development.isAsyncMode = isAsyncMode;
reactIs_development.isConcurrentMode = isConcurrentMode;
reactIs_development.isContextConsumer = isContextConsumer;
reactIs_development.isContextProvider = isContextProvider;
reactIs_development.isElement = isElement;
reactIs_development.isForwardRef = isForwardRef;
reactIs_development.isFragment = isFragment;
reactIs_development.isLazy = isLazy;
reactIs_development.isMemo = isMemo;
reactIs_development.isPortal = isPortal;
reactIs_development.isProfiler = isProfiler;
reactIs_development.isStrictMode = isStrictMode;
reactIs_development.isSuspense = isSuspense;
reactIs_development.isValidElementType = isValidElementType;
reactIs_development.typeOf = typeOf;
  })();
}

if (process.env.NODE_ENV === 'production') {
  reactIs$1.exports = reactIs_production_min;
} else {
  reactIs$1.exports = reactIs_development;
}

function stylis_min (W) {
  function M(d, c, e, h, a) {
    for (var m = 0, b = 0, v = 0, n = 0, q, g, x = 0, K = 0, k, u = k = q = 0, l = 0, r = 0, I = 0, t = 0, B = e.length, J = B - 1, y, f = '', p = '', F = '', G = '', C; l < B;) {
      g = e.charCodeAt(l);
      l === J && 0 !== b + n + v + m && (0 !== b && (g = 47 === b ? 10 : 47), n = v = m = 0, B++, J++);

      if (0 === b + n + v + m) {
        if (l === J && (0 < r && (f = f.replace(N, '')), 0 < f.trim().length)) {
          switch (g) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;

            default:
              f += e.charAt(l);
          }

          g = 59;
        }

        switch (g) {
          case 123:
            f = f.trim();
            q = f.charCodeAt(0);
            k = 1;

            for (t = ++l; l < B;) {
              switch (g = e.charCodeAt(l)) {
                case 123:
                  k++;
                  break;

                case 125:
                  k--;
                  break;

                case 47:
                  switch (g = e.charCodeAt(l + 1)) {
                    case 42:
                    case 47:
                      a: {
                        for (u = l + 1; u < J; ++u) {
                          switch (e.charCodeAt(u)) {
                            case 47:
                              if (42 === g && 42 === e.charCodeAt(u - 1) && l + 2 !== u) {
                                l = u + 1;
                                break a;
                              }

                              break;

                            case 10:
                              if (47 === g) {
                                l = u + 1;
                                break a;
                              }

                          }
                        }

                        l = u;
                      }

                  }

                  break;

                case 91:
                  g++;

                case 40:
                  g++;

                case 34:
                case 39:
                  for (; l++ < J && e.charCodeAt(l) !== g;) {
                  }

              }

              if (0 === k) break;
              l++;
            }

            k = e.substring(t, l);
            0 === q && (q = (f = f.replace(ca, '').trim()).charCodeAt(0));

            switch (q) {
              case 64:
                0 < r && (f = f.replace(N, ''));
                g = f.charCodeAt(1);

                switch (g) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    r = c;
                    break;

                  default:
                    r = O;
                }

                k = M(c, r, k, g, a + 1);
                t = k.length;
                0 < A && (r = X(O, f, I), C = H(3, k, r, c, D, z, t, g, a, h), f = r.join(''), void 0 !== C && 0 === (t = (k = C.trim()).length) && (g = 0, k = ''));
                if (0 < t) switch (g) {
                  case 115:
                    f = f.replace(da, ea);

                  case 100:
                  case 109:
                  case 45:
                    k = f + '{' + k + '}';
                    break;

                  case 107:
                    f = f.replace(fa, '$1 $2');
                    k = f + '{' + k + '}';
                    k = 1 === w || 2 === w && L('@' + k, 3) ? '@-webkit-' + k + '@' + k : '@' + k;
                    break;

                  default:
                    k = f + k, 112 === h && (k = (p += k, ''));
                } else k = '';
                break;

              default:
                k = M(c, X(c, f, I), k, h, a + 1);
            }

            F += k;
            k = I = r = u = q = 0;
            f = '';
            g = e.charCodeAt(++l);
            break;

          case 125:
          case 59:
            f = (0 < r ? f.replace(N, '') : f).trim();
            if (1 < (t = f.length)) switch (0 === u && (q = f.charCodeAt(0), 45 === q || 96 < q && 123 > q) && (t = (f = f.replace(' ', ':')).length), 0 < A && void 0 !== (C = H(1, f, c, d, D, z, p.length, h, a, h)) && 0 === (t = (f = C.trim()).length) && (f = '\x00\x00'), q = f.charCodeAt(0), g = f.charCodeAt(1), q) {
              case 0:
                break;

              case 64:
                if (105 === g || 99 === g) {
                  G += f + e.charAt(l);
                  break;
                }

              default:
                58 !== f.charCodeAt(t - 1) && (p += P(f, q, g, f.charCodeAt(2)));
            }
            I = r = u = q = 0;
            f = '';
            g = e.charCodeAt(++l);
        }
      }

      switch (g) {
        case 13:
        case 10:
          47 === b ? b = 0 : 0 === 1 + q && 107 !== h && 0 < f.length && (r = 1, f += '\x00');
          0 < A * Y && H(0, f, c, d, D, z, p.length, h, a, h);
          z = 1;
          D++;
          break;

        case 59:
        case 125:
          if (0 === b + n + v + m) {
            z++;
            break;
          }

        default:
          z++;
          y = e.charAt(l);

          switch (g) {
            case 9:
            case 32:
              if (0 === n + m + b) switch (x) {
                case 44:
                case 58:
                case 9:
                case 32:
                  y = '';
                  break;

                default:
                  32 !== g && (y = ' ');
              }
              break;

            case 0:
              y = '\\0';
              break;

            case 12:
              y = '\\f';
              break;

            case 11:
              y = '\\v';
              break;

            case 38:
              0 === n + b + m && (r = I = 1, y = '\f' + y);
              break;

            case 108:
              if (0 === n + b + m + E && 0 < u) switch (l - u) {
                case 2:
                  112 === x && 58 === e.charCodeAt(l - 3) && (E = x);

                case 8:
                  111 === K && (E = K);
              }
              break;

            case 58:
              0 === n + b + m && (u = l);
              break;

            case 44:
              0 === b + v + n + m && (r = 1, y += '\r');
              break;

            case 34:
            case 39:
              0 === b && (n = n === g ? 0 : 0 === n ? g : n);
              break;

            case 91:
              0 === n + b + v && m++;
              break;

            case 93:
              0 === n + b + v && m--;
              break;

            case 41:
              0 === n + b + m && v--;
              break;

            case 40:
              if (0 === n + b + m) {
                if (0 === q) switch (2 * x + 3 * K) {
                  case 533:
                    break;

                  default:
                    q = 1;
                }
                v++;
              }

              break;

            case 64:
              0 === b + v + n + m + u + k && (k = 1);
              break;

            case 42:
            case 47:
              if (!(0 < n + m + v)) switch (b) {
                case 0:
                  switch (2 * g + 3 * e.charCodeAt(l + 1)) {
                    case 235:
                      b = 47;
                      break;

                    case 220:
                      t = l, b = 42;
                  }

                  break;

                case 42:
                  47 === g && 42 === x && t + 2 !== l && (33 === e.charCodeAt(t + 2) && (p += e.substring(t, l + 1)), y = '', b = 0);
              }
          }

          0 === b && (f += y);
      }

      K = x;
      x = g;
      l++;
    }

    t = p.length;

    if (0 < t) {
      r = c;
      if (0 < A && (C = H(2, p, r, d, D, z, t, h, a, h), void 0 !== C && 0 === (p = C).length)) return G + p + F;
      p = r.join(',') + '{' + p + '}';

      if (0 !== w * E) {
        2 !== w || L(p, 2) || (E = 0);

        switch (E) {
          case 111:
            p = p.replace(ha, ':-moz-$1') + p;
            break;

          case 112:
            p = p.replace(Q, '::-webkit-input-$1') + p.replace(Q, '::-moz-$1') + p.replace(Q, ':-ms-input-$1') + p;
        }

        E = 0;
      }
    }

    return G + p + F;
  }

  function X(d, c, e) {
    var h = c.trim().split(ia);
    c = h;
    var a = h.length,
        m = d.length;

    switch (m) {
      case 0:
      case 1:
        var b = 0;

        for (d = 0 === m ? '' : d[0] + ' '; b < a; ++b) {
          c[b] = Z(d, c[b], e).trim();
        }

        break;

      default:
        var v = b = 0;

        for (c = []; b < a; ++b) {
          for (var n = 0; n < m; ++n) {
            c[v++] = Z(d[n] + ' ', h[b], e).trim();
          }
        }

    }

    return c;
  }

  function Z(d, c, e) {
    var h = c.charCodeAt(0);
    33 > h && (h = (c = c.trim()).charCodeAt(0));

    switch (h) {
      case 38:
        return c.replace(F, '$1' + d.trim());

      case 58:
        return d.trim() + c.replace(F, '$1' + d.trim());

      default:
        if (0 < 1 * e && 0 < c.indexOf('\f')) return c.replace(F, (58 === d.charCodeAt(0) ? '' : '$1') + d.trim());
    }

    return d + c;
  }

  function P(d, c, e, h) {
    var a = d + ';',
        m = 2 * c + 3 * e + 4 * h;

    if (944 === m) {
      d = a.indexOf(':', 9) + 1;
      var b = a.substring(d, a.length - 1).trim();
      b = a.substring(0, d).trim() + b + ';';
      return 1 === w || 2 === w && L(b, 1) ? '-webkit-' + b + b : b;
    }

    if (0 === w || 2 === w && !L(a, 1)) return a;

    switch (m) {
      case 1015:
        return 97 === a.charCodeAt(10) ? '-webkit-' + a + a : a;

      case 951:
        return 116 === a.charCodeAt(3) ? '-webkit-' + a + a : a;

      case 963:
        return 110 === a.charCodeAt(5) ? '-webkit-' + a + a : a;

      case 1009:
        if (100 !== a.charCodeAt(4)) break;

      case 969:
      case 942:
        return '-webkit-' + a + a;

      case 978:
        return '-webkit-' + a + '-moz-' + a + a;

      case 1019:
      case 983:
        return '-webkit-' + a + '-moz-' + a + '-ms-' + a + a;

      case 883:
        if (45 === a.charCodeAt(8)) return '-webkit-' + a + a;
        if (0 < a.indexOf('image-set(', 11)) return a.replace(ja, '$1-webkit-$2') + a;
        break;

      case 932:
        if (45 === a.charCodeAt(4)) switch (a.charCodeAt(5)) {
          case 103:
            return '-webkit-box-' + a.replace('-grow', '') + '-webkit-' + a + '-ms-' + a.replace('grow', 'positive') + a;

          case 115:
            return '-webkit-' + a + '-ms-' + a.replace('shrink', 'negative') + a;

          case 98:
            return '-webkit-' + a + '-ms-' + a.replace('basis', 'preferred-size') + a;
        }
        return '-webkit-' + a + '-ms-' + a + a;

      case 964:
        return '-webkit-' + a + '-ms-flex-' + a + a;

      case 1023:
        if (99 !== a.charCodeAt(8)) break;
        b = a.substring(a.indexOf(':', 15)).replace('flex-', '').replace('space-between', 'justify');
        return '-webkit-box-pack' + b + '-webkit-' + a + '-ms-flex-pack' + b + a;

      case 1005:
        return ka.test(a) ? a.replace(aa, ':-webkit-') + a.replace(aa, ':-moz-') + a : a;

      case 1e3:
        b = a.substring(13).trim();
        c = b.indexOf('-') + 1;

        switch (b.charCodeAt(0) + b.charCodeAt(c)) {
          case 226:
            b = a.replace(G, 'tb');
            break;

          case 232:
            b = a.replace(G, 'tb-rl');
            break;

          case 220:
            b = a.replace(G, 'lr');
            break;

          default:
            return a;
        }

        return '-webkit-' + a + '-ms-' + b + a;

      case 1017:
        if (-1 === a.indexOf('sticky', 9)) break;

      case 975:
        c = (a = d).length - 10;
        b = (33 === a.charCodeAt(c) ? a.substring(0, c) : a).substring(d.indexOf(':', 7) + 1).trim();

        switch (m = b.charCodeAt(0) + (b.charCodeAt(7) | 0)) {
          case 203:
            if (111 > b.charCodeAt(8)) break;

          case 115:
            a = a.replace(b, '-webkit-' + b) + ';' + a;
            break;

          case 207:
          case 102:
            a = a.replace(b, '-webkit-' + (102 < m ? 'inline-' : '') + 'box') + ';' + a.replace(b, '-webkit-' + b) + ';' + a.replace(b, '-ms-' + b + 'box') + ';' + a;
        }

        return a + ';';

      case 938:
        if (45 === a.charCodeAt(5)) switch (a.charCodeAt(6)) {
          case 105:
            return b = a.replace('-items', ''), '-webkit-' + a + '-webkit-box-' + b + '-ms-flex-' + b + a;

          case 115:
            return '-webkit-' + a + '-ms-flex-item-' + a.replace(ba, '') + a;

          default:
            return '-webkit-' + a + '-ms-flex-line-pack' + a.replace('align-content', '').replace(ba, '') + a;
        }
        break;

      case 973:
      case 989:
        if (45 !== a.charCodeAt(3) || 122 === a.charCodeAt(4)) break;

      case 931:
      case 953:
        if (!0 === la.test(d)) return 115 === (b = d.substring(d.indexOf(':') + 1)).charCodeAt(0) ? P(d.replace('stretch', 'fill-available'), c, e, h).replace(':fill-available', ':stretch') : a.replace(b, '-webkit-' + b) + a.replace(b, '-moz-' + b.replace('fill-', '')) + a;
        break;

      case 962:
        if (a = '-webkit-' + a + (102 === a.charCodeAt(5) ? '-ms-' + a : '') + a, 211 === e + h && 105 === a.charCodeAt(13) && 0 < a.indexOf('transform', 10)) return a.substring(0, a.indexOf(';', 27) + 1).replace(ma, '$1-webkit-$2') + a;
    }

    return a;
  }

  function L(d, c) {
    var e = d.indexOf(1 === c ? ':' : '{'),
        h = d.substring(0, 3 !== c ? e : 10);
    e = d.substring(e + 1, d.length - 1);
    return R(2 !== c ? h : h.replace(na, '$1'), e, c);
  }

  function ea(d, c) {
    var e = P(c, c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2));
    return e !== c + ';' ? e.replace(oa, ' or ($1)').substring(4) : '(' + c + ')';
  }

  function H(d, c, e, h, a, m, b, v, n, q) {
    for (var g = 0, x = c, w; g < A; ++g) {
      switch (w = S[g].call(B, d, x, e, h, a, m, b, v, n, q)) {
        case void 0:
        case !1:
        case !0:
        case null:
          break;

        default:
          x = w;
      }
    }

    if (x !== c) return x;
  }

  function T(d) {
    switch (d) {
      case void 0:
      case null:
        A = S.length = 0;
        break;

      default:
        if ('function' === typeof d) S[A++] = d;else if ('object' === typeof d) for (var c = 0, e = d.length; c < e; ++c) {
          T(d[c]);
        } else Y = !!d | 0;
    }

    return T;
  }

  function U(d) {
    d = d.prefix;
    void 0 !== d && (R = null, d ? 'function' !== typeof d ? w = 1 : (w = 2, R = d) : w = 0);
    return U;
  }

  function B(d, c) {
    var e = d;
    33 > e.charCodeAt(0) && (e = e.trim());
    V = e;
    e = [V];

    if (0 < A) {
      var h = H(-1, c, e, e, D, z, 0, 0, 0, 0);
      void 0 !== h && 'string' === typeof h && (c = h);
    }

    var a = M(O, e, c, 0, 0);
    0 < A && (h = H(-2, a, e, e, D, z, a.length, 0, 0, 0), void 0 !== h && (a = h));
    V = '';
    E = 0;
    z = D = 1;
    return a;
  }

  var ca = /^\0+/g,
      N = /[\0\r\f]/g,
      aa = /: */g,
      ka = /zoo|gra/,
      ma = /([,: ])(transform)/g,
      ia = /,\r+?/g,
      F = /([\t\r\n ])*\f?&/g,
      fa = /@(k\w+)\s*(\S*)\s*/,
      Q = /::(place)/g,
      ha = /:(read-only)/g,
      G = /[svh]\w+-[tblr]{2}/,
      da = /\(\s*(.*)\s*\)/g,
      oa = /([\s\S]*?);/g,
      ba = /-self|flex-/g,
      na = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
      la = /stretch|:\s*\w+\-(?:conte|avail)/,
      ja = /([^-])(image-set\()/,
      z = 1,
      D = 1,
      E = 0,
      w = 1,
      O = [],
      S = [],
      A = 0,
      R = null,
      Y = 0,
      V = '';
  B.use = T;
  B.set = U;
  void 0 !== W && U(W);
  return B;
}

var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

function memoize(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

var isPropValid = /* #__PURE__ */memoize(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
  /* o */
  && prop.charCodeAt(1) === 110
  /* n */
  && prop.charCodeAt(2) < 91;
}
/* Z+1 */
);

var reactIs = reactIs$1.exports;

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

var hoistNonReactStatics_cjs = hoistNonReactStatics;

function v(){return (v=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r]);}return e}).apply(this,arguments)}var g=function(e,t){for(var n=[e[0]],r=0,o=t.length;r<o;r+=1)n.push(t[r],e[r+1]);return n},S=function(t){return null!==t&&"object"==typeof t&&"[object Object]"===(t.toString?t.toString():Object.prototype.toString.call(t))&&!reactIs$1.exports.typeOf(t)},w=Object.freeze([]),E=Object.freeze({});function b(e){return "function"==typeof e}function _(e){return "production"!==process.env.NODE_ENV&&"string"==typeof e&&e||e.displayName||e.name||"Component"}function N(e){return e&&"string"==typeof e.styledComponentId}var A="undefined"!=typeof process&&(process.env.REACT_APP_SC_ATTR||process.env.SC_ATTR)||"data-styled",I="undefined"!=typeof window$1&&"HTMLElement"in window$1,P=Boolean("boolean"==typeof SC_DISABLE_SPEEDY?SC_DISABLE_SPEEDY:"undefined"!=typeof process&&void 0!==process.env.REACT_APP_SC_DISABLE_SPEEDY&&""!==process.env.REACT_APP_SC_DISABLE_SPEEDY?"false"!==process.env.REACT_APP_SC_DISABLE_SPEEDY&&process.env.REACT_APP_SC_DISABLE_SPEEDY:"undefined"!=typeof process&&void 0!==process.env.SC_DISABLE_SPEEDY&&""!==process.env.SC_DISABLE_SPEEDY?"false"!==process.env.SC_DISABLE_SPEEDY&&process.env.SC_DISABLE_SPEEDY:"production"!==process.env.NODE_ENV),R="production"!==process.env.NODE_ENV?{1:"Cannot create styled-component for component: %s.\n\n",2:"Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n",3:"Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n",4:"The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n",5:"The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n",6:"Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n",7:'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n',8:'ThemeProvider: Please make your "theme" prop an object.\n\n',9:"Missing document `<head>`\n\n",10:"Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n",11:"_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n",12:"It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n",13:"%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n",14:'ThemeProvider: "theme" prop is required.\n\n',15:"A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n",16:"Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n",17:"CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n"}:{};function D(){for(var e=arguments.length<=0?void 0:arguments[0],t=[],n=1,r=arguments.length;n<r;n+=1)t.push(n<0||arguments.length<=n?void 0:arguments[n]);return t.forEach((function(t){e=e.replace(/%[a-z]/,t);})),e}function j(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];throw "production"===process.env.NODE_ENV?new Error("An error occurred. See https://git.io/JUIaE#"+e+" for more information."+(n.length>0?" Args: "+n.join(", "):"")):new Error(D.apply(void 0,[R[e]].concat(n)).trim())}var T=function(){function e(e){this.groupSizes=new Uint32Array(512),this.length=512,this.tag=e;}var t=e.prototype;return t.indexOfGroup=function(e){for(var t=0,n=0;n<e;n++)t+=this.groupSizes[n];return t},t.insertRules=function(e,t){if(e>=this.groupSizes.length){for(var n=this.groupSizes,r=n.length,o=r;e>=o;)(o<<=1)<0&&j(16,""+e);this.groupSizes=new Uint32Array(o),this.groupSizes.set(n),this.length=o;for(var s=r;s<o;s++)this.groupSizes[s]=0;}for(var i=this.indexOfGroup(e+1),a=0,c=t.length;a<c;a++)this.tag.insertRule(i,t[a])&&(this.groupSizes[e]++,i++);},t.clearGroup=function(e){if(e<this.length){var t=this.groupSizes[e],n=this.indexOfGroup(e),r=n+t;this.groupSizes[e]=0;for(var o=n;o<r;o++)this.tag.deleteRule(n);}},t.getGroup=function(e){var t="";if(e>=this.length||0===this.groupSizes[e])return t;for(var n=this.groupSizes[e],r=this.indexOfGroup(e),o=r+n,s=r;s<o;s++)t+=this.tag.getRule(s)+"/*!sc*/\n";return t},e}(),x=new Map,k=new Map,V=1,B=function(e){if(x.has(e))return x.get(e);for(;k.has(V);)V++;var t=V++;return "production"!==process.env.NODE_ENV&&((0|t)<0||t>1<<30)&&j(16,""+t),x.set(e,t),k.set(t,e),t},z=function(e){return k.get(e)},M=function(e,t){t>=V&&(V=t+1),x.set(e,t),k.set(t,e);},G="style["+A+'][data-styled-version="5.3.5"]',L=new RegExp("^"+A+'\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'),F=function(e,t,n){for(var r,o=n.split(","),s=0,i=o.length;s<i;s++)(r=o[s])&&e.registerName(t,r);},Y=function(e,t){for(var n=(t.textContent||"").split("/*!sc*/\n"),r=[],o=0,s=n.length;o<s;o++){var i=n[o].trim();if(i){var a=i.match(L);if(a){var c=0|parseInt(a[1],10),u=a[2];0!==c&&(M(u,c),F(e,u,a[3]),e.getTag().insertRules(c,r)),r.length=0;}else r.push(i);}}},q=function(){return "undefined"!=typeof window$1&&void 0!==window$1.__webpack_nonce__?window$1.__webpack_nonce__:null},H=function(e){var t=document.head,n=e||t,r=document.createElement("style"),o=function(e){for(var t=e.childNodes,n=t.length;n>=0;n--){var r=t[n];if(r&&1===r.nodeType&&r.hasAttribute(A))return r}}(n),s=void 0!==o?o.nextSibling:null;r.setAttribute(A,"active"),r.setAttribute("data-styled-version","5.3.5");var i=q();return i&&r.setAttribute("nonce",i),n.insertBefore(r,s),r},$=function(){function e(e){var t=this.element=H(e);t.appendChild(document.createTextNode("")),this.sheet=function(e){if(e.sheet)return e.sheet;for(var t=document.styleSheets,n=0,r=t.length;n<r;n++){var o=t[n];if(o.ownerNode===e)return o}j(17);}(t),this.length=0;}var t=e.prototype;return t.insertRule=function(e,t){try{return this.sheet.insertRule(t,e),this.length++,!0}catch(e){return !1}},t.deleteRule=function(e){this.sheet.deleteRule(e),this.length--;},t.getRule=function(e){var t=this.sheet.cssRules[e];return void 0!==t&&"string"==typeof t.cssText?t.cssText:""},e}(),W=function(){function e(e){var t=this.element=H(e);this.nodes=t.childNodes,this.length=0;}var t=e.prototype;return t.insertRule=function(e,t){if(e<=this.length&&e>=0){var n=document.createTextNode(t),r=this.nodes[e];return this.element.insertBefore(n,r||null),this.length++,!0}return !1},t.deleteRule=function(e){this.element.removeChild(this.nodes[e]),this.length--;},t.getRule=function(e){return e<this.length?this.nodes[e].textContent:""},e}(),U=function(){function e(e){this.rules=[],this.length=0;}var t=e.prototype;return t.insertRule=function(e,t){return e<=this.length&&(this.rules.splice(e,0,t),this.length++,!0)},t.deleteRule=function(e){this.rules.splice(e,1),this.length--;},t.getRule=function(e){return e<this.length?this.rules[e]:""},e}(),J=I,X={isServer:!I,useCSSOMInjection:!P},Z=function(){function e(e,t,n){void 0===e&&(e=E),void 0===t&&(t={}),this.options=v({},X,{},e),this.gs=t,this.names=new Map(n),this.server=!!e.isServer,!this.server&&I&&J&&(J=!1,function(e){for(var t=document.querySelectorAll(G),n=0,r=t.length;n<r;n++){var o=t[n];o&&"active"!==o.getAttribute(A)&&(Y(e,o),o.parentNode&&o.parentNode.removeChild(o));}}(this));}e.registerId=function(e){return B(e)};var t=e.prototype;return t.reconstructWithOptions=function(t,n){return void 0===n&&(n=!0),new e(v({},this.options,{},t),this.gs,n&&this.names||void 0)},t.allocateGSInstance=function(e){return this.gs[e]=(this.gs[e]||0)+1},t.getTag=function(){return this.tag||(this.tag=(n=(t=this.options).isServer,r=t.useCSSOMInjection,o=t.target,e=n?new U(o):r?new $(o):new W(o),new T(e)));var e,t,n,r,o;},t.hasNameForId=function(e,t){return this.names.has(e)&&this.names.get(e).has(t)},t.registerName=function(e,t){if(B(e),this.names.has(e))this.names.get(e).add(t);else {var n=new Set;n.add(t),this.names.set(e,n);}},t.insertRules=function(e,t,n){this.registerName(e,t),this.getTag().insertRules(B(e),n);},t.clearNames=function(e){this.names.has(e)&&this.names.get(e).clear();},t.clearRules=function(e){this.getTag().clearGroup(B(e)),this.clearNames(e);},t.clearTag=function(){this.tag=void 0;},t.toString=function(){return function(e){for(var t=e.getTag(),n=t.length,r="",o=0;o<n;o++){var s=z(o);if(void 0!==s){var i=e.names.get(s),a=t.getGroup(o);if(i&&a&&i.size){var c=A+".g"+o+'[id="'+s+'"]',u="";void 0!==i&&i.forEach((function(e){e.length>0&&(u+=e+",");})),r+=""+a+c+'{content:"'+u+'"}/*!sc*/\n';}}}return r}(this)},e}(),K=/(a)(d)/gi,Q=function(e){return String.fromCharCode(e+(e>25?39:97))};function ee(e){var t,n="";for(t=Math.abs(e);t>52;t=t/52|0)n=Q(t%52)+n;return (Q(t%52)+n).replace(K,"$1-$2")}var te=function(e,t){for(var n=t.length;n;)e=33*e^t.charCodeAt(--n);return e},ne=function(e){return te(5381,e)};function re(e){for(var t=0;t<e.length;t+=1){var n=e[t];if(b(n)&&!N(n))return !1}return !0}var oe=ne("5.3.5"),se=function(){function e(e,t,n){this.rules=e,this.staticRulesId="",this.isStatic="production"===process.env.NODE_ENV&&(void 0===n||n.isStatic)&&re(e),this.componentId=t,this.baseHash=te(oe,t),this.baseStyle=n,Z.registerId(t);}return e.prototype.generateAndInjectStyles=function(e,t,n){var r=this.componentId,o=[];if(this.baseStyle&&o.push(this.baseStyle.generateAndInjectStyles(e,t,n)),this.isStatic&&!n.hash)if(this.staticRulesId&&t.hasNameForId(r,this.staticRulesId))o.push(this.staticRulesId);else {var s=Ne(this.rules,e,t,n).join(""),i=ee(te(this.baseHash,s)>>>0);if(!t.hasNameForId(r,i)){var a=n(s,"."+i,void 0,r);t.insertRules(r,i,a);}o.push(i),this.staticRulesId=i;}else {for(var c=this.rules.length,u=te(this.baseHash,n.hash),l="",d=0;d<c;d++){var h=this.rules[d];if("string"==typeof h)l+=h,"production"!==process.env.NODE_ENV&&(u=te(u,h+d));else if(h){var p=Ne(h,e,t,n),f=Array.isArray(p)?p.join(""):p;u=te(u,f+d),l+=f;}}if(l){var m=ee(u>>>0);if(!t.hasNameForId(r,m)){var y=n(l,"."+m,void 0,r);t.insertRules(r,m,y);}o.push(m);}}return o.join(" ")},e}(),ie$2=/^\s*\/\/.*$/gm,ae=[":","[",".","#"];function ce(e){var t,n,r,o,s=void 0===e?E:e,i=s.options,a=void 0===i?E:i,c=s.plugins,u=void 0===c?w:c,l=new stylis_min(a),d=[],h=function(e){function t(t){if(t)try{e(t+"}");}catch(e){}}return function(n,r,o,s,i,a,c,u,l,d){switch(n){case 1:if(0===l&&64===r.charCodeAt(0))return e(r+";"),"";break;case 2:if(0===u)return r+"/*|*/";break;case 3:switch(u){case 102:case 112:return e(o[0]+r),"";default:return r+(0===d?"/*|*/":"")}case-2:r.split("/*|*/}").forEach(t);}}}((function(e){d.push(e);})),f=function(e,r,s){return 0===r&&-1!==ae.indexOf(s[n.length])||s.match(o)?e:"."+t};function m(e,s,i,a){void 0===a&&(a="&");var c=e.replace(ie$2,""),u=s&&i?i+" "+s+" { "+c+" }":c;return t=a,n=s,r=new RegExp("\\"+n+"\\b","g"),o=new RegExp("(\\"+n+"\\b){2,}"),l(i||!s?"":s,u)}return l.use([].concat(u,[function(e,t,o){2===e&&o.length&&o[0].lastIndexOf(n)>0&&(o[0]=o[0].replace(r,f));},h,function(e){if(-2===e){var t=d;return d=[],t}}])),m.hash=u.length?u.reduce((function(e,t){return t.name||j(15),te(e,t.name)}),5381).toString():"",m}var ue=React__default.createContext();ue.Consumer;var de=React__default.createContext(),he=(de.Consumer,new Z),pe=ce();function fe(){return useContext(ue)||he}function me(){return useContext(de)||pe}var ve=function(){function e(e,t){var n=this;this.inject=function(e,t){void 0===t&&(t=pe);var r=n.name+t.hash;e.hasNameForId(n.id,r)||e.insertRules(n.id,r,t(n.rules,r,"@keyframes"));},this.toString=function(){return j(12,String(n.name))},this.name=e,this.id="sc-keyframes-"+e,this.rules=t;}return e.prototype.getName=function(e){return void 0===e&&(e=pe),this.name+e.hash},e}(),ge=/([A-Z])/,Se=/([A-Z])/g,we=/^ms-/,Ee=function(e){return "-"+e.toLowerCase()};function be(e){return ge.test(e)?e.replace(Se,Ee).replace(we,"-ms-"):e}var _e=function(e){return null==e||!1===e||""===e};function Ne(e,n,r,o){if(Array.isArray(e)){for(var s,i=[],a=0,c=e.length;a<c;a+=1)""!==(s=Ne(e[a],n,r,o))&&(Array.isArray(s)?i.push.apply(i,s):i.push(s));return i}if(_e(e))return "";if(N(e))return "."+e.styledComponentId;if(b(e)){if("function"!=typeof(l=e)||l.prototype&&l.prototype.isReactComponent||!n)return e;var u=e(n);return "production"!==process.env.NODE_ENV&&reactIs$1.exports.isElement(u)&&console.warn(_(e)+" is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."),Ne(u,n,r,o)}var l;return e instanceof ve?r?(e.inject(r,o),e.getName(o)):e:S(e)?function e(t,n){var r,o,s=[];for(var i in t)t.hasOwnProperty(i)&&!_e(t[i])&&(Array.isArray(t[i])&&t[i].isCss||b(t[i])?s.push(be(i)+":",t[i],";"):S(t[i])?s.push.apply(s,e(t[i],i)):s.push(be(i)+": "+(r=i,null==(o=t[i])||"boolean"==typeof o||""===o?"":"number"!=typeof o||0===o||r in unitlessKeys?String(o).trim():o+"px")+";"));return n?[n+" {"].concat(s,["}"]):s}(e):e.toString()}var Ae=function(e){return Array.isArray(e)&&(e.isCss=!0),e};function Ce(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return b(e)||S(e)?Ae(Ne(g(w,[e].concat(n)))):0===n.length&&1===e.length&&"string"==typeof e[0]?e:Ae(Ne(g(e,n)))}var Ie=/invalid hook call/i,Pe=new Set,Oe=function(e,t){if("production"!==process.env.NODE_ENV){var n="The component "+e+(t?' with the id of "'+t+'"':"")+" has been created dynamically.\nYou may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.",r=console.error;try{var o=!0;console.error=function(e){if(Ie.test(e))o=!1,Pe.delete(n);else {for(var t=arguments.length,s=new Array(t>1?t-1:0),i=1;i<t;i++)s[i-1]=arguments[i];r.apply(void 0,[e].concat(s));}},useRef(),o&&!Pe.has(n)&&(console.warn(n),Pe.add(n));}catch(e){Ie.test(e.message)&&Pe.delete(n);}finally{console.error=r;}}},Re=function(e,t,n){return void 0===n&&(n=E),e.theme!==n.theme&&e.theme||t||n.theme},De=/[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,je=/(^-|-$)/g;function Te(e){return e.replace(De,"-").replace(je,"")}var xe=function(e){return ee(ne(e)>>>0)};function ke(e){return "string"==typeof e&&("production"===process.env.NODE_ENV||e.charAt(0)===e.charAt(0).toLowerCase())}var Ve=function(e){return "function"==typeof e||"object"==typeof e&&null!==e&&!Array.isArray(e)},Be=function(e){return "__proto__"!==e&&"constructor"!==e&&"prototype"!==e};function ze(e,t,n){var r=e[n];Ve(t)&&Ve(r)?Me(r,t):e[n]=t;}function Me(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];for(var o=0,s=n;o<s.length;o++){var i=s[o];if(Ve(i))for(var a in i)Be(a)&&ze(e,i[a],a);}return e}var Ge=React__default.createContext();Ge.Consumer;var Ye={};function qe(e,t,n){var o=N(e),i=!ke(e),a=t.attrs,c=void 0===a?w:a,d=t.componentId,h=void 0===d?function(e,t){var n="string"!=typeof e?"sc":Te(e);Ye[n]=(Ye[n]||0)+1;var r=n+"-"+xe("5.3.5"+n+Ye[n]);return t?t+"-"+r:r}(t.displayName,t.parentComponentId):d,p=t.displayName,f=void 0===p?function(e){return ke(e)?"styled."+e:"Styled("+_(e)+")"}(e):p,g=t.displayName&&t.componentId?Te(t.displayName)+"-"+t.componentId:t.componentId||h,S=o&&e.attrs?Array.prototype.concat(e.attrs,c).filter(Boolean):c,A=t.shouldForwardProp;o&&e.shouldForwardProp&&(A=t.shouldForwardProp?function(n,r,o){return e.shouldForwardProp(n,r,o)&&t.shouldForwardProp(n,r,o)}:e.shouldForwardProp);var C,I=new se(n,g,o?e.componentStyle:void 0),P=I.isStatic&&0===c.length,O=function(e,t){return function(e,t,n,r){var o=e.attrs,i=e.componentStyle,a=e.defaultProps,c=e.foldedComponentIds,d=e.shouldForwardProp,h=e.styledComponentId,p=e.target;"production"!==process.env.NODE_ENV&&useDebugValue(h);var f=function(e,t,n){void 0===e&&(e=E);var r=v({},t,{theme:e}),o={};return n.forEach((function(e){var t,n,s,i=e;for(t in b(i)&&(i=i(r)),i)r[t]=o[t]="className"===t?(n=o[t],s=i[t],n&&s?n+" "+s:n||s):i[t];})),[r,o]}(Re(t,useContext(Ge),a)||E,t,o),y=f[0],g=f[1],S=function(e,t,n,r){var o=fe(),s=me(),i=t?e.generateAndInjectStyles(E,o,s):e.generateAndInjectStyles(n,o,s);return "production"!==process.env.NODE_ENV&&useDebugValue(i),"production"!==process.env.NODE_ENV&&!t&&r&&r(i),i}(i,r,y,"production"!==process.env.NODE_ENV?e.warnTooManyClasses:void 0),w=n,_=g.$as||t.$as||g.as||t.as||p,N=ke(_),A=g!==t?v({},t,{},g):t,C={};for(var I in A)"$"!==I[0]&&"as"!==I&&("forwardedAs"===I?C.as=A[I]:(d?d(I,isPropValid,_):!N||isPropValid(I))&&(C[I]=A[I]));return t.style&&g.style!==t.style&&(C.style=v({},t.style,{},g.style)),C.className=Array.prototype.concat(c,h,S!==h?S:null,t.className,g.className).filter(Boolean).join(" "),C.ref=w,createElement$1(_,C)}(C,e,t,P)};return O.displayName=f,(C=React__default.forwardRef(O)).attrs=S,C.componentStyle=I,C.displayName=f,C.shouldForwardProp=A,C.foldedComponentIds=o?Array.prototype.concat(e.foldedComponentIds,e.styledComponentId):w,C.styledComponentId=g,C.target=o?e.target:e,C.withComponent=function(e){var r=t.componentId,o=function(e,t){if(null==e)return {};var n,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(t,["componentId"]),s=r&&r+"-"+(ke(e)?e:Te(_(e)));return qe(e,v({},o,{attrs:S,componentId:s}),n)},Object.defineProperty(C,"defaultProps",{get:function(){return this._foldedDefaultProps},set:function(t){this._foldedDefaultProps=o?Me({},e.defaultProps,t):t;}}),"production"!==process.env.NODE_ENV&&(Oe(f,g),C.warnTooManyClasses=function(e,t){var n={},r=!1;return function(o){if(!r&&(n[o]=!0,Object.keys(n).length>=200)){var s=t?' with the id of "'+t+'"':"";console.warn("Over 200 classes were generated for component "+e+s+".\nConsider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"),r=!0,n={};}}}(f,g)),C.toString=function(){return "."+C.styledComponentId},i&&hoistNonReactStatics_cjs(C,e,{attrs:!0,componentStyle:!0,displayName:!0,foldedComponentIds:!0,shouldForwardProp:!0,styledComponentId:!0,target:!0,withComponent:!0}),C}var He=function(e){return function e(t,r,o){if(void 0===o&&(o=E),!reactIs$1.exports.isValidElementType(r))return j(1,String(r));var s=function(){return t(r,o,Ce.apply(void 0,arguments))};return s.withConfig=function(n){return e(t,r,v({},o,{},n))},s.attrs=function(n){return e(t,r,v({},o,{attrs:Array.prototype.concat(o.attrs,n).filter(Boolean)}))},s}(qe,e)};["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","marquee","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","marker","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","textPath","tspan"].forEach((function(e){He[e]=He(e);}));"production"!==process.env.NODE_ENV&&"undefined"!=typeof navigator&&"ReactNative"===navigator.product&&console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native"),"production"!==process.env.NODE_ENV&&"test"!==process.env.NODE_ENV&&"undefined"!=typeof window$1&&(window$1["__styled-components-init__"]=window$1["__styled-components-init__"]||0,1===window$1["__styled-components-init__"]&&console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."),window$1["__styled-components-init__"]+=1);var styled = He;

var NotificationContainer = styled.div(templateObject_1$N || (templateObject_1$N = __makeTemplateObject(["\n  width: 25px;\n  height: 25px;\n  cursor: pointer;\n  margin-right: 23px;\n  display: flex;\n  justify-content: center;\n  position: relative;\n  margin-right: 190px;\n\n  > button {\n    outline: none;\n    background-color: transparent;\n    border: none;\n    width: 25px;\n    height: 25px;\n    cursor: pointer;\n    img {\n      width: 20px;\n      height: auto;\n      margin: 0 30px 0 0 !important;\n      display: block;\n      font-size: 40px;\n      margin: 50px auto 0;\n      color: #9e9e9e;\n      -webkit-animation: ", ";\n      -webkit-transform-origin: 50% 4px;\n      -moz-animation: ", ";\n      -moz-transform-origin: 50% 4px;\n      animation: ", ";\n      transform-origin: 50% 4px;\n    }\n\n    @-webkit-keyframes ring {\n      0% {\n        -webkit-transform: rotateZ(0);\n      }\n      1% {\n        -webkit-transform: rotateZ(30deg);\n      }\n      3% {\n        -webkit-transform: rotateZ(-28deg);\n      }\n      5% {\n        -webkit-transform: rotateZ(34deg);\n      }\n      7% {\n        -webkit-transform: rotateZ(-32deg);\n      }\n      9% {\n        -webkit-transform: rotateZ(30deg);\n      }\n      11% {\n        -webkit-transform: rotateZ(-28deg);\n      }\n      13% {\n        -webkit-transform: rotateZ(26deg);\n      }\n      15% {\n        -webkit-transform: rotateZ(-24deg);\n      }\n      17% {\n        -webkit-transform: rotateZ(22deg);\n      }\n      19% {\n        -webkit-transform: rotateZ(-20deg);\n      }\n      21% {\n        -webkit-transform: rotateZ(18deg);\n      }\n      23% {\n        -webkit-transform: rotateZ(-16deg);\n      }\n      25% {\n        -webkit-transform: rotateZ(14deg);\n      }\n      27% {\n        -webkit-transform: rotateZ(-12deg);\n      }\n      29% {\n        -webkit-transform: rotateZ(10deg);\n      }\n      31% {\n        -webkit-transform: rotateZ(-8deg);\n      }\n      33% {\n        -webkit-transform: rotateZ(6deg);\n      }\n      35% {\n        -webkit-transform: rotateZ(-4deg);\n      }\n      37% {\n        -webkit-transform: rotateZ(2deg);\n      }\n      39% {\n        -webkit-transform: rotateZ(-1deg);\n      }\n      41% {\n        -webkit-transform: rotateZ(1deg);\n      }\n\n      43% {\n        -webkit-transform: rotateZ(0);\n      }\n      100% {\n        -webkit-transform: rotateZ(0);\n      }\n    }\n\n    @-moz-keyframes ring {\n      0% {\n        -moz-transform: rotate(0);\n      }\n      1% {\n        -moz-transform: rotate(30deg);\n      }\n      3% {\n        -moz-transform: rotate(-28deg);\n      }\n      5% {\n        -moz-transform: rotate(34deg);\n      }\n      7% {\n        -moz-transform: rotate(-32deg);\n      }\n      9% {\n        -moz-transform: rotate(30deg);\n      }\n      11% {\n        -moz-transform: rotate(-28deg);\n      }\n      13% {\n        -moz-transform: rotate(26deg);\n      }\n      15% {\n        -moz-transform: rotate(-24deg);\n      }\n      17% {\n        -moz-transform: rotate(22deg);\n      }\n      19% {\n        -moz-transform: rotate(-20deg);\n      }\n      21% {\n        -moz-transform: rotate(18deg);\n      }\n      23% {\n        -moz-transform: rotate(-16deg);\n      }\n      25% {\n        -moz-transform: rotate(14deg);\n      }\n      27% {\n        -moz-transform: rotate(-12deg);\n      }\n      29% {\n        -moz-transform: rotate(10deg);\n      }\n      31% {\n        -moz-transform: rotate(-8deg);\n      }\n      33% {\n        -moz-transform: rotate(6deg);\n      }\n      35% {\n        -moz-transform: rotate(-4deg);\n      }\n      37% {\n        -moz-transform: rotate(2deg);\n      }\n      39% {\n        -moz-transform: rotate(-1deg);\n      }\n      41% {\n        -moz-transform: rotate(1deg);\n      }\n\n      43% {\n        -moz-transform: rotate(0);\n      }\n      100% {\n        -moz-transform: rotate(0);\n      }\n    }\n\n    @keyframes ring {\n      0% {\n        transform: rotate(0);\n      }\n      1% {\n        transform: rotate(30deg);\n      }\n      3% {\n        transform: rotate(-28deg);\n      }\n      5% {\n        transform: rotate(34deg);\n      }\n      7% {\n        transform: rotate(-32deg);\n      }\n      9% {\n        transform: rotate(30deg);\n      }\n      11% {\n        transform: rotate(-28deg);\n      }\n      13% {\n        transform: rotate(26deg);\n      }\n      15% {\n        transform: rotate(-24deg);\n      }\n      17% {\n        transform: rotate(22deg);\n      }\n      19% {\n        transform: rotate(-20deg);\n      }\n      21% {\n        transform: rotate(18deg);\n      }\n      23% {\n        transform: rotate(-16deg);\n      }\n      25% {\n        transform: rotate(14deg);\n      }\n      27% {\n        transform: rotate(-12deg);\n      }\n      29% {\n        transform: rotate(10deg);\n      }\n      31% {\n        transform: rotate(-8deg);\n      }\n      33% {\n        transform: rotate(6deg);\n      }\n      35% {\n        transform: rotate(-4deg);\n      }\n      37% {\n        transform: rotate(2deg);\n      }\n      39% {\n        transform: rotate(-1deg);\n      }\n      41% {\n        transform: rotate(1deg);\n      }\n\n      43% {\n        transform: rotate(0);\n      }\n      100% {\n        transform: rotate(0);\n      }\n    }\n  }\n"], ["\n  width: 25px;\n  height: 25px;\n  cursor: pointer;\n  margin-right: 23px;\n  display: flex;\n  justify-content: center;\n  position: relative;\n  margin-right: 190px;\n\n  > button {\n    outline: none;\n    background-color: transparent;\n    border: none;\n    width: 25px;\n    height: 25px;\n    cursor: pointer;\n    img {\n      width: 20px;\n      height: auto;\n      margin: 0 30px 0 0 !important;\n      display: block;\n      font-size: 40px;\n      margin: 50px auto 0;\n      color: #9e9e9e;\n      -webkit-animation: ", ";\n      -webkit-transform-origin: 50% 4px;\n      -moz-animation: ", ";\n      -moz-transform-origin: 50% 4px;\n      animation: ", ";\n      transform-origin: 50% 4px;\n    }\n\n    @-webkit-keyframes ring {\n      0% {\n        -webkit-transform: rotateZ(0);\n      }\n      1% {\n        -webkit-transform: rotateZ(30deg);\n      }\n      3% {\n        -webkit-transform: rotateZ(-28deg);\n      }\n      5% {\n        -webkit-transform: rotateZ(34deg);\n      }\n      7% {\n        -webkit-transform: rotateZ(-32deg);\n      }\n      9% {\n        -webkit-transform: rotateZ(30deg);\n      }\n      11% {\n        -webkit-transform: rotateZ(-28deg);\n      }\n      13% {\n        -webkit-transform: rotateZ(26deg);\n      }\n      15% {\n        -webkit-transform: rotateZ(-24deg);\n      }\n      17% {\n        -webkit-transform: rotateZ(22deg);\n      }\n      19% {\n        -webkit-transform: rotateZ(-20deg);\n      }\n      21% {\n        -webkit-transform: rotateZ(18deg);\n      }\n      23% {\n        -webkit-transform: rotateZ(-16deg);\n      }\n      25% {\n        -webkit-transform: rotateZ(14deg);\n      }\n      27% {\n        -webkit-transform: rotateZ(-12deg);\n      }\n      29% {\n        -webkit-transform: rotateZ(10deg);\n      }\n      31% {\n        -webkit-transform: rotateZ(-8deg);\n      }\n      33% {\n        -webkit-transform: rotateZ(6deg);\n      }\n      35% {\n        -webkit-transform: rotateZ(-4deg);\n      }\n      37% {\n        -webkit-transform: rotateZ(2deg);\n      }\n      39% {\n        -webkit-transform: rotateZ(-1deg);\n      }\n      41% {\n        -webkit-transform: rotateZ(1deg);\n      }\n\n      43% {\n        -webkit-transform: rotateZ(0);\n      }\n      100% {\n        -webkit-transform: rotateZ(0);\n      }\n    }\n\n    @-moz-keyframes ring {\n      0% {\n        -moz-transform: rotate(0);\n      }\n      1% {\n        -moz-transform: rotate(30deg);\n      }\n      3% {\n        -moz-transform: rotate(-28deg);\n      }\n      5% {\n        -moz-transform: rotate(34deg);\n      }\n      7% {\n        -moz-transform: rotate(-32deg);\n      }\n      9% {\n        -moz-transform: rotate(30deg);\n      }\n      11% {\n        -moz-transform: rotate(-28deg);\n      }\n      13% {\n        -moz-transform: rotate(26deg);\n      }\n      15% {\n        -moz-transform: rotate(-24deg);\n      }\n      17% {\n        -moz-transform: rotate(22deg);\n      }\n      19% {\n        -moz-transform: rotate(-20deg);\n      }\n      21% {\n        -moz-transform: rotate(18deg);\n      }\n      23% {\n        -moz-transform: rotate(-16deg);\n      }\n      25% {\n        -moz-transform: rotate(14deg);\n      }\n      27% {\n        -moz-transform: rotate(-12deg);\n      }\n      29% {\n        -moz-transform: rotate(10deg);\n      }\n      31% {\n        -moz-transform: rotate(-8deg);\n      }\n      33% {\n        -moz-transform: rotate(6deg);\n      }\n      35% {\n        -moz-transform: rotate(-4deg);\n      }\n      37% {\n        -moz-transform: rotate(2deg);\n      }\n      39% {\n        -moz-transform: rotate(-1deg);\n      }\n      41% {\n        -moz-transform: rotate(1deg);\n      }\n\n      43% {\n        -moz-transform: rotate(0);\n      }\n      100% {\n        -moz-transform: rotate(0);\n      }\n    }\n\n    @keyframes ring {\n      0% {\n        transform: rotate(0);\n      }\n      1% {\n        transform: rotate(30deg);\n      }\n      3% {\n        transform: rotate(-28deg);\n      }\n      5% {\n        transform: rotate(34deg);\n      }\n      7% {\n        transform: rotate(-32deg);\n      }\n      9% {\n        transform: rotate(30deg);\n      }\n      11% {\n        transform: rotate(-28deg);\n      }\n      13% {\n        transform: rotate(26deg);\n      }\n      15% {\n        transform: rotate(-24deg);\n      }\n      17% {\n        transform: rotate(22deg);\n      }\n      19% {\n        transform: rotate(-20deg);\n      }\n      21% {\n        transform: rotate(18deg);\n      }\n      23% {\n        transform: rotate(-16deg);\n      }\n      25% {\n        transform: rotate(14deg);\n      }\n      27% {\n        transform: rotate(-12deg);\n      }\n      29% {\n        transform: rotate(10deg);\n      }\n      31% {\n        transform: rotate(-8deg);\n      }\n      33% {\n        transform: rotate(6deg);\n      }\n      35% {\n        transform: rotate(-4deg);\n      }\n      37% {\n        transform: rotate(2deg);\n      }\n      39% {\n        transform: rotate(-1deg);\n      }\n      41% {\n        transform: rotate(1deg);\n      }\n\n      43% {\n        transform: rotate(0);\n      }\n      100% {\n        transform: rotate(0);\n      }\n    }\n  }\n"])), function (props) {
    return props.newNotification === true
        ? "ring 4s 0.7s ease-in-out infinite"
        : "none";
}, function (props) {
    return props.newNotification === true
        ? "ring 4s 0.7s ease-in-out infinite"
        : "none";
}, function (props) {
    return props.newNotification === true
        ? "ring 4s 0.7s ease-in-out infinite"
        : "none";
});
var Count = styled.div(templateObject_2$B || (templateObject_2$B = __makeTemplateObject(["\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  background-color: ", ";\n  position: absolute;\n  right: -10px;\n  top: -10px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n\n  span {\n    font-size: 14px;\n    font-weight: 600;\n    color: white;\n    padding: 2px;\n  }\n"], ["\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  background-color: ", ";\n  position: absolute;\n  right: -10px;\n  top: -10px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n\n  span {\n    font-size: 14px;\n    font-weight: 600;\n    color: white;\n    padding: 2px;\n  }\n"])), function (_a) {
    var color = _a.color;
    return color || "#fe6a6a";
});
var NotificationModal = styled.div(templateObject_3$t || (templateObject_3$t = __makeTemplateObject(["\n  width: auto;\n  height: auto;\n  min-width: 200px;\n  padding: 30px;\n  z-index: 11;\n  position: absolute;\n  background-color: transparent;\n  right: 0;\n  display: flex;\n  flex-direction: column;\n  display: ", ";\n"], ["\n  width: auto;\n  height: auto;\n  min-width: 200px;\n  padding: 30px;\n  z-index: 11;\n  position: absolute;\n  background-color: transparent;\n  right: 0;\n  display: flex;\n  flex-direction: column;\n  display: ", ";\n"])), function (props) { return (props.open === true ? "flex" : "none"); });
var ModalConainer = styled.div(templateObject_4$k || (templateObject_4$k = __makeTemplateObject(["\n  width: 100;\n  // max-height: 350px;\n  height: auto;\n  padding: 30px;\n  z-index: 11;\n  position: absolute;\n  background-color: #fff;\n  filter: drop-shadow(10px 10px 10px rgba(0, 0, 0, 0.25));\n  border-radius: 5px;\n  right: -75px;\n  top: 40px;\n  opacity: 1;\n  flex-direction: column;\n  animation: Notf 0.8s forwards;\n\n  @keyframes Notf {\n    0% {\n      transform: translateX(3000px);\n    }\n    60% {\n      transform: translateX(-25px);\n    }\n    75% {\n      transform: translateX(10px);\n    }\n    90% {\n      transform: translateX(-5px);\n    }\n  }\n"], ["\n  width: 100;\n  // max-height: 350px;\n  height: auto;\n  padding: 30px;\n  z-index: 11;\n  position: absolute;\n  background-color: #fff;\n  filter: drop-shadow(10px 10px 10px rgba(0, 0, 0, 0.25));\n  border-radius: 5px;\n  right: -75px;\n  top: 40px;\n  opacity: 1;\n  flex-direction: column;\n  animation: Notf 0.8s forwards;\n\n  @keyframes Notf {\n    0% {\n      transform: translateX(3000px);\n    }\n    60% {\n      transform: translateX(-25px);\n    }\n    75% {\n      transform: translateX(10px);\n    }\n    90% {\n      transform: translateX(-5px);\n    }\n  }\n"])));
var MessageSection = styled.div(templateObject_5$g || (templateObject_5$g = __makeTemplateObject(["\n  width: auto;\n  height: auto;\n  max-height: 30vh;\n  overflow-y: auto;\n  /* &::-webkit-scrollbar {\n    display: none;\n  } */\n"], ["\n  width: auto;\n  height: auto;\n  max-height: 30vh;\n  overflow-y: auto;\n  /* &::-webkit-scrollbar {\n    display: none;\n  } */\n"])));
styled.div(templateObject_6$c || (templateObject_6$c = __makeTemplateObject(["\n  display: flex;\n  justify-content: center;\n  width: 100%;\n  padding: 10px;\n\n  button {\n    outline: none;\n    background-color: transparent !important;\n    width: auto !important;\n    cursor: pointer;\n    margin-top: 15px;\n    color: ", ";\n    height: auto !important;\n    display: flex !important;\n    justify-content: center;\n    align-items: center;\n    &:hover {\n      filter: none;\n    }\n  }\n"], ["\n  display: flex;\n  justify-content: center;\n  width: 100%;\n  padding: 10px;\n\n  button {\n    outline: none;\n    background-color: transparent !important;\n    width: auto !important;\n    cursor: pointer;\n    margin-top: 15px;\n    color: ", ";\n    height: auto !important;\n    display: flex !important;\n    justify-content: center;\n    align-items: center;\n    &:hover {\n      filter: none;\n    }\n  }\n"])), function (_a) {
    var color = _a.color;
    return color || "#fe6a6a";
});
var Triangle$1 = styled.div(templateObject_7$a || (templateObject_7$a = __makeTemplateObject(["\n  width: 0;\n  height: 0;\n  display: ", ";\n  border-left: 12px solid transparent;\n  border-right: 12px solid transparent;\n  margin: 0 -35px 0 0;\n  border-bottom: 10px solid #fff;\n  align-self: flex-end;\n  top: 60px;\n  animation: ShoppinModal 0.8s forwards;\n\n  @keyframes ShoppinModal {\n    0% {\n      transform: translateX(3000px);\n    }\n    60% {\n      transform: translateX(-25px);\n    }\n    75% {\n      transform: translateX(10px);\n    }\n    90% {\n      transform: translateX(-5px);\n    }\n  }\n"], ["\n  width: 0;\n  height: 0;\n  display: ", ";\n  border-left: 12px solid transparent;\n  border-right: 12px solid transparent;\n  margin: 0 -35px 0 0;\n  border-bottom: 10px solid #fff;\n  align-self: flex-end;\n  top: 60px;\n  animation: ShoppinModal 0.8s forwards;\n\n  @keyframes ShoppinModal {\n    0% {\n      transform: translateX(3000px);\n    }\n    60% {\n      transform: translateX(-25px);\n    }\n    75% {\n      transform: translateX(10px);\n    }\n    90% {\n      transform: translateX(-5px);\n    }\n  }\n"])), function (_a) {
    var open = _a.open;
    return (open ? "flex" : "none");
});
var templateObject_1$N, templateObject_2$B, templateObject_3$t, templateObject_4$k, templateObject_5$g, templateObject_6$c, templateObject_7$a;

var AtomNotification = function (props) {
    var notification = props.notification, count = props.count, color = props.color;
    var _a = __read(useState(false), 2), clase = _a[0], setClase = _a[1];
    var _b = __read(useState(false), 2), showNotification = _b[0], setShowNotification = _b[1];
    var wrapperRef = useRef(null);
    function useOutsideAlerter(ref) {
        useEffect(function () {
            function handleClickOutside(event) {
                if (ref.current && !ref.current.contains(event.target)) {
                    setClase(clase);
                }
            }
            // Bind the event listener
            document.addEventListener("mousedown", handleClickOutside);
            return function () {
                // Unbind the event listener on clean up
                document.removeEventListener("mousedow", handleClickOutside);
            };
        }, [ref]);
    }
    useEffect(function () {
        if (count >= 1) {
            setShowNotification(true);
        }
        else {
            setShowNotification(false);
        }
    });
    useOutsideAlerter(wrapperRef);
    return (jsx(Fragment$1, { children: jsxs(NotificationContainer, __assign({ newNotification: showNotification }, { children: [count >= 1 ? (jsx(Count, __assign({ color: color }, { children: jsx("span", { children: count }) }))) : (""), jsx("button", __assign({ type: "button", onClick: function () { return setClase(!clase); } }, { children: jsx("img", { src: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/icons/bell.svg", alt: "Notification icon" }) })), jsxs(NotificationModal, __assign({ open: clase, ref: wrapperRef }, { children: [jsx(Triangle$1, { open: clase }), jsx(ModalConainer, { children: count !== 0 ? (jsx(MessageSection, { children: notification })) : (jsx(Text$2, __assign({ width: "auto" }, { children: "No tienes notificaciones nuevas." }))) })] }))] })) }));
};

var AtomPagination = function (props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    var statePagination = props.statePagination, setStatePagination = props.setStatePagination, acentColor = props.acentColor, componentsProps = props.componentsProps;
    var _m = __read(useState((_a = (statePagination === null || statePagination === void 0 ? void 0 : statePagination.page) + 1) !== null && _a !== void 0 ? _a : 1), 2), pagination = _m[0], setPagination = _m[1];
    var pages = Math.ceil(statePagination.totaldocs / statePagination.limit) === 0
        ? 1
        : Math.ceil(statePagination.totaldocs / statePagination.limit);
    var _o = __read(useState(Array.from({ length: pages || 10 }, function (_, i) { return ({
        id: i + 1,
        label: i + 1,
    }); })), 2), quantyPages = _o[0], setQuantyPages = _o[1];
    useEffect(function () {
        setStatePagination(__assign(__assign({}, statePagination), { page: pagination - 1 }));
    }, [pagination]);
    useEffect(function () {
        setQuantyPages(Array.from({ length: pages || 10 }, function (_, i) { return ({
            id: i + 1,
            label: i + 1,
        }); }));
    }, [pages]);
    useEffect(function () {
        var _a;
        if (statePagination.page !== pagination - 1) {
            setPagination((_a = (statePagination === null || statePagination === void 0 ? void 0 : statePagination.page) + 1) !== null && _a !== void 0 ? _a : 1);
        }
    }, [statePagination]);
    var diff = Math.max(0, (quantyPages.length - pagination - 2) * -1);
    var start = Math.max(0, pagination - (3 + diff));
    var end = Math.min(start + 4, quantyPages.length - 1);
    return (jsx(Wrapper$2, __assign({ flexDirection: "row", width: "100%" }, { children: jsxs(Wrapper$2, __assign({ flexDirection: "row", width: "max-content", position: "relative" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.containerProps, { children: [jsx(AtomButton, __assign({ height: "50px", width: "50px", backgroundColor: "".concat(pagination > 1 ? acentColor || '#fe6a6a' : '#f2f2f2'), padding: "0", onClick: function () {
                        setPagination(pagination > 1 ? pagination - 1 : pagination);
                    } }, (_b = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.controlsProps) === null || _b === void 0 ? void 0 : _b.buttonsProps, { customCSS: css$1(templateObject_1$M || (templateObject_1$M = __makeTemplateObject(["\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            position: absolute;\n            left: -65px;\n            ", "\n          "], ["\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            position: absolute;\n            left: -65px;\n            ", "\n          "])), (_d = (_c = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.controlsProps) === null || _c === void 0 ? void 0 : _c.buttonsProps) === null || _d === void 0 ? void 0 : _d.customCSS) }, { children: jsx(Icon$1, __assign({ height: "15px", width: "15px", color: pagination > 1 ? 'white' : '#dcdcdc', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/images/left-arrow-return-svgrepo-com.svg" }, (_e = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.controlsProps) === null || _e === void 0 ? void 0 : _e.iconProps)) })), quantyPages
                    .filter(function (_, index) { return index >= start && index <= end; })
                    .map(function (item) {
                    var _a, _b, _c, _d;
                    return (jsx(AtomButton, __assign({ height: "50px", width: "50px", backgroundColor: pagination === item.id ? "".concat(acentColor || '#fe6a6a') : '#fff', margin: "0px 10px", padding: "0px", onClick: function () { return setPagination(item.id); } }, (_a = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.itemsProps) === null || _a === void 0 ? void 0 : _a.buttonsProps, { customCSS: css$1(templateObject_2$A || (templateObject_2$A = __makeTemplateObject(["\n                box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);\n                ", "\n              "], ["\n                box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);\n                ", "\n              "])), (_c = (_b = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.itemsProps) === null || _b === void 0 ? void 0 : _b.buttonsProps) === null || _c === void 0 ? void 0 : _c.customCSS) }, { children: jsx(Text$2, __assign({ cursor: "pointer", fontWeight: "bold", color: pagination === item.id ? '#fff' : "".concat(acentColor || '#fe6a6a') }, (_d = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.itemsProps) === null || _d === void 0 ? void 0 : _d.textProps, { children: item.label })) }), "Pagination".concat(item.id)));
                }), jsx(AtomButton, __assign({ height: "50px", width: "50px", backgroundColor: "".concat(pagination < (pages || quantyPages.length)
                        ? acentColor || '#fe6a6a'
                        : '#f2f2f2'), padding: "0", onClick: function () {
                        setPagination(pagination < (pages || quantyPages.length)
                            ? pagination + 1
                            : pagination);
                    } }, (_f = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.controlsProps) === null || _f === void 0 ? void 0 : _f.buttonsProps, { customCSS: css$1(templateObject_3$s || (templateObject_3$s = __makeTemplateObject(["\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            position: absolute;\n            right: -65px;\n            ", "\n          "], ["\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            position: absolute;\n            right: -65px;\n            ", "\n          "])), (_h = (_g = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.controlsProps) === null || _g === void 0 ? void 0 : _g.buttonsProps) === null || _h === void 0 ? void 0 : _h.customCSS) }, { children: jsx(Icon$1, __assign({ height: "15px", width: "15px", color: pagination < (pages || quantyPages.length) ? 'white' : '#dcdcdc', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/images/left-arrow-return-svgrepo-com.svg" }, (_j = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.controlsProps) === null || _j === void 0 ? void 0 : _j.iconProps, { customCSS: css$1(templateObject_4$j || (templateObject_4$j = __makeTemplateObject(["\n              transform: rotate(180deg);\n              ", "\n            "], ["\n              transform: rotate(180deg);\n              ", "\n            "])), (_l = (_k = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.controlsProps) === null || _k === void 0 ? void 0 : _k.iconProps) === null || _l === void 0 ? void 0 : _l.customCSS) })) }))] })) })));
};
var templateObject_1$M, templateObject_2$A, templateObject_3$s, templateObject_4$j;

var Wrapper = styled$1.div(templateObject_1$L || (templateObject_1$L = __makeTemplateObject(["\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: ", ";\n  justify-content: center;\n\n  .bar {\n    margin-left: ", "!important;\n    margin-right: ", "!important;\n  }\n\n  .progress {\n    display: flex;\n    justify-content: flex-start;\n    align-items: center;\n    padding-left: 30px;\n  }\n\n  .inner-label {\n    white-space: nowrap;\n    font-weight: 600;\n  }\n"], ["\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: ", ";\n  justify-content: center;\n\n  .bar {\n    margin-left: ", "!important;\n    margin-right: ", "!important;\n  }\n\n  .progress {\n    display: flex;\n    justify-content: flex-start;\n    align-items: center;\n    padding-left: 30px;\n  }\n\n  .inner-label {\n    white-space: nowrap;\n    font-weight: 600;\n  }\n"])), function (_a) {
    var row = _a.row;
    return (row ? 'row' : 'column');
}, function (_a) {
    var row = _a.row;
    return (row ? '20px' : '0px');
}, function (_a) {
    var row = _a.row;
    return (row ? '20px' : '0px');
});
var LabelWrapper = styled$1.div(templateObject_2$z || (templateObject_2$z = __makeTemplateObject(["\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: space-between;\n  margin-bottom: 12px;\n\n  span {\n    display: flex;\n    width: fit-content;\n    justify-content: center;\n    align-items: center;\n  }\n"], ["\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: space-between;\n  margin-bottom: 12px;\n\n  span {\n    display: flex;\n    width: fit-content;\n    justify-content: center;\n    align-items: center;\n  }\n"])));
var templateObject_1$L, templateObject_2$z;

var ProgressBar = function (_a) {
    var _b = _a.backgroundColor, backgroundColor = _b === void 0 ? 'gray' : _b, progressColor = _a.progressColor, borderRadius = _a.borderRadius, rightLabel = _a.rightLabel, innerLabel = _a.innerLabel, leftLabel = _a.leftLabel, className = _a.className, progress = _a.progress, height = _a.height, width = _a.width, row = _a.row;
    var containerStyles = {
        height: height || 5,
        width: width || '100%',
        backgroundColor: backgroundColor,
        borderRadius: borderRadius,
        margin: 'auto',
    };
    var fillerStyles = {
        height: '100%',
        width: "".concat(progress, "%"),
        backgroundColor: progressColor || 'red',
        borderRadius: 'inherit',
        textAlign: 'right',
    };
    return (jsxs(Wrapper, __assign({ className: "".concat(className, " progress-bar"), row: row }, { children: [!row && (jsxs(LabelWrapper, __assign({ className: "label-wrapper" }, { children: [jsx("span", __assign({ className: "left-label" }, { children: leftLabel })), rightLabel && jsx("span", __assign({ className: "right-label" }, { children: rightLabel }))] }))), row && leftLabel && jsx("span", __assign({ className: "left-label" }, { children: leftLabel })), jsx("div", __assign({ style: containerStyles, className: "bar" }, { children: jsx("div", __assign({ style: fillerStyles, className: "progress" }, { children: innerLabel && jsx("span", __assign({ className: "inner-label" }, { children: innerLabel })) })) })), row && rightLabel && jsx("span", __assign({ className: "right-label" }, { children: rightLabel }))] })));
};

var Seo = function (_a) {
    var title = _a.title, page = _a.page, description = _a.description, website = _a.website, name = _a.name, sameAs = _a.sameAs, alternateName = _a.alternateName, keywords = _a.keywords, icon = _a.icon;
    return (jsxs(Head, { children: [jsxs("title", { children: [title, " | ", page] }), jsx("link", { rel: "icon", type: "image/png", href: icon || "/favicon.png" }), jsx("meta", { httpEquiv: "Content-Type", content: "text/html;charset=UTF-8" }), jsx("meta", { httpEquiv: "X-UA-Compatible", content: "IE=7" }), jsx("meta", { httpEquiv: "X-UA-Compatible", content: "ie=edge" }), jsx("meta", { name: "canonical", content: website }), jsx("meta", { name: "keywords", content: keywords ? keywords.join(", ") : "nextjs, typescript" }), jsx("meta", { name: "viewport", content: "width=device-width, initial-scale=1" }), jsx("link", { rel: "manifest", href: "/manifest.json" }), jsx("meta", { name: "theme-color", content: "#292929" }), jsx("link", { rel: "apple-touch-icon", href: "/logo-96x96.png" }), jsx("meta", { name: "apple-mobile-web-app-status-bar", content: "#90cdf4" }), jsx("meta", { name: "description", content: description }), jsx("meta", { name: "author", content: "Ixulabs" }), jsx("meta", { name: "copyright", content: "Ixulabs" }), jsx("meta", { name: "title", content: title }), jsx("meta", { name: "description", content: description }), jsx("meta", { name: "googlebot", content: "index,follow" }), jsx("meta", { property: "og:type", content: "website" }), jsx("meta", { property: "og:url", content: website }), jsx("meta", { property: "og:title", content: title }), jsx("meta", { property: "og:description", content: description }), jsx("meta", { property: "og:image", content: "/preview.png" }), jsx("meta", { name: "twitter:site", content: "@StacklyCode" }), jsx("meta", { name: "twitter:creator", content: "@StacklyCode" }), jsx("meta", { name: "twitter:card", content: "summary_large_image" }), jsx("meta", { name: "twitter:url", content: website }), jsx("meta", { name: "twitter:title", content: title }), jsx("meta", { name: "twitter:description", content: description }), jsx("meta", { name: "twitter:image", content: "/preview.png" }), jsx("link", { rel: "manifest", href: "manifest.webmanifest" }), jsx("script", { type: "application/ld+json", dangerouslySetInnerHTML: {
                    __html: JSON.stringify({
                        '@context': "https://schema.org",
                        '@type': "Organization",
                        name: name,
                        alternateName: alternateName,
                        url: website,
                        logo: "".concat(website, "logo-512x512.png"),
                        contactPoint: {
                            '@type': "ContactPoint",
                            telephone: "",
                            contactType: "customer service",
                            areaServed: ["AR", "CO", "MX", "UY", "SV", "DO"],
                            availableLanguage: ["en", "es"],
                        },
                        sameAs: sameAs,
                    }),
                } })] }));
};

var SeoPage = function (props) {
    var _a, _b, _c, _d;
    return (jsxs(Head, { children: [jsxs("title", { children: [props.title, " | ", props.page] }), props.icon && (jsx("link", { rel: "icon", type: "image/png", href: (_a = props.icon) !== null && _a !== void 0 ? _a : "/favicon.png" })), jsx("meta", { httpEquiv: "Content-Type", content: "text/html;charset=UTF-8" }), jsx("meta", { httpEquiv: "X-UA-Compatible", content: "IE=7" }), jsx("meta", { httpEquiv: "X-UA-Compatible", content: "ie=edge" }), jsx("meta", { name: "canonical", content: props.website }), jsx("meta", { name: "keywords", content: props.keywords ? props.keywords.join(", ") : "nextjs, typescript" }), jsx("meta", { name: "viewport", content: "width=device-width, initial-scale=1" }), jsx("link", { rel: "manifest", href: "/manifest.json" }), jsx("meta", { name: "description", content: props.description }), jsx("meta", { name: "author", content: "Ixulabs" }), jsx("meta", { name: "copyright", content: "Ixulabs" }), jsx("meta", { name: "title", content: props.title }), jsx("meta", { name: "description", content: props.description }), jsx("meta", { name: "googlebot", content: "index,follow" }), jsx("meta", { property: "og:locale", content: (_b = props.locale) !== null && _b !== void 0 ? _b : 'es_ES' }), jsx("meta", { property: "og:type", content: "article" }), jsx("meta", { property: "og:title", content: props.title }), jsx("meta", { property: "og:description", content: props.description }), jsx("meta", { property: "og:url", content: props.website }), jsx("meta", { property: "og:site_name", content: "".concat(props.title, " | ").concat(props.page) }), jsx("meta", { property: "og:image", content: props.image || "/preview.png" }), jsx("meta", { property: "og:image:secure_url", content: props.image || "/preview.png" }), jsx("meta", { property: "og:image:width", content: "1200" }), jsx("meta", { property: "og:image:height", content: "630" }), jsx("meta", { property: "og:image:alt", content: props.title }), jsx("meta", { name: "twitter:card", content: "summary_large_image" }), jsx("meta", { name: "twitter:description", content: props.description }), jsx("meta", { name: "twitter:title", content: props.title }), jsx("meta", { name: "twitter:image", content: props.image || "/preview.png" }), jsx("meta", { property: "og:image", itemProp: "image", content: props.image || "/preview.png" }), jsx("meta", { property: "og:image:secure_url", content: props.image || "/preview.png" }), jsx("meta", { property: "og:image:type", content: "image/png" }), jsx("meta", { property: "og:image:width", content: "300" }), jsx("meta", { property: "og:image:height", content: "300" }), jsx("script", { type: (_c = props.jsonType) !== null && _c !== void 0 ? _c : 'application/ld+json', dangerouslySetInnerHTML: {
                    __html: (_d = props === null || props === void 0 ? void 0 : props.json) !== null && _d !== void 0 ? _d : '',
                } })] }));
};

var OptionsPagination = [
    {
        id: 'paginationKey0',
        label: '5',
        value: '5',
    },
    {
        id: 'paginationKey1',
        label: '10',
        value: '10',
    },
    {
        id: 'paginationKey1',
        label: '25',
        value: '25',
    },
    {
        id: 'paginationKey1',
        label: '50',
        value: '50',
    },
    // {
    //   id: 'paginationKey1',
    //   label: '75',
    //   value: '75',
    // },
    // {
    //   id: 'paginationKey1',
    //   label: '100',
    //   value: '100',
    // },
];
var Table$1 = function (props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    var columns = props.columns, data = props.data, tableWidth = props.tableWidth, customCSS = props.customCSS, state = props.state, dispatch = props.dispatch, loading = props.loading, loaderWrapper = props.loaderWrapper, loaderProps = props.loaderProps;
    var TableData = __assign(__assign({}, props), { data: null, customCSS: null });
    return (jsxs(Wrapper$2, __assign({ width: tableWidth || "100%", padding: "0px 0px", borderRadius: "4px", overflowX: "auto" }, TableData, { customCSS: customCSS !== null && customCSS !== void 0 ? customCSS : css$1(templateObject_1$K || (templateObject_1$K = __makeTemplateObject(["\n          overflow-x: auto;\n          /* width */\n          ::-webkit-scrollbar {\n            height: 10px;\n          }\n\n          ::-webkit-scrollbar-thumb {\n            border-radius: 2px;\n          }\n        "], ["\n          overflow-x: auto;\n          /* width */\n          ::-webkit-scrollbar {\n            height: 10px;\n          }\n\n          ::-webkit-scrollbar-thumb {\n            border-radius: 2px;\n          }\n        "]))) }, { children: [jsxs(AtomTableStyled$1, __assign({}, TableData, { children: [(columns === null || columns === void 0 ? void 0 : columns.some(function (column) { return column.title; })) && (jsx("thead", { children: jsx("tr", { children: columns.length > 0 &&
                                (columns === null || columns === void 0 ? void 0 : columns.map(function (e, i) {
                                    var _a;
                                    return (jsx("th", __assign({ style: { width: "".concat(e.width) } }, { children: e.title }), "header ".concat((_a = e.id) !== null && _a !== void 0 ? _a : i + 1)));
                                })) }) })), jsx(AtomTbodyStyled$1, { children: (data === null || data === void 0 ? void 0 : data.length) > 0 &&
                            (data === null || data === void 0 ? void 0 : data.map(function (e, i) {
                                var _a;
                                return (jsx("tr", { children: columns.length > 0 &&
                                        (columns === null || columns === void 0 ? void 0 : columns.map(function (td, j) { return (jsx(TDStyled$1, __assign({}, td, { title: "".concat(td === null || td === void 0 ? void 0 : td.title) }, { children: td.view(e) }), "cell ".concat(i + 1, " ").concat(j + 1))); })) }, "row ".concat((_a = e.id) !== null && _a !== void 0 ? _a : i + 1)));
                            })) })] })), dispatch && state && (jsx(Fragment$1, { children: jsxs(Wrapper$2, __assign({ flexDirection: "row", justifyContent: "flex-end", alignItems: "center", customCSS: css$1(templateObject_2$y || (templateObject_2$y = __makeTemplateObject(["\n              padding: 20px 10px;\n              background-color: #ffffff;\n              box-shadow: 0px 2px 10px rgba(0, 0, 0, 0.05);\n            "], ["\n              padding: 20px 10px;\n              background-color: #ffffff;\n              box-shadow: 0px 2px 10px rgba(0, 0, 0, 0.05);\n            "]))) }, { children: [jsxs(Wrapper$2, __assign({ flexDirection: "row", height: "100%", maxWidth: "max-content", justifyContent: "center", alignItems: "center" }, { children: [jsx(Text$2, __assign({ color: "#4A4A49", fontWeight: 500, margin: "0px 15px 0px 0px" }, { children: "Mostrar" })), jsx(Input, { type: "select", border: "1px solid #e0e0e0", labelWidth: "80px", height: "30px", customCSS: css$1(templateObject_3$r || (templateObject_3$r = __makeTemplateObject(["\n                  span {\n                    display: none;\n                  }\n                "], ["\n                  span {\n                    display: none;\n                  }\n                "]))), value: "".concat(state.limit), options: OptionsPagination === null || OptionsPagination === void 0 ? void 0 : OptionsPagination.filter(function (e) { return Number(e.value) <= state.totaldocs; }), onChange: function (e) {
                                        dispatch === null || dispatch === void 0 ? void 0 : dispatch(__assign(__assign({}, state), { limit: parseInt(e.target.value, 10) }));
                                    } })] })), jsxs(Wrapper$2, __assign({ maxWidth: "max-content", margin: "0px 20px" }, { children: [jsxs(Text$2, __assign({ color: "#4A4A49", fontWeight: 500, align: "center" }, { children: [((_a = state.limit) !== null && _a !== void 0 ? _a : 0) * ((_b = (state === null || state === void 0 ? void 0 : state.page) + 1) !== null && _b !== void 0 ? _b : 0) >
                                            ((_c = state === null || state === void 0 ? void 0 : state.totaldocs) !== null && _c !== void 0 ? _c : 0)
                                            ? (_d = state === null || state === void 0 ? void 0 : state.totaldocs) !== null && _d !== void 0 ? _d : 0
                                            : ((_e = state.limit) !== null && _e !== void 0 ? _e : 0) * ((_f = (state === null || state === void 0 ? void 0 : state.page) + 1) !== null && _f !== void 0 ? _f : 0), ' ', "de ", (_g = state === null || state === void 0 ? void 0 : state.totaldocs) !== null && _g !== void 0 ? _g : 0] })), jsxs(Text$2, __assign({ color: "#4A4A49", fontWeight: 500, align: "center" }, { children: ["P\u00E1gina ", (_h = (state === null || state === void 0 ? void 0 : state.page) + 1) !== null && _h !== void 0 ? _h : 0, " de", ' ', Math.ceil(((_j = state.totaldocs) !== null && _j !== void 0 ? _j : 0) / ((_k = state.limit) !== null && _k !== void 0 ? _k : 0))] }))] })), jsxs(Wrapper$2, __assign({ maxWidth: "max-content", margin: "0px 0px", flexDirection: "row" }, { children: [jsx(AtomButton, __assign({ padding: "0px 0px", margin: "0px 10px 0px 0px", backgroundColor: "transparent", onClick: function () {
                                        var _a;
                                        dispatch === null || dispatch === void 0 ? void 0 : dispatch(__assign(__assign({}, state), { page: (state === null || state === void 0 ? void 0 : state.hasprevpage)
                                                ? ((_a = state === null || state === void 0 ? void 0 : state.page) !== null && _a !== void 0 ? _a : 0) - 1
                                                : state === null || state === void 0 ? void 0 : state.page }));
                                    } }, { children: jsx(Icon$1, { height: "18px", width: "18px", color: (state === null || state === void 0 ? void 0 : state.hasprevpage) ? '#262626' : '#c0c0c0', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/MDC-0001/svg/chevron-left-solid%20(2).svg" }) })), jsx(AtomButton, __assign({ padding: "0px 0px", margin: "0px 0px 0px 10px", backgroundColor: "transparent", onClick: function () {
                                        var _a;
                                        dispatch === null || dispatch === void 0 ? void 0 : dispatch(__assign(__assign({}, state), { page: (state === null || state === void 0 ? void 0 : state.hasnextpage)
                                                ? ((_a = state === null || state === void 0 ? void 0 : state.page) !== null && _a !== void 0 ? _a : 0) + 1
                                                : state === null || state === void 0 ? void 0 : state.page }));
                                    } }, { children: jsx(Icon$1, { height: "18px", width: "18px", color: (state === null || state === void 0 ? void 0 : state.hasnextpage) ? '#262626' : '#c0c0c0', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/MDC-0001/svg/chevron-right-solid%20(7).svg" }) }))] }))] })) })), loading && (jsx(Wrapper$2, __assign({}, loaderWrapper, { children: jsx(Loader, __assign({}, loaderProps)) })))] })));
};
var templateObject_1$K, templateObject_2$y, templateObject_3$r;

css$1(templateObject_1$J || (templateObject_1$J = __makeTemplateObject(["\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  gap: 15px;\n  min-height: 34px;\n  font-size: 10px;\n  padding: 8px 20px 8px 20px;\n  font-weight: 700;\n"], ["\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  gap: 15px;\n  min-height: 34px;\n  font-size: 10px;\n  padding: 8px 20px 8px 20px;\n  font-weight: 700;\n"])));
var BUTTON_ICON = css$1(templateObject_2$x || (templateObject_2$x = __makeTemplateObject(["\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  gap: 10px;\n  font-weight: 700;\n  padding: 0px 0px;\n  min-height: 34px;\n  background-color: transparent;\n"], ["\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  gap: 10px;\n  font-weight: 700;\n  padding: 0px 0px;\n  min-height: 34px;\n  background-color: transparent;\n"])));
var templateObject_1$J, templateObject_2$x;

var INPUT_TEXT = css$1(templateObject_1$I || (templateObject_1$I = __makeTemplateObject(["\n  span:nth-of-type(1) {\n    margin: 0 0 0 0;\n    font-size: 12px;\n    font-weight: 600;\n    padding-bottom: 10px;\n  }\n  input {\n    width: 100%;\n    height: 35px;\n    min-width: 200px;\n    border: 1px solid #e5e5e5;\n    border-radius: 4px;\n    padding: 0 10px;\n    font-size: 12px;\n    padding: 0px 0px 0px 15px;\n  }\n  span:nth-of-type(2) {\n    margin: 0 0 0 0;\n    font-size: 8px;\n    font-weight: 700;\n    padding-top: 5px;\n  }\n"], ["\n  span:nth-of-type(1) {\n    margin: 0 0 0 0;\n    font-size: 12px;\n    font-weight: 600;\n    padding-bottom: 10px;\n  }\n  input {\n    width: 100%;\n    height: 35px;\n    min-width: 200px;\n    border: 1px solid #e5e5e5;\n    border-radius: 4px;\n    padding: 0 10px;\n    font-size: 12px;\n    padding: 0px 0px 0px 15px;\n  }\n  span:nth-of-type(2) {\n    margin: 0 0 0 0;\n    font-size: 8px;\n    font-weight: 700;\n    padding-top: 5px;\n  }\n"])));
css$1(templateObject_2$w || (templateObject_2$w = __makeTemplateObject(["\n  span:nth-of-type(1) {\n    margin: 0 0 0 0;\n    font-size: 12px;\n    font-weight: 600;\n    padding-bottom: 10px;\n  }\n  input {\n    width: 100%;\n    height: 35px;\n    min-width: 200px;\n    border: 1px solid #e5e5e5;\n    border-radius: 4px;\n    padding: 0 10px;\n    font-size: 12px;\n    padding: 0px 0px 0px 15px;\n  }\n  span:nth-of-type(2) {\n    margin: 0 0 0 0;\n    font-size: 8px;\n    font-weight: 700;\n    padding-top: 5px;\n  }\n"], ["\n  span:nth-of-type(1) {\n    margin: 0 0 0 0;\n    font-size: 12px;\n    font-weight: 600;\n    padding-bottom: 10px;\n  }\n  input {\n    width: 100%;\n    height: 35px;\n    min-width: 200px;\n    border: 1px solid #e5e5e5;\n    border-radius: 4px;\n    padding: 0 10px;\n    font-size: 12px;\n    padding: 0px 0px 0px 15px;\n  }\n  span:nth-of-type(2) {\n    margin: 0 0 0 0;\n    font-size: 8px;\n    font-weight: 700;\n    padding-top: 5px;\n  }\n"])));
var INPUT_SELECT = css$1(templateObject_3$q || (templateObject_3$q = __makeTemplateObject(["\n  span:nth-of-type(1) {\n    margin: 0 0 0 0;\n    font-size: 12px;\n    font-weight: 600;\n    padding-bottom: 10px;\n  }\n  select {\n    width: 100%;\n    min-width: 200px;\n    height: 35px;\n    border: 1px solid #e5e5e5;\n    border-radius: 4px;\n    padding: 0 10px;\n    font-size: 12px;\n    padding: 0px 0px 0px 15px;\n  }\n  span:nth-of-type(2) {\n    margin: 0 0 0 0;\n    font-size: 8px;\n    font-weight: 700;\n    padding-top: 5px;\n  }\n"], ["\n  span:nth-of-type(1) {\n    margin: 0 0 0 0;\n    font-size: 12px;\n    font-weight: 600;\n    padding-bottom: 10px;\n  }\n  select {\n    width: 100%;\n    min-width: 200px;\n    height: 35px;\n    border: 1px solid #e5e5e5;\n    border-radius: 4px;\n    padding: 0 10px;\n    font-size: 12px;\n    padding: 0px 0px 0px 15px;\n  }\n  span:nth-of-type(2) {\n    margin: 0 0 0 0;\n    font-size: 8px;\n    font-weight: 700;\n    padding-top: 5px;\n  }\n"])));
var templateObject_1$I, templateObject_2$w, templateObject_3$q;

var LoaderSmall = function () {
    return (jsx(Loader, { isLoading: true, type: "small", colorLoading: "#a5a5a5", widthLoader: "2px", customCSS: css$1(templateObject_1$H || (templateObject_1$H = __makeTemplateObject(["\n        width: 100%;\n        .lds-ring {\n          width: 15px;\n          height: 15px;\n          div {\n            margin: 1px 2px;\n            width: 14px;\n            height: 14px;\n          }\n        }\n      "], ["\n        width: 100%;\n        .lds-ring {\n          width: 15px;\n          height: 15px;\n          div {\n            margin: 1px 2px;\n            width: 14px;\n            height: 14px;\n          }\n        }\n      "]))) }));
};
var templateObject_1$H;

var IsLoadingTable = function (props) {
    var loading = props.loading, columns = props.columns, take = props.take;
    if (loading)
        return (jsxs(Fragment$1, { children: [jsxs("thead", { children: [columns.filter(function (item) { return item === null || item === void 0 ? void 0 : item.searchable; }).length > 0 && (jsx("tr", __assign({ className: "searchTR" }, { children: columns.map(function (_, index) {
                                return (columns === null || columns === void 0 ? void 0 : columns.length) === index + 1 ? (jsx("th", { children: jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_1$G || (templateObject_1$G = __makeTemplateObject(["\n                        flex-direction: row;\n                        justify-content: flex-end;\n                        align-items: center;\n                        gap: 10px;\n                      "], ["\n                        flex-direction: row;\n                        justify-content: flex-end;\n                        align-items: center;\n                        gap: 10px;\n                      "]))) }, { children: [jsxs(Text$2, __assign({ customCSS: css$1(templateObject_2$v || (templateObject_2$v = __makeTemplateObject(["\n                          font-size: 12px;\n                          font-weight: 600;\n                          color: #383838;\n                        "], ["\n                          font-size: 12px;\n                          font-weight: 600;\n                          color: #383838;\n                        "]))) }, { children: ["Buscar:", ' '] })), jsx(Input, { customCSS: css$1(templateObject_3$p || (templateObject_3$p = __makeTemplateObject(["\n                          ", "\n                        "], ["\n                          ", "\n                        "])), INPUT_TEXT) })] })) })) : (jsx("th", { children: jsx(Fragment$1, {}) }));
                            }) }))), jsx("tr", { children: columns === null || columns === void 0 ? void 0 : columns.map(function (e, i) { return (jsx("th", { children: jsx(LoaderSmall, {}) }, "header ".concat(i + 1))); }) })] }), jsx(AtomTbodyStyled, { children: Array.from({ length: take !== null && take !== void 0 ? take : 5 }).map(function (e, i) {
                        var _a;
                        return (jsx(TRStyled, __assign({ animate: {
                                opacity: 1,
                            }, initial: { opacity: 0 }, transition: { delay: i * 0.045, duration: 0.1 } }, { children: (_a = Array.from({ length: columns.length })) === null || _a === void 0 ? void 0 : _a.map(function (_, i2) { return (jsx(TDStyled, { children: jsx(LoaderSmall, {}) }, "Loading-".concat(i2 + 1))); }) }), "row ".concat(i + 1)));
                    }) })] }));
    return jsx(Fragment$1, { children: props.children });
};
var templateObject_1$G, templateObject_2$v, templateObject_3$p;

var LISTPRODUCTS = gql(templateObject_1$F || (templateObject_1$F = __makeTemplateObject(["\n  query listProducts(\n    $filter: ProductFilterInput\n    $order: [ProductSortInput!]\n    $skip: Int\n    $take: Int\n  ) {\n    listProducts(filter: $filter, order: $order, skip: $skip, take: $take) {\n      pageInfo {\n        hasNextPage\n        hasPreviousPage\n      }\n      totalCount\n      items {\n        id\n        photo\n        sku\n        title\n        slug\n        description\n        projectId\n        createdAt\n        updatedAt\n        shopType\n      }\n    }\n  }\n"], ["\n  query listProducts(\n    $filter: ProductFilterInput\n    $order: [ProductSortInput!]\n    $skip: Int\n    $take: Int\n  ) {\n    listProducts(filter: $filter, order: $order, skip: $skip, take: $take) {\n      pageInfo {\n        hasNextPage\n        hasPreviousPage\n      }\n      totalCount\n      items {\n        id\n        photo\n        sku\n        title\n        slug\n        description\n        projectId\n        createdAt\n        updatedAt\n        shopType\n      }\n    }\n  }\n"])));
var templateObject_1$F;

var OptionsTake = [
    {
        id: 'takeKey0',
        label: '5',
        value: '5',
    },
    {
        id: 'takeKey1',
        label: '10',
        value: '10',
    },
    {
        id: 'takeKey2',
        label: '25',
        value: '25',
    },
    {
        id: 'takeKey3',
        label: '50',
        value: '50',
    },
];
var AtomTableQuery = function (props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    var customCSS = props.customCSS, columnscss = props.columnscss, QUERY = props.QUERY, data = props.data, searchBar = props.searchBar, options = props.options, columns = props.columns, onCompleted = props.onCompleted, onError = props.onError, onLoading = props.onLoading, onUpdated = props.onUpdated, id = props.id;
    var _l = __read(useState(10), 2), take = _l[0], setTake = _l[1];
    var _m = __read(useState(0), 2), skip = _m[0], setSkip = _m[1];
    var _o = __read(useState({}), 2), order = _o[0], setOrder = _o[1];
    var _p = __read(useState(''), 2), search = _p[0], setSearch = _p[1];
    var _q = __read(useState({}), 2), getParams = _q[0], setParams = _q[1];
    var _r = __read(useState([]), 2), getData = _r[0], setData = _r[1];
    var _s = __read(useState(true), 2), loading = _s[0], setLoading = _s[1];
    var customize = useSelector(function (state) { return state.customize; });
    var getOrder = useMemo(function () {
        var orderArray = Object.entries(order);
        if (orderArray.length === 0)
            return {};
        var orderArrayFiltered = orderArray.filter(function (item) { return item[1] !== 'NONE'; });
        return {
            order: Object.fromEntries(orderArrayFiltered),
        };
    }, [order]);
    var getSearch = useMemo(function () {
        var itemFiltered = columns.filter(function (item) { return item === null || item === void 0 ? void 0 : item.searchable; });
        if (search === '' || itemFiltered.length === 0)
            return null;
        return {
            filter: itemFiltered === null || itemFiltered === void 0 ? void 0 : itemFiltered.reduce(function (acc, item) {
                var _a;
                return ({
                    or: __spreadArray(__spreadArray([], __read(acc.or), false), [
                        (_a = {},
                            _a[item.key] = {
                                contains: search,
                            },
                            _a),
                    ], false),
                });
            }, {
                or: [],
            }),
        };
    }, [search]);
    var getFilter = useMemo(function () {
        var _a, _b;
        if (((_a = options === null || options === void 0 ? void 0 : options.variables) === null || _a === void 0 ? void 0 : _a.filter) || (getSearch === null || getSearch === void 0 ? void 0 : getSearch.filter)) {
            return {
                filter: __assign(__assign({}, (_b = options === null || options === void 0 ? void 0 : options.variables) === null || _b === void 0 ? void 0 : _b.filter), getSearch === null || getSearch === void 0 ? void 0 : getSearch.filter),
            };
        }
        return null;
    }, [getParams, getSearch, options]);
    var QUERYGET = useQuery(QUERY !== null && QUERY !== void 0 ? QUERY : LISTPRODUCTS, __assign(__assign({}, options), { variables: __assign(__assign(__assign(__assign({}, options === null || options === void 0 ? void 0 : options.variables), getFilter), { skip: take * skip, take: take }), getOrder), onCompleted: function (e) {
            setLoading(false);
            onCompleted === null || onCompleted === void 0 ? void 0 : onCompleted(e);
        }, onError: function (error) {
            setLoading(false);
            onError === null || onError === void 0 ? void 0 : onError(error);
        } }));
    useEffect(function () {
        onLoading === null || onLoading === void 0 ? void 0 : onLoading(QUERYGET === null || QUERYGET === void 0 ? void 0 : QUERYGET.loading);
    }, [QUERYGET === null || QUERYGET === void 0 ? void 0 : QUERYGET.loading]);
    useEffect(function () {
        onUpdated === null || onUpdated === void 0 ? void 0 : onUpdated(QUERYGET);
    }, [QUERYGET]);
    var ErrorMessages = useMemo(function () {
        var _a, _b, _c;
        var getErros = (_a = QUERYGET === null || QUERYGET === void 0 ? void 0 : QUERYGET.error) === null || _a === void 0 ? void 0 : _a.networkError;
        return (_c = (_b = getErros === null || getErros === void 0 ? void 0 : getErros.result) === null || _b === void 0 ? void 0 : _b.errors) !== null && _c !== void 0 ? _c : [];
    }, [QUERYGET === null || QUERYGET === void 0 ? void 0 : QUERYGET.error]);
    var getArrayPages = useMemo(function () {
        return Array.from({ length: Math.ceil((getParams === null || getParams === void 0 ? void 0 : getParams.totalCount) / take) }, function (_, i) { return i; });
    }, [getParams === null || getParams === void 0 ? void 0 : getParams.totalCount, take]);
    var getArrayPagesShow = useMemo(function () {
        return getArrayPages.filter(function (item) {
            return item >= Math.min(skip - 2, getArrayPages.length - 5) &&
                item <= Math.max(skip + 2, 4);
        });
    }, [getArrayPages, skip]);
    useEffect(function () {
        var _a, _b, _c, _d, _e;
        var get = (_b = Object.values((_a = QUERYGET === null || QUERYGET === void 0 ? void 0 : QUERYGET.data) !== null && _a !== void 0 ? _a : {})) === null || _b === void 0 ? void 0 : _b[0];
        var params = {
            pageInfo: (_c = get === null || get === void 0 ? void 0 : get.pageInfo) !== null && _c !== void 0 ? _c : getParams === null || getParams === void 0 ? void 0 : getParams.pageInfo,
            totalCount: (_d = get === null || get === void 0 ? void 0 : get.totalCount) !== null && _d !== void 0 ? _d : getParams === null || getParams === void 0 ? void 0 : getParams.totalCount,
        };
        var dataTable = (_e = data === null || data === void 0 ? void 0 : data(QUERYGET === null || QUERYGET === void 0 ? void 0 : QUERYGET.data)) !== null && _e !== void 0 ? _e : getData;
        setParams(params);
        setData(dataTable);
    }, [QUERYGET, QUERY, options]);
    var isSearchBar = useMemo(function () {
        var isSearch = columns.filter(function (item) { return item === null || item === void 0 ? void 0 : item.searchable; }).length > 0;
        return searchBar || isSearch;
    }, [searchBar, columns]);
    return (jsxs(AtomTableContainerStyled, __assign({ css: css$1(templateObject_1$E || (templateObject_1$E = __makeTemplateObject(["\n        width: 100%;\n        ", "\n      "], ["\n        width: 100%;\n        ", "\n      "])), customCSS) }, { children: [isSearchBar && (jsx(AtomTheaderStyled, { children: searchBar ? (jsx(Fragment$1, { children: searchBar })) : (jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_2$u || (templateObject_2$u = __makeTemplateObject(["\n                flex-direction: row;\n                justify-content: flex-end;\n                align-items: center;\n                gap: 10px;\n              "], ["\n                flex-direction: row;\n                justify-content: flex-end;\n                align-items: center;\n                gap: 10px;\n              "]))) }, { children: [jsx(Text$2, { children: "Buscar " }), jsx(Input, { value: search, onChange: function (e) { return setSearch(e.target.value); }, customCSS: css$1(templateObject_3$o || (templateObject_3$o = __makeTemplateObject(["\n                  ", "\n                  input {\n                    font-size: 10px;\n                    font-weight: 700;\n                    color: #424242;\n                    height: 30px;\n                    min-width: 180px;\n                  }\n                "], ["\n                  ", "\n                  input {\n                    font-size: 10px;\n                    font-weight: 700;\n                    color: #424242;\n                    height: 30px;\n                    min-width: 180px;\n                  }\n                "])), INPUT_TEXT) })] }))) })), jsxs(AtomTableStyled, __assign({ id: id, cl: columns === null || columns === void 0 ? void 0 : columns.length, customCSST: props === null || props === void 0 ? void 0 : props.customCSST }, { children: [(ErrorMessages === null || ErrorMessages === void 0 ? void 0 : ErrorMessages.length) > 0 && (jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_4$i || (templateObject_4$i = __makeTemplateObject(["\n              align-items: center;\n              justify-content: center;\n              position: absolute;\n              width: 100%;\n              height: 100%;\n              background-color: #fcfcfc6d;\n              backdrop-filter: blur(5px);\n              z-index: 1;\n              gap: 20px;\n            "], ["\n              align-items: center;\n              justify-content: center;\n              position: absolute;\n              width: 100%;\n              height: 100%;\n              background-color: #fcfcfc6d;\n              backdrop-filter: blur(5px);\n              z-index: 1;\n              gap: 20px;\n            "]))) }, { children: jsx(Text$2, { children: ErrorMessages === null || ErrorMessages === void 0 ? void 0 : ErrorMessages.map(function (e) { return (jsx(Text$2, __assign({ customCSS: css$1(templateObject_5$f || (templateObject_5$f = __makeTemplateObject(["\n                    font-size: 16px;\n                    color: #ff0000;\n                    font-weight: 600;\n                  "], ["\n                    font-size: 16px;\n                    color: #ff0000;\n                    font-weight: 600;\n                  "]))) }, { children: e.message }), e === null || e === void 0 ? void 0 : e.message)); }) }) }))), jsx(IsLoadingTable, __assign({ loading: loading, columns: columns, take: take }, { children: jsxs(AtomTbodyStyled, { children: [jsx(TRStyled, __assign({ className: "head" }, { children: columns === null || columns === void 0 ? void 0 : columns.map(function (e, i) { return (jsx("th", { children: jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_6$b || (templateObject_6$b = __makeTemplateObject(["\n                      padding-right: 10px;\n                      align-items: center;\n                      justify-content: space-between;\n                      flex-direction: row;\n                      width: 100%;\n                    "], ["\n                      padding-right: 10px;\n                      align-items: center;\n                      justify-content: space-between;\n                      flex-direction: row;\n                      width: 100%;\n                    "]))) }, { children: [e.title, (e === null || e === void 0 ? void 0 : e.sortable) && (jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_7$9 || (templateObject_7$9 = __makeTemplateObject(["\n                          width: max-content;\n                        "], ["\n                          width: max-content;\n                        "]))) }, { children: [jsx(AtomButton, __assign({ onClick: function () {
                                                                var _a;
                                                                setOrder(__assign(__assign({}, order), (_a = {}, _a[e.key] = (order === null || order === void 0 ? void 0 : order[e.key]) === 'ASC' ? 'NONE' : 'ASC', _a)));
                                                            }, customCSS: css$1(templateObject_8$5 || (templateObject_8$5 = __makeTemplateObject(["\n                            ", "\n                            transform: rotate(90deg)!important;\n                            min-height: 0;\n                          "], ["\n                            ", "\n                            transform: rotate(90deg)!important;\n                            min-height: 0;\n                          "])), BUTTON_ICON) }, { children: jsx(Icon$1, { height: "10px", width: "10px", color: (order === null || order === void 0 ? void 0 : order[e.key]) === 'ASC' ? '#565656' : '#c0c0c0', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/MDC-0001/svg/chevron-left-solid%20(2).svg" }) })), jsx(AtomButton, __assign({ onClick: function () {
                                                                var _a;
                                                                setOrder(__assign(__assign({}, order), (_a = {}, _a[e.key] = (order === null || order === void 0 ? void 0 : order[e.key]) === 'DESC' ? 'NONE' : 'DESC', _a)));
                                                            }, customCSS: css$1(templateObject_9$3 || (templateObject_9$3 = __makeTemplateObject(["\n                            ", "\n                            transform: rotate(90deg)!important;\n                            min-height: 0;\n                          "], ["\n                            ", "\n                            transform: rotate(90deg)!important;\n                            min-height: 0;\n                          "])), BUTTON_ICON) }, { children: jsx(Icon$1, { height: "10px", width: "10px", color: (order === null || order === void 0 ? void 0 : order[e.key]) === 'DESC' ? '#565656' : '#c0c0c0', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/MDC-0001/svg/chevron-right-solid%20(7).svg" }) }))] })))] })) }, "header ".concat(i + 1))); }) })), getData === null || getData === void 0 ? void 0 : getData.map(function (e, i) { return (jsx(TRStyled, __assign({ animate: {
                                        opacity: 1,
                                    }, initial: { opacity: 0 }, transition: { delay: i * 0.03, duration: 0, ease: 'easeOut' }, css: columnscss === null || columnscss === void 0 ? void 0 : columnscss(e) }, { children: columns === null || columns === void 0 ? void 0 : columns.map(function (td, j) {
                                        var _a;
                                        return (jsx(TDStyled, __assign({}, td, { title: (_a = "".concat(td === null || td === void 0 ? void 0 : td.key, " ").concat(i + 1)) === null || _a === void 0 ? void 0 : _a.toUpperCase() }, { children: td.view(e) }), "cell ".concat(i + 1, " ").concat(j + 1)));
                                    }) }), "row".concat(i + 1, "-").concat(skip, "-").concat(take))); })] }) }))] })), jsx(AtomTfooterStyled, { children: jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_10$3 || (templateObject_10$3 = __makeTemplateObject(["\n            display: flex;\n            table-layout: inherit;\n            flex-direction: row;\n            align-items: center;\n            justify-content: space-between;\n          "], ["\n            display: flex;\n            table-layout: inherit;\n            flex-direction: row;\n            align-items: center;\n            justify-content: space-between;\n          "]))) }, { children: [jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_11$3 || (templateObject_11$3 = __makeTemplateObject(["\n              flex-direction: row;\n              align-items: center;\n              gap: 20px;\n              width: max-content;\n            "], ["\n              flex-direction: row;\n              align-items: center;\n              gap: 20px;\n              width: max-content;\n            "]))) }, { children: [jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_12$3 || (templateObject_12$3 = __makeTemplateObject(["\n                span {\n                  font-size: 12px;\n                  font-weight: 600;\n                  color: #383838;\n                }\n              "], ["\n                span {\n                  font-size: 12px;\n                  font-weight: 600;\n                  color: #383838;\n                }\n              "]))) }, { children: [(getParams === null || getParams === void 0 ? void 0 : getParams.totalCount) && (jsxs(Text$2, { children: ["Pagina ", skip + 1, " de", ' ', (_b = Math.ceil(((_a = getParams === null || getParams === void 0 ? void 0 : getParams.totalCount) !== null && _a !== void 0 ? _a : 1) / take)) !== null && _b !== void 0 ? _b : (jsx(Fragment$1, { children: "Cargando..." }))] })), jsxs(Text$2, { children: ["Elementos ", (_d = (_c = getParams === null || getParams === void 0 ? void 0 : getParams.totalCount) !== null && _c !== void 0 ? _c : getData.length) !== null && _d !== void 0 ? _d : 1] })] })), getArrayPagesShow.length > 0 && (jsx(Input, { id: "take", value: take, options: OptionsTake, onChange: function (e) {
                                        var _a;
                                        setTake(Number((_a = e === null || e === void 0 ? void 0 : e.target) === null || _a === void 0 ? void 0 : _a.value));
                                        setSkip(0);
                                    }, type: "select", customCSS: css$1(templateObject_13$2 || (templateObject_13$2 = __makeTemplateObject(["\n                  ", "\n                  select {\n                    height: 30px;\n                    font-size: 10px;\n                    min-width: 150px;\n                  }\n                "], ["\n                  ", "\n                  select {\n                    height: 30px;\n                    font-size: 10px;\n                    min-width: 150px;\n                  }\n                "])), INPUT_SELECT) }))] })), getArrayPagesShow.length > 0 && (jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_14$2 || (templateObject_14$2 = __makeTemplateObject(["\n                flex-direction: row;\n                align-items: center;\n                gap: 10px;\n                width: max-content;\n              "], ["\n                flex-direction: row;\n                align-items: center;\n                gap: 10px;\n                width: max-content;\n              "]))) }, { children: [jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_15$2 || (templateObject_15$2 = __makeTemplateObject(["\n                  flex-direction: row;\n                  align-items: center;\n                  gap: 10px;\n                "], ["\n                  flex-direction: row;\n                  align-items: center;\n                  gap: 10px;\n                "]))) }, { children: [jsx(AtomButton, __assign({ onClick: function () { var _a; return setSkip(((_a = getParams === null || getParams === void 0 ? void 0 : getParams.pageInfo) === null || _a === void 0 ? void 0 : _a.hasPreviousPage) ? skip - 1 : 0); }, customCSS: css$1(templateObject_16$2 || (templateObject_16$2 = __makeTemplateObject(["\n                    ", "\n                  "], ["\n                    ", "\n                  "])), BUTTON_ICON) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: ((_e = getParams === null || getParams === void 0 ? void 0 : getParams.pageInfo) === null || _e === void 0 ? void 0 : _e.hasPreviousPage)
                                                    ? (_g = (_f = customize === null || customize === void 0 ? void 0 : customize.colors) === null || _f === void 0 ? void 0 : _f.primary) !== null && _g !== void 0 ? _g : '#f1576c'
                                                    : '#c0c0c0', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/MDC-0001/svg/chevron-left-solid%20(2).svg" }) })), jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_17$2 || (templateObject_17$2 = __makeTemplateObject(["\n                    flex-direction: row;\n                    align-items: center;\n                    gap: 10px;\n                  "], ["\n                    flex-direction: row;\n                    align-items: center;\n                    gap: 10px;\n                  "]))) }, { children: getArrayPagesShow.map(function (i) {
                                                var _a, _b;
                                                return (jsx(AtomButton, __assign({ onClick: function () { return setSkip(i); }, customCSS: css$1(templateObject_18$1 || (templateObject_18$1 = __makeTemplateObject(["\n                        display: flex;\n                        align-items: center;\n                        justify-content: center;\n                        padding: 6px 12px;\n                        font-size: 12px;\n                        background-color: ", ";\n                        color: ", ";\n                      "], ["\n                        display: flex;\n                        align-items: center;\n                        justify-content: center;\n                        padding: 6px 12px;\n                        font-size: 12px;\n                        background-color: ", ";\n                        color: ", ";\n                      "])), skip === i
                                                        ? (_b = (_a = customize === null || customize === void 0 ? void 0 : customize.colors) === null || _a === void 0 ? void 0 : _a.primary) !== null && _b !== void 0 ? _b : '#f1576c'
                                                        : 'white', skip === i ? 'white' : '#383838') }, { children: "".concat(i + 1) }), "page ".concat(i)));
                                            }) })), jsx(AtomButton, __assign({ onClick: function () { var _a; return setSkip(((_a = getParams === null || getParams === void 0 ? void 0 : getParams.pageInfo) === null || _a === void 0 ? void 0 : _a.hasNextPage) ? skip + 1 : skip); }, customCSS: css$1(templateObject_19$1 || (templateObject_19$1 = __makeTemplateObject(["\n                    ", "\n                  "], ["\n                    ", "\n                  "])), BUTTON_ICON) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: ((_h = getParams === null || getParams === void 0 ? void 0 : getParams.pageInfo) === null || _h === void 0 ? void 0 : _h.hasNextPage)
                                                    ? (_k = (_j = customize === null || customize === void 0 ? void 0 : customize.colors) === null || _j === void 0 ? void 0 : _j.primary) !== null && _k !== void 0 ? _k : '#f1576c'
                                                    : '#c0c0c0', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/MDC-0001/svg/chevron-right-solid%20(7).svg" }) }))] })), jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_20$1 || (templateObject_20$1 = __makeTemplateObject(["\n                  width: 20px;\n                  height: 20px;\n                  justify-content: center;\n                  align-items: center;\n                "], ["\n                  width: 20px;\n                  height: 20px;\n                  justify-content: center;\n                  align-items: center;\n                "]))) }, { children: (QUERYGET === null || QUERYGET === void 0 ? void 0 : QUERYGET.loading) && jsx(LoaderSmall, {}) }))] })))] })) })] })));
};
var templateObject_1$E, templateObject_2$u, templateObject_3$o, templateObject_4$i, templateObject_5$f, templateObject_6$b, templateObject_7$9, templateObject_8$5, templateObject_9$3, templateObject_10$3, templateObject_11$3, templateObject_12$3, templateObject_13$2, templateObject_14$2, templateObject_15$2, templateObject_16$2, templateObject_17$2, templateObject_18$1, templateObject_19$1, templateObject_20$1;

var AtomTabs = function (props) {
    var _a, _b, _c;
    var _d = __read(useState(0), 2), activeTab = _d[0], setActiveTab = _d[1];
    var tabs = props.tabs, componentsProps = props.componentsProps;
    return (jsxs(Wrapper$2, __assign({ width: "100%", flexDirection: "column" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.containerProps, { children: [jsx(Wrapper$2, __assign({ flexDirection: "row", width: "100%", justifyContent: "flex-start" }, (_a = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.tabsProps) === null || _a === void 0 ? void 0 : _a.wrapperProps, { children: tabs === null || tabs === void 0 ? void 0 : tabs.map(function (tab, index) {
                    var _a, _b, _c, _d, _e;
                    var buttonProps = index === activeTab
                        ? (_a = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.tabsProps) === null || _a === void 0 ? void 0 : _a.buttonActiveProps
                        : (_b = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.tabsProps) === null || _b === void 0 ? void 0 : _b.buttonDisabledProps;
                    return (jsx(AtomButton, __assign({ onClick: function () {
                            var _a;
                            setActiveTab(index);
                            (_a = tab === null || tab === void 0 ? void 0 : tab.onClick) === null || _a === void 0 ? void 0 : _a.call(tab);
                        }, backgroundColor: index === activeTab ? '#00abb9' : '#b2b1af', padding: "10px 30px", borderRadius: "0px" }, buttonProps, { children: (tab === null || tab === void 0 ? void 0 : tab.button) ? ((_c = tab === null || tab === void 0 ? void 0 : tab.button) === null || _c === void 0 ? void 0 : _c.call(tab, index === activeTab)) : (jsx(Text$2, __assign({ color: "white", fontSize: "14px", fontWeight: "bold", cursor: "pointer" }, { children: (_d = tab === null || tab === void 0 ? void 0 : tab.title) !== null && _d !== void 0 ? _d : "Tab ".concat(index + 1) }))) }), (_e = tab.id) !== null && _e !== void 0 ? _e : index + 1));
                }) })), jsx(Wrapper$2, __assign({ border: "1px solid #e6e6e6" }, (_b = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.contentProps) === null || _b === void 0 ? void 0 : _b.wrapperProps, { children: (_c = tabs === null || tabs === void 0 ? void 0 : tabs.find(function (_, index) { return index === activeTab; })) === null || _c === void 0 ? void 0 : _c.content }))] })));
};

// ::- Persistent data structure representing an ordered mapping from
// strings to values, with some convenient update methods.
function OrderedMap(content) {
  this.content = content;
}

OrderedMap.prototype = {
  constructor: OrderedMap,

  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key) return i
    return -1
  },

  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found = this.find(key);
    return found == -1 ? undefined : this.content[found + 1]
  },

  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found = self.find(key), content = self.content.slice();
    if (found == -1) {
      content.push(newKey || key, value);
    } else {
      content[found + 1] = value;
      if (newKey) content[found] = newKey;
    }
    return new OrderedMap(content)
  },

  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found = this.find(key);
    if (found == -1) return this
    var content = this.content.slice();
    content.splice(found, 2);
    return new OrderedMap(content)
  },

  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content))
  },

  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content)
  },

  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found = without.find(place);
    content.splice(found == -1 ? content.length : found, 0, key, value);
    return new OrderedMap(content)
  },

  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this
    return new OrderedMap(map.content.concat(this.subtract(map).content))
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this
    return new OrderedMap(this.subtract(map).content.concat(map.content))
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map) {
    var result = this;
    map = OrderedMap.from(map);
    for (var i = 0; i < map.content.length; i += 2)
      result = result.remove(map.content[i]);
    return result
  },

  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1
  }
};

// :: (?union<Object, OrderedMap>) → OrderedMap
// Return a map with the given content. If null, create an empty
// map. If given an ordered map, return that map itself. If given an
// object, create a map from the object's properties.
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content)
};

function findDiffStart(a, b, pos) {
    for (let i = 0;; i++) {
        if (i == a.childCount || i == b.childCount)
            return a.childCount == b.childCount ? null : pos;
        let childA = a.child(i), childB = b.child(i);
        if (childA == childB) {
            pos += childA.nodeSize;
            continue;
        }
        if (!childA.sameMarkup(childB))
            return pos;
        if (childA.isText && childA.text != childB.text) {
            for (let j = 0; childA.text[j] == childB.text[j]; j++)
                pos++;
            return pos;
        }
        if (childA.content.size || childB.content.size) {
            let inner = findDiffStart(childA.content, childB.content, pos + 1);
            if (inner != null)
                return inner;
        }
        pos += childA.nodeSize;
    }
}
function findDiffEnd(a, b, posA, posB) {
    for (let iA = a.childCount, iB = b.childCount;;) {
        if (iA == 0 || iB == 0)
            return iA == iB ? null : { a: posA, b: posB };
        let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
        if (childA == childB) {
            posA -= size;
            posB -= size;
            continue;
        }
        if (!childA.sameMarkup(childB))
            return { a: posA, b: posB };
        if (childA.isText && childA.text != childB.text) {
            let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
            while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
                same++;
                posA--;
                posB--;
            }
            return { a: posA, b: posB };
        }
        if (childA.content.size || childB.content.size) {
            let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
            if (inner)
                return inner;
        }
        posA -= size;
        posB -= size;
    }
}

/**
A fragment represents a node's collection of child nodes.

Like nodes, fragments are persistent data structures, and you
should not mutate them or their content. Rather, you create new
instances whenever needed. The API tries to make this easy.
*/
class Fragment {
    /**
    @internal
    */
    constructor(
    /**
    @internal
    */
    content, size) {
        this.content = content;
        this.size = size || 0;
        if (size == null)
            for (let i = 0; i < content.length; i++)
                this.size += content[i].nodeSize;
    }
    /**
    Invoke a callback for all descendant nodes between the given two
    positions (relative to start of this fragment). Doesn't descend
    into a node when the callback returns `false`.
    */
    nodesBetween(from, to, f, nodeStart = 0, parent) {
        for (let i = 0, pos = 0; pos < to; i++) {
            let child = this.content[i], end = pos + child.nodeSize;
            if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
                let start = pos + 1;
                child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);
            }
            pos = end;
        }
    }
    /**
    Call the given callback for every descendant node. `pos` will be
    relative to the start of the fragment. The callback may return
    `false` to prevent traversal of a given node's children.
    */
    descendants(f) {
        this.nodesBetween(0, this.size, f);
    }
    /**
    Extract the text between `from` and `to`. See the same method on
    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
    */
    textBetween(from, to, blockSeparator, leafText) {
        let text = "", separated = true;
        this.nodesBetween(from, to, (node, pos) => {
            if (node.isText) {
                text += node.text.slice(Math.max(from, pos) - pos, to - pos);
                separated = !blockSeparator;
            }
            else if (node.isLeaf && leafText) {
                text += typeof leafText === 'function' ? leafText(node) : leafText;
                separated = !blockSeparator;
            }
            else if (!separated && node.isBlock) {
                text += blockSeparator;
                separated = true;
            }
        }, 0);
        return text;
    }
    /**
    Create a new fragment containing the combined content of this
    fragment and the other.
    */
    append(other) {
        if (!other.size)
            return this;
        if (!this.size)
            return other;
        let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;
        if (last.isText && last.sameMarkup(first)) {
            content[content.length - 1] = last.withText(last.text + first.text);
            i = 1;
        }
        for (; i < other.content.length; i++)
            content.push(other.content[i]);
        return new Fragment(content, this.size + other.size);
    }
    /**
    Cut out the sub-fragment between the two given positions.
    */
    cut(from, to = this.size) {
        if (from == 0 && to == this.size)
            return this;
        let result = [], size = 0;
        if (to > from)
            for (let i = 0, pos = 0; pos < to; i++) {
                let child = this.content[i], end = pos + child.nodeSize;
                if (end > from) {
                    if (pos < from || end > to) {
                        if (child.isText)
                            child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));
                        else
                            child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
                    }
                    result.push(child);
                    size += child.nodeSize;
                }
                pos = end;
            }
        return new Fragment(result, size);
    }
    /**
    @internal
    */
    cutByIndex(from, to) {
        if (from == to)
            return Fragment.empty;
        if (from == 0 && to == this.content.length)
            return this;
        return new Fragment(this.content.slice(from, to));
    }
    /**
    Create a new fragment in which the node at the given index is
    replaced by the given node.
    */
    replaceChild(index, node) {
        let current = this.content[index];
        if (current == node)
            return this;
        let copy = this.content.slice();
        let size = this.size + node.nodeSize - current.nodeSize;
        copy[index] = node;
        return new Fragment(copy, size);
    }
    /**
    Create a new fragment by prepending the given node to this
    fragment.
    */
    addToStart(node) {
        return new Fragment([node].concat(this.content), this.size + node.nodeSize);
    }
    /**
    Create a new fragment by appending the given node to this
    fragment.
    */
    addToEnd(node) {
        return new Fragment(this.content.concat(node), this.size + node.nodeSize);
    }
    /**
    Compare this fragment to another one.
    */
    eq(other) {
        if (this.content.length != other.content.length)
            return false;
        for (let i = 0; i < this.content.length; i++)
            if (!this.content[i].eq(other.content[i]))
                return false;
        return true;
    }
    /**
    The first child of the fragment, or `null` if it is empty.
    */
    get firstChild() { return this.content.length ? this.content[0] : null; }
    /**
    The last child of the fragment, or `null` if it is empty.
    */
    get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null; }
    /**
    The number of child nodes in this fragment.
    */
    get childCount() { return this.content.length; }
    /**
    Get the child node at the given index. Raise an error when the
    index is out of range.
    */
    child(index) {
        let found = this.content[index];
        if (!found)
            throw new RangeError("Index " + index + " out of range for " + this);
        return found;
    }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index) {
        return this.content[index] || null;
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f) {
        for (let i = 0, p = 0; i < this.content.length; i++) {
            let child = this.content[i];
            f(child, p, i);
            p += child.nodeSize;
        }
    }
    /**
    Find the first position at which this fragment and another
    fragment differ, or `null` if they are the same.
    */
    findDiffStart(other, pos = 0) {
        return findDiffStart(this, other, pos);
    }
    /**
    Find the first position, searching from the end, at which this
    fragment and the given fragment differ, or `null` if they are
    the same. Since this position will not be the same in both
    nodes, an object with two separate positions is returned.
    */
    findDiffEnd(other, pos = this.size, otherPos = other.size) {
        return findDiffEnd(this, other, pos, otherPos);
    }
    /**
    Find the index and inner offset corresponding to a given relative
    position in this fragment. The result object will be reused
    (overwritten) the next time the function is called. (Not public.)
    */
    findIndex(pos, round = -1) {
        if (pos == 0)
            return retIndex(0, pos);
        if (pos == this.size)
            return retIndex(this.content.length, pos);
        if (pos > this.size || pos < 0)
            throw new RangeError(`Position ${pos} outside of fragment (${this})`);
        for (let i = 0, curPos = 0;; i++) {
            let cur = this.child(i), end = curPos + cur.nodeSize;
            if (end >= pos) {
                if (end == pos || round > 0)
                    return retIndex(i + 1, end);
                return retIndex(i, curPos);
            }
            curPos = end;
        }
    }
    /**
    Return a debugging string that describes this fragment.
    */
    toString() { return "<" + this.toStringInner() + ">"; }
    /**
    @internal
    */
    toStringInner() { return this.content.join(", "); }
    /**
    Create a JSON-serializeable representation of this fragment.
    */
    toJSON() {
        return this.content.length ? this.content.map(n => n.toJSON()) : null;
    }
    /**
    Deserialize a fragment from its JSON representation.
    */
    static fromJSON(schema, value) {
        if (!value)
            return Fragment.empty;
        if (!Array.isArray(value))
            throw new RangeError("Invalid input for Fragment.fromJSON");
        return new Fragment(value.map(schema.nodeFromJSON));
    }
    /**
    Build a fragment from an array of nodes. Ensures that adjacent
    text nodes with the same marks are joined together.
    */
    static fromArray(array) {
        if (!array.length)
            return Fragment.empty;
        let joined, size = 0;
        for (let i = 0; i < array.length; i++) {
            let node = array[i];
            size += node.nodeSize;
            if (i && node.isText && array[i - 1].sameMarkup(node)) {
                if (!joined)
                    joined = array.slice(0, i);
                joined[joined.length - 1] = node
                    .withText(joined[joined.length - 1].text + node.text);
            }
            else if (joined) {
                joined.push(node);
            }
        }
        return new Fragment(joined || array, size);
    }
    /**
    Create a fragment from something that can be interpreted as a
    set of nodes. For `null`, it returns the empty fragment. For a
    fragment, the fragment itself. For a node or array of nodes, a
    fragment containing those nodes.
    */
    static from(nodes) {
        if (!nodes)
            return Fragment.empty;
        if (nodes instanceof Fragment)
            return nodes;
        if (Array.isArray(nodes))
            return this.fromArray(nodes);
        if (nodes.attrs)
            return new Fragment([nodes], nodes.nodeSize);
        throw new RangeError("Can not convert " + nodes + " to a Fragment" +
            (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
    }
}
/**
An empty fragment. Intended to be reused whenever a node doesn't
contain anything (rather than allocating a new empty fragment for
each leaf node).
*/
Fragment.empty = new Fragment([], 0);
const found = { index: 0, offset: 0 };
function retIndex(index, offset) {
    found.index = index;
    found.offset = offset;
    return found;
}

function compareDeep(a, b) {
    if (a === b)
        return true;
    if (!(a && typeof a == "object") ||
        !(b && typeof b == "object"))
        return false;
    let array = Array.isArray(a);
    if (Array.isArray(b) != array)
        return false;
    if (array) {
        if (a.length != b.length)
            return false;
        for (let i = 0; i < a.length; i++)
            if (!compareDeep(a[i], b[i]))
                return false;
    }
    else {
        for (let p in a)
            if (!(p in b) || !compareDeep(a[p], b[p]))
                return false;
        for (let p in b)
            if (!(p in a))
                return false;
    }
    return true;
}

/**
A mark is a piece of information that can be attached to a node,
such as it being emphasized, in code font, or a link. It has a
type and optionally a set of attributes that provide further
information (such as the target of the link). Marks are created
through a `Schema`, which controls which types exist and which
attributes they have.
*/
class Mark$1 {
    /**
    @internal
    */
    constructor(
    /**
    The type of this mark.
    */
    type, 
    /**
    The attributes associated with this mark.
    */
    attrs) {
        this.type = type;
        this.attrs = attrs;
    }
    /**
    Given a set of marks, create a new set which contains this one as
    well, in the right position. If this mark is already in the set,
    the set itself is returned. If any marks that are set to be
    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
    those are replaced by this one.
    */
    addToSet(set) {
        let copy, placed = false;
        for (let i = 0; i < set.length; i++) {
            let other = set[i];
            if (this.eq(other))
                return set;
            if (this.type.excludes(other.type)) {
                if (!copy)
                    copy = set.slice(0, i);
            }
            else if (other.type.excludes(this.type)) {
                return set;
            }
            else {
                if (!placed && other.type.rank > this.type.rank) {
                    if (!copy)
                        copy = set.slice(0, i);
                    copy.push(this);
                    placed = true;
                }
                if (copy)
                    copy.push(other);
            }
        }
        if (!copy)
            copy = set.slice();
        if (!placed)
            copy.push(this);
        return copy;
    }
    /**
    Remove this mark from the given set, returning a new set. If this
    mark is not in the set, the set itself is returned.
    */
    removeFromSet(set) {
        for (let i = 0; i < set.length; i++)
            if (this.eq(set[i]))
                return set.slice(0, i).concat(set.slice(i + 1));
        return set;
    }
    /**
    Test whether this mark is in the given set of marks.
    */
    isInSet(set) {
        for (let i = 0; i < set.length; i++)
            if (this.eq(set[i]))
                return true;
        return false;
    }
    /**
    Test whether this mark has the same type and attributes as
    another mark.
    */
    eq(other) {
        return this == other ||
            (this.type == other.type && compareDeep(this.attrs, other.attrs));
    }
    /**
    Convert this mark to a JSON-serializeable representation.
    */
    toJSON() {
        let obj = { type: this.type.name };
        for (let _ in this.attrs) {
            obj.attrs = this.attrs;
            break;
        }
        return obj;
    }
    /**
    Deserialize a mark from JSON.
    */
    static fromJSON(schema, json) {
        if (!json)
            throw new RangeError("Invalid input for Mark.fromJSON");
        let type = schema.marks[json.type];
        if (!type)
            throw new RangeError(`There is no mark type ${json.type} in this schema`);
        return type.create(json.attrs);
    }
    /**
    Test whether two sets of marks are identical.
    */
    static sameSet(a, b) {
        if (a == b)
            return true;
        if (a.length != b.length)
            return false;
        for (let i = 0; i < a.length; i++)
            if (!a[i].eq(b[i]))
                return false;
        return true;
    }
    /**
    Create a properly sorted mark set from null, a single mark, or an
    unsorted array of marks.
    */
    static setFrom(marks) {
        if (!marks || Array.isArray(marks) && marks.length == 0)
            return Mark$1.none;
        if (marks instanceof Mark$1)
            return [marks];
        let copy = marks.slice();
        copy.sort((a, b) => a.type.rank - b.type.rank);
        return copy;
    }
}
/**
The empty set of marks.
*/
Mark$1.none = [];

/**
Error type raised by [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) when
given an invalid replacement.
*/
class ReplaceError extends Error {
}
/*
ReplaceError = function(this: any, message: string) {
  let err = Error.call(this, message)
  ;(err as any).__proto__ = ReplaceError.prototype
  return err
} as any

ReplaceError.prototype = Object.create(Error.prototype)
ReplaceError.prototype.constructor = ReplaceError
ReplaceError.prototype.name = "ReplaceError"
*/
/**
A slice represents a piece cut out of a larger document. It
stores not only a fragment, but also the depth up to which nodes on
both side are ‘open’ (cut through).
*/
class Slice {
    /**
    Create a slice. When specifying a non-zero open depth, you must
    make sure that there are nodes of at least that depth at the
    appropriate side of the fragment—i.e. if the fragment is an
    empty paragraph node, `openStart` and `openEnd` can't be greater
    than 1.
    
    It is not necessary for the content of open nodes to conform to
    the schema's content constraints, though it should be a valid
    start/end/middle for such a node, depending on which sides are
    open.
    */
    constructor(
    /**
    The slice's content.
    */
    content, 
    /**
    The open depth at the start of the fragment.
    */
    openStart, 
    /**
    The open depth at the end.
    */
    openEnd) {
        this.content = content;
        this.openStart = openStart;
        this.openEnd = openEnd;
    }
    /**
    The size this slice would add when inserted into a document.
    */
    get size() {
        return this.content.size - this.openStart - this.openEnd;
    }
    /**
    @internal
    */
    insertAt(pos, fragment) {
        let content = insertInto(this.content, pos + this.openStart, fragment);
        return content && new Slice(content, this.openStart, this.openEnd);
    }
    /**
    @internal
    */
    removeBetween(from, to) {
        return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);
    }
    /**
    Tests whether this slice is equal to another slice.
    */
    eq(other) {
        return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
    }
    /**
    @internal
    */
    toString() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    }
    /**
    Convert a slice to a JSON-serializable representation.
    */
    toJSON() {
        if (!this.content.size)
            return null;
        let json = { content: this.content.toJSON() };
        if (this.openStart > 0)
            json.openStart = this.openStart;
        if (this.openEnd > 0)
            json.openEnd = this.openEnd;
        return json;
    }
    /**
    Deserialize a slice from its JSON representation.
    */
    static fromJSON(schema, json) {
        if (!json)
            return Slice.empty;
        let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
        if (typeof openStart != "number" || typeof openEnd != "number")
            throw new RangeError("Invalid input for Slice.fromJSON");
        return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
    }
    /**
    Create a slice from a fragment by taking the maximum possible
    open value on both side of the fragment.
    */
    static maxOpen(fragment, openIsolating = true) {
        let openStart = 0, openEnd = 0;
        for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
            openStart++;
        for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
            openEnd++;
        return new Slice(fragment, openStart, openEnd);
    }
}
/**
The empty slice.
*/
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from, to) {
    let { index, offset } = content.findIndex(from), child = content.maybeChild(index);
    let { index: indexTo, offset: offsetTo } = content.findIndex(to);
    if (offset == from || child.isText) {
        if (offsetTo != to && !content.child(indexTo).isText)
            throw new RangeError("Removing non-flat range");
        return content.cut(0, from).append(content.cut(to));
    }
    if (index != indexTo)
        throw new RangeError("Removing non-flat range");
    return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));
}
function insertInto(content, dist, insert, parent) {
    let { index, offset } = content.findIndex(dist), child = content.maybeChild(index);
    if (offset == dist || child.isText) {
        if (parent && !parent.canReplace(index, index, insert))
            return null;
        return content.cut(0, dist).append(insert).append(content.cut(dist));
    }
    let inner = insertInto(child.content, dist - offset - 1, insert);
    return inner && content.replaceChild(index, child.copy(inner));
}
function replace($from, $to, slice) {
    if (slice.openStart > $from.depth)
        throw new ReplaceError("Inserted content deeper than insertion position");
    if ($from.depth - slice.openStart != $to.depth - slice.openEnd)
        throw new ReplaceError("Inconsistent open depths");
    return replaceOuter($from, $to, slice, 0);
}
function replaceOuter($from, $to, slice, depth) {
    let index = $from.index(depth), node = $from.node(depth);
    if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
        let inner = replaceOuter($from, $to, slice, depth + 1);
        return node.copy(node.content.replaceChild(index, inner));
    }
    else if (!slice.content.size) {
        return close(node, replaceTwoWay($from, $to, depth));
    }
    else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case
        let parent = $from.parent, content = parent.content;
        return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));
    }
    else {
        let { start, end } = prepareSliceForReplace(slice, $from);
        return close(node, replaceThreeWay($from, start, end, $to, depth));
    }
}
function checkJoin(main, sub) {
    if (!sub.type.compatibleContent(main.type))
        throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}
function joinable$1($before, $after, depth) {
    let node = $before.node(depth);
    checkJoin(node, $after.node(depth));
    return node;
}
function addNode(child, target) {
    let last = target.length - 1;
    if (last >= 0 && child.isText && child.sameMarkup(target[last]))
        target[last] = child.withText(target[last].text + child.text);
    else
        target.push(child);
}
function addRange($start, $end, depth, target) {
    let node = ($end || $start).node(depth);
    let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
    if ($start) {
        startIndex = $start.index(depth);
        if ($start.depth > depth) {
            startIndex++;
        }
        else if ($start.textOffset) {
            addNode($start.nodeAfter, target);
            startIndex++;
        }
    }
    for (let i = startIndex; i < endIndex; i++)
        addNode(node.child(i), target);
    if ($end && $end.depth == depth && $end.textOffset)
        addNode($end.nodeBefore, target);
}
function close(node, content) {
    if (!node.type.validContent(content))
        throw new ReplaceError("Invalid content for node " + node.type.name);
    return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
    let openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
    let openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
    let content = [];
    addRange(null, $from, depth, content);
    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
        checkJoin(openStart, openEnd);
        addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
    }
    else {
        if (openStart)
            addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
        addRange($start, $end, depth, content);
        if (openEnd)
            addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
    }
    addRange($to, null, depth, content);
    return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
    let content = [];
    addRange(null, $from, depth, content);
    if ($from.depth > depth) {
        let type = joinable$1($from, $to, depth + 1);
        addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
    }
    addRange($to, null, depth, content);
    return new Fragment(content);
}
function prepareSliceForReplace(slice, $along) {
    let extra = $along.depth - slice.openStart, parent = $along.node(extra);
    let node = parent.copy(slice.content);
    for (let i = extra - 1; i >= 0; i--)
        node = $along.node(i).copy(Fragment.from(node));
    return { start: node.resolveNoCache(slice.openStart + extra),
        end: node.resolveNoCache(node.content.size - slice.openEnd - extra) };
}

/**
You can [_resolve_](https://prosemirror.net/docs/ref/#model.Node.resolve) a position to get more
information about it. Objects of this class represent such a
resolved position, providing various pieces of context
information, and some helper methods.

Throughout this interface, methods that take an optional `depth`
parameter will interpret undefined as `this.depth` and negative
numbers as `this.depth + value`.
*/
class ResolvedPos {
    /**
    @internal
    */
    constructor(
    /**
    The position that was resolved.
    */
    pos, 
    /**
    @internal
    */
    path, 
    /**
    The offset this position has into its parent node.
    */
    parentOffset) {
        this.pos = pos;
        this.path = path;
        this.parentOffset = parentOffset;
        this.depth = path.length / 3 - 1;
    }
    /**
    @internal
    */
    resolveDepth(val) {
        if (val == null)
            return this.depth;
        if (val < 0)
            return this.depth + val;
        return val;
    }
    /**
    The parent node that the position points into. Note that even if
    a position points into a text node, that node is not considered
    the parent—text nodes are ‘flat’ in this model, and have no content.
    */
    get parent() { return this.node(this.depth); }
    /**
    The root node in which the position was resolved.
    */
    get doc() { return this.node(0); }
    /**
    The ancestor node at the given level. `p.node(p.depth)` is the
    same as `p.parent`.
    */
    node(depth) { return this.path[this.resolveDepth(depth) * 3]; }
    /**
    The index into the ancestor at the given level. If this points
    at the 3rd node in the 2nd paragraph on the top level, for
    example, `p.index(0)` is 1 and `p.index(1)` is 2.
    */
    index(depth) { return this.path[this.resolveDepth(depth) * 3 + 1]; }
    /**
    The index pointing after this position into the ancestor at the
    given level.
    */
    indexAfter(depth) {
        depth = this.resolveDepth(depth);
        return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
    }
    /**
    The (absolute) position at the start of the node at the given
    level.
    */
    start(depth) {
        depth = this.resolveDepth(depth);
        return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    }
    /**
    The (absolute) position at the end of the node at the given
    level.
    */
    end(depth) {
        depth = this.resolveDepth(depth);
        return this.start(depth) + this.node(depth).content.size;
    }
    /**
    The (absolute) position directly before the wrapping node at the
    given level, or, when `depth` is `this.depth + 1`, the original
    position.
    */
    before(depth) {
        depth = this.resolveDepth(depth);
        if (!depth)
            throw new RangeError("There is no position before the top-level node");
        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
    }
    /**
    The (absolute) position directly after the wrapping node at the
    given level, or the original position when `depth` is `this.depth + 1`.
    */
    after(depth) {
        depth = this.resolveDepth(depth);
        if (!depth)
            throw new RangeError("There is no position after the top-level node");
        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
    }
    /**
    When this position points into a text node, this returns the
    distance between the position and the start of the text node.
    Will be zero for positions that point between nodes.
    */
    get textOffset() { return this.pos - this.path[this.path.length - 1]; }
    /**
    Get the node directly after the position, if any. If the position
    points into a text node, only the part of that node after the
    position is returned.
    */
    get nodeAfter() {
        let parent = this.parent, index = this.index(this.depth);
        if (index == parent.childCount)
            return null;
        let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
        return dOff ? parent.child(index).cut(dOff) : child;
    }
    /**
    Get the node directly before the position, if any. If the
    position points into a text node, only the part of that node
    before the position is returned.
    */
    get nodeBefore() {
        let index = this.index(this.depth);
        let dOff = this.pos - this.path[this.path.length - 1];
        if (dOff)
            return this.parent.child(index).cut(0, dOff);
        return index == 0 ? null : this.parent.child(index - 1);
    }
    /**
    Get the position at the given index in the parent node at the
    given depth (which defaults to `this.depth`).
    */
    posAtIndex(index, depth) {
        depth = this.resolveDepth(depth);
        let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
        for (let i = 0; i < index; i++)
            pos += node.child(i).nodeSize;
        return pos;
    }
    /**
    Get the marks at this position, factoring in the surrounding
    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
    position is at the start of a non-empty node, the marks of the
    node after it (if any) are returned.
    */
    marks() {
        let parent = this.parent, index = this.index();
        // In an empty parent, return the empty array
        if (parent.content.size == 0)
            return Mark$1.none;
        // When inside a text node, just return the text node's marks
        if (this.textOffset)
            return parent.child(index).marks;
        let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
        // If the `after` flag is true of there is no node before, make
        // the node after this position the main reference.
        if (!main) {
            let tmp = main;
            main = other;
            other = tmp;
        }
        // Use all marks in the main node, except those that have
        // `inclusive` set to false and are not present in the other node.
        let marks = main.marks;
        for (var i = 0; i < marks.length; i++)
            if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
                marks = marks[i--].removeFromSet(marks);
        return marks;
    }
    /**
    Get the marks after the current position, if any, except those
    that are non-inclusive and not present at position `$end`. This
    is mostly useful for getting the set of marks to preserve after a
    deletion. Will return `null` if this position is at the end of
    its parent node or its parent node isn't a textblock (in which
    case no marks should be preserved).
    */
    marksAcross($end) {
        let after = this.parent.maybeChild(this.index());
        if (!after || !after.isInline)
            return null;
        let marks = after.marks, next = $end.parent.maybeChild($end.index());
        for (var i = 0; i < marks.length; i++)
            if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
                marks = marks[i--].removeFromSet(marks);
        return marks;
    }
    /**
    The depth up to which this position and the given (non-resolved)
    position share the same parent nodes.
    */
    sharedDepth(pos) {
        for (let depth = this.depth; depth > 0; depth--)
            if (this.start(depth) <= pos && this.end(depth) >= pos)
                return depth;
        return 0;
    }
    /**
    Returns a range based on the place where this position and the
    given position diverge around block content. If both point into
    the same textblock, for example, a range around that textblock
    will be returned. If they point into different blocks, the range
    around those blocks in their shared ancestor is returned. You can
    pass in an optional predicate that will be called with a parent
    node to see if a range into that parent is acceptable.
    */
    blockRange(other = this, pred) {
        if (other.pos < this.pos)
            return other.blockRange(this);
        for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
            if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
                return new NodeRange(this, other, d);
        return null;
    }
    /**
    Query whether the given position shares the same parent node.
    */
    sameParent(other) {
        return this.pos - this.parentOffset == other.pos - other.parentOffset;
    }
    /**
    Return the greater of this and the given position.
    */
    max(other) {
        return other.pos > this.pos ? other : this;
    }
    /**
    Return the smaller of this and the given position.
    */
    min(other) {
        return other.pos < this.pos ? other : this;
    }
    /**
    @internal
    */
    toString() {
        let str = "";
        for (let i = 1; i <= this.depth; i++)
            str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
        return str + ":" + this.parentOffset;
    }
    /**
    @internal
    */
    static resolve(doc, pos) {
        if (!(pos >= 0 && pos <= doc.content.size))
            throw new RangeError("Position " + pos + " out of range");
        let path = [];
        let start = 0, parentOffset = pos;
        for (let node = doc;;) {
            let { index, offset } = node.content.findIndex(parentOffset);
            let rem = parentOffset - offset;
            path.push(node, index, start + offset);
            if (!rem)
                break;
            node = node.child(index);
            if (node.isText)
                break;
            parentOffset = rem - 1;
            start += offset + 1;
        }
        return new ResolvedPos(pos, path, parentOffset);
    }
    /**
    @internal
    */
    static resolveCached(doc, pos) {
        for (let i = 0; i < resolveCache.length; i++) {
            let cached = resolveCache[i];
            if (cached.pos == pos && cached.doc == doc)
                return cached;
        }
        let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);
        resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
        return result;
    }
}
let resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;
/**
Represents a flat range of content, i.e. one that starts and
ends in the same node.
*/
class NodeRange {
    /**
    Construct a node range. `$from` and `$to` should point into the
    same node until at least the given `depth`, since a node range
    denotes an adjacent set of nodes in a single parent node.
    */
    constructor(
    /**
    A resolved position along the start of the content. May have a
    `depth` greater than this object's `depth` property, since
    these are the positions that were used to compute the range,
    not re-resolved positions directly at its boundaries.
    */
    $from, 
    /**
    A position along the end of the content. See
    caveat for [`$from`](https://prosemirror.net/docs/ref/#model.NodeRange.$from).
    */
    $to, 
    /**
    The depth of the node that this range points into.
    */
    depth) {
        this.$from = $from;
        this.$to = $to;
        this.depth = depth;
    }
    /**
    The position at the start of the range.
    */
    get start() { return this.$from.before(this.depth + 1); }
    /**
    The position at the end of the range.
    */
    get end() { return this.$to.after(this.depth + 1); }
    /**
    The parent node that the range points into.
    */
    get parent() { return this.$from.node(this.depth); }
    /**
    The start index of the range in the parent node.
    */
    get startIndex() { return this.$from.index(this.depth); }
    /**
    The end index of the range in the parent node.
    */
    get endIndex() { return this.$to.indexAfter(this.depth); }
}

const emptyAttrs = Object.create(null);
/**
This class represents a node in the tree that makes up a
ProseMirror document. So a document is an instance of `Node`, with
children that are also instances of `Node`.

Nodes are persistent data structures. Instead of changing them, you
create new ones with the content you want. Old ones keep pointing
at the old document shape. This is made cheaper by sharing
structure between the old and new data as much as possible, which a
tree shape like this (without back pointers) makes easy.

**Do not** directly mutate the properties of a `Node` object. See
[the guide](/docs/guide/#doc) for more information.
*/
class Node$1 {
    /**
    @internal
    */
    constructor(
    /**
    The type of node that this is.
    */
    type, 
    /**
    An object mapping attribute names to values. The kind of
    attributes allowed and required are
    [determined](https://prosemirror.net/docs/ref/#model.NodeSpec.attrs) by the node type.
    */
    attrs, 
    // A fragment holding the node's children.
    content, 
    /**
    The marks (things like whether it is emphasized or part of a
    link) applied to this node.
    */
    marks = Mark$1.none) {
        this.type = type;
        this.attrs = attrs;
        this.marks = marks;
        this.content = content || Fragment.empty;
    }
    /**
    The size of this node, as defined by the integer-based [indexing
    scheme](/docs/guide/#doc.indexing). For text nodes, this is the
    amount of characters. For other leaf nodes, it is one. For
    non-leaf nodes, it is the size of the content plus two (the
    start and end token).
    */
    get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size; }
    /**
    The number of children that the node has.
    */
    get childCount() { return this.content.childCount; }
    /**
    Get the child node at the given index. Raises an error when the
    index is out of range.
    */
    child(index) { return this.content.child(index); }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index) { return this.content.maybeChild(index); }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f) { this.content.forEach(f); }
    /**
    Invoke a callback for all descendant nodes recursively between
    the given two positions that are relative to start of this
    node's content. The callback is invoked with the node, its
    parent-relative position, its parent node, and its child index.
    When the callback returns false for a given node, that node's
    children will not be recursed over. The last parameter can be
    used to specify a starting position to count from.
    */
    nodesBetween(from, to, f, startPos = 0) {
        this.content.nodesBetween(from, to, f, startPos, this);
    }
    /**
    Call the given callback for every descendant node. Doesn't
    descend into a node when the callback returns `false`.
    */
    descendants(f) {
        this.nodesBetween(0, this.content.size, f);
    }
    /**
    Concatenates all the text nodes found in this fragment and its
    children.
    */
    get textContent() { return this.textBetween(0, this.content.size, ""); }
    /**
    Get all text between positions `from` and `to`. When
    `blockSeparator` is given, it will be inserted to separate text
    from different block nodes. When `leafText` is given, it'll be
    inserted for every non-text leaf node encountered.
    */
    textBetween(from, to, blockSeparator, leafText) {
        return this.content.textBetween(from, to, blockSeparator, leafText);
    }
    /**
    Returns this node's first child, or `null` if there are no
    children.
    */
    get firstChild() { return this.content.firstChild; }
    /**
    Returns this node's last child, or `null` if there are no
    children.
    */
    get lastChild() { return this.content.lastChild; }
    /**
    Test whether two nodes represent the same piece of document.
    */
    eq(other) {
        return this == other || (this.sameMarkup(other) && this.content.eq(other.content));
    }
    /**
    Compare the markup (type, attributes, and marks) of this node to
    those of another. Returns `true` if both have the same markup.
    */
    sameMarkup(other) {
        return this.hasMarkup(other.type, other.attrs, other.marks);
    }
    /**
    Check whether this node's markup correspond to the given type,
    attributes, and marks.
    */
    hasMarkup(type, attrs, marks) {
        return this.type == type &&
            compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&
            Mark$1.sameSet(this.marks, marks || Mark$1.none);
    }
    /**
    Create a new node with the same markup as this node, containing
    the given content (or empty, if no content is given).
    */
    copy(content = null) {
        if (content == this.content)
            return this;
        return new Node$1(this.type, this.attrs, content, this.marks);
    }
    /**
    Create a copy of this node, with the given set of marks instead
    of the node's own marks.
    */
    mark(marks) {
        return marks == this.marks ? this : new Node$1(this.type, this.attrs, this.content, marks);
    }
    /**
    Create a copy of this node with only the content between the
    given positions. If `to` is not given, it defaults to the end of
    the node.
    */
    cut(from, to = this.content.size) {
        if (from == 0 && to == this.content.size)
            return this;
        return this.copy(this.content.cut(from, to));
    }
    /**
    Cut out the part of the document between the given positions, and
    return it as a `Slice` object.
    */
    slice(from, to = this.content.size, includeParents = false) {
        if (from == to)
            return Slice.empty;
        let $from = this.resolve(from), $to = this.resolve(to);
        let depth = includeParents ? 0 : $from.sharedDepth(to);
        let start = $from.start(depth), node = $from.node(depth);
        let content = node.content.cut($from.pos - start, $to.pos - start);
        return new Slice(content, $from.depth - depth, $to.depth - depth);
    }
    /**
    Replace the part of the document between the given positions with
    the given slice. The slice must 'fit', meaning its open sides
    must be able to connect to the surrounding content, and its
    content nodes must be valid children for the node they are placed
    into. If any of this is violated, an error of type
    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
    */
    replace(from, to, slice) {
        return replace(this.resolve(from), this.resolve(to), slice);
    }
    /**
    Find the node directly after the given position.
    */
    nodeAt(pos) {
        for (let node = this;;) {
            let { index, offset } = node.content.findIndex(pos);
            node = node.maybeChild(index);
            if (!node)
                return null;
            if (offset == pos || node.isText)
                return node;
            pos -= offset + 1;
        }
    }
    /**
    Find the (direct) child node after the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childAfter(pos) {
        let { index, offset } = this.content.findIndex(pos);
        return { node: this.content.maybeChild(index), index, offset };
    }
    /**
    Find the (direct) child node before the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childBefore(pos) {
        if (pos == 0)
            return { node: null, index: 0, offset: 0 };
        let { index, offset } = this.content.findIndex(pos);
        if (offset < pos)
            return { node: this.content.child(index), index, offset };
        let node = this.content.child(index - 1);
        return { node, index: index - 1, offset: offset - node.nodeSize };
    }
    /**
    Resolve the given position in the document, returning an
    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
    */
    resolve(pos) { return ResolvedPos.resolveCached(this, pos); }
    /**
    @internal
    */
    resolveNoCache(pos) { return ResolvedPos.resolve(this, pos); }
    /**
    Test whether a given mark or mark type occurs in this document
    between the two given positions.
    */
    rangeHasMark(from, to, type) {
        let found = false;
        if (to > from)
            this.nodesBetween(from, to, node => {
                if (type.isInSet(node.marks))
                    found = true;
                return !found;
            });
        return found;
    }
    /**
    True when this is a block (non-inline node)
    */
    get isBlock() { return this.type.isBlock; }
    /**
    True when this is a textblock node, a block node with inline
    content.
    */
    get isTextblock() { return this.type.isTextblock; }
    /**
    True when this node allows inline content.
    */
    get inlineContent() { return this.type.inlineContent; }
    /**
    True when this is an inline node (a text node or a node that can
    appear among text).
    */
    get isInline() { return this.type.isInline; }
    /**
    True when this is a text node.
    */
    get isText() { return this.type.isText; }
    /**
    True when this is a leaf node.
    */
    get isLeaf() { return this.type.isLeaf; }
    /**
    True when this is an atom, i.e. when it does not have directly
    editable content. This is usually the same as `isLeaf`, but can
    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
    on a node's spec (typically used when the node is displayed as
    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
    */
    get isAtom() { return this.type.isAtom; }
    /**
    Return a string representation of this node for debugging
    purposes.
    */
    toString() {
        if (this.type.spec.toDebugString)
            return this.type.spec.toDebugString(this);
        let name = this.type.name;
        if (this.content.size)
            name += "(" + this.content.toStringInner() + ")";
        return wrapMarks(this.marks, name);
    }
    /**
    Get the content match in this node at the given index.
    */
    contentMatchAt(index) {
        let match = this.type.contentMatch.matchFragment(this.content, 0, index);
        if (!match)
            throw new Error("Called contentMatchAt on a node with invalid content");
        return match;
    }
    /**
    Test whether replacing the range between `from` and `to` (by
    child index) with the given replacement fragment (which defaults
    to the empty fragment) would leave the node's content valid. You
    can optionally pass `start` and `end` indices into the
    replacement fragment.
    */
    canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {
        let one = this.contentMatchAt(from).matchFragment(replacement, start, end);
        let two = one && one.matchFragment(this.content, to);
        if (!two || !two.validEnd)
            return false;
        for (let i = start; i < end; i++)
            if (!this.type.allowsMarks(replacement.child(i).marks))
                return false;
        return true;
    }
    /**
    Test whether replacing the range `from` to `to` (by index) with
    a node of the given type would leave the node's content valid.
    */
    canReplaceWith(from, to, type, marks) {
        if (marks && !this.type.allowsMarks(marks))
            return false;
        let start = this.contentMatchAt(from).matchType(type);
        let end = start && start.matchFragment(this.content, to);
        return end ? end.validEnd : false;
    }
    /**
    Test whether the given node's content could be appended to this
    node. If that node is empty, this will only return true if there
    is at least one node type that can appear in both nodes (to avoid
    merging completely incompatible nodes).
    */
    canAppend(other) {
        if (other.content.size)
            return this.canReplace(this.childCount, this.childCount, other.content);
        else
            return this.type.compatibleContent(other.type);
    }
    /**
    Check whether this node and its descendants conform to the
    schema, and raise error when they do not.
    */
    check() {
        if (!this.type.validContent(this.content))
            throw new RangeError(`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0, 50)}`);
        let copy = Mark$1.none;
        for (let i = 0; i < this.marks.length; i++)
            copy = this.marks[i].addToSet(copy);
        if (!Mark$1.sameSet(copy, this.marks))
            throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(m => m.type.name)}`);
        this.content.forEach(node => node.check());
    }
    /**
    Return a JSON-serializeable representation of this node.
    */
    toJSON() {
        let obj = { type: this.type.name };
        for (let _ in this.attrs) {
            obj.attrs = this.attrs;
            break;
        }
        if (this.content.size)
            obj.content = this.content.toJSON();
        if (this.marks.length)
            obj.marks = this.marks.map(n => n.toJSON());
        return obj;
    }
    /**
    Deserialize a node from its JSON representation.
    */
    static fromJSON(schema, json) {
        if (!json)
            throw new RangeError("Invalid input for Node.fromJSON");
        let marks = null;
        if (json.marks) {
            if (!Array.isArray(json.marks))
                throw new RangeError("Invalid mark data for Node.fromJSON");
            marks = json.marks.map(schema.markFromJSON);
        }
        if (json.type == "text") {
            if (typeof json.text != "string")
                throw new RangeError("Invalid text node in JSON");
            return schema.text(json.text, marks);
        }
        let content = Fragment.fromJSON(schema, json.content);
        return schema.nodeType(json.type).create(json.attrs, content, marks);
    }
}
Node$1.prototype.text = undefined;
class TextNode extends Node$1 {
    /**
    @internal
    */
    constructor(type, attrs, content, marks) {
        super(type, attrs, null, marks);
        if (!content)
            throw new RangeError("Empty text nodes are not allowed");
        this.text = content;
    }
    toString() {
        if (this.type.spec.toDebugString)
            return this.type.spec.toDebugString(this);
        return wrapMarks(this.marks, JSON.stringify(this.text));
    }
    get textContent() { return this.text; }
    textBetween(from, to) { return this.text.slice(from, to); }
    get nodeSize() { return this.text.length; }
    mark(marks) {
        return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
    }
    withText(text) {
        if (text == this.text)
            return this;
        return new TextNode(this.type, this.attrs, text, this.marks);
    }
    cut(from = 0, to = this.text.length) {
        if (from == 0 && to == this.text.length)
            return this;
        return this.withText(this.text.slice(from, to));
    }
    eq(other) {
        return this.sameMarkup(other) && this.text == other.text;
    }
    toJSON() {
        let base = super.toJSON();
        base.text = this.text;
        return base;
    }
}
function wrapMarks(marks, str) {
    for (let i = marks.length - 1; i >= 0; i--)
        str = marks[i].type.name + "(" + str + ")";
    return str;
}

/**
Instances of this class represent a match state of a node type's
[content expression](https://prosemirror.net/docs/ref/#model.NodeSpec.content), and can be used to
find out whether further content matches here, and whether a given
position is a valid end of the node.
*/
class ContentMatch {
    /**
    @internal
    */
    constructor(
    /**
    True when this match state represents a valid end of the node.
    */
    validEnd) {
        this.validEnd = validEnd;
        /**
        @internal
        */
        this.next = [];
        /**
        @internal
        */
        this.wrapCache = [];
    }
    /**
    @internal
    */
    static parse(string, nodeTypes) {
        let stream = new TokenStream(string, nodeTypes);
        if (stream.next == null)
            return ContentMatch.empty;
        let expr = parseExpr(stream);
        if (stream.next)
            stream.err("Unexpected trailing text");
        let match = dfa(nfa(expr));
        checkForDeadEnds(match, stream);
        return match;
    }
    /**
    Match a node type, returning a match after that node if
    successful.
    */
    matchType(type) {
        for (let i = 0; i < this.next.length; i++)
            if (this.next[i].type == type)
                return this.next[i].next;
        return null;
    }
    /**
    Try to match a fragment. Returns the resulting match when
    successful.
    */
    matchFragment(frag, start = 0, end = frag.childCount) {
        let cur = this;
        for (let i = start; cur && i < end; i++)
            cur = cur.matchType(frag.child(i).type);
        return cur;
    }
    /**
    @internal
    */
    get inlineContent() {
        return this.next.length && this.next[0].type.isInline;
    }
    /**
    Get the first matching node type at this match position that can
    be generated.
    */
    get defaultType() {
        for (let i = 0; i < this.next.length; i++) {
            let { type } = this.next[i];
            if (!(type.isText || type.hasRequiredAttrs()))
                return type;
        }
        return null;
    }
    /**
    @internal
    */
    compatible(other) {
        for (let i = 0; i < this.next.length; i++)
            for (let j = 0; j < other.next.length; j++)
                if (this.next[i].type == other.next[j].type)
                    return true;
        return false;
    }
    /**
    Try to match the given fragment, and if that fails, see if it can
    be made to match by inserting nodes in front of it. When
    successful, return a fragment of inserted nodes (which may be
    empty if nothing had to be inserted). When `toEnd` is true, only
    return a fragment if the resulting match goes to the end of the
    content expression.
    */
    fillBefore(after, toEnd = false, startIndex = 0) {
        let seen = [this];
        function search(match, types) {
            let finished = match.matchFragment(after, startIndex);
            if (finished && (!toEnd || finished.validEnd))
                return Fragment.from(types.map(tp => tp.createAndFill()));
            for (let i = 0; i < match.next.length; i++) {
                let { type, next } = match.next[i];
                if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
                    seen.push(next);
                    let found = search(next, types.concat(type));
                    if (found)
                        return found;
                }
            }
            return null;
        }
        return search(this, []);
    }
    /**
    Find a set of wrapping node types that would allow a node of the
    given type to appear at this position. The result may be empty
    (when it fits directly) and will be null when no such wrapping
    exists.
    */
    findWrapping(target) {
        for (let i = 0; i < this.wrapCache.length; i += 2)
            if (this.wrapCache[i] == target)
                return this.wrapCache[i + 1];
        let computed = this.computeWrapping(target);
        this.wrapCache.push(target, computed);
        return computed;
    }
    /**
    @internal
    */
    computeWrapping(target) {
        let seen = Object.create(null), active = [{ match: this, type: null, via: null }];
        while (active.length) {
            let current = active.shift(), match = current.match;
            if (match.matchType(target)) {
                let result = [];
                for (let obj = current; obj.type; obj = obj.via)
                    result.push(obj.type);
                return result.reverse();
            }
            for (let i = 0; i < match.next.length; i++) {
                let { type, next } = match.next[i];
                if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
                    active.push({ match: type.contentMatch, type, via: current });
                    seen[type.name] = true;
                }
            }
        }
        return null;
    }
    /**
    The number of outgoing edges this node has in the finite
    automaton that describes the content expression.
    */
    get edgeCount() {
        return this.next.length;
    }
    /**
    Get the _n_​th outgoing edge from this node in the finite
    automaton that describes the content expression.
    */
    edge(n) {
        if (n >= this.next.length)
            throw new RangeError(`There's no ${n}th edge in this content match`);
        return this.next[n];
    }
    /**
    @internal
    */
    toString() {
        let seen = [];
        function scan(m) {
            seen.push(m);
            for (let i = 0; i < m.next.length; i++)
                if (seen.indexOf(m.next[i].next) == -1)
                    scan(m.next[i].next);
        }
        scan(this);
        return seen.map((m, i) => {
            let out = i + (m.validEnd ? "*" : " ") + " ";
            for (let i = 0; i < m.next.length; i++)
                out += (i ? ", " : "") + m.next[i].type.name + "->" + seen.indexOf(m.next[i].next);
            return out;
        }).join("\n");
    }
}
/**
@internal
*/
ContentMatch.empty = new ContentMatch(true);
class TokenStream {
    constructor(string, nodeTypes) {
        this.string = string;
        this.nodeTypes = nodeTypes;
        this.inline = null;
        this.pos = 0;
        this.tokens = string.split(/\s*(?=\b|\W|$)/);
        if (this.tokens[this.tokens.length - 1] == "")
            this.tokens.pop();
        if (this.tokens[0] == "")
            this.tokens.shift();
    }
    get next() { return this.tokens[this.pos]; }
    eat(tok) { return this.next == tok && (this.pos++ || true); }
    err(str) { throw new SyntaxError(str + " (in content expression '" + this.string + "')"); }
}
function parseExpr(stream) {
    let exprs = [];
    do {
        exprs.push(parseExprSeq(stream));
    } while (stream.eat("|"));
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
    let exprs = [];
    do {
        exprs.push(parseExprSubscript(stream));
    } while (stream.next && stream.next != ")" && stream.next != "|");
    return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
    let expr = parseExprAtom(stream);
    for (;;) {
        if (stream.eat("+"))
            expr = { type: "plus", expr };
        else if (stream.eat("*"))
            expr = { type: "star", expr };
        else if (stream.eat("?"))
            expr = { type: "opt", expr };
        else if (stream.eat("{"))
            expr = parseExprRange(stream, expr);
        else
            break;
    }
    return expr;
}
function parseNum(stream) {
    if (/\D/.test(stream.next))
        stream.err("Expected number, got '" + stream.next + "'");
    let result = Number(stream.next);
    stream.pos++;
    return result;
}
function parseExprRange(stream, expr) {
    let min = parseNum(stream), max = min;
    if (stream.eat(",")) {
        if (stream.next != "}")
            max = parseNum(stream);
        else
            max = -1;
    }
    if (!stream.eat("}"))
        stream.err("Unclosed braced range");
    return { type: "range", min, max, expr };
}
function resolveName(stream, name) {
    let types = stream.nodeTypes, type = types[name];
    if (type)
        return [type];
    let result = [];
    for (let typeName in types) {
        let type = types[typeName];
        if (type.groups.indexOf(name) > -1)
            result.push(type);
    }
    if (result.length == 0)
        stream.err("No node type or group '" + name + "' found");
    return result;
}
function parseExprAtom(stream) {
    if (stream.eat("(")) {
        let expr = parseExpr(stream);
        if (!stream.eat(")"))
            stream.err("Missing closing paren");
        return expr;
    }
    else if (!/\W/.test(stream.next)) {
        let exprs = resolveName(stream, stream.next).map(type => {
            if (stream.inline == null)
                stream.inline = type.isInline;
            else if (stream.inline != type.isInline)
                stream.err("Mixing inline and block content");
            return { type: "name", value: type };
        });
        stream.pos++;
        return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
    }
    else {
        stream.err("Unexpected token '" + stream.next + "'");
    }
}
/**
Construct an NFA from an expression as returned by the parser. The
NFA is represented as an array of states, which are themselves
arrays of edges, which are `{term, to}` objects. The first state is
the entry state and the last node is the success state.

Note that unlike typical NFAs, the edge ordering in this one is
significant, in that it is used to contruct filler content when
necessary.
*/
function nfa(expr) {
    let nfa = [[]];
    connect(compile(expr, 0), node());
    return nfa;
    function node() { return nfa.push([]) - 1; }
    function edge(from, to, term) {
        let edge = { term, to };
        nfa[from].push(edge);
        return edge;
    }
    function connect(edges, to) {
        edges.forEach(edge => edge.to = to);
    }
    function compile(expr, from) {
        if (expr.type == "choice") {
            return expr.exprs.reduce((out, expr) => out.concat(compile(expr, from)), []);
        }
        else if (expr.type == "seq") {
            for (let i = 0;; i++) {
                let next = compile(expr.exprs[i], from);
                if (i == expr.exprs.length - 1)
                    return next;
                connect(next, from = node());
            }
        }
        else if (expr.type == "star") {
            let loop = node();
            edge(from, loop);
            connect(compile(expr.expr, loop), loop);
            return [edge(loop)];
        }
        else if (expr.type == "plus") {
            let loop = node();
            connect(compile(expr.expr, from), loop);
            connect(compile(expr.expr, loop), loop);
            return [edge(loop)];
        }
        else if (expr.type == "opt") {
            return [edge(from)].concat(compile(expr.expr, from));
        }
        else if (expr.type == "range") {
            let cur = from;
            for (let i = 0; i < expr.min; i++) {
                let next = node();
                connect(compile(expr.expr, cur), next);
                cur = next;
            }
            if (expr.max == -1) {
                connect(compile(expr.expr, cur), cur);
            }
            else {
                for (let i = expr.min; i < expr.max; i++) {
                    let next = node();
                    edge(cur, next);
                    connect(compile(expr.expr, cur), next);
                    cur = next;
                }
            }
            return [edge(cur)];
        }
        else if (expr.type == "name") {
            return [edge(from, undefined, expr.value)];
        }
        else {
            throw new Error("Unknown expr type");
        }
    }
}
function cmp(a, b) { return b - a; }
// Get the set of nodes reachable by null edges from `node`. Omit
// nodes with only a single null-out-edge, since they may lead to
// needless duplicated nodes.
function nullFrom(nfa, node) {
    let result = [];
    scan(node);
    return result.sort(cmp);
    function scan(node) {
        let edges = nfa[node];
        if (edges.length == 1 && !edges[0].term)
            return scan(edges[0].to);
        result.push(node);
        for (let i = 0; i < edges.length; i++) {
            let { term, to } = edges[i];
            if (!term && result.indexOf(to) == -1)
                scan(to);
        }
    }
}
// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set
// of state objects (`ContentMatch` instances) with transitions
// between them.
function dfa(nfa) {
    let labeled = Object.create(null);
    return explore(nullFrom(nfa, 0));
    function explore(states) {
        let out = [];
        states.forEach(node => {
            nfa[node].forEach(({ term, to }) => {
                if (!term)
                    return;
                let set;
                for (let i = 0; i < out.length; i++)
                    if (out[i][0] == term)
                        set = out[i][1];
                nullFrom(nfa, to).forEach(node => {
                    if (!set)
                        out.push([term, set = []]);
                    if (set.indexOf(node) == -1)
                        set.push(node);
                });
            });
        });
        let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);
        for (let i = 0; i < out.length; i++) {
            let states = out[i][1].sort(cmp);
            state.next.push({ type: out[i][0], next: labeled[states.join(",")] || explore(states) });
        }
        return state;
    }
}
function checkForDeadEnds(match, stream) {
    for (let i = 0, work = [match]; i < work.length; i++) {
        let state = work[i], dead = !state.validEnd, nodes = [];
        for (let j = 0; j < state.next.length; j++) {
            let { type, next } = state.next[j];
            nodes.push(type.name);
            if (dead && !(type.isText || type.hasRequiredAttrs()))
                dead = false;
            if (work.indexOf(next) == -1)
                work.push(next);
        }
        if (dead)
            stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
}

// For node types where all attrs have a default value (or which don't
// have any attributes), build up a single reusable default attribute
// object, and use it for all nodes that don't specify specific
// attributes.
function defaultAttrs(attrs) {
    let defaults = Object.create(null);
    for (let attrName in attrs) {
        let attr = attrs[attrName];
        if (!attr.hasDefault)
            return null;
        defaults[attrName] = attr.default;
    }
    return defaults;
}
function computeAttrs(attrs, value) {
    let built = Object.create(null);
    for (let name in attrs) {
        let given = value && value[name];
        if (given === undefined) {
            let attr = attrs[name];
            if (attr.hasDefault)
                given = attr.default;
            else
                throw new RangeError("No value supplied for attribute " + name);
        }
        built[name] = given;
    }
    return built;
}
function initAttrs(attrs) {
    let result = Object.create(null);
    if (attrs)
        for (let name in attrs)
            result[name] = new Attribute(attrs[name]);
    return result;
}
/**
Node types are objects allocated once per `Schema` and used to
[tag](https://prosemirror.net/docs/ref/#model.Node.type) `Node` instances. They contain information
about the node type, such as its name and what kind of node it
represents.
*/
class NodeType$1 {
    /**
    @internal
    */
    constructor(
    /**
    The name the node type has in this schema.
    */
    name, 
    /**
    A link back to the `Schema` the node type belongs to.
    */
    schema, 
    /**
    The spec that this type is based on
    */
    spec) {
        this.name = name;
        this.schema = schema;
        this.spec = spec;
        /**
        The set of marks allowed in this node. `null` means all marks
        are allowed.
        */
        this.markSet = null;
        this.groups = spec.group ? spec.group.split(" ") : [];
        this.attrs = initAttrs(spec.attrs);
        this.defaultAttrs = defaultAttrs(this.attrs);
        this.contentMatch = null;
        this.inlineContent = null;
        this.isBlock = !(spec.inline || name == "text");
        this.isText = name == "text";
    }
    /**
    True if this is an inline type.
    */
    get isInline() { return !this.isBlock; }
    /**
    True if this is a textblock type, a block that contains inline
    content.
    */
    get isTextblock() { return this.isBlock && this.inlineContent; }
    /**
    True for node types that allow no content.
    */
    get isLeaf() { return this.contentMatch == ContentMatch.empty; }
    /**
    True when this node is an atom, i.e. when it does not have
    directly editable content.
    */
    get isAtom() { return this.isLeaf || !!this.spec.atom; }
    /**
    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
    */
    get whitespace() {
        return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
    }
    /**
    Tells you whether this node type has any required attributes.
    */
    hasRequiredAttrs() {
        for (let n in this.attrs)
            if (this.attrs[n].isRequired)
                return true;
        return false;
    }
    /**
    @internal
    */
    compatibleContent(other) {
        return this == other || this.contentMatch.compatible(other.contentMatch);
    }
    /**
    @internal
    */
    computeAttrs(attrs) {
        if (!attrs && this.defaultAttrs)
            return this.defaultAttrs;
        else
            return computeAttrs(this.attrs, attrs);
    }
    /**
    Create a `Node` of this type. The given attributes are
    checked and defaulted (you can pass `null` to use the type's
    defaults entirely, if no required attributes exist). `content`
    may be a `Fragment`, a node, an array of nodes, or
    `null`. Similarly `marks` may be `null` to default to the empty
    set of marks.
    */
    create(attrs = null, content, marks) {
        if (this.isText)
            throw new Error("NodeType.create can't construct text nodes");
        return new Node$1(this, this.computeAttrs(attrs), Fragment.from(content), Mark$1.setFrom(marks));
    }
    /**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
    against the node type's content restrictions, and throw an error
    if it doesn't match.
    */
    createChecked(attrs = null, content, marks) {
        content = Fragment.from(content);
        if (!this.validContent(content))
            throw new RangeError("Invalid content for node " + this.name);
        return new Node$1(this, this.computeAttrs(attrs), content, Mark$1.setFrom(marks));
    }
    /**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
    necessary to add nodes to the start or end of the given fragment
    to make it fit the node. If no fitting wrapping can be found,
    return null. Note that, due to the fact that required nodes can
    always be created, this will always succeed if you pass null or
    `Fragment.empty` as content.
    */
    createAndFill(attrs = null, content, marks) {
        attrs = this.computeAttrs(attrs);
        content = Fragment.from(content);
        if (content.size) {
            let before = this.contentMatch.fillBefore(content);
            if (!before)
                return null;
            content = before.append(content);
        }
        let matched = this.contentMatch.matchFragment(content);
        let after = matched && matched.fillBefore(Fragment.empty, true);
        if (!after)
            return null;
        return new Node$1(this, attrs, content.append(after), Mark$1.setFrom(marks));
    }
    /**
    Returns true if the given fragment is valid content for this node
    type with the given attributes.
    */
    validContent(content) {
        let result = this.contentMatch.matchFragment(content);
        if (!result || !result.validEnd)
            return false;
        for (let i = 0; i < content.childCount; i++)
            if (!this.allowsMarks(content.child(i).marks))
                return false;
        return true;
    }
    /**
    Check whether the given mark type is allowed in this node.
    */
    allowsMarkType(markType) {
        return this.markSet == null || this.markSet.indexOf(markType) > -1;
    }
    /**
    Test whether the given set of marks are allowed in this node.
    */
    allowsMarks(marks) {
        if (this.markSet == null)
            return true;
        for (let i = 0; i < marks.length; i++)
            if (!this.allowsMarkType(marks[i].type))
                return false;
        return true;
    }
    /**
    Removes the marks that are not allowed in this node from the given set.
    */
    allowedMarks(marks) {
        if (this.markSet == null)
            return marks;
        let copy;
        for (let i = 0; i < marks.length; i++) {
            if (!this.allowsMarkType(marks[i].type)) {
                if (!copy)
                    copy = marks.slice(0, i);
            }
            else if (copy) {
                copy.push(marks[i]);
            }
        }
        return !copy ? marks : copy.length ? copy : Mark$1.none;
    }
    /**
    @internal
    */
    static compile(nodes, schema) {
        let result = Object.create(null);
        nodes.forEach((name, spec) => result[name] = new NodeType$1(name, schema, spec));
        let topType = schema.spec.topNode || "doc";
        if (!result[topType])
            throw new RangeError("Schema is missing its top node type ('" + topType + "')");
        if (!result.text)
            throw new RangeError("Every schema needs a 'text' type");
        for (let _ in result.text.attrs)
            throw new RangeError("The text node type should not have attributes");
        return result;
    }
}
// Attribute descriptors
class Attribute {
    constructor(options) {
        this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
        this.default = options.default;
    }
    get isRequired() {
        return !this.hasDefault;
    }
}
// Marks
/**
Like nodes, marks (which are associated with nodes to signify
things like emphasis or being part of a link) are
[tagged](https://prosemirror.net/docs/ref/#model.Mark.type) with type objects, which are
instantiated once per `Schema`.
*/
class MarkType {
    /**
    @internal
    */
    constructor(
    /**
    The name of the mark type.
    */
    name, 
    /**
    @internal
    */
    rank, 
    /**
    The schema that this mark type instance is part of.
    */
    schema, 
    /**
    The spec on which the type is based.
    */
    spec) {
        this.name = name;
        this.rank = rank;
        this.schema = schema;
        this.spec = spec;
        this.attrs = initAttrs(spec.attrs);
        this.excluded = null;
        let defaults = defaultAttrs(this.attrs);
        this.instance = defaults ? new Mark$1(this, defaults) : null;
    }
    /**
    Create a mark of this type. `attrs` may be `null` or an object
    containing only some of the mark's attributes. The others, if
    they have defaults, will be added.
    */
    create(attrs = null) {
        if (!attrs && this.instance)
            return this.instance;
        return new Mark$1(this, computeAttrs(this.attrs, attrs));
    }
    /**
    @internal
    */
    static compile(marks, schema) {
        let result = Object.create(null), rank = 0;
        marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec));
        return result;
    }
    /**
    When there is a mark of this type in the given set, a new set
    without it is returned. Otherwise, the input set is returned.
    */
    removeFromSet(set) {
        for (var i = 0; i < set.length; i++)
            if (set[i].type == this) {
                set = set.slice(0, i).concat(set.slice(i + 1));
                i--;
            }
        return set;
    }
    /**
    Tests whether there is a mark of this type in the given set.
    */
    isInSet(set) {
        for (let i = 0; i < set.length; i++)
            if (set[i].type == this)
                return set[i];
    }
    /**
    Queries whether a given mark type is
    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
    */
    excludes(other) {
        return this.excluded.indexOf(other) > -1;
    }
}
/**
A document schema. Holds [node](https://prosemirror.net/docs/ref/#model.NodeType) and [mark
type](https://prosemirror.net/docs/ref/#model.MarkType) objects for the nodes and marks that may
occur in conforming documents, and provides functionality for
creating and deserializing such documents.
*/
class Schema {
    /**
    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
    */
    constructor(spec) {
        /**
        An object for storing whatever values modules may want to
        compute and cache per schema. (If you want to store something
        in it, try to use property names unlikely to clash.)
        */
        this.cached = Object.create(null);
        this.spec = {
            nodes: OrderedMap.from(spec.nodes),
            marks: OrderedMap.from(spec.marks || {}),
            topNode: spec.topNode
        };
        this.nodes = NodeType$1.compile(this.spec.nodes, this);
        this.marks = MarkType.compile(this.spec.marks, this);
        let contentExprCache = Object.create(null);
        for (let prop in this.nodes) {
            if (prop in this.marks)
                throw new RangeError(prop + " can not be both a node and a mark");
            let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
            type.contentMatch = contentExprCache[contentExpr] ||
                (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
            type.inlineContent = type.contentMatch.inlineContent;
            type.markSet = markExpr == "_" ? null :
                markExpr ? gatherMarks(this, markExpr.split(" ")) :
                    markExpr == "" || !type.inlineContent ? [] : null;
        }
        for (let prop in this.marks) {
            let type = this.marks[prop], excl = type.spec.excludes;
            type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
        }
        this.nodeFromJSON = this.nodeFromJSON.bind(this);
        this.markFromJSON = this.markFromJSON.bind(this);
        this.topNodeType = this.nodes[this.spec.topNode || "doc"];
        this.cached.wrappings = Object.create(null);
    }
    /**
    Create a node in this schema. The `type` may be a string or a
    `NodeType` instance. Attributes will be extended with defaults,
    `content` may be a `Fragment`, `null`, a `Node`, or an array of
    nodes.
    */
    node(type, attrs = null, content, marks) {
        if (typeof type == "string")
            type = this.nodeType(type);
        else if (!(type instanceof NodeType$1))
            throw new RangeError("Invalid node type: " + type);
        else if (type.schema != this)
            throw new RangeError("Node type from different schema used (" + type.name + ")");
        return type.createChecked(attrs, content, marks);
    }
    /**
    Create a text node in the schema. Empty text nodes are not
    allowed.
    */
    text(text, marks) {
        let type = this.nodes.text;
        return new TextNode(type, type.defaultAttrs, text, Mark$1.setFrom(marks));
    }
    /**
    Create a mark with the given type and attributes.
    */
    mark(type, attrs) {
        if (typeof type == "string")
            type = this.marks[type];
        return type.create(attrs);
    }
    /**
    Deserialize a node from its JSON representation. This method is
    bound.
    */
    nodeFromJSON(json) {
        return Node$1.fromJSON(this, json);
    }
    /**
    Deserialize a mark from its JSON representation. This method is
    bound.
    */
    markFromJSON(json) {
        return Mark$1.fromJSON(this, json);
    }
    /**
    @internal
    */
    nodeType(name) {
        let found = this.nodes[name];
        if (!found)
            throw new RangeError("Unknown node type: " + name);
        return found;
    }
}
function gatherMarks(schema, marks) {
    let found = [];
    for (let i = 0; i < marks.length; i++) {
        let name = marks[i], mark = schema.marks[name], ok = mark;
        if (mark) {
            found.push(mark);
        }
        else {
            for (let prop in schema.marks) {
                let mark = schema.marks[prop];
                if (name == "_" || (mark.spec.group && mark.spec.group.split(" ").indexOf(name) > -1))
                    found.push(ok = mark);
            }
        }
        if (!ok)
            throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
    }
    return found;
}

/**
A DOM parser represents a strategy for parsing DOM content into a
ProseMirror document conforming to a given schema. Its behavior is
defined by an array of [rules](https://prosemirror.net/docs/ref/#model.ParseRule).
*/
class DOMParser {
    /**
    Create a parser that targets the given schema, using the given
    parsing rules.
    */
    constructor(
    /**
    The schema into which the parser parses.
    */
    schema, 
    /**
    The set of [parse rules](https://prosemirror.net/docs/ref/#model.ParseRule) that the parser
    uses, in order of precedence.
    */
    rules) {
        this.schema = schema;
        this.rules = rules;
        /**
        @internal
        */
        this.tags = [];
        /**
        @internal
        */
        this.styles = [];
        rules.forEach(rule => {
            if (rule.tag)
                this.tags.push(rule);
            else if (rule.style)
                this.styles.push(rule);
        });
        // Only normalize list elements when lists in the schema can't directly contain themselves
        this.normalizeLists = !this.tags.some(r => {
            if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
                return false;
            let node = schema.nodes[r.node];
            return node.contentMatch.matchType(node);
        });
    }
    /**
    Parse a document from the content of a DOM node.
    */
    parse(dom, options = {}) {
        let context = new ParseContext(this, options, false);
        context.addAll(dom, options.from, options.to);
        return context.finish();
    }
    /**
    Parses the content of the given DOM node, like
    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
    options. But unlike that method, which produces a whole node,
    this one returns a slice that is open at the sides, meaning that
    the schema constraints aren't applied to the start of nodes to
    the left of the input and the end of nodes at the end.
    */
    parseSlice(dom, options = {}) {
        let context = new ParseContext(this, options, true);
        context.addAll(dom, options.from, options.to);
        return Slice.maxOpen(context.finish());
    }
    /**
    @internal
    */
    matchTag(dom, context, after) {
        for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
            let rule = this.tags[i];
            if (matches(dom, rule.tag) &&
                (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&
                (!rule.context || context.matchesContext(rule.context))) {
                if (rule.getAttrs) {
                    let result = rule.getAttrs(dom);
                    if (result === false)
                        continue;
                    rule.attrs = result || undefined;
                }
                return rule;
            }
        }
    }
    /**
    @internal
    */
    matchStyle(prop, value, context, after) {
        for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
            let rule = this.styles[i], style = rule.style;
            if (style.indexOf(prop) != 0 ||
                rule.context && !context.matchesContext(rule.context) ||
                // Test that the style string either precisely matches the prop,
                // or has an '=' sign after the prop, followed by the given
                // value.
                style.length > prop.length &&
                    (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value))
                continue;
            if (rule.getAttrs) {
                let result = rule.getAttrs(value);
                if (result === false)
                    continue;
                rule.attrs = result || undefined;
            }
            return rule;
        }
    }
    /**
    @internal
    */
    static schemaRules(schema) {
        let result = [];
        function insert(rule) {
            let priority = rule.priority == null ? 50 : rule.priority, i = 0;
            for (; i < result.length; i++) {
                let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
                if (nextPriority < priority)
                    break;
            }
            result.splice(i, 0, rule);
        }
        for (let name in schema.marks) {
            let rules = schema.marks[name].spec.parseDOM;
            if (rules)
                rules.forEach(rule => {
                    insert(rule = copy(rule));
                    rule.mark = name;
                });
        }
        for (let name in schema.nodes) {
            let rules = schema.nodes[name].spec.parseDOM;
            if (rules)
                rules.forEach(rule => {
                    insert(rule = copy(rule));
                    rule.node = name;
                });
        }
        return result;
    }
    /**
    Construct a DOM parser using the parsing rules listed in a
    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
    */
    static fromSchema(schema) {
        return schema.cached.domParser ||
            (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));
    }
}
const blockTags = {
    address: true, article: true, aside: true, blockquote: true, canvas: true,
    dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,
    footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,
    h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,
    output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true
};
const ignoreTags = {
    head: true, noscript: true, object: true, script: true, style: true, title: true
};
const listTags = { ol: true, ul: true };
// Using a bitfield for node context options
const OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base) {
    if (preserveWhitespace != null)
        return (preserveWhitespace ? OPT_PRESERVE_WS : 0) |
            (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
    return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;
}
class NodeContext {
    constructor(type, attrs, 
    // Marks applied to this node itself
    marks, 
    // Marks that can't apply here, but will be used in children if possible
    pendingMarks, solid, match, options) {
        this.type = type;
        this.attrs = attrs;
        this.marks = marks;
        this.pendingMarks = pendingMarks;
        this.solid = solid;
        this.options = options;
        this.content = [];
        // Marks applied to the node's children
        this.activeMarks = Mark$1.none;
        // Nested Marks with same type
        this.stashMarks = [];
        this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
    }
    findWrapping(node) {
        if (!this.match) {
            if (!this.type)
                return [];
            let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
            if (fill) {
                this.match = this.type.contentMatch.matchFragment(fill);
            }
            else {
                let start = this.type.contentMatch, wrap;
                if (wrap = start.findWrapping(node.type)) {
                    this.match = start;
                    return wrap;
                }
                else {
                    return null;
                }
            }
        }
        return this.match.findWrapping(node.type);
    }
    finish(openEnd) {
        if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace
            let last = this.content[this.content.length - 1], m;
            if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
                let text = last;
                if (last.text.length == m[0].length)
                    this.content.pop();
                else
                    this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
            }
        }
        let content = Fragment.from(this.content);
        if (!openEnd && this.match)
            content = content.append(this.match.fillBefore(Fragment.empty, true));
        return this.type ? this.type.create(this.attrs, content, this.marks) : content;
    }
    popFromStashMark(mark) {
        for (let i = this.stashMarks.length - 1; i >= 0; i--)
            if (mark.eq(this.stashMarks[i]))
                return this.stashMarks.splice(i, 1)[0];
    }
    applyPending(nextType) {
        for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {
            let mark = pending[i];
            if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&
                !mark.isInSet(this.activeMarks)) {
                this.activeMarks = mark.addToSet(this.activeMarks);
                this.pendingMarks = mark.removeFromSet(this.pendingMarks);
            }
        }
    }
    inlineContext(node) {
        if (this.type)
            return this.type.inlineContent;
        if (this.content.length)
            return this.content[0].isInline;
        return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
    }
}
class ParseContext {
    constructor(
    // The parser we are using.
    parser, 
    // The options passed to this parse.
    options, isOpen) {
        this.parser = parser;
        this.options = options;
        this.isOpen = isOpen;
        this.open = 0;
        let topNode = options.topNode, topContext;
        let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
        if (topNode)
            topContext = new NodeContext(topNode.type, topNode.attrs, Mark$1.none, Mark$1.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
        else if (isOpen)
            topContext = new NodeContext(null, null, Mark$1.none, Mark$1.none, true, null, topOptions);
        else
            topContext = new NodeContext(parser.schema.topNodeType, null, Mark$1.none, Mark$1.none, true, null, topOptions);
        this.nodes = [topContext];
        this.find = options.findPositions;
        this.needsBlock = false;
    }
    get top() {
        return this.nodes[this.open];
    }
    // Add a DOM node to the content. Text is inserted as text node,
    // otherwise, the node is passed to `addElement` or, if it has a
    // `style` attribute, `addElementWithStyles`.
    addDOM(dom) {
        if (dom.nodeType == 3) {
            this.addTextNode(dom);
        }
        else if (dom.nodeType == 1) {
            let style = dom.getAttribute("style");
            let marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top;
            if (marks != null)
                for (let i = 0; i < marks.length; i++)
                    this.addPendingMark(marks[i]);
            this.addElement(dom);
            if (marks != null)
                for (let i = 0; i < marks.length; i++)
                    this.removePendingMark(marks[i], top);
        }
    }
    addTextNode(dom) {
        let value = dom.nodeValue;
        let top = this.top;
        if (top.options & OPT_PRESERVE_WS_FULL ||
            top.inlineContext(dom) ||
            /[^ \t\r\n\u000c]/.test(value)) {
            if (!(top.options & OPT_PRESERVE_WS)) {
                value = value.replace(/[ \t\r\n\u000c]+/g, " ");
                // If this starts with whitespace, and there is no node before it, or
                // a hard break, or a text node that ends with whitespace, strip the
                // leading space.
                if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
                    let nodeBefore = top.content[top.content.length - 1];
                    let domNodeBefore = dom.previousSibling;
                    if (!nodeBefore ||
                        (domNodeBefore && domNodeBefore.nodeName == 'BR') ||
                        (nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)))
                        value = value.slice(1);
                }
            }
            else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
                value = value.replace(/\r?\n|\r/g, " ");
            }
            else {
                value = value.replace(/\r\n?/g, "\n");
            }
            if (value)
                this.insertNode(this.parser.schema.text(value));
            this.findInText(dom);
        }
        else {
            this.findInside(dom);
        }
    }
    // Try to find a handler for the given tag and use that to parse. If
    // none is found, the element's content nodes are added directly.
    addElement(dom, matchAfter) {
        let name = dom.nodeName.toLowerCase(), ruleID;
        if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
            normalizeList(dom);
        let rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||
            (ruleID = this.parser.matchTag(dom, this, matchAfter));
        if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
            this.findInside(dom);
            this.ignoreFallback(dom);
        }
        else if (!rule || rule.skip || rule.closeParent) {
            if (rule && rule.closeParent)
                this.open = Math.max(0, this.open - 1);
            else if (rule && rule.skip.nodeType)
                dom = rule.skip;
            let sync, top = this.top, oldNeedsBlock = this.needsBlock;
            if (blockTags.hasOwnProperty(name)) {
                sync = true;
                if (!top.type)
                    this.needsBlock = true;
            }
            else if (!dom.firstChild) {
                this.leafFallback(dom);
                return;
            }
            this.addAll(dom);
            if (sync)
                this.sync(top);
            this.needsBlock = oldNeedsBlock;
        }
        else {
            this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : undefined);
        }
    }
    // Called for leaf DOM nodes that would otherwise be ignored
    leafFallback(dom) {
        if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
            this.addTextNode(dom.ownerDocument.createTextNode("\n"));
    }
    // Called for ignored nodes
    ignoreFallback(dom) {
        // Ignored BR nodes should at least create an inline context
        if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
            this.findPlace(this.parser.schema.text("-"));
    }
    // Run any style parser associated with the node's styles. Either
    // return an array of marks, or null to indicate some of the styles
    // had a rule with `ignore` set.
    readStyles(styles) {
        let marks = Mark$1.none;
        style: for (let i = 0; i < styles.length; i += 2) {
            for (let after = undefined;;) {
                let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);
                if (!rule)
                    continue style;
                if (rule.ignore)
                    return null;
                marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);
                if (rule.consuming === false)
                    after = rule;
                else
                    break;
            }
        }
        return marks;
    }
    // Look up a handler for the given node. If none are found, return
    // false. Otherwise, apply it, use its return value to drive the way
    // the node's content is wrapped, and return true.
    addElementByRule(dom, rule, continueAfter) {
        let sync, nodeType, mark;
        if (rule.node) {
            nodeType = this.parser.schema.nodes[rule.node];
            if (!nodeType.isLeaf) {
                sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
            }
            else if (!this.insertNode(nodeType.create(rule.attrs))) {
                this.leafFallback(dom);
            }
        }
        else {
            let markType = this.parser.schema.marks[rule.mark];
            mark = markType.create(rule.attrs);
            this.addPendingMark(mark);
        }
        let startIn = this.top;
        if (nodeType && nodeType.isLeaf) {
            this.findInside(dom);
        }
        else if (continueAfter) {
            this.addElement(dom, continueAfter);
        }
        else if (rule.getContent) {
            this.findInside(dom);
            rule.getContent(dom, this.parser.schema).forEach(node => this.insertNode(node));
        }
        else {
            let contentDOM = dom;
            if (typeof rule.contentElement == "string")
                contentDOM = dom.querySelector(rule.contentElement);
            else if (typeof rule.contentElement == "function")
                contentDOM = rule.contentElement(dom);
            else if (rule.contentElement)
                contentDOM = rule.contentElement;
            this.findAround(dom, contentDOM, true);
            this.addAll(contentDOM);
        }
        if (sync && this.sync(startIn))
            this.open--;
        if (mark)
            this.removePendingMark(mark, startIn);
    }
    // Add all child nodes between `startIndex` and `endIndex` (or the
    // whole node, if not given). If `sync` is passed, use it to
    // synchronize after every block element.
    addAll(parent, startIndex, endIndex) {
        let index = startIndex || 0;
        for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
            this.findAtPoint(parent, index);
            this.addDOM(dom);
        }
        this.findAtPoint(parent, index);
    }
    // Try to find a way to fit the given node type into the current
    // context. May add intermediate wrappers and/or leave non-solid
    // nodes that we're in.
    findPlace(node) {
        let route, sync;
        for (let depth = this.open; depth >= 0; depth--) {
            let cx = this.nodes[depth];
            let found = cx.findWrapping(node);
            if (found && (!route || route.length > found.length)) {
                route = found;
                sync = cx;
                if (!found.length)
                    break;
            }
            if (cx.solid)
                break;
        }
        if (!route)
            return false;
        this.sync(sync);
        for (let i = 0; i < route.length; i++)
            this.enterInner(route[i], null, false);
        return true;
    }
    // Try to insert the given node, adjusting the context when needed.
    insertNode(node) {
        if (node.isInline && this.needsBlock && !this.top.type) {
            let block = this.textblockFromContext();
            if (block)
                this.enterInner(block);
        }
        if (this.findPlace(node)) {
            this.closeExtra();
            let top = this.top;
            top.applyPending(node.type);
            if (top.match)
                top.match = top.match.matchType(node.type);
            let marks = top.activeMarks;
            for (let i = 0; i < node.marks.length; i++)
                if (!top.type || top.type.allowsMarkType(node.marks[i].type))
                    marks = node.marks[i].addToSet(marks);
            top.content.push(node.mark(marks));
            return true;
        }
        return false;
    }
    // Try to start a node of the given type, adjusting the context when
    // necessary.
    enter(type, attrs, preserveWS) {
        let ok = this.findPlace(type.create(attrs));
        if (ok)
            this.enterInner(type, attrs, true, preserveWS);
        return ok;
    }
    // Open a node of the given type
    enterInner(type, attrs = null, solid = false, preserveWS) {
        this.closeExtra();
        let top = this.top;
        top.applyPending(type);
        top.match = top.match && top.match.matchType(type);
        let options = wsOptionsFor(type, preserveWS, top.options);
        if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0)
            options |= OPT_OPEN_LEFT;
        this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));
        this.open++;
    }
    // Make sure all nodes above this.open are finished and added to
    // their parents
    closeExtra(openEnd = false) {
        let i = this.nodes.length - 1;
        if (i > this.open) {
            for (; i > this.open; i--)
                this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
            this.nodes.length = this.open + 1;
        }
    }
    finish() {
        this.open = 0;
        this.closeExtra(this.isOpen);
        return this.nodes[0].finish(this.isOpen || this.options.topOpen);
    }
    sync(to) {
        for (let i = this.open; i >= 0; i--)
            if (this.nodes[i] == to) {
                this.open = i;
                return true;
            }
        return false;
    }
    get currentPos() {
        this.closeExtra();
        let pos = 0;
        for (let i = this.open; i >= 0; i--) {
            let content = this.nodes[i].content;
            for (let j = content.length - 1; j >= 0; j--)
                pos += content[j].nodeSize;
            if (i)
                pos++;
        }
        return pos;
    }
    findAtPoint(parent, offset) {
        if (this.find)
            for (let i = 0; i < this.find.length; i++) {
                if (this.find[i].node == parent && this.find[i].offset == offset)
                    this.find[i].pos = this.currentPos;
            }
    }
    findInside(parent) {
        if (this.find)
            for (let i = 0; i < this.find.length; i++) {
                if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
                    this.find[i].pos = this.currentPos;
            }
    }
    findAround(parent, content, before) {
        if (parent != content && this.find)
            for (let i = 0; i < this.find.length; i++) {
                if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
                    let pos = content.compareDocumentPosition(this.find[i].node);
                    if (pos & (before ? 2 : 4))
                        this.find[i].pos = this.currentPos;
                }
            }
    }
    findInText(textNode) {
        if (this.find)
            for (let i = 0; i < this.find.length; i++) {
                if (this.find[i].node == textNode)
                    this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
            }
    }
    // Determines whether the given context string matches this context.
    matchesContext(context) {
        if (context.indexOf("|") > -1)
            return context.split(/\s*\|\s*/).some(this.matchesContext, this);
        let parts = context.split("/");
        let option = this.options.context;
        let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
        let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
        let match = (i, depth) => {
            for (; i >= 0; i--) {
                let part = parts[i];
                if (part == "") {
                    if (i == parts.length - 1 || i == 0)
                        continue;
                    for (; depth >= minDepth; depth--)
                        if (match(i - 1, depth))
                            return true;
                    return false;
                }
                else {
                    let next = depth > 0 || (depth == 0 && useRoot) ? this.nodes[depth].type
                        : option && depth >= minDepth ? option.node(depth - minDepth).type
                            : null;
                    if (!next || (next.name != part && next.groups.indexOf(part) == -1))
                        return false;
                    depth--;
                }
            }
            return true;
        };
        return match(parts.length - 1, this.open);
    }
    textblockFromContext() {
        let $context = this.options.context;
        if ($context)
            for (let d = $context.depth; d >= 0; d--) {
                let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
                if (deflt && deflt.isTextblock && deflt.defaultAttrs)
                    return deflt;
            }
        for (let name in this.parser.schema.nodes) {
            let type = this.parser.schema.nodes[name];
            if (type.isTextblock && type.defaultAttrs)
                return type;
        }
    }
    addPendingMark(mark) {
        let found = findSameMarkInSet(mark, this.top.pendingMarks);
        if (found)
            this.top.stashMarks.push(found);
        this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
    }
    removePendingMark(mark, upto) {
        for (let depth = this.open; depth >= 0; depth--) {
            let level = this.nodes[depth];
            let found = level.pendingMarks.lastIndexOf(mark);
            if (found > -1) {
                level.pendingMarks = mark.removeFromSet(level.pendingMarks);
            }
            else {
                level.activeMarks = mark.removeFromSet(level.activeMarks);
                let stashMark = level.popFromStashMark(mark);
                if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
                    level.activeMarks = stashMark.addToSet(level.activeMarks);
            }
            if (level == upto)
                break;
        }
    }
}
// Kludge to work around directly nested list nodes produced by some
// tools and allowed by browsers to mean that the nested list is
// actually part of the list item above it.
function normalizeList(dom) {
    for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
        let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
        if (name && listTags.hasOwnProperty(name) && prevItem) {
            prevItem.appendChild(child);
            child = prevItem;
        }
        else if (name == "li") {
            prevItem = child;
        }
        else if (name) {
            prevItem = null;
        }
    }
}
// Apply a CSS selector.
function matches(dom, selector) {
    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
// Tokenize a style attribute into property/value pairs.
function parseStyles(style) {
    let re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
    while (m = re.exec(style))
        result.push(m[1], m[2].trim());
    return result;
}
function copy(obj) {
    let copy = {};
    for (let prop in obj)
        copy[prop] = obj[prop];
    return copy;
}
// Used when finding a mark at the top level of a fragment parse.
// Checks whether it would be reasonable to apply a given mark type to
// a given node, by looking at the way the mark occurs in the schema.
function markMayApply(markType, nodeType) {
    let nodes = nodeType.schema.nodes;
    for (let name in nodes) {
        let parent = nodes[name];
        if (!parent.allowsMarkType(markType))
            continue;
        let seen = [], scan = (match) => {
            seen.push(match);
            for (let i = 0; i < match.edgeCount; i++) {
                let { type, next } = match.edge(i);
                if (type == nodeType)
                    return true;
                if (seen.indexOf(next) < 0 && scan(next))
                    return true;
            }
        };
        if (scan(parent.contentMatch))
            return true;
    }
}
function findSameMarkInSet(mark, set) {
    for (let i = 0; i < set.length; i++) {
        if (mark.eq(set[i]))
            return set[i];
    }
}

/**
A DOM serializer knows how to convert ProseMirror nodes and
marks of various types to DOM nodes.
*/
class DOMSerializer {
    /**
    Create a serializer. `nodes` should map node names to functions
    that take a node and return a description of the corresponding
    DOM. `marks` does the same for mark names, but also gets an
    argument that tells it whether the mark's content is block or
    inline content (for typical use, it'll always be inline). A mark
    serializer may be `null` to indicate that marks of that type
    should not be serialized.
    */
    constructor(
    /**
    The node serialization functions.
    */
    nodes, 
    /**
    The mark serialization functions.
    */
    marks) {
        this.nodes = nodes;
        this.marks = marks;
    }
    /**
    Serialize the content of this fragment to a DOM fragment. When
    not in the browser, the `document` option, containing a DOM
    document, should be passed so that the serializer can create
    nodes.
    */
    serializeFragment(fragment, options = {}, target) {
        if (!target)
            target = doc$1(options).createDocumentFragment();
        let top = target, active = [];
        fragment.forEach(node => {
            if (active.length || node.marks.length) {
                let keep = 0, rendered = 0;
                while (keep < active.length && rendered < node.marks.length) {
                    let next = node.marks[rendered];
                    if (!this.marks[next.type.name]) {
                        rendered++;
                        continue;
                    }
                    if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
                        break;
                    keep++;
                    rendered++;
                }
                while (keep < active.length)
                    top = active.pop()[1];
                while (rendered < node.marks.length) {
                    let add = node.marks[rendered++];
                    let markDOM = this.serializeMark(add, node.isInline, options);
                    if (markDOM) {
                        active.push([add, top]);
                        top.appendChild(markDOM.dom);
                        top = markDOM.contentDOM || markDOM.dom;
                    }
                }
            }
            top.appendChild(this.serializeNodeInner(node, options));
        });
        return target;
    }
    /**
    @internal
    */
    serializeNodeInner(node, options) {
        let { dom, contentDOM } = DOMSerializer.renderSpec(doc$1(options), this.nodes[node.type.name](node));
        if (contentDOM) {
            if (node.isLeaf)
                throw new RangeError("Content hole not allowed in a leaf node spec");
            this.serializeFragment(node.content, options, contentDOM);
        }
        return dom;
    }
    /**
    Serialize this node to a DOM node. This can be useful when you
    need to serialize a part of a document, as opposed to the whole
    document. To serialize a whole document, use
    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
    its [content](https://prosemirror.net/docs/ref/#model.Node.content).
    */
    serializeNode(node, options = {}) {
        let dom = this.serializeNodeInner(node, options);
        for (let i = node.marks.length - 1; i >= 0; i--) {
            let wrap = this.serializeMark(node.marks[i], node.isInline, options);
            if (wrap) {
                (wrap.contentDOM || wrap.dom).appendChild(dom);
                dom = wrap.dom;
            }
        }
        return dom;
    }
    /**
    @internal
    */
    serializeMark(mark, inline, options = {}) {
        let toDOM = this.marks[mark.type.name];
        return toDOM && DOMSerializer.renderSpec(doc$1(options), toDOM(mark, inline));
    }
    /**
    Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
    the spec has a hole (zero) in it, `contentDOM` will point at the
    node with the hole.
    */
    static renderSpec(doc, structure, xmlNS = null) {
        if (typeof structure == "string")
            return { dom: doc.createTextNode(structure) };
        if (structure.nodeType != null)
            return { dom: structure };
        if (structure.dom && structure.dom.nodeType != null)
            return structure;
        let tagName = structure[0], space = tagName.indexOf(" ");
        if (space > 0) {
            xmlNS = tagName.slice(0, space);
            tagName = tagName.slice(space + 1);
        }
        let contentDOM;
        let dom = (xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName));
        let attrs = structure[1], start = 1;
        if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
            start = 2;
            for (let name in attrs)
                if (attrs[name] != null) {
                    let space = name.indexOf(" ");
                    if (space > 0)
                        dom.setAttributeNS(name.slice(0, space), name.slice(space + 1), attrs[name]);
                    else
                        dom.setAttribute(name, attrs[name]);
                }
        }
        for (let i = start; i < structure.length; i++) {
            let child = structure[i];
            if (child === 0) {
                if (i < structure.length - 1 || i > start)
                    throw new RangeError("Content hole must be the only child of its parent node");
                return { dom, contentDOM: dom };
            }
            else {
                let { dom: inner, contentDOM: innerContent } = DOMSerializer.renderSpec(doc, child, xmlNS);
                dom.appendChild(inner);
                if (innerContent) {
                    if (contentDOM)
                        throw new RangeError("Multiple content holes");
                    contentDOM = innerContent;
                }
            }
        }
        return { dom, contentDOM };
    }
    /**
    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
    properties in a schema's node and mark specs.
    */
    static fromSchema(schema) {
        return schema.cached.domSerializer ||
            (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
    }
    /**
    Gather the serializers in a schema's node specs into an object.
    This can be useful as a base to build a custom serializer from.
    */
    static nodesFromSchema(schema) {
        let result = gatherToDOM(schema.nodes);
        if (!result.text)
            result.text = node => node.text;
        return result;
    }
    /**
    Gather the serializers in a schema's mark specs into an object.
    */
    static marksFromSchema(schema) {
        return gatherToDOM(schema.marks);
    }
}
function gatherToDOM(obj) {
    let result = {};
    for (let name in obj) {
        let toDOM = obj[name].spec.toDOM;
        if (toDOM)
            result[name] = toDOM;
    }
    return result;
}
function doc$1(options) {
    return options.document || window$1.document;
}

// Recovery values encode a range index and an offset. They are
// represented as numbers, because tons of them will be created when
// mapping, for example, a large number of decorations. The number's
// lower 16 bits provide the index, the remaining bits the offset.
//
// Note: We intentionally don't use bit shift operators to en- and
// decode these, since those clip to 32 bits, which we might in rare
// cases want to overflow. A 64-bit float can represent 48-bit
// integers precisely.
const lower16 = 0xffff;
const factor16 = Math.pow(2, 16);
function makeRecover(index, offset) { return index + offset * factor16; }
function recoverIndex(value) { return value & lower16; }
function recoverOffset(value) { return (value - (value & lower16)) / factor16; }
const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
/**
An object representing a mapped position with extra
information.
*/
class MapResult {
    /**
    @internal
    */
    constructor(
    /**
    The mapped version of the position.
    */
    pos, 
    /**
    @internal
    */
    delInfo, 
    /**
    @internal
    */
    recover) {
        this.pos = pos;
        this.delInfo = delInfo;
        this.recover = recover;
    }
    /**
    Tells you whether the position was deleted, that is, whether the
    step removed the token on the side queried (via the `assoc`)
    argument from the document.
    */
    get deleted() { return (this.delInfo & DEL_SIDE) > 0; }
    /**
    Tells you whether the token before the mapped position was deleted.
    */
    get deletedBefore() { return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0; }
    /**
    True when the token after the mapped position was deleted.
    */
    get deletedAfter() { return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0; }
    /**
    Tells whether any of the steps mapped through deletes across the
    position (including both the token before and after the
    position).
    */
    get deletedAcross() { return (this.delInfo & DEL_ACROSS) > 0; }
}
/**
A map describing the deletions and insertions made by a step, which
can be used to find the correspondence between positions in the
pre-step version of a document and the same position in the
post-step version.
*/
class StepMap {
    /**
    Create a position map. The modifications to the document are
    represented as an array of numbers, in which each group of three
    represents a modified chunk as `[start, oldSize, newSize]`.
    */
    constructor(
    /**
    @internal
    */
    ranges, 
    /**
    @internal
    */
    inverted = false) {
        this.ranges = ranges;
        this.inverted = inverted;
        if (!ranges.length && StepMap.empty)
            return StepMap.empty;
    }
    /**
    @internal
    */
    recover(value) {
        let diff = 0, index = recoverIndex(value);
        if (!this.inverted)
            for (let i = 0; i < index; i++)
                diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
        return this.ranges[index * 3] + diff + recoverOffset(value);
    }
    mapResult(pos, assoc = 1) { return this._map(pos, assoc, false); }
    map(pos, assoc = 1) { return this._map(pos, assoc, true); }
    /**
    @internal
    */
    _map(pos, assoc, simple) {
        let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
        for (let i = 0; i < this.ranges.length; i += 3) {
            let start = this.ranges[i] - (this.inverted ? diff : 0);
            if (start > pos)
                break;
            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
            if (pos <= end) {
                let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
                let result = start + diff + (side < 0 ? 0 : newSize);
                if (simple)
                    return result;
                let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
                let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
                if (assoc < 0 ? pos != start : pos != end)
                    del |= DEL_SIDE;
                return new MapResult(result, del, recover);
            }
            diff += newSize - oldSize;
        }
        return simple ? pos + diff : new MapResult(pos + diff, 0, null);
    }
    /**
    @internal
    */
    touches(pos, recover) {
        let diff = 0, index = recoverIndex(recover);
        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
        for (let i = 0; i < this.ranges.length; i += 3) {
            let start = this.ranges[i] - (this.inverted ? diff : 0);
            if (start > pos)
                break;
            let oldSize = this.ranges[i + oldIndex], end = start + oldSize;
            if (pos <= end && i == index * 3)
                return true;
            diff += this.ranges[i + newIndex] - oldSize;
        }
        return false;
    }
    /**
    Calls the given function on each of the changed ranges included in
    this map.
    */
    forEach(f) {
        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
        for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
            let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
            f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
            diff += newSize - oldSize;
        }
    }
    /**
    Create an inverted version of this map. The result can be used to
    map positions in the post-step document to the pre-step document.
    */
    invert() {
        return new StepMap(this.ranges, !this.inverted);
    }
    /**
    @internal
    */
    toString() {
        return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    }
    /**
    Create a map that moves all positions by offset `n` (which may be
    negative). This can be useful when applying steps meant for a
    sub-document to a larger document, or vice-versa.
    */
    static offset(n) {
        return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
    }
}
/**
A StepMap that contains no changed ranges.
*/
StepMap.empty = new StepMap([]);
/**
A mapping represents a pipeline of zero or more [step
maps](https://prosemirror.net/docs/ref/#transform.StepMap). It has special provisions for losslessly
handling mapping positions through a series of steps in which some
steps are inverted versions of earlier steps. (This comes up when
‘[rebasing](/docs/guide/#transform.rebasing)’ steps for
collaboration or history management.)
*/
class Mapping {
    /**
    Create a new mapping with the given position maps.
    */
    constructor(
    /**
    The step maps in this mapping.
    */
    maps = [], 
    /**
    @internal
    */
    mirror, 
    /**
    The starting position in the `maps` array, used when `map` or
    `mapResult` is called.
    */
    from = 0, 
    /**
    The end position in the `maps` array.
    */
    to = maps.length) {
        this.maps = maps;
        this.mirror = mirror;
        this.from = from;
        this.to = to;
    }
    /**
    Create a mapping that maps only through a part of this one.
    */
    slice(from = 0, to = this.maps.length) {
        return new Mapping(this.maps, this.mirror, from, to);
    }
    /**
    @internal
    */
    copy() {
        return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
    }
    /**
    Add a step map to the end of this mapping. If `mirrors` is
    given, it should be the index of the step map that is the mirror
    image of this one.
    */
    appendMap(map, mirrors) {
        this.to = this.maps.push(map);
        if (mirrors != null)
            this.setMirror(this.maps.length - 1, mirrors);
    }
    /**
    Add all the step maps in a given mapping to this one (preserving
    mirroring information).
    */
    appendMapping(mapping) {
        for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
            let mirr = mapping.getMirror(i);
            this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);
        }
    }
    /**
    Finds the offset of the step map that mirrors the map at the
    given offset, in this mapping (as per the second argument to
    `appendMap`).
    */
    getMirror(n) {
        if (this.mirror)
            for (let i = 0; i < this.mirror.length; i++)
                if (this.mirror[i] == n)
                    return this.mirror[i + (i % 2 ? -1 : 1)];
    }
    /**
    @internal
    */
    setMirror(n, m) {
        if (!this.mirror)
            this.mirror = [];
        this.mirror.push(n, m);
    }
    /**
    Append the inverse of the given mapping to this one.
    */
    appendMappingInverted(mapping) {
        for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
            let mirr = mapping.getMirror(i);
            this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);
        }
    }
    /**
    Create an inverted version of this mapping.
    */
    invert() {
        let inverse = new Mapping;
        inverse.appendMappingInverted(this);
        return inverse;
    }
    /**
    Map a position through this mapping.
    */
    map(pos, assoc = 1) {
        if (this.mirror)
            return this._map(pos, assoc, true);
        for (let i = this.from; i < this.to; i++)
            pos = this.maps[i].map(pos, assoc);
        return pos;
    }
    /**
    Map a position through this mapping, returning a mapping
    result.
    */
    mapResult(pos, assoc = 1) { return this._map(pos, assoc, false); }
    /**
    @internal
    */
    _map(pos, assoc, simple) {
        let delInfo = 0;
        for (let i = this.from; i < this.to; i++) {
            let map = this.maps[i], result = map.mapResult(pos, assoc);
            if (result.recover != null) {
                let corr = this.getMirror(i);
                if (corr != null && corr > i && corr < this.to) {
                    i = corr;
                    pos = this.maps[corr].recover(result.recover);
                    continue;
                }
            }
            delInfo |= result.delInfo;
            pos = result.pos;
        }
        return simple ? pos : new MapResult(pos, delInfo, null);
    }
}

const stepsByID = Object.create(null);
/**
A step object represents an atomic change. It generally applies
only to the document it was created for, since the positions
stored in it will only make sense for that document.

New steps are defined by creating classes that extend `Step`,
overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`
methods, and registering your class with a unique
JSON-serialization identifier using
[`Step.jsonID`](https://prosemirror.net/docs/ref/#transform.Step^jsonID).
*/
class Step {
    /**
    Get the step map that represents the changes made by this step,
    and which can be used to transform between positions in the old
    and the new document.
    */
    getMap() { return StepMap.empty; }
    /**
    Try to merge this step with another one, to be applied directly
    after it. Returns the merged step when possible, null if the
    steps can't be merged.
    */
    merge(other) { return null; }
    /**
    Deserialize a step from its JSON representation. Will call
    through to the step class' own implementation of this method.
    */
    static fromJSON(schema, json) {
        if (!json || !json.stepType)
            throw new RangeError("Invalid input for Step.fromJSON");
        let type = stepsByID[json.stepType];
        if (!type)
            throw new RangeError(`No step type ${json.stepType} defined`);
        return type.fromJSON(schema, json);
    }
    /**
    To be able to serialize steps to JSON, each step needs a string
    ID to attach to its JSON representation. Use this method to
    register an ID for your step classes. Try to pick something
    that's unlikely to clash with steps from other modules.
    */
    static jsonID(id, stepClass) {
        if (id in stepsByID)
            throw new RangeError("Duplicate use of step JSON ID " + id);
        stepsByID[id] = stepClass;
        stepClass.prototype.jsonID = id;
        return stepClass;
    }
}
/**
The result of [applying](https://prosemirror.net/docs/ref/#transform.Step.apply) a step. Contains either a
new document or a failure value.
*/
class StepResult {
    /**
    @internal
    */
    constructor(
    /**
    The transformed document, if successful.
    */
    doc, 
    /**
    The failure message, if unsuccessful.
    */
    failed) {
        this.doc = doc;
        this.failed = failed;
    }
    /**
    Create a successful step result.
    */
    static ok(doc) { return new StepResult(doc, null); }
    /**
    Create a failed step result.
    */
    static fail(message) { return new StepResult(null, message); }
    /**
    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
    arguments. Create a successful result if it succeeds, and a
    failed one if it throws a `ReplaceError`.
    */
    static fromReplace(doc, from, to, slice) {
        try {
            return StepResult.ok(doc.replace(from, to, slice));
        }
        catch (e) {
            if (e instanceof ReplaceError)
                return StepResult.fail(e.message);
            throw e;
        }
    }
}

function mapFragment(fragment, f, parent) {
    let mapped = [];
    for (let i = 0; i < fragment.childCount; i++) {
        let child = fragment.child(i);
        if (child.content.size)
            child = child.copy(mapFragment(child.content, f, child));
        if (child.isInline)
            child = f(child, parent, i);
        mapped.push(child);
    }
    return Fragment.fromArray(mapped);
}
/**
Add a mark to all inline content between two positions.
*/
class AddMarkStep extends Step {
    /**
    Create a mark step.
    */
    constructor(
    /**
    The start of the marked range.
    */
    from, 
    /**
    The end of the marked range.
    */
    to, 
    /**
    The mark to add.
    */
    mark) {
        super();
        this.from = from;
        this.to = to;
        this.mark = mark;
    }
    apply(doc) {
        let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);
        let parent = $from.node($from.sharedDepth(this.to));
        let slice = new Slice(mapFragment(oldSlice.content, (node, parent) => {
            if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type))
                return node;
            return node.mark(this.mark.addToSet(node.marks));
        }, parent), oldSlice.openStart, oldSlice.openEnd);
        return StepResult.fromReplace(doc, this.from, this.to, slice);
    }
    invert() {
        return new RemoveMarkStep(this.from, this.to, this.mark);
    }
    map(mapping) {
        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from.deleted && to.deleted || from.pos >= to.pos)
            return null;
        return new AddMarkStep(from.pos, to.pos, this.mark);
    }
    merge(other) {
        if (other instanceof AddMarkStep &&
            other.mark.eq(this.mark) &&
            this.from <= other.to && this.to >= other.from)
            return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
        return null;
    }
    toJSON() {
        return { stepType: "addMark", mark: this.mark.toJSON(),
            from: this.from, to: this.to };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number")
            throw new RangeError("Invalid input for AddMarkStep.fromJSON");
        return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
}
Step.jsonID("addMark", AddMarkStep);
/**
Remove a mark from all inline content between two positions.
*/
class RemoveMarkStep extends Step {
    /**
    Create a mark-removing step.
    */
    constructor(
    /**
    The start of the unmarked range.
    */
    from, 
    /**
    The end of the unmarked range.
    */
    to, 
    /**
    The mark to remove.
    */
    mark) {
        super();
        this.from = from;
        this.to = to;
        this.mark = mark;
    }
    apply(doc) {
        let oldSlice = doc.slice(this.from, this.to);
        let slice = new Slice(mapFragment(oldSlice.content, node => {
            return node.mark(this.mark.removeFromSet(node.marks));
        }, doc), oldSlice.openStart, oldSlice.openEnd);
        return StepResult.fromReplace(doc, this.from, this.to, slice);
    }
    invert() {
        return new AddMarkStep(this.from, this.to, this.mark);
    }
    map(mapping) {
        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from.deleted && to.deleted || from.pos >= to.pos)
            return null;
        return new RemoveMarkStep(from.pos, to.pos, this.mark);
    }
    merge(other) {
        if (other instanceof RemoveMarkStep &&
            other.mark.eq(this.mark) &&
            this.from <= other.to && this.to >= other.from)
            return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
        return null;
    }
    toJSON() {
        return { stepType: "removeMark", mark: this.mark.toJSON(),
            from: this.from, to: this.to };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number")
            throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
        return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
}
Step.jsonID("removeMark", RemoveMarkStep);

/**
Replace a part of the document with a slice of new content.
*/
class ReplaceStep extends Step {
    /**
    The given `slice` should fit the 'gap' between `from` and
    `to`—the depths must line up, and the surrounding nodes must be
    able to be joined with the open sides of the slice. When
    `structure` is true, the step will fail if the content between
    from and to is not just a sequence of closing and then opening
    tokens (this is to guard against rebased replace steps
    overwriting something they weren't supposed to).
    */
    constructor(
    /**
    The start position of the replaced range.
    */
    from, 
    /**
    The end position of the replaced range.
    */
    to, 
    /**
    The slice to insert.
    */
    slice, 
    /**
    @internal
    */
    structure = false) {
        super();
        this.from = from;
        this.to = to;
        this.slice = slice;
        this.structure = structure;
    }
    apply(doc) {
        if (this.structure && contentBetween(doc, this.from, this.to))
            return StepResult.fail("Structure replace would overwrite content");
        return StepResult.fromReplace(doc, this.from, this.to, this.slice);
    }
    getMap() {
        return new StepMap([this.from, this.to - this.from, this.slice.size]);
    }
    invert(doc) {
        return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));
    }
    map(mapping) {
        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from.deletedAcross && to.deletedAcross)
            return null;
        return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);
    }
    merge(other) {
        if (!(other instanceof ReplaceStep) || other.structure || this.structure)
            return null;
        if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
            let slice = this.slice.size + other.slice.size == 0 ? Slice.empty
                : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
            return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);
        }
        else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
            let slice = this.slice.size + other.slice.size == 0 ? Slice.empty
                : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
            return new ReplaceStep(other.from, this.to, slice, this.structure);
        }
        else {
            return null;
        }
    }
    toJSON() {
        let json = { stepType: "replace", from: this.from, to: this.to };
        if (this.slice.size)
            json.slice = this.slice.toJSON();
        if (this.structure)
            json.structure = true;
        return json;
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number")
            throw new RangeError("Invalid input for ReplaceStep.fromJSON");
        return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
    }
}
Step.jsonID("replace", ReplaceStep);
/**
Replace a part of the document with a slice of content, but
preserve a range of the replaced content by moving it into the
slice.
*/
class ReplaceAroundStep extends Step {
    /**
    Create a replace-around step with the given range and gap.
    `insert` should be the point in the slice into which the content
    of the gap should be moved. `structure` has the same meaning as
    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
    */
    constructor(
    /**
    The start position of the replaced range.
    */
    from, 
    /**
    The end position of the replaced range.
    */
    to, 
    /**
    The start of preserved range.
    */
    gapFrom, 
    /**
    The end of preserved range.
    */
    gapTo, 
    /**
    The slice to insert.
    */
    slice, 
    /**
    The position in the slice where the preserved range should be
    inserted.
    */
    insert, 
    /**
    @internal
    */
    structure = false) {
        super();
        this.from = from;
        this.to = to;
        this.gapFrom = gapFrom;
        this.gapTo = gapTo;
        this.slice = slice;
        this.insert = insert;
        this.structure = structure;
    }
    apply(doc) {
        if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||
            contentBetween(doc, this.gapTo, this.to)))
            return StepResult.fail("Structure gap-replace would overwrite content");
        let gap = doc.slice(this.gapFrom, this.gapTo);
        if (gap.openStart || gap.openEnd)
            return StepResult.fail("Gap is not a flat range");
        let inserted = this.slice.insertAt(this.insert, gap.content);
        if (!inserted)
            return StepResult.fail("Content does not fit in gap");
        return StepResult.fromReplace(doc, this.from, this.to, inserted);
    }
    getMap() {
        return new StepMap([this.from, this.gapFrom - this.from, this.insert,
            this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);
    }
    invert(doc) {
        let gap = this.gapTo - this.gapFrom;
        return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
    }
    map(mapping) {
        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
        if ((from.deletedAcross && to.deletedAcross) || gapFrom < from.pos || gapTo > to.pos)
            return null;
        return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
    }
    toJSON() {
        let json = { stepType: "replaceAround", from: this.from, to: this.to,
            gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert };
        if (this.slice.size)
            json.slice = this.slice.toJSON();
        if (this.structure)
            json.structure = true;
        return json;
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number" ||
            typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
            throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
        return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
    }
}
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc, from, to) {
    let $from = doc.resolve(from), dist = to - from, depth = $from.depth;
    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
        depth--;
        dist--;
    }
    if (dist > 0) {
        let next = $from.node(depth).maybeChild($from.indexAfter(depth));
        while (dist > 0) {
            if (!next || next.isLeaf)
                return true;
            next = next.firstChild;
            dist--;
        }
    }
    return false;
}

function addMark(tr, from, to, mark) {
    let removed = [], added = [];
    let removing, adding;
    tr.doc.nodesBetween(from, to, (node, pos, parent) => {
        if (!node.isInline)
            return;
        let marks = node.marks;
        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
            let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);
            let newSet = mark.addToSet(marks);
            for (let i = 0; i < marks.length; i++) {
                if (!marks[i].isInSet(newSet)) {
                    if (removing && removing.to == start && removing.mark.eq(marks[i]))
                        removing.to = end;
                    else
                        removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
                }
            }
            if (adding && adding.to == start)
                adding.to = end;
            else
                added.push(adding = new AddMarkStep(start, end, mark));
        }
    });
    removed.forEach(s => tr.step(s));
    added.forEach(s => tr.step(s));
}
function removeMark(tr, from, to, mark) {
    let matched = [], step = 0;
    tr.doc.nodesBetween(from, to, (node, pos) => {
        if (!node.isInline)
            return;
        step++;
        let toRemove = null;
        if (mark instanceof MarkType) {
            let set = node.marks, found;
            while (found = mark.isInSet(set)) {
                (toRemove || (toRemove = [])).push(found);
                set = found.removeFromSet(set);
            }
        }
        else if (mark) {
            if (mark.isInSet(node.marks))
                toRemove = [mark];
        }
        else {
            toRemove = node.marks;
        }
        if (toRemove && toRemove.length) {
            let end = Math.min(pos + node.nodeSize, to);
            for (let i = 0; i < toRemove.length; i++) {
                let style = toRemove[i], found;
                for (let j = 0; j < matched.length; j++) {
                    let m = matched[j];
                    if (m.step == step - 1 && style.eq(matched[j].style))
                        found = m;
                }
                if (found) {
                    found.to = end;
                    found.step = step;
                }
                else {
                    matched.push({ style, from: Math.max(pos, from), to: end, step });
                }
            }
        }
    });
    matched.forEach(m => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr, pos, parentType, match = parentType.contentMatch) {
    let node = tr.doc.nodeAt(pos);
    let delSteps = [], cur = pos + 1;
    for (let i = 0; i < node.childCount; i++) {
        let child = node.child(i), end = cur + child.nodeSize;
        let allowed = match.matchType(child.type);
        if (!allowed) {
            delSteps.push(new ReplaceStep(cur, end, Slice.empty));
        }
        else {
            match = allowed;
            for (let j = 0; j < child.marks.length; j++)
                if (!parentType.allowsMarkType(child.marks[j].type))
                    tr.step(new RemoveMarkStep(cur, end, child.marks[j]));
        }
        cur = end;
    }
    if (!match.validEnd) {
        let fill = match.fillBefore(Fragment.empty, true);
        tr.replace(cur, cur, new Slice(fill, 0, 0));
    }
    for (let i = delSteps.length - 1; i >= 0; i--)
        tr.step(delSteps[i]);
}

function canCut(node, start, end) {
    return (start == 0 || node.canReplace(start, node.childCount)) &&
        (end == node.childCount || node.canReplace(0, end));
}
/**
Try to find a target depth to which the content in the given range
can be lifted. Will not go across
[isolating](https://prosemirror.net/docs/ref/#model.NodeSpec.isolating) parent nodes.
*/
function liftTarget(range) {
    let parent = range.parent;
    let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
    for (let depth = range.depth;; --depth) {
        let node = range.$from.node(depth);
        let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
        if (depth < range.depth && node.canReplace(index, endIndex, content))
            return depth;
        if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))
            break;
    }
    return null;
}
function lift$3(tr, range, target) {
    let { $from, $to, depth } = range;
    let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
    let start = gapStart, end = gapEnd;
    let before = Fragment.empty, openStart = 0;
    for (let d = depth, splitting = false; d > target; d--)
        if (splitting || $from.index(d) > 0) {
            splitting = true;
            before = Fragment.from($from.node(d).copy(before));
            openStart++;
        }
        else {
            start--;
        }
    let after = Fragment.empty, openEnd = 0;
    for (let d = depth, splitting = false; d > target; d--)
        if (splitting || $to.after(d + 1) < $to.end(d)) {
            splitting = true;
            after = Fragment.from($to.node(d).copy(after));
            openEnd++;
        }
        else {
            end++;
        }
    tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
/**
Try to find a valid way to wrap the content in the given range in a
node of the given type. May introduce extra nodes around and inside
the wrapper node, if necessary. Returns null if no valid wrapping
could be found. When `innerRange` is given, that range's content is
used as the content to fit into the wrapping, instead of the
content of `range`.
*/
function findWrapping(range, nodeType, attrs = null, innerRange = range) {
    let around = findWrappingOutside(range, nodeType);
    let inner = around && findWrappingInside(innerRange, nodeType);
    if (!inner)
        return null;
    return around.map(withAttrs)
        .concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) { return { type, attrs: null }; }
function findWrappingOutside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let around = parent.contentMatchAt(startIndex).findWrapping(type);
    if (!around)
        return null;
    let outer = around.length ? around[0] : type;
    return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let inner = parent.child(startIndex);
    let inside = type.contentMatch.findWrapping(inner.type);
    if (!inside)
        return null;
    let lastType = inside.length ? inside[inside.length - 1] : type;
    let innerMatch = lastType.contentMatch;
    for (let i = startIndex; innerMatch && i < endIndex; i++)
        innerMatch = innerMatch.matchType(parent.child(i).type);
    if (!innerMatch || !innerMatch.validEnd)
        return null;
    return inside;
}
function wrap(tr, range, wrappers) {
    let content = Fragment.empty;
    for (let i = wrappers.length - 1; i >= 0; i--) {
        if (content.size) {
            let match = wrappers[i].type.contentMatch.matchFragment(content);
            if (!match || !match.validEnd)
                throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
        }
        content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
    }
    let start = range.start, end = range.end;
    tr.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType$1(tr, from, to, type, attrs) {
    if (!type.isTextblock)
        throw new RangeError("Type given to setBlockType should be a textblock");
    let mapFrom = tr.steps.length;
    tr.doc.nodesBetween(from, to, (node, pos) => {
        if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {
            // Ensure all markup that isn't allowed in the new node type is cleared
            tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), type);
            let mapping = tr.mapping.slice(mapFrom);
            let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
            tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
            return false;
        }
    });
}
function canChangeType(doc, pos, type) {
    let $pos = doc.resolve(pos), index = $pos.index();
    return $pos.parent.canReplaceWith(index, index + 1, type);
}
/**
Change the type, attributes, and/or marks of the node at `pos`.
When `type` isn't given, the existing node type is preserved,
*/
function setNodeMarkup(tr, pos, type, attrs, marks) {
    let node = tr.doc.nodeAt(pos);
    if (!node)
        throw new RangeError("No node at given position");
    if (!type)
        type = node.type;
    let newNode = type.create(attrs, null, marks || node.marks);
    if (node.isLeaf)
        return tr.replaceWith(pos, pos + node.nodeSize, newNode);
    if (!type.validContent(node.content))
        throw new RangeError("Invalid content for node type " + type.name);
    tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
}
/**
Check whether splitting at the given position is allowed.
*/
function canSplit(doc, pos, depth = 1, typesAfter) {
    let $pos = doc.resolve(pos), base = $pos.depth - depth;
    let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent;
    if (base < 0 || $pos.parent.type.spec.isolating ||
        !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||
        !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
        return false;
    for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {
        let node = $pos.node(d), index = $pos.index(d);
        if (node.type.spec.isolating)
            return false;
        let rest = node.content.cutByIndex(index, node.childCount);
        let after = (typesAfter && typesAfter[i]) || node;
        if (after != node)
            rest = rest.replaceChild(0, after.type.create(after.attrs));
        if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))
            return false;
    }
    let index = $pos.indexAfter(base);
    let baseType = typesAfter && typesAfter[0];
    return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);
}
function split(tr, pos, depth = 1, typesAfter) {
    let $pos = tr.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
    for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
        before = Fragment.from($pos.node(d).copy(before));
        let typeAfter = typesAfter && typesAfter[i];
        after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
    }
    tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
/**
Test whether the blocks before and after a given position can be
joined.
*/
function canJoin(doc, pos) {
    let $pos = doc.resolve(pos), index = $pos.index();
    return joinable($pos.nodeBefore, $pos.nodeAfter) &&
        $pos.parent.canReplace(index, index + 1);
}
function joinable(a, b) {
    return !!(a && b && !a.isLeaf && a.canAppend(b));
}
function join(tr, pos, depth) {
    let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
    tr.step(step);
}
/**
Try to find a point where a node of the given type can be inserted
near `pos`, by searching up the node hierarchy when `pos` itself
isn't a valid place but is at the start or end of a node. Return
null if no position was found.
*/
function insertPoint(doc, pos, nodeType) {
    let $pos = doc.resolve(pos);
    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
        return pos;
    if ($pos.parentOffset == 0)
        for (let d = $pos.depth - 1; d >= 0; d--) {
            let index = $pos.index(d);
            if ($pos.node(d).canReplaceWith(index, index, nodeType))
                return $pos.before(d + 1);
            if (index > 0)
                return null;
        }
    if ($pos.parentOffset == $pos.parent.content.size)
        for (let d = $pos.depth - 1; d >= 0; d--) {
            let index = $pos.indexAfter(d);
            if ($pos.node(d).canReplaceWith(index, index, nodeType))
                return $pos.after(d + 1);
            if (index < $pos.node(d).childCount)
                return null;
        }
    return null;
}
/**
Finds a position at or around the given position where the given
slice can be inserted. Will look at parent nodes' nearest boundary
and try there, even if the original position wasn't directly at the
start or end of that node. Returns null when no position was found.
*/
function dropPoint(doc, pos, slice) {
    let $pos = doc.resolve(pos);
    if (!slice.content.size)
        return pos;
    let content = slice.content;
    for (let i = 0; i < slice.openStart; i++)
        content = content.firstChild.content;
    for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
        for (let d = $pos.depth; d >= 0; d--) {
            let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
            let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
            let parent = $pos.node(d), fits = false;
            if (pass == 1) {
                fits = parent.canReplace(insertPos, insertPos, content);
            }
            else {
                let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
                fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
            }
            if (fits)
                return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
        }
    }
    return null;
}

/**
‘Fit’ a slice into a given position in the document, producing a
[step](https://prosemirror.net/docs/ref/#transform.Step) that inserts it. Will return null if
there's no meaningful way to insert the slice here, or inserting it
would be a no-op (an empty slice over an empty range).
*/
function replaceStep(doc, from, to = from, slice = Slice.empty) {
    if (from == to && !slice.size)
        return null;
    let $from = doc.resolve(from), $to = doc.resolve(to);
    // Optimization -- avoid work if it's obvious that it's not needed.
    if (fitsTrivially($from, $to, slice))
        return new ReplaceStep(from, to, slice);
    return new Fitter($from, $to, slice).fit();
}
function fitsTrivially($from, $to, slice) {
    return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&
        $from.parent.canReplace($from.index(), $to.index(), slice.content);
}
// Algorithm for 'placing' the elements of a slice into a gap:
//
// We consider the content of each node that is open to the left to be
// independently placeable. I.e. in <p("foo"), p("bar")>, when the
// paragraph on the left is open, "foo" can be placed (somewhere on
// the left side of the replacement gap) independently from p("bar").
//
// This class tracks the state of the placement progress in the
// following properties:
//
//  - `frontier` holds a stack of `{type, match}` objects that
//    represent the open side of the replacement. It starts at
//    `$from`, then moves forward as content is placed, and is finally
//    reconciled with `$to`.
//
//  - `unplaced` is a slice that represents the content that hasn't
//    been placed yet.
//
//  - `placed` is a fragment of placed content. Its open-start value
//    is implicit in `$from`, and its open-end value in `frontier`.
class Fitter {
    constructor($from, $to, unplaced) {
        this.$from = $from;
        this.$to = $to;
        this.unplaced = unplaced;
        this.frontier = [];
        this.placed = Fragment.empty;
        for (let i = 0; i <= $from.depth; i++) {
            let node = $from.node(i);
            this.frontier.push({
                type: node.type,
                match: node.contentMatchAt($from.indexAfter(i))
            });
        }
        for (let i = $from.depth; i > 0; i--)
            this.placed = Fragment.from($from.node(i).copy(this.placed));
    }
    get depth() { return this.frontier.length - 1; }
    fit() {
        // As long as there's unplaced content, try to place some of it.
        // If that fails, either increase the open score of the unplaced
        // slice, or drop nodes from it, and then try again.
        while (this.unplaced.size) {
            let fit = this.findFittable();
            if (fit)
                this.placeNodes(fit);
            else
                this.openMore() || this.dropNode();
        }
        // When there's inline content directly after the frontier _and_
        // directly after `this.$to`, we must generate a `ReplaceAround`
        // step that pulls that content into the node after the frontier.
        // That means the fitting must be done to the end of the textblock
        // node after `this.$to`, not `this.$to` itself.
        let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
        let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
        if (!$to)
            return null;
        // If closing to `$to` succeeded, create a step
        let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
        while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes
            content = content.firstChild.content;
            openStart--;
            openEnd--;
        }
        let slice = new Slice(content, openStart, openEnd);
        if (moveInline > -1)
            return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);
        if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps
            return new ReplaceStep($from.pos, $to.pos, slice);
        return null;
    }
    // Find a position on the start spine of `this.unplaced` that has
    // content that can be moved somewhere on the frontier. Returns two
    // depths, one for the slice and one for the frontier.
    findFittable() {
        // Only try wrapping nodes (pass 2) after finding a place without
        // wrapping failed.
        for (let pass = 1; pass <= 2; pass++) {
            for (let sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
                let fragment, parent = null;
                if (sliceDepth) {
                    parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
                    fragment = parent.content;
                }
                else {
                    fragment = this.unplaced.content;
                }
                let first = fragment.firstChild;
                for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
                    let { type, match } = this.frontier[frontierDepth], wrap, inject = null;
                    // In pass 1, if the next node matches, or there is no next
                    // node but the parents look compatible, we've found a
                    // place.
                    if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))
                        : parent && type.compatibleContent(parent.type)))
                        return { sliceDepth, frontierDepth, parent, inject };
                    // In pass 2, look for a set of wrapping nodes that make
                    // `first` fit here.
                    else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))
                        return { sliceDepth, frontierDepth, parent, wrap };
                    // Don't continue looking further up if the parent node
                    // would fit here.
                    if (parent && match.matchType(parent.type))
                        break;
                }
            }
        }
    }
    openMore() {
        let { content, openStart, openEnd } = this.unplaced;
        let inner = contentAt(content, openStart);
        if (!inner.childCount || inner.firstChild.isLeaf)
            return false;
        this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
        return true;
    }
    dropNode() {
        let { content, openStart, openEnd } = this.unplaced;
        let inner = contentAt(content, openStart);
        if (inner.childCount <= 1 && openStart > 0) {
            let openAtEnd = content.size - openStart <= openStart + inner.size;
            this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
        }
        else {
            this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
        }
    }
    // Move content from the unplaced slice at `sliceDepth` to the
    // frontier node at `frontierDepth`. Close that frontier node when
    // applicable.
    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap }) {
        while (this.depth > frontierDepth)
            this.closeFrontierNode();
        if (wrap)
            for (let i = 0; i < wrap.length; i++)
                this.openFrontierNode(wrap[i]);
        let slice = this.unplaced, fragment = parent ? parent.content : slice.content;
        let openStart = slice.openStart - sliceDepth;
        let taken = 0, add = [];
        let { match, type } = this.frontier[frontierDepth];
        if (inject) {
            for (let i = 0; i < inject.childCount; i++)
                add.push(inject.child(i));
            match = match.matchFragment(inject);
        }
        // Computes the amount of (end) open nodes at the end of the
        // fragment. When 0, the parent is open, but no more. When
        // negative, nothing is open.
        let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd);
        // Scan over the fragment, fitting as many child nodes as
        // possible.
        while (taken < fragment.childCount) {
            let next = fragment.child(taken), matches = match.matchType(next.type);
            if (!matches)
                break;
            taken++;
            if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes
                match = matches;
                add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
            }
        }
        let toEnd = taken == fragment.childCount;
        if (!toEnd)
            openEndCount = -1;
        this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
        this.frontier[frontierDepth].match = match;
        // If the parent types match, and the entire node was moved, and
        // it's not open, close this frontier node right away.
        if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
            this.closeFrontierNode();
        // Add new frontier nodes for any open nodes at the end.
        for (let i = 0, cur = fragment; i < openEndCount; i++) {
            let node = cur.lastChild;
            this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
            cur = node.content;
        }
        // Update `this.unplaced`. Drop the entire node from which we
        // placed it we got to its end, otherwise just drop the placed
        // nodes.
        this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)
            : sliceDepth == 0 ? Slice.empty
                : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
    }
    mustMoveInline() {
        if (!this.$to.parent.isTextblock)
            return -1;
        let top = this.frontier[this.depth], level;
        if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||
            (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth))
            return -1;
        let { depth } = this.$to, after = this.$to.after(depth);
        while (depth > 1 && after == this.$to.end(--depth))
            ++after;
        return after;
    }
    findCloseLevel($to) {
        scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
            let { match, type } = this.frontier[i];
            let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
            let fit = contentAfterFits($to, i, type, match, dropInner);
            if (!fit)
                continue;
            for (let d = i - 1; d >= 0; d--) {
                let { match, type } = this.frontier[d];
                let matches = contentAfterFits($to, d, type, match, true);
                if (!matches || matches.childCount)
                    continue scan;
            }
            return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
        }
    }
    close($to) {
        let close = this.findCloseLevel($to);
        if (!close)
            return null;
        while (this.depth > close.depth)
            this.closeFrontierNode();
        if (close.fit.childCount)
            this.placed = addToFragment(this.placed, close.depth, close.fit);
        $to = close.move;
        for (let d = close.depth + 1; d <= $to.depth; d++) {
            let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
            this.openFrontierNode(node.type, node.attrs, add);
        }
        return $to;
    }
    openFrontierNode(type, attrs = null, content) {
        let top = this.frontier[this.depth];
        top.match = top.match.matchType(type);
        this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
        this.frontier.push({ type, match: type.contentMatch });
    }
    closeFrontierNode() {
        let open = this.frontier.pop();
        let add = open.match.fillBefore(Fragment.empty, true);
        if (add.childCount)
            this.placed = addToFragment(this.placed, this.frontier.length, add);
    }
}
function dropFromFragment(fragment, depth, count) {
    if (depth == 0)
        return fragment.cutByIndex(count, fragment.childCount);
    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
    if (depth == 0)
        return fragment.append(content);
    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
    for (let i = 0; i < depth; i++)
        fragment = fragment.firstChild.content;
    return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
    if (openStart <= 0)
        return node;
    let frag = node.content;
    if (openStart > 1)
        frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
    if (openStart > 0) {
        frag = node.type.contentMatch.fillBefore(frag).append(frag);
        if (openEnd <= 0)
            frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
    }
    return node.copy(frag);
}
function contentAfterFits($to, depth, type, match, open) {
    let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
    if (index == node.childCount && !type.compatibleContent(node.type))
        return null;
    let fit = match.fillBefore(node.content, true, index);
    return fit && !invalidMarks(type, node.content, index) ? fit : null;
}
function invalidMarks(type, fragment, start) {
    for (let i = start; i < fragment.childCount; i++)
        if (!type.allowsMarks(fragment.child(i).marks))
            return true;
    return false;
}
function definesContent(type) {
    return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr, from, to, slice) {
    if (!slice.size)
        return tr.deleteRange(from, to);
    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);
    if (fitsTrivially($from, $to, slice))
        return tr.step(new ReplaceStep(from, to, slice));
    let targetDepths = coveredDepths($from, tr.doc.resolve(to));
    // Can't replace the whole document, so remove 0 if it's present
    if (targetDepths[targetDepths.length - 1] == 0)
        targetDepths.pop();
    // Negative numbers represent not expansion over the whole node at
    // that depth, but replacing from $from.before(-D) to $to.pos.
    let preferredTarget = -($from.depth + 1);
    targetDepths.unshift(preferredTarget);
    // This loop picks a preferred target depth, if one of the covering
    // depths is not outside of a defining node, and adds negative
    // depths for any depth that has $from at its start and does not
    // cross a defining node.
    for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
        let spec = $from.node(d).type.spec;
        if (spec.defining || spec.definingAsContext || spec.isolating)
            break;
        if (targetDepths.indexOf(d) > -1)
            preferredTarget = d;
        else if ($from.before(d) == pos)
            targetDepths.splice(1, 0, -d);
    }
    // Try to fit each possible depth of the slice into each possible
    // target depth, starting with the preferred depths.
    let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
    let leftNodes = [], preferredDepth = slice.openStart;
    for (let content = slice.content, i = 0;; i++) {
        let node = content.firstChild;
        leftNodes.push(node);
        if (i == slice.openStart)
            break;
        content = node.content;
    }
    // Back up preferredDepth to cover defining textblocks directly
    // above it, possibly skipping a non-defining textblock.
    for (let d = preferredDepth - 1; d >= 0; d--) {
        let type = leftNodes[d].type, def = definesContent(type);
        if (def && $from.node(preferredTargetIndex).type != type)
            preferredDepth = d;
        else if (def || !type.isTextblock)
            break;
    }
    for (let j = slice.openStart; j >= 0; j--) {
        let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
        let insert = leftNodes[openDepth];
        if (!insert)
            continue;
        for (let i = 0; i < targetDepths.length; i++) {
            // Loop over possible expansion levels, starting with the
            // preferred one
            let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
            if (targetDepth < 0) {
                expand = false;
                targetDepth = -targetDepth;
            }
            let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
            if (parent.canReplaceWith(index, index, insert.type, insert.marks))
                return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));
        }
    }
    let startSteps = tr.steps.length;
    for (let i = targetDepths.length - 1; i >= 0; i--) {
        tr.replace(from, to, slice);
        if (tr.steps.length > startSteps)
            break;
        let depth = targetDepths[i];
        if (depth < 0)
            continue;
        from = $from.before(depth);
        to = $to.after(depth);
    }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
    if (depth < oldOpen) {
        let first = fragment.firstChild;
        fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
    }
    if (depth > newOpen) {
        let match = parent.contentMatchAt(0);
        let start = match.fillBefore(fragment).append(fragment);
        fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
    }
    return fragment;
}
function replaceRangeWith(tr, from, to, node) {
    if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {
        let point = insertPoint(tr.doc, from, node.type);
        if (point != null)
            from = to = point;
    }
    tr.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0));
}
function deleteRange$2(tr, from, to) {
    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);
    let covered = coveredDepths($from, $to);
    for (let i = 0; i < covered.length; i++) {
        let depth = covered[i], last = i == covered.length - 1;
        if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)
            return tr.delete($from.start(depth), $to.end(depth));
        if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
            return tr.delete($from.before(depth), $to.after(depth));
    }
    for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
        if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)
            return tr.delete($from.before(d), to);
    }
    tr.delete(from, to);
}
// Returns an array of all depths for which $from - $to spans the
// whole content of the nodes at that depth.
function coveredDepths($from, $to) {
    let result = [], minDepth = Math.min($from.depth, $to.depth);
    for (let d = minDepth; d >= 0; d--) {
        let start = $from.start(d);
        if (start < $from.pos - ($from.depth - d) ||
            $to.end(d) > $to.pos + ($to.depth - d) ||
            $from.node(d).type.spec.isolating ||
            $to.node(d).type.spec.isolating)
            break;
        if (start == $to.start(d) ||
            (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&
                d && $to.start(d - 1) == start - 1))
            result.push(d);
    }
    return result;
}

/**
@internal
*/
let TransformError = class extends Error {
};
TransformError = function TransformError(message) {
    let err = Error.call(this, message);
    err.__proto__ = TransformError.prototype;
    return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
/**
Abstraction to build up and track an array of
[steps](https://prosemirror.net/docs/ref/#transform.Step) representing a document transformation.

Most transforming methods return the `Transform` object itself, so
that they can be chained.
*/
class Transform {
    /**
    Create a transform that starts with the given document.
    */
    constructor(
    /**
    The current document (the result of applying the steps in the
    transform).
    */
    doc) {
        this.doc = doc;
        /**
        The steps in this transform.
        */
        this.steps = [];
        /**
        The documents before each of the steps.
        */
        this.docs = [];
        /**
        A mapping with the maps for each of the steps in this transform.
        */
        this.mapping = new Mapping;
    }
    /**
    The starting document.
    */
    get before() { return this.docs.length ? this.docs[0] : this.doc; }
    /**
    Apply a new step in this transform, saving the result. Throws an
    error when the step fails.
    */
    step(step) {
        let result = this.maybeStep(step);
        if (result.failed)
            throw new TransformError(result.failed);
        return this;
    }
    /**
    Try to apply a step in this transformation, ignoring it if it
    fails. Returns the step result.
    */
    maybeStep(step) {
        let result = step.apply(this.doc);
        if (!result.failed)
            this.addStep(step, result.doc);
        return result;
    }
    /**
    True when the document has been changed (when there are any
    steps).
    */
    get docChanged() {
        return this.steps.length > 0;
    }
    /**
    @internal
    */
    addStep(step, doc) {
        this.docs.push(this.doc);
        this.steps.push(step);
        this.mapping.appendMap(step.getMap());
        this.doc = doc;
    }
    /**
    Replace the part of the document between `from` and `to` with the
    given `slice`.
    */
    replace(from, to = from, slice = Slice.empty) {
        let step = replaceStep(this.doc, from, to, slice);
        if (step)
            this.step(step);
        return this;
    }
    /**
    Replace the given range with the given content, which may be a
    fragment, node, or array of nodes.
    */
    replaceWith(from, to, content) {
        return this.replace(from, to, new Slice(Fragment.from(content), 0, 0));
    }
    /**
    Delete the content between the given positions.
    */
    delete(from, to) {
        return this.replace(from, to, Slice.empty);
    }
    /**
    Insert the given content at the given position.
    */
    insert(pos, content) {
        return this.replaceWith(pos, pos, content);
    }
    /**
    Replace a range of the document with a given slice, using
    `from`, `to`, and the slice's
    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
    than fixed start and end points. This method may grow the
    replaced area or close open nodes in the slice in order to get a
    fit that is more in line with WYSIWYG expectations, by dropping
    fully covered parent nodes of the replaced region when they are
    marked [non-defining as
    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
    open parent node from the slice that _is_ marked as [defining
    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
    
    This is the method, for example, to handle paste. The similar
    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
    primitive tool which will _not_ move the start and end of its given
    range, and is useful in situations where you need more precise
    control over what happens.
    */
    replaceRange(from, to, slice) {
        replaceRange(this, from, to, slice);
        return this;
    }
    /**
    Replace the given range with a node, but use `from` and `to` as
    hints, rather than precise positions. When from and to are the same
    and are at the start or end of a parent node in which the given
    node doesn't fit, this method may _move_ them out towards a parent
    that does allow the given node to be placed. When the given range
    completely covers a parent node, this method may completely replace
    that parent node.
    */
    replaceRangeWith(from, to, node) {
        replaceRangeWith(this, from, to, node);
        return this;
    }
    /**
    Delete the given range, expanding it to cover fully covered
    parent nodes until a valid replace is found.
    */
    deleteRange(from, to) {
        deleteRange$2(this, from, to);
        return this;
    }
    /**
    Split the content in the given range off from its parent, if there
    is sibling content before or after it, and move it up the tree to
    the depth specified by `target`. You'll probably want to use
    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
    sure the lift is valid.
    */
    lift(range, target) {
        lift$3(this, range, target);
        return this;
    }
    /**
    Join the blocks around the given position. If depth is 2, their
    last and first siblings are also joined, and so on.
    */
    join(pos, depth = 1) {
        join(this, pos, depth);
        return this;
    }
    /**
    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
    The wrappers are assumed to be valid in this position, and should
    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
    */
    wrap(range, wrappers) {
        wrap(this, range, wrappers);
        return this;
    }
    /**
    Set the type of all textblocks (partly) between `from` and `to` to
    the given node type with the given attributes.
    */
    setBlockType(from, to = from, type, attrs = null) {
        setBlockType$1(this, from, to, type, attrs);
        return this;
    }
    /**
    Change the type, attributes, and/or marks of the node at `pos`.
    When `type` isn't given, the existing node type is preserved,
    */
    setNodeMarkup(pos, type, attrs = null, marks = []) {
        setNodeMarkup(this, pos, type, attrs, marks);
        return this;
    }
    /**
    Split the node at the given position, and optionally, if `depth` is
    greater than one, any number of nodes above that. By default, the
    parts split off will inherit the node type of the original node.
    This can be changed by passing an array of types and attributes to
    use after the split.
    */
    split(pos, depth = 1, typesAfter) {
        split(this, pos, depth, typesAfter);
        return this;
    }
    /**
    Add the given mark to the inline content between `from` and `to`.
    */
    addMark(from, to, mark) {
        addMark(this, from, to, mark);
        return this;
    }
    /**
    Remove marks from inline nodes between `from` and `to`. When
    `mark` is a single mark, remove precisely that mark. When it is
    a mark type, remove all marks of that type. When it is null,
    remove all marks of any type.
    */
    removeMark(from, to, mark) {
        removeMark(this, from, to, mark);
        return this;
    }
    /**
    Removes all marks and nodes from the content of the node at
    `pos` that don't match the given new parent node type. Accepts
    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
    third argument.
    */
    clearIncompatible(pos, parentType, match) {
        clearIncompatible(this, pos, parentType, match);
        return this;
    }
}

const classesById = Object.create(null);
/**
Superclass for editor selections. Every selection type should
extend this. Should not be instantiated directly.
*/
class Selection {
    /**
    Initialize a selection with the head and anchor and ranges. If no
    ranges are given, constructs a single range across `$anchor` and
    `$head`.
    */
    constructor(
    /**
    The resolved anchor of the selection (the side that stays in
    place when the selection is modified).
    */
    $anchor, 
    /**
    The resolved head of the selection (the side that moves when
    the selection is modified).
    */
    $head, ranges) {
        this.$anchor = $anchor;
        this.$head = $head;
        this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
    }
    /**
    The selection's anchor, as an unresolved position.
    */
    get anchor() { return this.$anchor.pos; }
    /**
    The selection's head.
    */
    get head() { return this.$head.pos; }
    /**
    The lower bound of the selection's main range.
    */
    get from() { return this.$from.pos; }
    /**
    The upper bound of the selection's main range.
    */
    get to() { return this.$to.pos; }
    /**
    The resolved lower  bound of the selection's main range.
    */
    get $from() {
        return this.ranges[0].$from;
    }
    /**
    The resolved upper bound of the selection's main range.
    */
    get $to() {
        return this.ranges[0].$to;
    }
    /**
    Indicates whether the selection contains any content.
    */
    get empty() {
        let ranges = this.ranges;
        for (let i = 0; i < ranges.length; i++)
            if (ranges[i].$from.pos != ranges[i].$to.pos)
                return false;
        return true;
    }
    /**
    Get the content of this selection as a slice.
    */
    content() {
        return this.$from.doc.slice(this.from, this.to, true);
    }
    /**
    Replace the selection with a slice or, if no slice is given,
    delete the selection. Will append to the given transaction.
    */
    replace(tr, content = Slice.empty) {
        // Put the new selection at the position after the inserted
        // content. When that ended in an inline node, search backwards,
        // to get the position after that node. If not, search forward.
        let lastNode = content.content.lastChild, lastParent = null;
        for (let i = 0; i < content.openEnd; i++) {
            lastParent = lastNode;
            lastNode = lastNode.lastChild;
        }
        let mapFrom = tr.steps.length, ranges = this.ranges;
        for (let i = 0; i < ranges.length; i++) {
            let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
            tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
            if (i == 0)
                selectionToInsertionEnd$1(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
        }
    }
    /**
    Replace the selection with the given node, appending the changes
    to the given transaction.
    */
    replaceWith(tr, node) {
        let mapFrom = tr.steps.length, ranges = this.ranges;
        for (let i = 0; i < ranges.length; i++) {
            let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
            let from = mapping.map($from.pos), to = mapping.map($to.pos);
            if (i) {
                tr.deleteRange(from, to);
            }
            else {
                tr.replaceRangeWith(from, to, node);
                selectionToInsertionEnd$1(tr, mapFrom, node.isInline ? -1 : 1);
            }
        }
    }
    /**
    Find a valid cursor or leaf node selection starting at the given
    position and searching back if `dir` is negative, and forward if
    positive. When `textOnly` is true, only consider cursor
    selections. Will return null when no valid selection position is
    found.
    */
    static findFrom($pos, dir, textOnly = false) {
        let inner = $pos.parent.inlineContent ? new TextSelection($pos)
            : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
        if (inner)
            return inner;
        for (let depth = $pos.depth - 1; depth >= 0; depth--) {
            let found = dir < 0
                ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)
                : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
            if (found)
                return found;
        }
        return null;
    }
    /**
    Find a valid cursor or leaf node selection near the given
    position. Searches forward first by default, but if `bias` is
    negative, it will search backwards first.
    */
    static near($pos, bias = 1) {
        return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
    }
    /**
    Find the cursor or leaf node selection closest to the start of
    the given document. Will return an
    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
    exists.
    */
    static atStart(doc) {
        return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);
    }
    /**
    Find the cursor or leaf node selection closest to the end of the
    given document.
    */
    static atEnd(doc) {
        return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);
    }
    /**
    Deserialize the JSON representation of a selection. Must be
    implemented for custom classes (as a static class method).
    */
    static fromJSON(doc, json) {
        if (!json || !json.type)
            throw new RangeError("Invalid input for Selection.fromJSON");
        let cls = classesById[json.type];
        if (!cls)
            throw new RangeError(`No selection type ${json.type} defined`);
        return cls.fromJSON(doc, json);
    }
    /**
    To be able to deserialize selections from JSON, custom selection
    classes must register themselves with an ID string, so that they
    can be disambiguated. Try to pick something that's unlikely to
    clash with classes from other modules.
    */
    static jsonID(id, selectionClass) {
        if (id in classesById)
            throw new RangeError("Duplicate use of selection JSON ID " + id);
        classesById[id] = selectionClass;
        selectionClass.prototype.jsonID = id;
        return selectionClass;
    }
    /**
    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
    which is a value that can be mapped without having access to a
    current document, and later resolved to a real selection for a
    given document again. (This is used mostly by the history to
    track and restore old selections.) The default implementation of
    this method just converts the selection to a text selection and
    returns the bookmark for that.
    */
    getBookmark() {
        return TextSelection.between(this.$anchor, this.$head).getBookmark();
    }
}
Selection.prototype.visible = true;
/**
Represents a selected range in a document.
*/
class SelectionRange {
    /**
    @internal
    */
    constructor(
    /**
    The lower bound of the range.
    */
    $from, 
    /**
    The upper bound of the range.
    */
    $to) {
        this.$from = $from;
        this.$to = $to;
    }
}
let warnedAboutTextSelection = false;
function checkTextSelection($pos) {
    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
        warnedAboutTextSelection = true;
        console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
    }
}
/**
A text selection represents a classical editor selection, with a
head (the moving side) and anchor (immobile side), both of which
point into textblock nodes. It can be empty (a regular cursor
position).
*/
class TextSelection extends Selection {
    /**
    Construct a text selection between the given points.
    */
    constructor($anchor, $head = $anchor) {
        checkTextSelection($anchor);
        checkTextSelection($head);
        super($anchor, $head);
    }
    /**
    Returns a resolved position if this is a cursor selection (an
    empty text selection), and null otherwise.
    */
    get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null; }
    map(doc, mapping) {
        let $head = doc.resolve(mapping.map(this.head));
        if (!$head.parent.inlineContent)
            return Selection.near($head);
        let $anchor = doc.resolve(mapping.map(this.anchor));
        return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
    }
    replace(tr, content = Slice.empty) {
        super.replace(tr, content);
        if (content == Slice.empty) {
            let marks = this.$from.marksAcross(this.$to);
            if (marks)
                tr.ensureMarks(marks);
        }
    }
    eq(other) {
        return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
    }
    getBookmark() {
        return new TextBookmark(this.anchor, this.head);
    }
    toJSON() {
        return { type: "text", anchor: this.anchor, head: this.head };
    }
    /**
    @internal
    */
    static fromJSON(doc, json) {
        if (typeof json.anchor != "number" || typeof json.head != "number")
            throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));
    }
    /**
    Create a text selection from non-resolved positions.
    */
    static create(doc, anchor, head = anchor) {
        let $anchor = doc.resolve(anchor);
        return new this($anchor, head == anchor ? $anchor : doc.resolve(head));
    }
    /**
    Return a text selection that spans the given positions or, if
    they aren't text positions, find a text selection near them.
    `bias` determines whether the method searches forward (default)
    or backwards (negative number) first. Will fall back to calling
    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
    doesn't contain a valid text position.
    */
    static between($anchor, $head, bias) {
        let dPos = $anchor.pos - $head.pos;
        if (!bias || dPos)
            bias = dPos >= 0 ? 1 : -1;
        if (!$head.parent.inlineContent) {
            let found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
            if (found)
                $head = found.$head;
            else
                return Selection.near($head, bias);
        }
        if (!$anchor.parent.inlineContent) {
            if (dPos == 0) {
                $anchor = $head;
            }
            else {
                $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
                if (($anchor.pos < $head.pos) != (dPos < 0))
                    $anchor = $head;
            }
        }
        return new TextSelection($anchor, $head);
    }
}
Selection.jsonID("text", TextSelection);
class TextBookmark {
    constructor(anchor, head) {
        this.anchor = anchor;
        this.head = head;
    }
    map(mapping) {
        return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
    }
    resolve(doc) {
        return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));
    }
}
/**
A node selection is a selection that points at a single node. All
nodes marked [selectable](https://prosemirror.net/docs/ref/#model.NodeSpec.selectable) can be the
target of a node selection. In such a selection, `from` and `to`
point directly before and after the selected node, `anchor` equals
`from`, and `head` equals `to`..
*/
class NodeSelection extends Selection {
    /**
    Create a node selection. Does not verify the validity of its
    argument.
    */
    constructor($pos) {
        let node = $pos.nodeAfter;
        let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
        super($pos, $end);
        this.node = node;
    }
    map(doc, mapping) {
        let { deleted, pos } = mapping.mapResult(this.anchor);
        let $pos = doc.resolve(pos);
        if (deleted)
            return Selection.near($pos);
        return new NodeSelection($pos);
    }
    content() {
        return new Slice(Fragment.from(this.node), 0, 0);
    }
    eq(other) {
        return other instanceof NodeSelection && other.anchor == this.anchor;
    }
    toJSON() {
        return { type: "node", anchor: this.anchor };
    }
    getBookmark() { return new NodeBookmark(this.anchor); }
    /**
    @internal
    */
    static fromJSON(doc, json) {
        if (typeof json.anchor != "number")
            throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new NodeSelection(doc.resolve(json.anchor));
    }
    /**
    Create a node selection from non-resolved positions.
    */
    static create(doc, from) {
        return new NodeSelection(doc.resolve(from));
    }
    /**
    Determines whether the given node may be selected as a node
    selection.
    */
    static isSelectable(node) {
        return !node.isText && node.type.spec.selectable !== false;
    }
}
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
class NodeBookmark {
    constructor(anchor) {
        this.anchor = anchor;
    }
    map(mapping) {
        let { deleted, pos } = mapping.mapResult(this.anchor);
        return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
    }
    resolve(doc) {
        let $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;
        if (node && NodeSelection.isSelectable(node))
            return new NodeSelection($pos);
        return Selection.near($pos);
    }
}
/**
A selection type that represents selecting the whole document
(which can not necessarily be expressed with a text selection, when
there are for example leaf block nodes at the start or end of the
document).
*/
class AllSelection extends Selection {
    /**
    Create an all-selection over the given document.
    */
    constructor(doc) {
        super(doc.resolve(0), doc.resolve(doc.content.size));
    }
    replace(tr, content = Slice.empty) {
        if (content == Slice.empty) {
            tr.delete(0, tr.doc.content.size);
            let sel = Selection.atStart(tr.doc);
            if (!sel.eq(tr.selection))
                tr.setSelection(sel);
        }
        else {
            super.replace(tr, content);
        }
    }
    toJSON() { return { type: "all" }; }
    /**
    @internal
    */
    static fromJSON(doc) { return new AllSelection(doc); }
    map(doc) { return new AllSelection(doc); }
    eq(other) { return other instanceof AllSelection; }
    getBookmark() { return AllBookmark; }
}
Selection.jsonID("all", AllSelection);
const AllBookmark = {
    map() { return this; },
    resolve(doc) { return new AllSelection(doc); }
};
// FIXME we'll need some awareness of text direction when scanning for selections
// Try to find a selection inside the given node. `pos` points at the
// position where the search starts. When `text` is true, only return
// text selections.
function findSelectionIn(doc, node, pos, index, dir, text = false) {
    if (node.inlineContent)
        return TextSelection.create(doc, pos);
    for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
        let child = node.child(i);
        if (!child.isAtom) {
            let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
            if (inner)
                return inner;
        }
        else if (!text && NodeSelection.isSelectable(child)) {
            return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));
        }
        pos += child.nodeSize * dir;
    }
    return null;
}
function selectionToInsertionEnd$1(tr, startLen, bias) {
    let last = tr.steps.length - 1;
    if (last < startLen)
        return;
    let step = tr.steps[last];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
        return;
    let map = tr.mapping.maps[last], end;
    map.forEach((_from, _to, _newFrom, newTo) => { if (end == null)
        end = newTo; });
    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}

const UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
/**
An editor state transaction, which can be applied to a state to
create an updated state. Use
[`EditorState.tr`](https://prosemirror.net/docs/ref/#state.EditorState.tr) to create an instance.

Transactions track changes to the document (they are a subclass of
[`Transform`](https://prosemirror.net/docs/ref/#transform.Transform)), but also other state changes,
like selection updates and adjustments of the set of [stored
marks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks). In addition, you can store
metadata properties in a transaction, which are extra pieces of
information that client code or plugins can use to describe what a
transaction represents, so that they can update their [own
state](https://prosemirror.net/docs/ref/#state.StateField) accordingly.

The [editor view](https://prosemirror.net/docs/ref/#view.EditorView) uses a few metadata properties:
it will attach a property `"pointer"` with the value `true` to
selection transactions directly caused by mouse or touch input, and
a `"uiEvent"` property of that may be `"paste"`, `"cut"`, or `"drop"`.
*/
class Transaction extends Transform {
    /**
    @internal
    */
    constructor(state) {
        super(state.doc);
        // The step count for which the current selection is valid.
        this.curSelectionFor = 0;
        // Bitfield to track which aspects of the state were updated by
        // this transaction.
        this.updated = 0;
        // Object used to store metadata properties for the transaction.
        this.meta = Object.create(null);
        this.time = Date.now();
        this.curSelection = state.selection;
        this.storedMarks = state.storedMarks;
    }
    /**
    The transaction's current selection. This defaults to the editor
    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
    transaction, but can be overwritten with
    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
    */
    get selection() {
        if (this.curSelectionFor < this.steps.length) {
            this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
            this.curSelectionFor = this.steps.length;
        }
        return this.curSelection;
    }
    /**
    Update the transaction's current selection. Will determine the
    selection that the editor gets when the transaction is applied.
    */
    setSelection(selection) {
        if (selection.$from.doc != this.doc)
            throw new RangeError("Selection passed to setSelection must point at the current document");
        this.curSelection = selection;
        this.curSelectionFor = this.steps.length;
        this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
        this.storedMarks = null;
        return this;
    }
    /**
    Whether the selection was explicitly updated by this transaction.
    */
    get selectionSet() {
        return (this.updated & UPDATED_SEL) > 0;
    }
    /**
    Set the current stored marks.
    */
    setStoredMarks(marks) {
        this.storedMarks = marks;
        this.updated |= UPDATED_MARKS;
        return this;
    }
    /**
    Make sure the current stored marks or, if that is null, the marks
    at the selection, match the given set of marks. Does nothing if
    this is already the case.
    */
    ensureMarks(marks) {
        if (!Mark$1.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
            this.setStoredMarks(marks);
        return this;
    }
    /**
    Add a mark to the set of stored marks.
    */
    addStoredMark(mark) {
        return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
    }
    /**
    Remove a mark or mark type from the set of stored marks.
    */
    removeStoredMark(mark) {
        return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
    }
    /**
    Whether the stored marks were explicitly set for this transaction.
    */
    get storedMarksSet() {
        return (this.updated & UPDATED_MARKS) > 0;
    }
    /**
    @internal
    */
    addStep(step, doc) {
        super.addStep(step, doc);
        this.updated = this.updated & ~UPDATED_MARKS;
        this.storedMarks = null;
    }
    /**
    Update the timestamp for the transaction.
    */
    setTime(time) {
        this.time = time;
        return this;
    }
    /**
    Replace the current selection with the given slice.
    */
    replaceSelection(slice) {
        this.selection.replace(this, slice);
        return this;
    }
    /**
    Replace the selection with the given node. When `inheritMarks` is
    true and the content is inline, it inherits the marks from the
    place where it is inserted.
    */
    replaceSelectionWith(node, inheritMarks = true) {
        let selection = this.selection;
        if (inheritMarks)
            node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || Mark$1.none)));
        selection.replaceWith(this, node);
        return this;
    }
    /**
    Delete the selection.
    */
    deleteSelection() {
        this.selection.replace(this);
        return this;
    }
    /**
    Replace the given range, or the selection if no range is given,
    with a text node containing the given string.
    */
    insertText(text, from, to) {
        let schema = this.doc.type.schema;
        if (from == null) {
            if (!text)
                return this.deleteSelection();
            return this.replaceSelectionWith(schema.text(text), true);
        }
        else {
            if (to == null)
                to = from;
            to = to == null ? from : to;
            if (!text)
                return this.deleteRange(from, to);
            let marks = this.storedMarks;
            if (!marks) {
                let $from = this.doc.resolve(from);
                marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
            }
            this.replaceRangeWith(from, to, schema.text(text, marks));
            if (!this.selection.empty)
                this.setSelection(Selection.near(this.selection.$to));
            return this;
        }
    }
    /**
    Store a metadata property in this transaction, keyed either by
    name or by plugin.
    */
    setMeta(key, value) {
        this.meta[typeof key == "string" ? key : key.key] = value;
        return this;
    }
    /**
    Retrieve a metadata property for a given name or plugin.
    */
    getMeta(key) {
        return this.meta[typeof key == "string" ? key : key.key];
    }
    /**
    Returns true if this transaction doesn't contain any metadata,
    and can thus safely be extended.
    */
    get isGeneric() {
        for (let _ in this.meta)
            return false;
        return true;
    }
    /**
    Indicate that the editor should scroll the selection into view
    when updated to the state produced by this transaction.
    */
    scrollIntoView() {
        this.updated |= UPDATED_SCROLL;
        return this;
    }
    /**
    True when this transaction has had `scrollIntoView` called on it.
    */
    get scrolledIntoView() {
        return (this.updated & UPDATED_SCROLL) > 0;
    }
}

function bind(f, self) {
    return !self || !f ? f : f.bind(self);
}
class FieldDesc {
    constructor(name, desc, self) {
        this.name = name;
        this.init = bind(desc.init, self);
        this.apply = bind(desc.apply, self);
    }
}
const baseFields = [
    new FieldDesc("doc", {
        init(config) { return config.doc || config.schema.topNodeType.createAndFill(); },
        apply(tr) { return tr.doc; }
    }),
    new FieldDesc("selection", {
        init(config, instance) { return config.selection || Selection.atStart(instance.doc); },
        apply(tr) { return tr.selection; }
    }),
    new FieldDesc("storedMarks", {
        init(config) { return config.storedMarks || null; },
        apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null; }
    }),
    new FieldDesc("scrollToSelection", {
        init() { return 0; },
        apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev; }
    })
];
// Object wrapping the part of a state object that stays the same
// across transactions. Stored in the state's `config` property.
class Configuration {
    constructor(schema, plugins) {
        this.schema = schema;
        this.plugins = [];
        this.pluginsByKey = Object.create(null);
        this.fields = baseFields.slice();
        if (plugins)
            plugins.forEach(plugin => {
                if (this.pluginsByKey[plugin.key])
                    throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
                this.plugins.push(plugin);
                this.pluginsByKey[plugin.key] = plugin;
                if (plugin.spec.state)
                    this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
            });
    }
}
/**
The state of a ProseMirror editor is represented by an object of
this type. A state is a persistent data structure—it isn't
updated, but rather a new state value is computed from an old one
using the [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) method.

A state holds a number of built-in fields, and plugins can
[define](https://prosemirror.net/docs/ref/#state.PluginSpec.state) additional fields.
*/
class EditorState {
    /**
    @internal
    */
    constructor(
    /**
    @internal
    */
    config) {
        this.config = config;
    }
    /**
    The schema of the state's document.
    */
    get schema() {
        return this.config.schema;
    }
    /**
    The plugins that are active in this state.
    */
    get plugins() {
        return this.config.plugins;
    }
    /**
    Apply the given transaction to produce a new state.
    */
    apply(tr) {
        return this.applyTransaction(tr).state;
    }
    /**
    @ignore
    */
    filterTransaction(tr, ignore = -1) {
        for (let i = 0; i < this.config.plugins.length; i++)
            if (i != ignore) {
                let plugin = this.config.plugins[i];
                if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
                    return false;
            }
        return true;
    }
    /**
    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
    returns the precise transactions that were applied (which might
    be influenced by the [transaction
    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
    plugins) along with the new state.
    */
    applyTransaction(rootTr) {
        if (!this.filterTransaction(rootTr))
            return { state: this, transactions: [] };
        let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
        // This loop repeatedly gives plugins a chance to respond to
        // transactions as new transactions are added, making sure to only
        // pass the transactions the plugin did not see before.
        for (;;) {
            let haveNew = false;
            for (let i = 0; i < this.config.plugins.length; i++) {
                let plugin = this.config.plugins[i];
                if (plugin.spec.appendTransaction) {
                    let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
                    let tr = n < trs.length &&
                        plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
                    if (tr && newState.filterTransaction(tr, i)) {
                        tr.setMeta("appendedTransaction", rootTr);
                        if (!seen) {
                            seen = [];
                            for (let j = 0; j < this.config.plugins.length; j++)
                                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
                        }
                        trs.push(tr);
                        newState = newState.applyInner(tr);
                        haveNew = true;
                    }
                    if (seen)
                        seen[i] = { state: newState, n: trs.length };
                }
            }
            if (!haveNew)
                return { state: newState, transactions: trs };
        }
    }
    /**
    @internal
    */
    applyInner(tr) {
        if (!tr.before.eq(this.doc))
            throw new RangeError("Applying a mismatched transaction");
        let newInstance = new EditorState(this.config), fields = this.config.fields;
        for (let i = 0; i < fields.length; i++) {
            let field = fields[i];
            newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
        }
        return newInstance;
    }
    /**
    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
    */
    get tr() { return new Transaction(this); }
    /**
    Create a new state.
    */
    static create(config) {
        let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
        let instance = new EditorState($config);
        for (let i = 0; i < $config.fields.length; i++)
            instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
        return instance;
    }
    /**
    Create a new state based on this one, but with an adjusted set
    of active plugins. State fields that exist in both sets of
    plugins are kept unchanged. Those that no longer exist are
    dropped, and those that are new are initialized using their
    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
    configuration object..
    */
    reconfigure(config) {
        let $config = new Configuration(this.schema, config.plugins);
        let fields = $config.fields, instance = new EditorState($config);
        for (let i = 0; i < fields.length; i++) {
            let name = fields[i].name;
            instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
        }
        return instance;
    }
    /**
    Serialize this state to JSON. If you want to serialize the state
    of plugins, pass an object mapping property names to use in the
    resulting JSON object to plugin objects. The argument may also be
    a string or number, in which case it is ignored, to support the
    way `JSON.stringify` calls `toString` methods.
    */
    toJSON(pluginFields) {
        let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
        if (this.storedMarks)
            result.storedMarks = this.storedMarks.map(m => m.toJSON());
        if (pluginFields && typeof pluginFields == 'object')
            for (let prop in pluginFields) {
                if (prop == "doc" || prop == "selection")
                    throw new RangeError("The JSON fields `doc` and `selection` are reserved");
                let plugin = pluginFields[prop], state = plugin.spec.state;
                if (state && state.toJSON)
                    result[prop] = state.toJSON.call(plugin, this[plugin.key]);
            }
        return result;
    }
    /**
    Deserialize a JSON representation of a state. `config` should
    have at least a `schema` field, and should contain array of
    plugins to initialize the state with. `pluginFields` can be used
    to deserialize the state of plugins, by associating plugin
    instances with the property names they use in the JSON object.
    */
    static fromJSON(config, json, pluginFields) {
        if (!json)
            throw new RangeError("Invalid input for EditorState.fromJSON");
        if (!config.schema)
            throw new RangeError("Required config field 'schema' missing");
        let $config = new Configuration(config.schema, config.plugins);
        let instance = new EditorState($config);
        $config.fields.forEach(field => {
            if (field.name == "doc") {
                instance.doc = Node$1.fromJSON(config.schema, json.doc);
            }
            else if (field.name == "selection") {
                instance.selection = Selection.fromJSON(instance.doc, json.selection);
            }
            else if (field.name == "storedMarks") {
                if (json.storedMarks)
                    instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
            }
            else {
                if (pluginFields)
                    for (let prop in pluginFields) {
                        let plugin = pluginFields[prop], state = plugin.spec.state;
                        if (plugin.key == field.name && state && state.fromJSON &&
                            Object.prototype.hasOwnProperty.call(json, prop)) {
                            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
                            return;
                        }
                    }
                instance[field.name] = field.init(config, instance);
            }
        });
        return instance;
    }
}

function bindProps(obj, self, target) {
    for (let prop in obj) {
        let val = obj[prop];
        if (val instanceof Function)
            val = val.bind(self);
        else if (prop == "handleDOMEvents")
            val = bindProps(val, self, {});
        target[prop] = val;
    }
    return target;
}
/**
Plugins bundle functionality that can be added to an editor.
They are part of the [editor state](https://prosemirror.net/docs/ref/#state.EditorState) and
may influence that state and the view that contains it.
*/
class Plugin {
    /**
    Create a plugin.
    */
    constructor(
    /**
    The plugin's [spec object](https://prosemirror.net/docs/ref/#state.PluginSpec).
    */
    spec) {
        this.spec = spec;
        /**
        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
        */
        this.props = {};
        if (spec.props)
            bindProps(spec.props, this, this.props);
        this.key = spec.key ? spec.key.key : createKey("plugin");
    }
    /**
    Extract the plugin's state field from an editor state.
    */
    getState(state) { return state[this.key]; }
}
const keys = Object.create(null);
function createKey(name) {
    if (name in keys)
        return name + "$" + ++keys[name];
    keys[name] = 0;
    return name + "$";
}
/**
A key is used to [tag](https://prosemirror.net/docs/ref/#state.PluginSpec.key) plugins in a way
that makes it possible to find them, given an editor state.
Assigning a key does mean only one plugin of that type can be
active in a state.
*/
class PluginKey {
    /**
    Create a plugin key.
    */
    constructor(name = "key") { this.key = createKey(name); }
    /**
    Get the active plugin with this key, if any, from an editor
    state.
    */
    get(state) { return state.config.pluginsByKey[this.key]; }
    /**
    Get the plugin's state from an editor state.
    */
    getState(state) { return state[this.key]; }
}

/**
Delete the selection, if there is one.
*/
const deleteSelection$2 = (state, dispatch) => {
    if (state.selection.empty)
        return false;
    if (dispatch)
        dispatch(state.tr.deleteSelection().scrollIntoView());
    return true;
};
/**
If the selection is empty and at the start of a textblock, try to
reduce the distance between that block and the one before it—if
there's a block directly before it that can be joined, join them.
If not, try to move the selected block closer to the next one in
the document structure by lifting it out of its parent or moving it
into a parent of the previous block. Will use the view for accurate
(bidi-aware) start-of-textblock detection if given.
*/
const joinBackward$2 = (state, dispatch, view) => {
    let { $cursor } = state.selection;
    if (!$cursor || (view ? !view.endOfTextblock("backward", state)
        : $cursor.parentOffset > 0))
        return false;
    let $cut = findCutBefore($cursor);
    // If there is no node before this, try to lift
    if (!$cut) {
        let range = $cursor.blockRange(), target = range && liftTarget(range);
        if (target == null)
            return false;
        if (dispatch)
            dispatch(state.tr.lift(range, target).scrollIntoView());
        return true;
    }
    let before = $cut.nodeBefore;
    // Apply the joining algorithm
    if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))
        return true;
    // If the node below has no content and the node above is
    // selectable, delete the node below and select the one above.
    if ($cursor.parent.content.size == 0 &&
        (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
        let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
        if (delStep && delStep.slice.size < delStep.to - delStep.from) {
            if (dispatch) {
                let tr = state.tr.step(delStep);
                tr.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)
                    : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
                dispatch(tr.scrollIntoView());
            }
            return true;
        }
    }
    // If the node before is an atom, delete it
    if (before.isAtom && $cut.depth == $cursor.depth - 1) {
        if (dispatch)
            dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
        return true;
    }
    return false;
};
function textblockAt(node, side, only = false) {
    for (let scan = node; scan; scan = (side == "start" ? scan.firstChild : scan.lastChild)) {
        if (scan.isTextblock)
            return true;
        if (only && scan.childCount != 1)
            return false;
    }
    return false;
}
/**
When the selection is empty and at the start of a textblock, select
the node before that textblock, if possible. This is intended to be
bound to keys like backspace, after
[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting
commands, as a fall-back behavior when the schema doesn't allow
deletion at the selected point.
*/
const selectNodeBackward$2 = (state, dispatch, view) => {
    let { $head, empty } = state.selection, $cut = $head;
    if (!empty)
        return false;
    if ($head.parent.isTextblock) {
        if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
            return false;
        $cut = findCutBefore($head);
    }
    let node = $cut && $cut.nodeBefore;
    if (!node || !NodeSelection.isSelectable(node))
        return false;
    if (dispatch)
        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
    return true;
};
function findCutBefore($pos) {
    if (!$pos.parent.type.spec.isolating)
        for (let i = $pos.depth - 1; i >= 0; i--) {
            if ($pos.index(i) > 0)
                return $pos.doc.resolve($pos.before(i + 1));
            if ($pos.node(i).type.spec.isolating)
                break;
        }
    return null;
}
/**
If the selection is empty and the cursor is at the end of a
textblock, try to reduce or remove the boundary between that block
and the one after it, either by joining them or by moving the other
block closer to this one in the tree structure. Will use the view
for accurate start-of-textblock detection if given.
*/
const joinForward$2 = (state, dispatch, view) => {
    let { $cursor } = state.selection;
    if (!$cursor || (view ? !view.endOfTextblock("forward", state)
        : $cursor.parentOffset < $cursor.parent.content.size))
        return false;
    let $cut = findCutAfter($cursor);
    // If there is no node after this, there's nothing to do
    if (!$cut)
        return false;
    let after = $cut.nodeAfter;
    // Try the joining algorithm
    if (deleteBarrier(state, $cut, dispatch))
        return true;
    // If the node above has no content and the node below is
    // selectable, delete the node above and select the one below.
    if ($cursor.parent.content.size == 0 &&
        (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
        let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
        if (delStep && delStep.slice.size < delStep.to - delStep.from) {
            if (dispatch) {
                let tr = state.tr.step(delStep);
                tr.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)
                    : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
                dispatch(tr.scrollIntoView());
            }
            return true;
        }
    }
    // If the next node is an atom, delete it
    if (after.isAtom && $cut.depth == $cursor.depth - 1) {
        if (dispatch)
            dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
        return true;
    }
    return false;
};
/**
When the selection is empty and at the end of a textblock, select
the node coming after that textblock, if possible. This is intended
to be bound to keys like delete, after
[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting
commands, to provide a fall-back behavior when the schema doesn't
allow deletion at the selected point.
*/
const selectNodeForward$2 = (state, dispatch, view) => {
    let { $head, empty } = state.selection, $cut = $head;
    if (!empty)
        return false;
    if ($head.parent.isTextblock) {
        if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
            return false;
        $cut = findCutAfter($head);
    }
    let node = $cut && $cut.nodeAfter;
    if (!node || !NodeSelection.isSelectable(node))
        return false;
    if (dispatch)
        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
    return true;
};
function findCutAfter($pos) {
    if (!$pos.parent.type.spec.isolating)
        for (let i = $pos.depth - 1; i >= 0; i--) {
            let parent = $pos.node(i);
            if ($pos.index(i) + 1 < parent.childCount)
                return $pos.doc.resolve($pos.after(i + 1));
            if (parent.type.spec.isolating)
                break;
        }
    return null;
}
/**
Lift the selected block, or the closest ancestor block of the
selection that can be lifted, out of its parent node.
*/
const lift$2 = (state, dispatch) => {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), target = range && liftTarget(range);
    if (target == null)
        return false;
    if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
};
/**
If the selection is in a node whose type has a truthy
[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, replace the
selection with a newline character.
*/
const newlineInCode$2 = (state, dispatch) => {
    let { $head, $anchor } = state.selection;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
        return false;
    if (dispatch)
        dispatch(state.tr.insertText("\n").scrollIntoView());
    return true;
};
function defaultBlockAt(match) {
    for (let i = 0; i < match.edgeCount; i++) {
        let { type } = match.edge(i);
        if (type.isTextblock && !type.hasRequiredAttrs())
            return type;
    }
    return null;
}
/**
When the selection is in a node with a truthy
[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a
default block after the code block, and move the cursor there.
*/
const exitCode$2 = (state, dispatch) => {
    let { $head, $anchor } = state.selection;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
        return false;
    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
    if (!type || !above.canReplaceWith(after, after, type))
        return false;
    if (dispatch) {
        let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
        tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
        dispatch(tr.scrollIntoView());
    }
    return true;
};
/**
If a block node is selected, create an empty paragraph before (if
it is its parent's first child) or after it.
*/
const createParagraphNear$2 = (state, dispatch) => {
    let sel = state.selection, { $from, $to } = sel;
    if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
        return false;
    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
    if (!type || !type.isTextblock)
        return false;
    if (dispatch) {
        let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
        let tr = state.tr.insert(side, type.createAndFill());
        tr.setSelection(TextSelection.create(tr.doc, side + 1));
        dispatch(tr.scrollIntoView());
    }
    return true;
};
/**
If the cursor is in an empty textblock that can be lifted, lift the
block.
*/
const liftEmptyBlock$2 = (state, dispatch) => {
    let { $cursor } = state.selection;
    if (!$cursor || $cursor.parent.content.size)
        return false;
    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
        let before = $cursor.before();
        if (canSplit(state.doc, before)) {
            if (dispatch)
                dispatch(state.tr.split(before).scrollIntoView());
            return true;
        }
    }
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
        return false;
    if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
};
/**
Move the selection to the node wrapping the current selection, if
any. (Will not select the document node.)
*/
const selectParentNode$2 = (state, dispatch) => {
    let { $from, to } = state.selection, pos;
    let same = $from.sharedDepth(to);
    if (same == 0)
        return false;
    pos = $from.before(same);
    if (dispatch)
        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
    return true;
};
function joinMaybeClear(state, $pos, dispatch) {
    let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
    if (!before || !after || !before.type.compatibleContent(after.type))
        return false;
    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
        if (dispatch)
            dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
        return true;
    }
    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
        return false;
    if (dispatch)
        dispatch(state.tr
            .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))
            .join($pos.pos)
            .scrollIntoView());
    return true;
}
function deleteBarrier(state, $cut, dispatch) {
    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
    if (before.type.spec.isolating || after.type.spec.isolating)
        return false;
    if (joinMaybeClear(state, $cut, dispatch))
        return true;
    let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
    if (canDelAfter &&
        (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&
        match.matchType(conn[0] || after.type).validEnd) {
        if (dispatch) {
            let end = $cut.pos + after.nodeSize, wrap = Fragment.empty;
            for (let i = conn.length - 1; i >= 0; i--)
                wrap = Fragment.from(conn[i].create(null, wrap));
            wrap = Fragment.from(before.copy(wrap));
            let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true));
            let joinAt = end + 2 * conn.length;
            if (canJoin(tr.doc, joinAt))
                tr.join(joinAt);
            dispatch(tr.scrollIntoView());
        }
        return true;
    }
    let selAfter = Selection.findFrom($cut, 1);
    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
    if (target != null && target >= $cut.depth) {
        if (dispatch)
            dispatch(state.tr.lift(range, target).scrollIntoView());
        return true;
    }
    if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
        let at = before, wrap = [];
        for (;;) {
            wrap.push(at);
            if (at.isTextblock)
                break;
            at = at.lastChild;
        }
        let afterText = after, afterDepth = 1;
        for (; !afterText.isTextblock; afterText = afterText.firstChild)
            afterDepth++;
        if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
            if (dispatch) {
                let end = Fragment.empty;
                for (let i = wrap.length - 1; i >= 0; i--)
                    end = Fragment.from(wrap[i].copy(end));
                let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap.length, 0), 0, true));
                dispatch(tr.scrollIntoView());
            }
            return true;
        }
    }
    return false;
}
function selectTextblockSide(side) {
    return function (state, dispatch) {
        let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
        let depth = $pos.depth;
        while ($pos.node(depth).isInline) {
            if (!depth)
                return false;
            depth--;
        }
        if (!$pos.node(depth).isTextblock)
            return false;
        if (dispatch)
            dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
        return true;
    };
}
/**
Moves the cursor to the start of current text block.
*/
const selectTextblockStart$2 = selectTextblockSide(-1);
/**
Moves the cursor to the end of current text block.
*/
const selectTextblockEnd$2 = selectTextblockSide(1);
// Parameterized commands
/**
Wrap the selection in a node of the given type with the given
attributes.
*/
function wrapIn$2(nodeType, attrs = null) {
    return function (state, dispatch) {
        let { $from, $to } = state.selection;
        let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
        if (!wrapping)
            return false;
        if (dispatch)
            dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
        return true;
    };
}
/**
Returns a command that tries to set the selected textblocks to the
given node type with the given attributes.
*/
function setBlockType(nodeType, attrs = null) {
    return function (state, dispatch) {
        let { from, to } = state.selection;
        let applicable = false;
        state.doc.nodesBetween(from, to, (node, pos) => {
            if (applicable)
                return false;
            if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
                return;
            if (node.type == nodeType) {
                applicable = true;
            }
            else {
                let $pos = state.doc.resolve(pos), index = $pos.index();
                applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
            }
        });
        if (!applicable)
            return false;
        if (dispatch)
            dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView());
        return true;
    };
}
typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
    // @ts-ignore
    : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;

/**
Returns a command function that wraps the selection in a list with
the given type an attributes. If `dispatch` is null, only return a
value to indicate whether this is possible, but don't actually
perform the change.
*/
function wrapInList$2(listType, attrs = null) {
    return function (state, dispatch) {
        let { $from, $to } = state.selection;
        let range = $from.blockRange($to), doJoin = false, outerRange = range;
        if (!range)
            return false;
        // This is at the top of an existing list item
        if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
            // Don't do anything if this is the top of the list
            if ($from.index(range.depth - 1) == 0)
                return false;
            let $insert = state.doc.resolve(range.start - 2);
            outerRange = new NodeRange($insert, $insert, range.depth);
            if (range.endIndex < range.parent.childCount)
                range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
            doJoin = true;
        }
        let wrap = findWrapping(outerRange, listType, attrs, range);
        if (!wrap)
            return false;
        if (dispatch)
            dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());
        return true;
    };
}
function doWrapInList(tr, range, wrappers, joinBefore, listType) {
    let content = Fragment.empty;
    for (let i = wrappers.length - 1; i >= 0; i--)
        content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
    tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
    let found = 0;
    for (let i = 0; i < wrappers.length; i++)
        if (wrappers[i].type == listType)
            found = i + 1;
    let splitDepth = wrappers.length - found;
    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
    for (let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false) {
        if (!first && canSplit(tr.doc, splitPos, splitDepth)) {
            tr.split(splitPos, splitDepth);
            splitPos += 2 * splitDepth;
        }
        splitPos += parent.child(i).nodeSize;
    }
    return tr;
}
/**
Create a command to lift the list item around the selection up into
a wrapping list.
*/
function liftListItem$2(itemType) {
    return function (state, dispatch) {
        let { $from, $to } = state.selection;
        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);
        if (!range)
            return false;
        if (!dispatch)
            return true;
        if ($from.node(range.depth - 1).type == itemType) // Inside a parent list
            return liftToOuterList(state, dispatch, itemType, range);
        else // Outer list node
            return liftOutOfList(state, dispatch, range);
    };
}
function liftToOuterList(state, dispatch, itemType, range) {
    let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
    if (end < endOfList) {
        // There are siblings after the lifted items, which must become
        // children of the last item
        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
        range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
    }
    dispatch(tr.lift(range, liftTarget(range)).scrollIntoView());
    return true;
}
function liftOutOfList(state, dispatch, range) {
    let tr = state.tr, list = range.parent;
    // Merge the list items into a single big item
    for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
        pos -= list.child(i).nodeSize;
        tr.delete(pos - 1, pos + 1);
    }
    let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
        return false;
    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
    let parent = $start.node(-1), indexBefore = $start.index(-1);
    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
        return false;
    let start = $start.pos, end = start + item.nodeSize;
    // Strip off the surrounding list. At the sides where we're not at
    // the end of the list, the existing list is closed. At sides where
    // this is the end, it is overwritten to its end.
    tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty)))
        .append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
    dispatch(tr.scrollIntoView());
    return true;
}
/**
Create a command to sink the list item around the selection down
into an inner list.
*/
function sinkListItem$2(itemType) {
    return function (state, dispatch) {
        let { $from, $to } = state.selection;
        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);
        if (!range)
            return false;
        let startIndex = range.startIndex;
        if (startIndex == 0)
            return false;
        let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
        if (nodeBefore.type != itemType)
            return false;
        if (dispatch) {
            let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
            let inner = Fragment.from(nestedBefore ? itemType.create() : null);
            let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
            let before = range.start, after = range.end;
            dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true))
                .scrollIntoView());
        }
        return true;
    };
}

const nav = typeof navigator != "undefined" ? navigator : null;
const doc = typeof document != "undefined" ? document : null;
const agent = (nav && nav.userAgent) || "";
const ie_edge = /Edge\/(\d+)/.exec(agent);
const ie_upto10 = /MSIE \d/.exec(agent);
const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
const ie$1 = !!(ie_upto10 || ie_11up || ie_edge);
const ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
const gecko$1 = !ie$1 && /gecko\/(\d+)/i.test(agent);
gecko$1 && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
const _chrome = !ie$1 && /Chrome\/(\d+)/.exec(agent);
const chrome$1 = !!_chrome;
const chrome_version = _chrome ? +_chrome[1] : 0;
const safari$1 = !ie$1 && !!nav && /Apple Computer/.test(nav.vendor);
// Is true for both iOS and iPadOS for convenience
const ios = safari$1 && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
const mac$2 = ios || (nav ? /Mac/.test(nav.platform) : false);
const android = /Android \d/.test(agent);
const webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
const webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;

const domIndex = function (node) {
    for (var index = 0;; index++) {
        node = node.previousSibling;
        if (!node)
            return index;
    }
};
const parentNode = function (node) {
    let parent = node.assignedSlot || node.parentNode;
    return parent && parent.nodeType == 11 ? parent.host : parent;
};
let reusedRange = null;
// Note that this will always return the same range, because DOM range
// objects are every expensive, and keep slowing down subsequent DOM
// updates, for some reason.
const textRange = function (node, from, to) {
    let range = reusedRange || (reusedRange = document.createRange());
    range.setEnd(node, to == null ? node.nodeValue.length : to);
    range.setStart(node, from || 0);
    return range;
};
// Scans forward and backward through DOM positions equivalent to the
// given one to see if the two are in the same place (i.e. after a
// text node vs at the end of that text node)
const isEquivalentPosition = function (node, off, targetNode, targetOff) {
    return targetNode && (scanFor(node, off, targetNode, targetOff, -1) ||
        scanFor(node, off, targetNode, targetOff, 1));
};
const atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
    for (;;) {
        if (node == targetNode && off == targetOff)
            return true;
        if (off == (dir < 0 ? 0 : nodeSize(node))) {
            let parent = node.parentNode;
            if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) ||
                node.contentEditable == "false")
                return false;
            off = domIndex(node) + (dir < 0 ? 0 : 1);
            node = parent;
        }
        else if (node.nodeType == 1) {
            node = node.childNodes[off + (dir < 0 ? -1 : 0)];
            if (node.contentEditable == "false")
                return false;
            off = dir < 0 ? nodeSize(node) : 0;
        }
        else {
            return false;
        }
    }
}
function nodeSize(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isOnEdge(node, offset, parent) {
    for (let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {
        if (node == parent)
            return true;
        let index = domIndex(node);
        node = node.parentNode;
        if (!node)
            return false;
        atStart = atStart && index == 0;
        atEnd = atEnd && index == nodeSize(node);
    }
}
function hasBlockDesc(dom) {
    let desc;
    for (let cur = dom; cur; cur = cur.parentNode)
        if (desc = cur.pmViewDesc)
            break;
    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523
// (isCollapsed inappropriately returns true in shadow dom)
const selectionCollapsed = function (domSel) {
    let collapsed = domSel.isCollapsed;
    if (collapsed && chrome$1 && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)
        collapsed = false;
    return collapsed;
};
function keyEvent(keyCode, key) {
    let event = document.createEvent("Event");
    event.initEvent("keydown", true, true);
    event.keyCode = keyCode;
    event.key = event.code = key;
    return event;
}

function windowRect(doc) {
    return { left: 0, right: doc.documentElement.clientWidth,
        top: 0, bottom: doc.documentElement.clientHeight };
}
function getSide(value, side) {
    return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
    let rect = node.getBoundingClientRect();
    // Adjust for elements with style "transform: scale()"
    let scaleX = (rect.width / node.offsetWidth) || 1;
    let scaleY = (rect.height / node.offsetHeight) || 1;
    // Make sure scrollbar width isn't included in the rectangle
    return { left: rect.left, right: rect.left + node.clientWidth * scaleX,
        top: rect.top, bottom: rect.top + node.clientHeight * scaleY };
}
function scrollRectIntoView(view, rect, startDOM) {
    let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
    let doc = view.dom.ownerDocument;
    for (let parent = startDOM || view.dom;; parent = parentNode(parent)) {
        if (!parent)
            break;
        if (parent.nodeType != 1)
            continue;
        let elt = parent;
        let atTop = elt == doc.body;
        let bounding = atTop ? windowRect(doc) : clientRect(elt);
        let moveX = 0, moveY = 0;
        if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
            moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
        else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
            moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
        if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
            moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
        else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
            moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
        if (moveX || moveY) {
            if (atTop) {
                doc.defaultView.scrollBy(moveX, moveY);
            }
            else {
                let startX = elt.scrollLeft, startY = elt.scrollTop;
                if (moveY)
                    elt.scrollTop += moveY;
                if (moveX)
                    elt.scrollLeft += moveX;
                let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
                rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
            }
        }
        if (atTop)
            break;
    }
}
// Store the scroll position of the editor's parent nodes, along with
// the top position of an element near the top of the editor, which
// will be used to make sure the visible viewport remains stable even
// when the size of the content above changes.
function storeScrollPos(view) {
    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
    let refDOM, refTop;
    for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
        let dom = view.root.elementFromPoint(x, y);
        if (!dom || dom == view.dom || !view.dom.contains(dom))
            continue;
        let localRect = dom.getBoundingClientRect();
        if (localRect.top >= startY - 20) {
            refDOM = dom;
            refTop = localRect.top;
            break;
        }
    }
    return { refDOM: refDOM, refTop: refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
    let stack = [], doc = dom.ownerDocument;
    for (let cur = dom; cur; cur = parentNode(cur)) {
        stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
        if (dom == doc)
            break;
    }
    return stack;
}
// Reset the scroll position of the editor's parent nodes to that what
// it was before, when storeScrollPos was called.
function resetScrollPos({ refDOM, refTop, stack }) {
    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
    for (let i = 0; i < stack.length; i++) {
        let { dom, top, left } = stack[i];
        if (dom.scrollTop != top + dTop)
            dom.scrollTop = top + dTop;
        if (dom.scrollLeft != left)
            dom.scrollLeft = left;
    }
}
let preventScrollSupported = null;
// Feature-detects support for .focus({preventScroll: true}), and uses
// a fallback kludge when not supported.
function focusPreventScroll(dom) {
    if (dom.setActive)
        return dom.setActive(); // in IE
    if (preventScrollSupported)
        return dom.focus(preventScrollSupported);
    let stored = scrollStack(dom);
    dom.focus(preventScrollSupported == null ? {
        get preventScroll() {
            preventScrollSupported = { preventScroll: true };
            return true;
        }
    } : undefined);
    if (!preventScrollSupported) {
        preventScrollSupported = false;
        restoreScrollStack(stored, 0);
    }
}
function findOffsetInNode(node, coords) {
    let closest, dxClosest = 2e8, coordsClosest, offset = 0;
    let rowBot = coords.top, rowTop = coords.top;
    for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
        let rects;
        if (child.nodeType == 1)
            rects = child.getClientRects();
        else if (child.nodeType == 3)
            rects = textRange(child).getClientRects();
        else
            continue;
        for (let i = 0; i < rects.length; i++) {
            let rect = rects[i];
            if (rect.top <= rowBot && rect.bottom >= rowTop) {
                rowBot = Math.max(rect.bottom, rowBot);
                rowTop = Math.min(rect.top, rowTop);
                let dx = rect.left > coords.left ? rect.left - coords.left
                    : rect.right < coords.left ? coords.left - rect.right : 0;
                if (dx < dxClosest) {
                    closest = child;
                    dxClosest = dx;
                    coordsClosest = dx && closest.nodeType == 3 ? {
                        left: rect.right < coords.left ? rect.right : rect.left,
                        top: coords.top
                    } : coords;
                    if (child.nodeType == 1 && dx)
                        offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
                    continue;
                }
            }
            if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||
                coords.left >= rect.left && coords.top >= rect.bottom))
                offset = childIndex + 1;
        }
    }
    if (closest && closest.nodeType == 3)
        return findOffsetInText(closest, coordsClosest);
    if (!closest || (dxClosest && closest.nodeType == 1))
        return { node, offset };
    return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
    let len = node.nodeValue.length;
    let range = document.createRange();
    for (let i = 0; i < len; i++) {
        range.setEnd(node, i + 1);
        range.setStart(node, i);
        let rect = singleRect(range, 1);
        if (rect.top == rect.bottom)
            continue;
        if (inRect(coords, rect))
            return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
    }
    return { node, offset: 0 };
}
function inRect(coords, rect) {
    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 &&
        coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
    let parent = dom.parentNode;
    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
        return parent;
    return dom;
}
function posFromElement(view, elt, coords) {
    let { node, offset } = findOffsetInNode(elt, coords), bias = -1;
    if (node.nodeType == 1 && !node.firstChild) {
        let rect = node.getBoundingClientRect();
        bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
    }
    return view.docView.posFromDOM(node, offset, bias);
}
function posFromCaret(view, node, offset, coords) {
    // Browser (in caretPosition/RangeFromPoint) will agressively
    // normalize towards nearby inline nodes. Since we are interested in
    // positions between block nodes too, we first walk up the hierarchy
    // of nodes to see if there are block nodes that the coordinates
    // fall outside of. If so, we take the position before/after that
    // block. If not, we call `posFromDOM` on the raw node/offset.
    let outside = -1;
    for (let cur = node;;) {
        if (cur == view.dom)
            break;
        let desc = view.docView.nearestDesc(cur, true);
        if (!desc)
            return null;
        if (desc.node.isBlock && desc.parent) {
            let rect = desc.dom.getBoundingClientRect();
            if (rect.left > coords.left || rect.top > coords.top)
                outside = desc.posBefore;
            else if (rect.right < coords.left || rect.bottom < coords.top)
                outside = desc.posAfter;
            else
                break;
        }
        cur = desc.dom.parentNode;
    }
    return outside > -1 ? outside : view.docView.posFromDOM(node, offset, 1);
}
function elementFromPoint(element, coords, box) {
    let len = element.childNodes.length;
    if (len && box.top < box.bottom) {
        for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {
            let child = element.childNodes[i];
            if (child.nodeType == 1) {
                let rects = child.getClientRects();
                for (let j = 0; j < rects.length; j++) {
                    let rect = rects[j];
                    if (inRect(coords, rect))
                        return elementFromPoint(child, coords, rect);
                }
            }
            if ((i = (i + 1) % len) == startI)
                break;
        }
    }
    return element;
}
// Given an x,y position on the editor, get the position in the document.
function posAtCoords(view, coords) {
    let doc = view.dom.ownerDocument, node, offset = 0;
    if (doc.caretPositionFromPoint) {
        try { // Firefox throws for this call in hard-to-predict circumstances (#994)
            let pos = doc.caretPositionFromPoint(coords.left, coords.top);
            if (pos)
                ({ offsetNode: node, offset } = pos);
        }
        catch (_) { }
    }
    if (!node && doc.caretRangeFromPoint) {
        let range = doc.caretRangeFromPoint(coords.left, coords.top);
        if (range)
            ({ startContainer: node, startOffset: offset } = range);
    }
    let elt = (view.root.elementFromPoint ? view.root : doc)
        .elementFromPoint(coords.left, coords.top + 1);
    let pos;
    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
        let box = view.dom.getBoundingClientRect();
        if (!inRect(coords, box))
            return null;
        elt = elementFromPoint(view.dom, coords, box);
        if (!elt)
            return null;
    }
    // Safari's caretRangeFromPoint returns nonsense when on a draggable element
    if (safari$1) {
        for (let p = elt; node && p; p = parentNode(p))
            if (p.draggable)
                node = undefined;
    }
    elt = targetKludge(elt, coords);
    if (node) {
        if (gecko$1 && node.nodeType == 1) {
            // Firefox will sometimes return offsets into <input> nodes, which
            // have no actual children, from caretPositionFromPoint (#953)
            offset = Math.min(offset, node.childNodes.length);
            // It'll also move the returned position before image nodes,
            // even if those are behind it.
            if (offset < node.childNodes.length) {
                let next = node.childNodes[offset], box;
                if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left &&
                    box.bottom > coords.top)
                    offset++;
            }
        }
        // Suspiciously specific kludge to work around caret*FromPoint
        // never returning a position at the end of the document
        if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 &&
            coords.top > node.lastChild.getBoundingClientRect().bottom)
            pos = view.state.doc.content.size;
        // Ignore positions directly after a BR, since caret*FromPoint
        // 'round up' positions that would be more accurately placed
        // before the BR node.
        else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR")
            pos = posFromCaret(view, node, offset, coords);
    }
    if (pos == null)
        pos = posFromElement(view, elt, coords);
    let desc = view.docView.nearestDesc(elt, true);
    return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function singleRect(target, bias) {
    let rects = target.getClientRects();
    return !rects.length ? target.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
}
const BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
// Given a position in the document model, get a bounding box of the
// character at that position, relative to the window.
function coordsAtPos(view, pos, side) {
    let { node, offset } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
    let supportEmptyRange = webkit || gecko$1;
    if (node.nodeType == 3) {
        // These browsers support querying empty text ranges. Prefer that in
        // bidi context or when at the end of a node.
        if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
            let rect = singleRect(textRange(node, offset, offset), side);
            // Firefox returns bad results (the position before the space)
            // when querying a position directly after line-broken
            // whitespace. Detect this situation and and kludge around it
            if (gecko$1 && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
                let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);
                if (rectBefore.top == rect.top) {
                    let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
                    if (rectAfter.top != rect.top)
                        return flattenV(rectAfter, rectAfter.left < rectBefore.left);
                }
            }
            return rect;
        }
        else {
            let from = offset, to = offset, takeSide = side < 0 ? 1 : -1;
            if (side < 0 && !offset) {
                to++;
                takeSide = -1;
            }
            else if (side >= 0 && offset == node.nodeValue.length) {
                from--;
                takeSide = 1;
            }
            else if (side < 0) {
                from--;
            }
            else {
                to++;
            }
            return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);
        }
    }
    // Return a horizontal line in block context
    if (!view.state.doc.resolve(pos).parent.inlineContent) {
        if (offset && (side < 0 || offset == nodeSize(node))) {
            let before = node.childNodes[offset - 1];
            if (before.nodeType == 1)
                return flattenH(before.getBoundingClientRect(), false);
        }
        if (offset < nodeSize(node)) {
            let after = node.childNodes[offset];
            if (after.nodeType == 1)
                return flattenH(after.getBoundingClientRect(), true);
        }
        return flattenH(node.getBoundingClientRect(), side >= 0);
    }
    // Inline, not in text node (this is not Bidi-safe)
    if (offset && (side < 0 || offset == nodeSize(node))) {
        let before = node.childNodes[offset - 1];
        let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1))
            // BR nodes tend to only return the rectangle before them.
            // Only use them if they are the last element in their parent
            : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
        if (target)
            return flattenV(singleRect(target, 1), false);
    }
    if (offset < nodeSize(node)) {
        let after = node.childNodes[offset];
        while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
            after = after.nextSibling;
        let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, (supportEmptyRange ? 0 : 1))
            : after.nodeType == 1 ? after : null;
        if (target)
            return flattenV(singleRect(target, -1), true);
    }
    // All else failed, just try to get a rectangle for the target node
    return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left) {
    if (rect.width == 0)
        return rect;
    let x = left ? rect.left : rect.right;
    return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top) {
    if (rect.height == 0)
        return rect;
    let y = top ? rect.top : rect.bottom;
    return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
    let viewState = view.state, active = view.root.activeElement;
    if (viewState != state)
        view.updateState(state);
    if (active != view.dom)
        view.focus();
    try {
        return f();
    }
    finally {
        if (viewState != state)
            view.updateState(viewState);
        if (active != view.dom && active)
            active.focus();
    }
}
// Whether vertical position motion in a given direction
// from a position would leave a text block.
function endOfTextblockVertical(view, state, dir) {
    let sel = state.selection;
    let $pos = dir == "up" ? sel.$from : sel.$to;
    return withFlushedState(view, state, () => {
        let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
        for (;;) {
            let nearest = view.docView.nearestDesc(dom, true);
            if (!nearest)
                break;
            if (nearest.node.isBlock) {
                dom = nearest.dom;
                break;
            }
            dom = nearest.dom.parentNode;
        }
        let coords = coordsAtPos(view, $pos.pos, 1);
        for (let child = dom.firstChild; child; child = child.nextSibling) {
            let boxes;
            if (child.nodeType == 1)
                boxes = child.getClientRects();
            else if (child.nodeType == 3)
                boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
            else
                continue;
            for (let i = 0; i < boxes.length; i++) {
                let box = boxes[i];
                if (box.bottom > box.top + 1 &&
                    (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2
                        : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
                    return false;
            }
        }
        return true;
    });
}
const maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
    let { $head } = state.selection;
    if (!$head.parent.isTextblock)
        return false;
    let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;
    let sel = view.domSelection();
    // If the textblock is all LTR, or the browser doesn't support
    // Selection.modify (Edge), fall back to a primitive approach
    if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
        return dir == "left" || dir == "backward" ? atStart : atEnd;
    return withFlushedState(view, state, () => {
        // This is a huge hack, but appears to be the best we can
        // currently do: use `Selection.modify` to move the selection by
        // one character, and see if that moves the cursor out of the
        // textblock (or doesn't move it at all, when at the start/end of
        // the document).
        let oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
        let oldBidiLevel = sel.caretBidiLevel // Only for Firefox
        ;
        sel.modify("move", dir, "character");
        let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
        let result = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) ||
            (oldNode == sel.focusNode && oldOff == sel.focusOffset);
        // Restore the previous selection
        sel.removeAllRanges();
        sel.addRange(oldRange);
        if (oldBidiLevel != null)
            sel.caretBidiLevel = oldBidiLevel;
        return result;
    });
}
let cachedState = null;
let cachedDir = null;
let cachedResult = false;
function endOfTextblock(view, state, dir) {
    if (cachedState == state && cachedDir == dir)
        return cachedResult;
    cachedState = state;
    cachedDir = dir;
    return cachedResult = dir == "up" || dir == "down"
        ? endOfTextblockVertical(view, state, dir)
        : endOfTextblockHorizontal(view, state, dir);
}

// View descriptions are data structures that describe the DOM that is
// used to represent the editor's content. They are used for:
//
// - Incremental redrawing when the document changes
//
// - Figuring out what part of the document a given DOM position
//   corresponds to
//
// - Wiring in custom implementations of the editing interface for a
//   given node
//
// They form a doubly-linked mutable tree, starting at `view.docView`.
const NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
// Superclass for the various kinds of descriptions. Defines their
// basic structure and shared methods.
class ViewDesc {
    constructor(parent, children, dom, 
    // This is the node that holds the child views. It may be null for
    // descs that don't have children.
    contentDOM) {
        this.parent = parent;
        this.children = children;
        this.dom = dom;
        this.contentDOM = contentDOM;
        this.dirty = NOT_DIRTY;
        // An expando property on the DOM node provides a link back to its
        // description.
        dom.pmViewDesc = this;
    }
    // Used to check whether a given description corresponds to a
    // widget/mark/node.
    matchesWidget(widget) { return false; }
    matchesMark(mark) { return false; }
    matchesNode(node, outerDeco, innerDeco) { return false; }
    matchesHack(nodeName) { return false; }
    // When parsing in-editor content (in domchange.js), we allow
    // descriptions to determine the parse rules that should be used to
    // parse them.
    parseRule() { return null; }
    // Used by the editor's event handler to ignore events that come
    // from certain descs.
    stopEvent(event) { return false; }
    // The size of the content represented by this desc.
    get size() {
        let size = 0;
        for (let i = 0; i < this.children.length; i++)
            size += this.children[i].size;
        return size;
    }
    // For block nodes, this represents the space taken up by their
    // start/end tokens.
    get border() { return 0; }
    destroy() {
        this.parent = undefined;
        if (this.dom.pmViewDesc == this)
            this.dom.pmViewDesc = undefined;
        for (let i = 0; i < this.children.length; i++)
            this.children[i].destroy();
    }
    posBeforeChild(child) {
        for (let i = 0, pos = this.posAtStart;; i++) {
            let cur = this.children[i];
            if (cur == child)
                return pos;
            pos += cur.size;
        }
    }
    get posBefore() {
        return this.parent.posBeforeChild(this);
    }
    get posAtStart() {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
    }
    get posAfter() {
        return this.posBefore + this.size;
    }
    get posAtEnd() {
        return this.posAtStart + this.size - 2 * this.border;
    }
    localPosFromDOM(dom, offset, bias) {
        // If the DOM position is in the content, use the child desc after
        // it to figure out a position.
        if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
            if (bias < 0) {
                let domBefore, desc;
                if (dom == this.contentDOM) {
                    domBefore = dom.childNodes[offset - 1];
                }
                else {
                    while (dom.parentNode != this.contentDOM)
                        dom = dom.parentNode;
                    domBefore = dom.previousSibling;
                }
                while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
                    domBefore = domBefore.previousSibling;
                return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
            }
            else {
                let domAfter, desc;
                if (dom == this.contentDOM) {
                    domAfter = dom.childNodes[offset];
                }
                else {
                    while (dom.parentNode != this.contentDOM)
                        dom = dom.parentNode;
                    domAfter = dom.nextSibling;
                }
                while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
                    domAfter = domAfter.nextSibling;
                return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
            }
        }
        // Otherwise, use various heuristics, falling back on the bias
        // parameter, to determine whether to return the position at the
        // start or at the end of this view desc.
        let atEnd;
        if (dom == this.dom && this.contentDOM) {
            atEnd = offset > domIndex(this.contentDOM);
        }
        else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
            atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
        }
        else if (this.dom.firstChild) {
            if (offset == 0)
                for (let search = dom;; search = search.parentNode) {
                    if (search == this.dom) {
                        atEnd = false;
                        break;
                    }
                    if (search.previousSibling)
                        break;
                }
            if (atEnd == null && offset == dom.childNodes.length)
                for (let search = dom;; search = search.parentNode) {
                    if (search == this.dom) {
                        atEnd = true;
                        break;
                    }
                    if (search.nextSibling)
                        break;
                }
        }
        return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
    }
    // Scan up the dom finding the first desc that is a descendant of
    // this one.
    nearestDesc(dom, onlyNodes = false) {
        for (let first = true, cur = dom; cur; cur = cur.parentNode) {
            let desc = this.getDesc(cur), nodeDOM;
            if (desc && (!onlyNodes || desc.node)) {
                // If dom is outside of this desc's nodeDOM, don't count it.
                if (first && (nodeDOM = desc.nodeDOM) &&
                    !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
                    first = false;
                else
                    return desc;
            }
        }
    }
    getDesc(dom) {
        let desc = dom.pmViewDesc;
        for (let cur = desc; cur; cur = cur.parent)
            if (cur == this)
                return desc;
    }
    posFromDOM(dom, offset, bias) {
        for (let scan = dom; scan; scan = scan.parentNode) {
            let desc = this.getDesc(scan);
            if (desc)
                return desc.localPosFromDOM(dom, offset, bias);
        }
        return -1;
    }
    // Find the desc for the node after the given pos, if any. (When a
    // parent node overrode rendering, there might not be one.)
    descAt(pos) {
        for (let i = 0, offset = 0; i < this.children.length; i++) {
            let child = this.children[i], end = offset + child.size;
            if (offset == pos && end != offset) {
                while (!child.border && child.children.length)
                    child = child.children[0];
                return child;
            }
            if (pos < end)
                return child.descAt(pos - offset - child.border);
            offset = end;
        }
    }
    domFromPos(pos, side) {
        if (!this.contentDOM)
            return { node: this.dom, offset: 0 };
        // First find the position in the child array
        let i = 0, offset = 0;
        for (let curPos = 0; i < this.children.length; i++) {
            let child = this.children[i], end = curPos + child.size;
            if (end > pos || child instanceof TrailingHackViewDesc) {
                offset = pos - curPos;
                break;
            }
            curPos = end;
        }
        // If this points into the middle of a child, call through
        if (offset)
            return this.children[i].domFromPos(offset - this.children[i].border, side);
        // Go back if there were any zero-length widgets with side >= 0 before this point
        for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) { }
        // Scan towards the first useable node
        if (side <= 0) {
            let prev, enter = true;
            for (;; i--, enter = false) {
                prev = i ? this.children[i - 1] : null;
                if (!prev || prev.dom.parentNode == this.contentDOM)
                    break;
            }
            if (prev && side && enter && !prev.border && !prev.domAtom)
                return prev.domFromPos(prev.size, side);
            return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
        }
        else {
            let next, enter = true;
            for (;; i++, enter = false) {
                next = i < this.children.length ? this.children[i] : null;
                if (!next || next.dom.parentNode == this.contentDOM)
                    break;
            }
            if (next && enter && !next.border && !next.domAtom)
                return next.domFromPos(0, side);
            return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
        }
    }
    // Used to find a DOM range in a single parent for a given changed
    // range.
    parseRange(from, to, base = 0) {
        if (this.children.length == 0)
            return { node: this.contentDOM, from, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
        let fromOffset = -1, toOffset = -1;
        for (let offset = base, i = 0;; i++) {
            let child = this.children[i], end = offset + child.size;
            if (fromOffset == -1 && from <= end) {
                let childBase = offset + child.border;
                // FIXME maybe descend mark views to parse a narrower range?
                if (from >= childBase && to <= end - child.border && child.node &&
                    child.contentDOM && this.contentDOM.contains(child.contentDOM))
                    return child.parseRange(from, to, childBase);
                from = offset;
                for (let j = i; j > 0; j--) {
                    let prev = this.children[j - 1];
                    if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
                        fromOffset = domIndex(prev.dom) + 1;
                        break;
                    }
                    from -= prev.size;
                }
                if (fromOffset == -1)
                    fromOffset = 0;
            }
            if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
                to = end;
                for (let j = i + 1; j < this.children.length; j++) {
                    let next = this.children[j];
                    if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
                        toOffset = domIndex(next.dom);
                        break;
                    }
                    to += next.size;
                }
                if (toOffset == -1)
                    toOffset = this.contentDOM.childNodes.length;
                break;
            }
            offset = end;
        }
        return { node: this.contentDOM, from, to, fromOffset, toOffset };
    }
    emptyChildAt(side) {
        if (this.border || !this.contentDOM || !this.children.length)
            return false;
        let child = this.children[side < 0 ? 0 : this.children.length - 1];
        return child.size == 0 || child.emptyChildAt(side);
    }
    domAfterPos(pos) {
        let { node, offset } = this.domFromPos(pos, 0);
        if (node.nodeType != 1 || offset == node.childNodes.length)
            throw new RangeError("No node after pos " + pos);
        return node.childNodes[offset];
    }
    // View descs are responsible for setting any selection that falls
    // entirely inside of them, so that custom implementations can do
    // custom things with the selection. Note that this falls apart when
    // a selection starts in such a node and ends in another, in which
    // case we just use whatever domFromPos produces as a best effort.
    setSelection(anchor, head, root, force = false) {
        // If the selection falls entirely in a child, give it to that child
        let from = Math.min(anchor, head), to = Math.max(anchor, head);
        for (let i = 0, offset = 0; i < this.children.length; i++) {
            let child = this.children[i], end = offset + child.size;
            if (from > offset && to < end)
                return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force);
            offset = end;
        }
        let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
        let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
        let domSel = root.getSelection();
        let brKludge = false;
        // On Firefox, using Selection.collapse to put the cursor after a
        // BR node for some reason doesn't always work (#1073). On Safari,
        // the cursor sometimes inexplicable visually lags behind its
        // reported position in such situations (#1092).
        if ((gecko$1 || safari$1) && anchor == head) {
            let { node, offset } = anchorDOM;
            if (node.nodeType == 3) {
                brKludge = !!(offset && node.nodeValue[offset - 1] == "\n");
                // Issue #1128
                if (brKludge && offset == node.nodeValue.length) {
                    for (let scan = node, after; scan; scan = scan.parentNode) {
                        if (after = scan.nextSibling) {
                            if (after.nodeName == "BR")
                                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
                            break;
                        }
                        let desc = scan.pmViewDesc;
                        if (desc && desc.node && desc.node.isBlock)
                            break;
                    }
                }
            }
            else {
                let prev = node.childNodes[offset - 1];
                brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
            }
        }
        // Firefox can act strangely when the selection is in front of an
        // uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536
        if (gecko$1 && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
            let after = domSel.focusNode.childNodes[domSel.focusOffset];
            if (after && after.contentEditable == "false")
                force = true;
        }
        if (!(force || brKludge && safari$1) &&
            isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) &&
            isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
            return;
        // Selection.extend can be used to create an 'inverted' selection
        // (one where the focus is before the anchor), but not all
        // browsers support it yet.
        let domSelExtended = false;
        if ((domSel.extend || anchor == head) && !brKludge) {
            domSel.collapse(anchorDOM.node, anchorDOM.offset);
            try {
                if (anchor != head)
                    domSel.extend(headDOM.node, headDOM.offset);
                domSelExtended = true;
            }
            catch (err) {
                // In some cases with Chrome the selection is empty after calling
                // collapse, even when it should be valid. This appears to be a bug, but
                // it is difficult to isolate. If this happens fallback to the old path
                // without using extend.
                if (!(err instanceof DOMException))
                    throw err;
                // declare global: DOMException
            }
        }
        if (!domSelExtended) {
            if (anchor > head) {
                let tmp = anchorDOM;
                anchorDOM = headDOM;
                headDOM = tmp;
            }
            let range = document.createRange();
            range.setEnd(headDOM.node, headDOM.offset);
            range.setStart(anchorDOM.node, anchorDOM.offset);
            domSel.removeAllRanges();
            domSel.addRange(range);
        }
    }
    ignoreMutation(mutation) {
        return !this.contentDOM && mutation.type != "selection";
    }
    get contentLost() {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
    }
    // Remove a subtree of the element tree that has been touched
    // by a DOM change, so that the next update will redraw it.
    markDirty(from, to) {
        for (let offset = 0, i = 0; i < this.children.length; i++) {
            let child = this.children[i], end = offset + child.size;
            if (offset == end ? from <= end && to >= offset : from < end && to > offset) {
                let startInside = offset + child.border, endInside = end - child.border;
                if (from >= startInside && to <= endInside) {
                    this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
                    if (from == startInside && to == endInside &&
                        (child.contentLost || child.dom.parentNode != this.contentDOM))
                        child.dirty = NODE_DIRTY;
                    else
                        child.markDirty(from - startInside, to - startInside);
                    return;
                }
                else {
                    child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length
                        ? CONTENT_DIRTY : NODE_DIRTY;
                }
            }
            offset = end;
        }
        this.dirty = CONTENT_DIRTY;
    }
    markParentsDirty() {
        let level = 1;
        for (let node = this.parent; node; node = node.parent, level++) {
            let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
            if (node.dirty < dirty)
                node.dirty = dirty;
        }
    }
    get domAtom() { return false; }
    get ignoreForCoords() { return false; }
}
// A widget desc represents a widget decoration, which is a DOM node
// drawn between the document nodes.
class WidgetViewDesc extends ViewDesc {
    constructor(parent, widget, view, pos) {
        let self, dom = widget.type.toDOM;
        if (typeof dom == "function")
            dom = dom(view, () => {
                if (!self)
                    return pos;
                if (self.parent)
                    return self.parent.posBeforeChild(self);
            });
        if (!widget.type.spec.raw) {
            if (dom.nodeType != 1) {
                let wrap = document.createElement("span");
                wrap.appendChild(dom);
                dom = wrap;
            }
            dom.contentEditable = "false";
            dom.classList.add("ProseMirror-widget");
        }
        super(parent, [], dom, null);
        this.widget = widget;
        this.widget = widget;
        self = this;
    }
    matchesWidget(widget) {
        return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
    }
    parseRule() { return { ignore: true }; }
    stopEvent(event) {
        let stop = this.widget.spec.stopEvent;
        return stop ? stop(event) : false;
    }
    ignoreMutation(mutation) {
        return mutation.type != "selection" || this.widget.spec.ignoreSelection;
    }
    destroy() {
        this.widget.type.destroy(this.dom);
        super.destroy();
    }
    get domAtom() { return true; }
    get side() { return this.widget.type.side; }
}
class CompositionViewDesc extends ViewDesc {
    constructor(parent, dom, textDOM, text) {
        super(parent, [], dom, null);
        this.textDOM = textDOM;
        this.text = text;
    }
    get size() { return this.text.length; }
    localPosFromDOM(dom, offset) {
        if (dom != this.textDOM)
            return this.posAtStart + (offset ? this.size : 0);
        return this.posAtStart + offset;
    }
    domFromPos(pos) {
        return { node: this.textDOM, offset: pos };
    }
    ignoreMutation(mut) {
        return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue;
    }
}
// A mark desc represents a mark. May have multiple children,
// depending on how the mark is split. Note that marks are drawn using
// a fixed nesting order, for simplicity and predictability, so in
// some cases they will be split more often than would appear
// necessary.
class MarkViewDesc extends ViewDesc {
    constructor(parent, mark, dom, contentDOM) {
        super(parent, [], dom, contentDOM);
        this.mark = mark;
    }
    static create(parent, mark, inline, view) {
        let custom = view.nodeViews[mark.type.name];
        let spec = custom && custom(mark, view, inline);
        if (!spec || !spec.dom)
            spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));
        return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);
    }
    parseRule() {
        if ((this.dirty & NODE_DIRTY) || this.mark.type.spec.reparseInView)
            return null;
        return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM || undefined };
    }
    matchesMark(mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark); }
    markDirty(from, to) {
        super.markDirty(from, to);
        // Move dirty info to nearest node view
        if (this.dirty != NOT_DIRTY) {
            let parent = this.parent;
            while (!parent.node)
                parent = parent.parent;
            if (parent.dirty < this.dirty)
                parent.dirty = this.dirty;
            this.dirty = NOT_DIRTY;
        }
    }
    slice(from, to, view) {
        let copy = MarkViewDesc.create(this.parent, this.mark, true, view);
        let nodes = this.children, size = this.size;
        if (to < size)
            nodes = replaceNodes(nodes, to, size, view);
        if (from > 0)
            nodes = replaceNodes(nodes, 0, from, view);
        for (let i = 0; i < nodes.length; i++)
            nodes[i].parent = copy;
        copy.children = nodes;
        return copy;
    }
}
// Node view descs are the main, most common type of view desc, and
// correspond to an actual node in the document. Unlike mark descs,
// they populate their child array themselves.
class NodeViewDesc extends ViewDesc {
    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
        super(parent, [], dom, contentDOM);
        this.node = node;
        this.outerDeco = outerDeco;
        this.innerDeco = innerDeco;
        this.nodeDOM = nodeDOM;
        if (contentDOM)
            this.updateChildren(view, pos);
    }
    // By default, a node is rendered using the `toDOM` method from the
    // node type spec. But client code can use the `nodeViews` spec to
    // supply a custom node view, which can influence various aspects of
    // the way the node works.
    //
    // (Using subclassing for this was intentionally decided against,
    // since it'd require exposing a whole slew of finicky
    // implementation details to the user code that they probably will
    // never need.)
    static create(parent, node, outerDeco, innerDeco, view, pos) {
        let custom = view.nodeViews[node.type.name], descObj;
        let spec = custom && custom(node, view, () => {
            // (This is a function that allows the custom view to find its
            // own position)
            if (!descObj)
                return pos;
            if (descObj.parent)
                return descObj.parent.posBeforeChild(descObj);
        }, outerDeco, innerDeco);
        let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
        if (node.isText) {
            if (!dom)
                dom = document.createTextNode(node.text);
            else if (dom.nodeType != 3)
                throw new RangeError("Text must be rendered as a DOM text node");
        }
        else if (!dom) {
            ({ dom, contentDOM } = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)));
        }
        if (!contentDOM && !node.isText && dom.nodeName != "BR") { // Chrome gets confused by <br contenteditable=false>
            if (!dom.hasAttribute("contenteditable"))
                dom.contentEditable = "false";
            if (node.type.spec.draggable)
                dom.draggable = true;
        }
        let nodeDOM = dom;
        dom = applyOuterDeco(dom, outerDeco, node);
        if (spec)
            return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
        else if (node.isText)
            return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
        else
            return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
    }
    parseRule() {
        // Experimental kludge to allow opt-in re-parsing of nodes
        if (this.node.type.spec.reparseInView)
            return null;
        // FIXME the assumption that this can always return the current
        // attrs means that if the user somehow manages to change the
        // attrs in the dom, that won't be picked up. Not entirely sure
        // whether this is a problem
        let rule = { node: this.node.type.name, attrs: this.node.attrs };
        if (this.node.type.whitespace == "pre")
            rule.preserveWhitespace = "full";
        if (!this.contentDOM) {
            rule.getContent = () => this.node.content;
        }
        else if (!this.contentLost) {
            rule.contentElement = this.contentDOM;
        }
        else {
            // Chrome likes to randomly recreate parent nodes when
            // backspacing things. When that happens, this tries to find the
            // new parent.
            for (let i = this.children.length - 1; i >= 0; i--) {
                let child = this.children[i];
                if (this.dom.contains(child.dom.parentNode)) {
                    rule.contentElement = child.dom.parentNode;
                    break;
                }
            }
            if (!rule.contentElement)
                rule.getContent = () => Fragment.empty;
        }
        return rule;
    }
    matchesNode(node, outerDeco, innerDeco) {
        return this.dirty == NOT_DIRTY && node.eq(this.node) &&
            sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
    }
    get size() { return this.node.nodeSize; }
    get border() { return this.node.isLeaf ? 0 : 1; }
    // Syncs `this.children` to match `this.node.content` and the local
    // decorations, possibly introducing nesting for marks. Then, in a
    // separate step, syncs the DOM inside `this.contentDOM` to
    // `this.children`.
    updateChildren(view, pos) {
        let inline = this.node.inlineContent, off = pos;
        let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
        let localComposition = composition && composition.pos > -1 ? composition : null;
        let compositionInChild = composition && composition.pos < 0;
        let updater = new ViewTreeUpdater(this, localComposition && localComposition.node);
        iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
            if (widget.spec.marks)
                updater.syncToMarks(widget.spec.marks, inline, view);
            else if (widget.type.side >= 0 && !insideNode)
                updater.syncToMarks(i == this.node.childCount ? Mark$1.none : this.node.child(i).marks, inline, view);
            // If the next node is a desc matching this widget, reuse it,
            // otherwise insert the widget as a new view desc.
            updater.placeWidget(widget, view, off);
        }, (child, outerDeco, innerDeco, i) => {
            // Make sure the wrapping mark descs match the node's marks.
            updater.syncToMarks(child.marks, inline, view);
            // Try several strategies for drawing this node
            let compIndex;
            if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;
            else if (compositionInChild && view.state.selection.from > off &&
                view.state.selection.to < off + child.nodeSize &&
                (compIndex = updater.findIndexWithChild(composition.node)) > -1 &&
                updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
            else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i)) ;
            else {
                // Add it as a new view
                updater.addNode(child, outerDeco, innerDeco, view, off);
            }
            off += child.nodeSize;
        });
        // Drop all remaining descs after the current position.
        updater.syncToMarks([], inline, view);
        if (this.node.isTextblock)
            updater.addTextblockHacks();
        updater.destroyRest();
        // Sync the DOM if anything changed
        if (updater.changed || this.dirty == CONTENT_DIRTY) {
            // May have to protect focused DOM from being changed if a composition is active
            if (localComposition)
                this.protectLocalComposition(view, localComposition);
            renderDescs(this.contentDOM, this.children, view);
            if (ios)
                iosHacks(this.dom);
        }
    }
    localCompositionInfo(view, pos) {
        // Only do something if both the selection and a focused text node
        // are inside of this node
        let { from, to } = view.state.selection;
        if (!(view.state.selection instanceof TextSelection) || from < pos || to > pos + this.node.content.size)
            return null;
        let sel = view.domSelection();
        let textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
        if (!textNode || !this.dom.contains(textNode.parentNode))
            return null;
        if (this.node.inlineContent) {
            // Find the text in the focused node in the node, stop if it's not
            // there (may have been modified through other means, in which
            // case it should overwritten)
            let text = textNode.nodeValue;
            let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);
            return textPos < 0 ? null : { node: textNode, pos: textPos, text };
        }
        else {
            return { node: textNode, pos: -1, text: "" };
        }
    }
    protectLocalComposition(view, { node, pos, text }) {
        // The node is already part of a local view desc, leave it there
        if (this.getDesc(node))
            return;
        // Create a composition view for the orphaned nodes
        let topNode = node;
        for (;; topNode = topNode.parentNode) {
            if (topNode.parentNode == this.contentDOM)
                break;
            while (topNode.previousSibling)
                topNode.parentNode.removeChild(topNode.previousSibling);
            while (topNode.nextSibling)
                topNode.parentNode.removeChild(topNode.nextSibling);
            if (topNode.pmViewDesc)
                topNode.pmViewDesc = undefined;
        }
        let desc = new CompositionViewDesc(this, topNode, node, text);
        view.input.compositionNodes.push(desc);
        // Patch up this.children to contain the composition view
        this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
    }
    // If this desc must be updated to match the given node decoration,
    // do so and return true.
    update(node, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY ||
            !node.sameMarkup(this.node))
            return false;
        this.updateInner(node, outerDeco, innerDeco, view);
        return true;
    }
    updateInner(node, outerDeco, innerDeco, view) {
        this.updateOuterDeco(outerDeco);
        this.node = node;
        this.innerDeco = innerDeco;
        if (this.contentDOM)
            this.updateChildren(view, this.posAtStart);
        this.dirty = NOT_DIRTY;
    }
    updateOuterDeco(outerDeco) {
        if (sameOuterDeco(outerDeco, this.outerDeco))
            return;
        let needsWrap = this.nodeDOM.nodeType != 1;
        let oldDOM = this.dom;
        this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
        if (this.dom != oldDOM) {
            oldDOM.pmViewDesc = undefined;
            this.dom.pmViewDesc = this;
        }
        this.outerDeco = outerDeco;
    }
    // Mark this node as being the selected node.
    selectNode() {
        if (this.nodeDOM.nodeType == 1)
            this.nodeDOM.classList.add("ProseMirror-selectednode");
        if (this.contentDOM || !this.node.type.spec.draggable)
            this.dom.draggable = true;
    }
    // Remove selected node marking from this node.
    deselectNode() {
        if (this.nodeDOM.nodeType == 1)
            this.nodeDOM.classList.remove("ProseMirror-selectednode");
        if (this.contentDOM || !this.node.type.spec.draggable)
            this.dom.removeAttribute("draggable");
    }
    get domAtom() { return this.node.isAtom; }
}
// Create a view desc for the top-level document node, to be exported
// and used by the view class.
function docViewDesc(doc, outerDeco, innerDeco, dom, view) {
    applyOuterDeco(dom, outerDeco, doc);
    return new NodeViewDesc(undefined, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);
}
class TextViewDesc extends NodeViewDesc {
    constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
        super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
    }
    parseRule() {
        let skip = this.nodeDOM.parentNode;
        while (skip && skip != this.dom && !skip.pmIsDeco)
            skip = skip.parentNode;
        return { skip: (skip || true) };
    }
    update(node, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent()) ||
            !node.sameMarkup(this.node))
            return false;
        this.updateOuterDeco(outerDeco);
        if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
            this.nodeDOM.nodeValue = node.text;
            if (view.trackWrites == this.nodeDOM)
                view.trackWrites = null;
        }
        this.node = node;
        this.dirty = NOT_DIRTY;
        return true;
    }
    inParent() {
        let parentDOM = this.parent.contentDOM;
        for (let n = this.nodeDOM; n; n = n.parentNode)
            if (n == parentDOM)
                return true;
        return false;
    }
    domFromPos(pos) {
        return { node: this.nodeDOM, offset: pos };
    }
    localPosFromDOM(dom, offset, bias) {
        if (dom == this.nodeDOM)
            return this.posAtStart + Math.min(offset, this.node.text.length);
        return super.localPosFromDOM(dom, offset, bias);
    }
    ignoreMutation(mutation) {
        return mutation.type != "characterData" && mutation.type != "selection";
    }
    slice(from, to, view) {
        let node = this.node.cut(from, to), dom = document.createTextNode(node.text);
        return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
    }
    markDirty(from, to) {
        super.markDirty(from, to);
        if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length))
            this.dirty = NODE_DIRTY;
    }
    get domAtom() { return false; }
}
// A dummy desc used to tag trailing BR or IMG nodes created to work
// around contentEditable terribleness.
class TrailingHackViewDesc extends ViewDesc {
    parseRule() { return { ignore: true }; }
    matchesHack(nodeName) { return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName; }
    get domAtom() { return true; }
    get ignoreForCoords() { return this.dom.nodeName == "IMG"; }
}
// A separate subclass is used for customized node views, so that the
// extra checks only have to be made for nodes that are actually
// customized.
class CustomNodeViewDesc extends NodeViewDesc {
    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
        super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
        this.spec = spec;
    }
    // A custom `update` method gets to decide whether the update goes
    // through. If it does, and there's a `contentDOM` node, our logic
    // updates the children.
    update(node, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY)
            return false;
        if (this.spec.update) {
            let result = this.spec.update(node, outerDeco, innerDeco);
            if (result)
                this.updateInner(node, outerDeco, innerDeco, view);
            return result;
        }
        else if (!this.contentDOM && !node.isLeaf) {
            return false;
        }
        else {
            return super.update(node, outerDeco, innerDeco, view);
        }
    }
    selectNode() {
        this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
    }
    deselectNode() {
        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
    }
    setSelection(anchor, head, root, force) {
        this.spec.setSelection ? this.spec.setSelection(anchor, head, root)
            : super.setSelection(anchor, head, root, force);
    }
    destroy() {
        if (this.spec.destroy)
            this.spec.destroy();
        super.destroy();
    }
    stopEvent(event) {
        return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
    }
    ignoreMutation(mutation) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
    }
}
// Sync the content of the given DOM node with the nodes associated
// with the given array of view descs, recursing into mark descs
// because this should sync the subtree for a whole node at a time.
function renderDescs(parentDOM, descs, view) {
    let dom = parentDOM.firstChild, written = false;
    for (let i = 0; i < descs.length; i++) {
        let desc = descs[i], childDOM = desc.dom;
        if (childDOM.parentNode == parentDOM) {
            while (childDOM != dom) {
                dom = rm(dom);
                written = true;
            }
            dom = dom.nextSibling;
        }
        else {
            written = true;
            parentDOM.insertBefore(childDOM, dom);
        }
        if (desc instanceof MarkViewDesc) {
            let pos = dom ? dom.previousSibling : parentDOM.lastChild;
            renderDescs(desc.contentDOM, desc.children, view);
            dom = pos ? pos.nextSibling : parentDOM.firstChild;
        }
    }
    while (dom) {
        dom = rm(dom);
        written = true;
    }
    if (written && view.trackWrites == parentDOM)
        view.trackWrites = null;
}
const OuterDecoLevel = function (nodeName) {
    if (nodeName)
        this.nodeName = nodeName;
};
OuterDecoLevel.prototype = Object.create(null);
const noDeco = [new OuterDecoLevel];
function computeOuterDeco(outerDeco, node, needsWrap) {
    if (outerDeco.length == 0)
        return noDeco;
    let top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top];
    for (let i = 0; i < outerDeco.length; i++) {
        let attrs = outerDeco[i].type.attrs;
        if (!attrs)
            continue;
        if (attrs.nodeName)
            result.push(top = new OuterDecoLevel(attrs.nodeName));
        for (let name in attrs) {
            let val = attrs[name];
            if (val == null)
                continue;
            if (needsWrap && result.length == 1)
                result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
            if (name == "class")
                top.class = (top.class ? top.class + " " : "") + val;
            else if (name == "style")
                top.style = (top.style ? top.style + ";" : "") + val;
            else if (name != "nodeName")
                top[name] = val;
        }
    }
    return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
    // Shortcut for trivial case
    if (prevComputed == noDeco && curComputed == noDeco)
        return nodeDOM;
    let curDOM = nodeDOM;
    for (let i = 0; i < curComputed.length; i++) {
        let deco = curComputed[i], prev = prevComputed[i];
        if (i) {
            let parent;
            if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&
                (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
                curDOM = parent;
            }
            else {
                parent = document.createElement(deco.nodeName);
                parent.pmIsDeco = true;
                parent.appendChild(curDOM);
                prev = noDeco[0];
                curDOM = parent;
            }
        }
        patchAttributes(curDOM, prev || noDeco[0], deco);
    }
    return curDOM;
}
function patchAttributes(dom, prev, cur) {
    for (let name in prev)
        if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
            dom.removeAttribute(name);
    for (let name in cur)
        if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
            dom.setAttribute(name, cur[name]);
    if (prev.class != cur.class) {
        let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
        let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
        for (let i = 0; i < prevList.length; i++)
            if (curList.indexOf(prevList[i]) == -1)
                dom.classList.remove(prevList[i]);
        for (let i = 0; i < curList.length; i++)
            if (prevList.indexOf(curList[i]) == -1)
                dom.classList.add(curList[i]);
        if (dom.classList.length == 0)
            dom.removeAttribute("class");
    }
    if (prev.style != cur.style) {
        if (prev.style) {
            let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
            while (m = prop.exec(prev.style))
                dom.style.removeProperty(m[1]);
        }
        if (cur.style)
            dom.style.cssText += cur.style;
    }
}
function applyOuterDeco(dom, deco, node) {
    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!a[i].type.eq(b[i].type))
            return false;
    return true;
}
// Remove a DOM node and return its next sibling.
function rm(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
}
// Helper class for incrementally updating a tree of mark descs and
// the widget and node descs inside of them.
class ViewTreeUpdater {
    constructor(top, lock) {
        this.lock = lock;
        // Index into `this.top`'s child array, represents the current
        // update position.
        this.index = 0;
        // When entering a mark, the current top and index are pushed
        // onto this.
        this.stack = [];
        // Tracks whether anything was changed
        this.changed = false;
        this.top = top;
        this.preMatch = preMatch(top.node.content, top);
    }
    // Destroy and remove the children between the given indices in
    // `this.top`.
    destroyBetween(start, end) {
        if (start == end)
            return;
        for (let i = start; i < end; i++)
            this.top.children[i].destroy();
        this.top.children.splice(start, end - start);
        this.changed = true;
    }
    // Destroy all remaining children in `this.top`.
    destroyRest() {
        this.destroyBetween(this.index, this.top.children.length);
    }
    // Sync the current stack of mark descs with the given array of
    // marks, reusing existing mark descs when possible.
    syncToMarks(marks, inline, view) {
        let keep = 0, depth = this.stack.length >> 1;
        let maxKeep = Math.min(depth, marks.length);
        while (keep < maxKeep &&
            (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1])
                .matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
            keep++;
        while (keep < depth) {
            this.destroyRest();
            this.top.dirty = NOT_DIRTY;
            this.index = this.stack.pop();
            this.top = this.stack.pop();
            depth--;
        }
        while (depth < marks.length) {
            this.stack.push(this.top, this.index + 1);
            let found = -1;
            for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
                if (this.top.children[i].matchesMark(marks[depth])) {
                    found = i;
                    break;
                }
            }
            if (found > -1) {
                if (found > this.index) {
                    this.changed = true;
                    this.destroyBetween(this.index, found);
                }
                this.top = this.top.children[this.index];
            }
            else {
                let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
                this.top.children.splice(this.index, 0, markDesc);
                this.top = markDesc;
                this.changed = true;
            }
            this.index = 0;
            depth++;
        }
    }
    // Try to find a node desc matching the given data. Skip over it and
    // return true when successful.
    findNodeMatch(node, outerDeco, innerDeco, index) {
        let found = -1, targetDesc;
        if (index >= this.preMatch.index &&
            (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top &&
            targetDesc.matchesNode(node, outerDeco, innerDeco)) {
            found = this.top.children.indexOf(targetDesc, this.index);
        }
        else {
            for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
                let child = this.top.children[i];
                if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
                    found = i;
                    break;
                }
            }
        }
        if (found < 0)
            return false;
        this.destroyBetween(this.index, found);
        this.index++;
        return true;
    }
    updateNodeAt(node, outerDeco, innerDeco, index, view) {
        let child = this.top.children[index];
        if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
            child.dirty = CONTENT_DIRTY;
        if (!child.update(node, outerDeco, innerDeco, view))
            return false;
        this.destroyBetween(this.index, index);
        this.index = index + 1;
        return true;
    }
    findIndexWithChild(domNode) {
        for (;;) {
            let parent = domNode.parentNode;
            if (!parent)
                return -1;
            if (parent == this.top.contentDOM) {
                let desc = domNode.pmViewDesc;
                if (desc)
                    for (let i = this.index; i < this.top.children.length; i++) {
                        if (this.top.children[i] == desc)
                            return i;
                    }
                return -1;
            }
            domNode = parent;
        }
    }
    // Try to update the next node, if any, to the given data. Checks
    // pre-matches to avoid overwriting nodes that could still be used.
    updateNextNode(node, outerDeco, innerDeco, view, index) {
        for (let i = this.index; i < this.top.children.length; i++) {
            let next = this.top.children[i];
            if (next instanceof NodeViewDesc) {
                let preMatch = this.preMatch.matched.get(next);
                if (preMatch != null && preMatch != index)
                    return false;
                let nextDOM = next.dom;
                // Can't update if nextDOM is or contains this.lock, except if
                // it's a text node whose content already matches the new text
                // and whose decorations match the new ones.
                let locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) &&
                    !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text &&
                        next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
                if (!locked && next.update(node, outerDeco, innerDeco, view)) {
                    this.destroyBetween(this.index, i);
                    if (next.dom != nextDOM)
                        this.changed = true;
                    this.index++;
                    return true;
                }
                break;
            }
        }
        return false;
    }
    // Insert the node as a newly created node desc.
    addNode(node, outerDeco, innerDeco, view, pos) {
        this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos));
        this.changed = true;
    }
    placeWidget(widget, view, pos) {
        let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
        if (next && next.matchesWidget(widget) &&
            (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
            this.index++;
        }
        else {
            let desc = new WidgetViewDesc(this.top, widget, view, pos);
            this.top.children.splice(this.index++, 0, desc);
            this.changed = true;
        }
    }
    // Make sure a textblock looks and behaves correctly in
    // contentEditable.
    addTextblockHacks() {
        let lastChild = this.top.children[this.index - 1], parent = this.top;
        while (lastChild instanceof MarkViewDesc) {
            parent = lastChild;
            lastChild = parent.children[parent.children.length - 1];
        }
        if (!lastChild || // Empty textblock
            !(lastChild instanceof TextViewDesc) ||
            /\n$/.test(lastChild.node.text)) {
            // Avoid bugs in Safari's cursor drawing (#1165) and Chrome's mouse selection (#1152)
            if ((safari$1 || chrome$1) && lastChild && lastChild.dom.contentEditable == "false")
                this.addHackNode("IMG", parent);
            this.addHackNode("BR", this.top);
        }
    }
    addHackNode(nodeName, parent) {
        if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
            this.index++;
        }
        else {
            let dom = document.createElement(nodeName);
            if (nodeName == "IMG") {
                dom.className = "ProseMirror-separator";
                dom.alt = "";
            }
            if (nodeName == "BR")
                dom.className = "ProseMirror-trailingBreak";
            let hack = new TrailingHackViewDesc(this.top, [], dom, null);
            if (parent != this.top)
                parent.children.push(hack);
            else
                parent.children.splice(this.index++, 0, hack);
            this.changed = true;
        }
    }
}
// Iterate from the end of the fragment and array of descs to find
// directly matching ones, in order to avoid overeagerly reusing those
// for other nodes. Returns the fragment index of the first node that
// is part of the sequence of matched nodes at the end of the
// fragment.
function preMatch(frag, parentDesc) {
    let curDesc = parentDesc, descI = curDesc.children.length;
    let fI = frag.childCount, matched = new Map, matches = [];
    outer: while (fI > 0) {
        let desc;
        for (;;) {
            if (descI) {
                let next = curDesc.children[descI - 1];
                if (next instanceof MarkViewDesc) {
                    curDesc = next;
                    descI = next.children.length;
                }
                else {
                    desc = next;
                    descI--;
                    break;
                }
            }
            else if (curDesc == parentDesc) {
                break outer;
            }
            else {
                // FIXME
                descI = curDesc.parent.children.indexOf(curDesc);
                curDesc = curDesc.parent;
            }
        }
        let node = desc.node;
        if (!node)
            continue;
        if (node != frag.child(fI - 1))
            break;
        --fI;
        matched.set(desc, fI);
        matches.push(desc);
    }
    return { index: fI, matched, matches: matches.reverse() };
}
function compareSide(a, b) {
    return a.type.side - b.type.side;
}
// This function abstracts iterating over the nodes and decorations in
// a fragment. Calls `onNode` for each node, with its local and child
// decorations. Splits text nodes when there is a decoration starting
// or ending inside of them. Calls `onWidget` for each widget.
function iterDeco(parent, deco, onWidget, onNode) {
    let locals = deco.locals(parent), offset = 0;
    // Simple, cheap variant for when there are no local decorations
    if (locals.length == 0) {
        for (let i = 0; i < parent.childCount; i++) {
            let child = parent.child(i);
            onNode(child, locals, deco.forChild(offset, child), i);
            offset += child.nodeSize;
        }
        return;
    }
    let decoIndex = 0, active = [], restNode = null;
    for (let parentIndex = 0;;) {
        if (decoIndex < locals.length && locals[decoIndex].to == offset) {
            let widget = locals[decoIndex++], widgets;
            while (decoIndex < locals.length && locals[decoIndex].to == offset)
                (widgets || (widgets = [widget])).push(locals[decoIndex++]);
            if (widgets) {
                widgets.sort(compareSide);
                for (let i = 0; i < widgets.length; i++)
                    onWidget(widgets[i], parentIndex, !!restNode);
            }
            else {
                onWidget(widget, parentIndex, !!restNode);
            }
        }
        let child, index;
        if (restNode) {
            index = -1;
            child = restNode;
            restNode = null;
        }
        else if (parentIndex < parent.childCount) {
            index = parentIndex;
            child = parent.child(parentIndex++);
        }
        else {
            break;
        }
        for (let i = 0; i < active.length; i++)
            if (active[i].to <= offset)
                active.splice(i--, 1);
        while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)
            active.push(locals[decoIndex++]);
        let end = offset + child.nodeSize;
        if (child.isText) {
            let cutAt = end;
            if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
                cutAt = locals[decoIndex].from;
            for (let i = 0; i < active.length; i++)
                if (active[i].to < cutAt)
                    cutAt = active[i].to;
            if (cutAt < end) {
                restNode = child.cut(cutAt - offset);
                child = child.cut(0, cutAt - offset);
                end = cutAt;
                index = -1;
            }
        }
        let outerDeco = child.isInline && !child.isLeaf ? active.filter(d => !d.inline) : active.slice();
        onNode(child, outerDeco, deco.forChild(offset, child), index);
        offset = end;
    }
}
// List markers in Mobile Safari will mysteriously disappear
// sometimes. This works around that.
function iosHacks(dom) {
    if (dom.nodeName == "UL" || dom.nodeName == "OL") {
        let oldCSS = dom.style.cssText;
        dom.style.cssText = oldCSS + "; list-style: square !important";
        window$1.getComputedStyle(dom).listStyle;
        dom.style.cssText = oldCSS;
    }
}
function nearbyTextNode(node, offset) {
    for (;;) {
        if (node.nodeType == 3)
            return node;
        if (node.nodeType == 1 && offset > 0) {
            if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3)
                return node.childNodes[offset];
            node = node.childNodes[offset - 1];
            offset = nodeSize(node);
        }
        else if (node.nodeType == 1 && offset < node.childNodes.length) {
            node = node.childNodes[offset];
            offset = 0;
        }
        else {
            return null;
        }
    }
}
// Find a piece of text in an inline fragment, overlapping from-to
function findTextInFragment(frag, text, from, to) {
    for (let i = 0, pos = 0; i < frag.childCount && pos <= to;) {
        let child = frag.child(i++), childStart = pos;
        pos += child.nodeSize;
        if (!child.isText)
            continue;
        let str = child.text;
        while (i < frag.childCount) {
            let next = frag.child(i++);
            pos += next.nodeSize;
            if (!next.isText)
                break;
            str += next.text;
        }
        if (pos >= from) {
            let found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
            if (found >= 0 && found + text.length + childStart >= from)
                return childStart + found;
            if (from == to && str.length >= (to + text.length) - childStart &&
                str.slice(to - childStart, to - childStart + text.length) == text)
                return to;
        }
    }
    return -1;
}
// Replace range from-to in an array of view descs with replacement
// (may be null to just delete). This goes very much against the grain
// of the rest of this code, which tends to create nodes with the
// right shape in one go, rather than messing with them after
// creation, but is necessary in the composition hack.
function replaceNodes(nodes, from, to, view, replacement) {
    let result = [];
    for (let i = 0, off = 0; i < nodes.length; i++) {
        let child = nodes[i], start = off, end = off += child.size;
        if (start >= to || end <= from) {
            result.push(child);
        }
        else {
            if (start < from)
                result.push(child.slice(0, from - start, view));
            if (replacement) {
                result.push(replacement);
                replacement = undefined;
            }
            if (end > to)
                result.push(child.slice(to - start, child.size, view));
        }
    }
    return result;
}

function selectionFromDOM(view, origin = null) {
    let domSel = view.domSelection(), doc = view.state.doc;
    if (!domSel.focusNode)
        return null;
    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
    let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
    if (head < 0)
        return null;
    let $head = doc.resolve(head), $anchor, selection;
    if (selectionCollapsed(domSel)) {
        $anchor = $head;
        while (nearestDesc && !nearestDesc.node)
            nearestDesc = nearestDesc.parent;
        let nearestDescNode = nearestDesc.node;
        if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent
            && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
            let pos = nearestDesc.posBefore;
            selection = new NodeSelection(head == pos ? $head : doc.resolve(pos));
        }
    }
    else {
        let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
        if (anchor < 0)
            return null;
        $anchor = doc.resolve(anchor);
    }
    if (!selection) {
        let bias = origin == "pointer" || (view.state.selection.head < $head.pos && !inWidget) ? 1 : -1;
        selection = selectionBetween(view, $anchor, $head, bias);
    }
    return selection;
}
function editorOwnsSelection(view) {
    return view.editable ? view.hasFocus() :
        hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
    let sel = view.state.selection;
    syncNodeSelection(view, sel);
    if (!editorOwnsSelection(view))
        return;
    // The delayed drag selection causes issues with Cell Selections
    // in Safari. And the drag selection delay is to workarond issues
    // which only present in Chrome.
    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome$1) {
        let domSel = view.domSelection(), curSel = view.domObserver.currentSelection;
        if (domSel.anchorNode && curSel.anchorNode &&
            isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
            view.input.mouseDown.delayedSelectionSync = true;
            view.domObserver.setCurSelection();
            return;
        }
    }
    view.domObserver.disconnectSelection();
    if (view.cursorWrapper) {
        selectCursorWrapper(view);
    }
    else {
        let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
        if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
            if (!sel.$from.parent.inlineContent)
                resetEditableFrom = temporarilyEditableNear(view, sel.from);
            if (!sel.empty && !sel.$from.parent.inlineContent)
                resetEditableTo = temporarilyEditableNear(view, sel.to);
        }
        view.docView.setSelection(anchor, head, view.root, force);
        if (brokenSelectBetweenUneditable) {
            if (resetEditableFrom)
                resetEditable(resetEditableFrom);
            if (resetEditableTo)
                resetEditable(resetEditableTo);
        }
        if (sel.visible) {
            view.dom.classList.remove("ProseMirror-hideselection");
        }
        else {
            view.dom.classList.add("ProseMirror-hideselection");
            if ("onselectionchange" in document)
                removeClassOnSelectionChange(view);
        }
    }
    view.domObserver.setCurSelection();
    view.domObserver.connectSelection();
}
// Kludge to work around Webkit not allowing a selection to start/end
// between non-editable block nodes. We briefly make something
// editable, set the selection, then set it uneditable again.
const brokenSelectBetweenUneditable = safari$1 || chrome$1 && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
    let { node, offset } = view.docView.domFromPos(pos, 0);
    let after = offset < node.childNodes.length ? node.childNodes[offset] : null;
    let before = offset ? node.childNodes[offset - 1] : null;
    if (safari$1 && after && after.contentEditable == "false")
        return setEditable(after);
    if ((!after || after.contentEditable == "false") &&
        (!before || before.contentEditable == "false")) {
        if (after)
            return setEditable(after);
        else if (before)
            return setEditable(before);
    }
}
function setEditable(element) {
    element.contentEditable = "true";
    if (safari$1 && element.draggable) {
        element.draggable = false;
        element.wasDraggable = true;
    }
    return element;
}
function resetEditable(element) {
    element.contentEditable = "false";
    if (element.wasDraggable) {
        element.draggable = true;
        element.wasDraggable = null;
    }
}
function removeClassOnSelectionChange(view) {
    let doc = view.dom.ownerDocument;
    doc.removeEventListener("selectionchange", view.input.hideSelectionGuard);
    let domSel = view.domSelection();
    let node = domSel.anchorNode, offset = domSel.anchorOffset;
    doc.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
        if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
            doc.removeEventListener("selectionchange", view.input.hideSelectionGuard);
            setTimeout(() => {
                if (!editorOwnsSelection(view) || view.state.selection.visible)
                    view.dom.classList.remove("ProseMirror-hideselection");
            }, 20);
        }
    });
}
function selectCursorWrapper(view) {
    let domSel = view.domSelection(), range = document.createRange();
    let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
    if (img)
        range.setEnd(node.parentNode, domIndex(node) + 1);
    else
        range.setEnd(node, 0);
    range.collapse(false);
    domSel.removeAllRanges();
    domSel.addRange(range);
    // Kludge to kill 'control selection' in IE11 when selecting an
    // invisible cursor wrapper, since that would result in those weird
    // resize handles and a selection that considers the absolutely
    // positioned wrapper, rather than the root editable node, the
    // focused element.
    if (!img && !view.state.selection.visible && ie$1 && ie_version <= 11) {
        node.disabled = true;
        node.disabled = false;
    }
}
function syncNodeSelection(view, sel) {
    if (sel instanceof NodeSelection) {
        let desc = view.docView.descAt(sel.from);
        if (desc != view.lastSelectedViewDesc) {
            clearNodeSelection(view);
            if (desc)
                desc.selectNode();
            view.lastSelectedViewDesc = desc;
        }
    }
    else {
        clearNodeSelection(view);
    }
}
// Clear all DOM statefulness of the last node selection.
function clearNodeSelection(view) {
    if (view.lastSelectedViewDesc) {
        if (view.lastSelectedViewDesc.parent)
            view.lastSelectedViewDesc.deselectNode();
        view.lastSelectedViewDesc = undefined;
    }
}
function selectionBetween(view, $anchor, $head, bias) {
    return view.someProp("createSelectionBetween", f => f(view, $anchor, $head))
        || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
    if (view.editable && view.root.activeElement != view.dom)
        return false;
    return hasSelection(view);
}
function hasSelection(view) {
    let sel = view.domSelection();
    if (!sel.anchorNode)
        return false;
    try {
        // Firefox will raise 'permission denied' errors when accessing
        // properties of `sel.anchorNode` when it's in a generated CSS
        // element.
        return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) &&
            (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
    }
    catch (_) {
        return false;
    }
}
function anchorInRightPlace(view) {
    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
    let domSel = view.domSelection();
    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}

function moveSelectionBlock(state, dir) {
    let { $anchor, $head } = state.selection;
    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
    return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
    return true;
}
function selectHorizontally(view, dir, mods) {
    let sel = view.state.selection;
    if (sel instanceof TextSelection) {
        if (!sel.empty || mods.indexOf("s") > -1) {
            return false;
        }
        else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
            let next = moveSelectionBlock(view.state, dir);
            if (next && (next instanceof NodeSelection))
                return apply(view, next);
            return false;
        }
        else if (!(mac$2 && mods.indexOf("m") > -1)) {
            let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
            if (!node || node.isText)
                return false;
            let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
            if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
                return false;
            if (NodeSelection.isSelectable(node)) {
                return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
            }
            else if (webkit) {
                // Chrome and Safari will introduce extra pointless cursor
                // positions around inline uneditable nodes, so we have to
                // take over and move the cursor past them (#937)
                return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
            }
            else {
                return false;
            }
        }
    }
    else if (sel instanceof NodeSelection && sel.node.isInline) {
        return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
    }
    else {
        let next = moveSelectionBlock(view.state, dir);
        if (next)
            return apply(view, next);
        return false;
    }
}
function nodeLen(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom) {
    let desc = dom.pmViewDesc;
    return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
}
// Make sure the cursor isn't directly after one or more ignored
// nodes, which will confuse the browser's cursor motion logic.
function skipIgnoredNodesLeft(view) {
    let sel = view.domSelection();
    let node = sel.focusNode, offset = sel.focusOffset;
    if (!node)
        return;
    let moveNode, moveOffset, force = false;
    // Gecko will do odd things when the selection is directly in front
    // of a non-editable node, so in that case, move it into the next
    // node if possible. Issue prosemirror/prosemirror#832.
    if (gecko$1 && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset]))
        force = true;
    for (;;) {
        if (offset > 0) {
            if (node.nodeType != 1) {
                break;
            }
            else {
                let before = node.childNodes[offset - 1];
                if (isIgnorable(before)) {
                    moveNode = node;
                    moveOffset = --offset;
                }
                else if (before.nodeType == 3) {
                    node = before;
                    offset = node.nodeValue.length;
                }
                else
                    break;
            }
        }
        else if (isBlockNode(node)) {
            break;
        }
        else {
            let prev = node.previousSibling;
            while (prev && isIgnorable(prev)) {
                moveNode = node.parentNode;
                moveOffset = domIndex(prev);
                prev = prev.previousSibling;
            }
            if (!prev) {
                node = node.parentNode;
                if (node == view.dom)
                    break;
                offset = 0;
            }
            else {
                node = prev;
                offset = nodeLen(node);
            }
        }
    }
    if (force)
        setSelFocus(view, sel, node, offset);
    else if (moveNode)
        setSelFocus(view, sel, moveNode, moveOffset);
}
// Make sure the cursor isn't directly before one or more ignored
// nodes.
function skipIgnoredNodesRight(view) {
    let sel = view.domSelection();
    let node = sel.focusNode, offset = sel.focusOffset;
    if (!node)
        return;
    let len = nodeLen(node);
    let moveNode, moveOffset;
    for (;;) {
        if (offset < len) {
            if (node.nodeType != 1)
                break;
            let after = node.childNodes[offset];
            if (isIgnorable(after)) {
                moveNode = node;
                moveOffset = ++offset;
            }
            else
                break;
        }
        else if (isBlockNode(node)) {
            break;
        }
        else {
            let next = node.nextSibling;
            while (next && isIgnorable(next)) {
                moveNode = next.parentNode;
                moveOffset = domIndex(next) + 1;
                next = next.nextSibling;
            }
            if (!next) {
                node = node.parentNode;
                if (node == view.dom)
                    break;
                offset = len = 0;
            }
            else {
                node = next;
                offset = 0;
                len = nodeLen(node);
            }
        }
    }
    if (moveNode)
        setSelFocus(view, sel, moveNode, moveOffset);
}
function isBlockNode(dom) {
    let desc = dom.pmViewDesc;
    return desc && desc.node && desc.node.isBlock;
}
function setSelFocus(view, sel, node, offset) {
    if (selectionCollapsed(sel)) {
        let range = document.createRange();
        range.setEnd(node, offset);
        range.setStart(node, offset);
        sel.removeAllRanges();
        sel.addRange(range);
    }
    else if (sel.extend) {
        sel.extend(node, offset);
    }
    view.domObserver.setCurSelection();
    let { state } = view;
    // If no state update ends up happening, reset the selection.
    setTimeout(() => {
        if (view.state == state)
            selectionToDOM(view);
    }, 50);
}
// Check whether vertical selection motion would involve node
// selections. If so, apply it (if not, the result is left to the
// browser)
function selectVertically(view, dir, mods) {
    let sel = view.state.selection;
    if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
        return false;
    if (mac$2 && mods.indexOf("m") > -1)
        return false;
    let { $from, $to } = sel;
    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
        let next = moveSelectionBlock(view.state, dir);
        if (next && (next instanceof NodeSelection))
            return apply(view, next);
    }
    if (!$from.parent.inlineContent) {
        let side = dir < 0 ? $from : $to;
        let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
        return beyond ? apply(view, beyond) : false;
    }
    return false;
}
function stopNativeHorizontalDelete(view, dir) {
    if (!(view.state.selection instanceof TextSelection))
        return true;
    let { $head, $anchor, empty } = view.state.selection;
    if (!$head.sameParent($anchor))
        return true;
    if (!empty)
        return false;
    if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
        return true;
    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
    if (nextNode && !nextNode.isText) {
        let tr = view.state.tr;
        if (dir < 0)
            tr.delete($head.pos - nextNode.nodeSize, $head.pos);
        else
            tr.delete($head.pos, $head.pos + nextNode.nodeSize);
        view.dispatch(tr);
        return true;
    }
    return false;
}
function switchEditable(view, node, state) {
    view.domObserver.stop();
    node.contentEditable = state;
    view.domObserver.start();
}
// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821
// In which Safari (and at some point in the past, Chrome) does really
// wrong things when the down arrow is pressed when the cursor is
// directly at the start of a textblock and has an uneditable node
// after it
function safariDownArrowBug(view) {
    if (!safari$1 || view.state.selection.$head.parentOffset > 0)
        return false;
    let { focusNode, focusOffset } = view.domSelection();
    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 &&
        focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
        let child = focusNode.firstChild;
        switchEditable(view, child, "true");
        setTimeout(() => switchEditable(view, child, "false"), 20);
    }
    return false;
}
// A backdrop key mapping used to make sure we always suppress keys
// that have a dangerous default effect, even if the commands they are
// bound to return false, and to make sure that cursor-motion keys
// find a cursor (as opposed to a node selection) when pressed. For
// cursor-motion keys, the code in the handlers also takes care of
// block selections.
function getMods(event) {
    let result = "";
    if (event.ctrlKey)
        result += "c";
    if (event.metaKey)
        result += "m";
    if (event.altKey)
        result += "a";
    if (event.shiftKey)
        result += "s";
    return result;
}
function captureKeyDown(view, event) {
    let code = event.keyCode, mods = getMods(event);
    if (code == 8 || (mac$2 && code == 72 && mods == "c")) { // Backspace, Ctrl-h on Mac
        return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view);
    }
    else if (code == 46 || (mac$2 && code == 68 && mods == "c")) { // Delete, Ctrl-d on Mac
        return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view);
    }
    else if (code == 13 || code == 27) { // Enter, Esc
        return true;
    }
    else if (code == 37 || (mac$2 && code == 66 && mods == "c")) { // Left arrow, Ctrl-b on Mac
        return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view);
    }
    else if (code == 39 || (mac$2 && code == 70 && mods == "c")) { // Right arrow, Ctrl-f on Mac
        return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view);
    }
    else if (code == 38 || (mac$2 && code == 80 && mods == "c")) { // Up arrow, Ctrl-p on Mac
        return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view);
    }
    else if (code == 40 || (mac$2 && code == 78 && mods == "c")) { // Down arrow, Ctrl-n on Mac
        return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view);
    }
    else if (mods == (mac$2 ? "m" : "c") &&
        (code == 66 || code == 73 || code == 89 || code == 90)) { // Mod-[biyz]
        return true;
    }
    return false;
}

function serializeForClipboard(view, slice) {
    let context = [], { content, openStart, openEnd } = slice;
    while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
        openStart--;
        openEnd--;
        let node = content.firstChild;
        context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
        content = node.content;
    }
    let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
    let doc = detachedDoc(), wrap = doc.createElement("div");
    wrap.appendChild(serializer.serializeFragment(content, { document: doc }));
    let firstChild = wrap.firstChild, needsWrap, wrappers = 0;
    while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
        for (let i = needsWrap.length - 1; i >= 0; i--) {
            let wrapper = doc.createElement(needsWrap[i]);
            while (wrap.firstChild)
                wrapper.appendChild(wrap.firstChild);
            wrap.appendChild(wrapper);
            wrappers++;
        }
        firstChild = wrap.firstChild;
    }
    if (firstChild && firstChild.nodeType == 1)
        firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
    let text = view.someProp("clipboardTextSerializer", f => f(slice)) ||
        slice.content.textBetween(0, slice.content.size, "\n\n");
    return { dom: wrap, text };
}
// Read a slice of content from the clipboard (or drop data).
function parseFromClipboard(view, text, html, plainText, $context) {
    let inCode = $context.parent.type.spec.code;
    let dom, slice;
    if (!html && !text)
        return null;
    let asText = text && (plainText || inCode || !html);
    if (asText) {
        view.someProp("transformPastedText", f => { text = f(text, inCode || plainText); });
        if (inCode)
            return text ? new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
        let parsed = view.someProp("clipboardTextParser", f => f(text, $context, plainText));
        if (parsed) {
            slice = parsed;
        }
        else {
            let marks = $context.marks();
            let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
            dom = document.createElement("div");
            text.split(/(?:\r\n?|\n)+/).forEach(block => {
                let p = dom.appendChild(document.createElement("p"));
                if (block)
                    p.appendChild(serializer.serializeNode(schema.text(block, marks)));
            });
        }
    }
    else {
        view.someProp("transformPastedHTML", f => { html = f(html); });
        dom = readHTML(html);
        if (webkit)
            restoreReplacedSpaces(dom);
    }
    let contextNode = dom && dom.querySelector("[data-pm-slice]");
    let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
    if (sliceData && sliceData[3])
        for (let i = +sliceData[3]; i > 0 && dom.firstChild; i--)
            dom = dom.firstChild;
    if (!slice) {
        let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
        slice = parser.parseSlice(dom, {
            preserveWhitespace: !!(asText || sliceData),
            context: $context,
            ruleFromNode(dom) {
                if (dom.nodeName == "BR" && !dom.nextSibling &&
                    dom.parentNode && !inlineParents.test(dom.parentNode.nodeName))
                    return { ignore: true };
                return null;
            }
        });
    }
    if (sliceData) {
        slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);
    }
    else { // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent
        slice = Slice.maxOpen(normalizeSiblings(slice.content, $context), true);
        if (slice.openStart || slice.openEnd) {
            let openStart = 0, openEnd = 0;
            for (let node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) { }
            for (let node = slice.content.lastChild; openEnd < slice.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) { }
            slice = closeSlice(slice, openStart, openEnd);
        }
    }
    view.someProp("transformPasted", f => { slice = f(slice); });
    return slice;
}
const inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
// Takes a slice parsed with parseSlice, which means there hasn't been
// any content-expression checking done on the top nodes, tries to
// find a parent node in the current context that might fit the nodes,
// and if successful, rebuilds the slice so that it fits into that parent.
//
// This addresses the problem that Transform.replace expects a
// coherent slice, and will fail to place a set of siblings that don't
// fit anywhere in the schema.
function normalizeSiblings(fragment, $context) {
    if (fragment.childCount < 2)
        return fragment;
    for (let d = $context.depth; d >= 0; d--) {
        let parent = $context.node(d);
        let match = parent.contentMatchAt($context.index(d));
        let lastWrap, result = [];
        fragment.forEach(node => {
            if (!result)
                return;
            let wrap = match.findWrapping(node.type), inLast;
            if (!wrap)
                return result = null;
            if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {
                result[result.length - 1] = inLast;
            }
            else {
                if (result.length)
                    result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
                let wrapped = withWrappers(node, wrap);
                result.push(wrapped);
                match = match.matchType(wrapped.type);
                lastWrap = wrap;
            }
        });
        if (result)
            return Fragment.from(result);
    }
    return fragment;
}
function withWrappers(node, wrap, from = 0) {
    for (let i = wrap.length - 1; i >= from; i--)
        node = wrap[i].create(null, Fragment.from(node));
    return node;
}
// Used to group adjacent nodes wrapped in similar parents by
// normalizeSiblings into the same parent node
function addToSibling(wrap, lastWrap, node, sibling, depth) {
    if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
        let inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);
        if (inner)
            return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
        let match = sibling.contentMatchAt(sibling.childCount);
        if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))
            return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap, depth + 1))));
    }
}
function closeRight(node, depth) {
    if (depth == 0)
        return node;
    let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
    let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
    return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from, to, depth, openEnd) {
    let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
    if (depth < to - 1)
        inner = closeRange(inner, side, from, to, depth + 1, openEnd);
    if (depth >= from)
        inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner)
            : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice, openStart, openEnd) {
    if (openStart < slice.openStart)
        slice = new Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);
    if (openEnd < slice.openEnd)
        slice = new Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);
    return slice;
}
// Trick from jQuery -- some elements must be wrapped in other
// elements for innerHTML to work. I.e. if you do `div.innerHTML =
// "<td>..</td>"` the table cells are ignored.
const wrapMap = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
};
let _detachedDoc = null;
function detachedDoc() {
    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(html) {
    let metas = /^(\s*<meta [^>]*>)*/.exec(html);
    if (metas)
        html = html.slice(metas[0].length);
    let elt = detachedDoc().createElement("div");
    let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap;
    if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])
        html = wrap.map(n => "<" + n + ">").join("") + html + wrap.map(n => "</" + n + ">").reverse().join("");
    elt.innerHTML = html;
    if (wrap)
        for (let i = 0; i < wrap.length; i++)
            elt = elt.querySelector(wrap[i]) || elt;
    return elt;
}
// Webkit browsers do some hard-to-predict replacement of regular
// spaces with non-breaking spaces when putting content on the
// clipboard. This tries to convert such non-breaking spaces (which
// will be wrapped in a plain span on Chrome, a span with class
// Apple-converted-space on Safari) back to regular spaces.
function restoreReplacedSpaces(dom) {
    let nodes = dom.querySelectorAll(chrome$1 ? "span:not([class]):not([style])" : "span.Apple-converted-space");
    for (let i = 0; i < nodes.length; i++) {
        let node = nodes[i];
        if (node.childNodes.length == 1 && node.textContent == "\u00a0" && node.parentNode)
            node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
    }
}
function addContext(slice, context) {
    if (!slice.size)
        return slice;
    let schema = slice.content.firstChild.type.schema, array;
    try {
        array = JSON.parse(context);
    }
    catch (e) {
        return slice;
    }
    let { content, openStart, openEnd } = slice;
    for (let i = array.length - 2; i >= 0; i -= 2) {
        let type = schema.nodes[array[i]];
        if (!type || type.hasRequiredAttrs())
            break;
        content = Fragment.from(type.create(array[i + 1], content));
        openStart++;
        openEnd++;
    }
    return new Slice(content, openStart, openEnd);
}

// A collection of DOM events that occur within the editor, and callback functions
// to invoke when the event fires.
const handlers = {};
let editHandlers = {};
class InputState {
    constructor() {
        this.shiftKey = false;
        this.mouseDown = null;
        this.lastKeyCode = null;
        this.lastKeyCodeTime = 0;
        this.lastClick = { time: 0, x: 0, y: 0, type: "" };
        this.lastSelectionOrigin = null;
        this.lastSelectionTime = 0;
        this.lastIOSEnter = 0;
        this.lastIOSEnterFallbackTimeout = -1;
        this.lastAndroidDelete = 0;
        this.composing = false;
        this.composingTimeout = -1;
        this.compositionNodes = [];
        this.compositionEndedAt = -2e8;
        this.domChangeCount = 0;
        this.eventHandlers = Object.create(null);
        this.hideSelectionGuard = null;
    }
}
function initInput(view) {
    for (let event in handlers) {
        let handler = handlers[event];
        view.dom.addEventListener(event, view.input.eventHandlers[event] = (event) => {
            if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&
                (view.editable || !(event.type in editHandlers)))
                handler(view, event);
        });
    }
    // On Safari, for reasons beyond my understanding, adding an input
    // event handler makes an issue where the composition vanishes when
    // you press enter go away.
    if (safari$1)
        view.dom.addEventListener("input", () => null);
    ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
    view.input.lastSelectionOrigin = origin;
    view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
    view.domObserver.stop();
    for (let type in view.input.eventHandlers)
        view.dom.removeEventListener(type, view.input.eventHandlers[type]);
    clearTimeout(view.input.composingTimeout);
    clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
    view.someProp("handleDOMEvents", currentHandlers => {
        for (let type in currentHandlers)
            if (!view.input.eventHandlers[type])
                view.dom.addEventListener(type, view.input.eventHandlers[type] = event => runCustomHandler(view, event));
    });
}
function runCustomHandler(view, event) {
    return view.someProp("handleDOMEvents", handlers => {
        let handler = handlers[event.type];
        return handler ? handler(view, event) || event.defaultPrevented : false;
    });
}
function eventBelongsToView(view, event) {
    if (!event.bubbles)
        return true;
    if (event.defaultPrevented)
        return false;
    for (let node = event.target; node != view.dom; node = node.parentNode)
        if (!node || node.nodeType == 11 ||
            (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))
            return false;
    return true;
}
function dispatchEvent(view, event) {
    if (!runCustomHandler(view, event) && handlers[event.type] &&
        (view.editable || !(event.type in editHandlers)))
        handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
    let event = _event;
    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
    if (inOrNearComposition(view, event))
        return;
    view.input.lastKeyCode = event.keyCode;
    view.input.lastKeyCodeTime = Date.now();
    // Suppress enter key events on Chrome Android, because those tend
    // to be part of a confused sequence of composition events fired,
    // and handling them eagerly tends to corrupt the input.
    if (android && chrome$1 && event.keyCode == 13)
        return;
    if (event.keyCode != 229)
        view.domObserver.forceFlush();
    // On iOS, if we preventDefault enter key presses, the virtual
    // keyboard gets confused. So the hack here is to set a flag that
    // makes the DOM change code recognize that what just happens should
    // be replaced by whatever the Enter key handlers do.
    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
        let now = Date.now();
        view.input.lastIOSEnter = now;
        view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
            if (view.input.lastIOSEnter == now) {
                view.someProp("handleKeyDown", f => f(view, keyEvent(13, "Enter")));
                view.input.lastIOSEnter = 0;
            }
        }, 200);
    }
    else if (view.someProp("handleKeyDown", f => f(view, event)) || captureKeyDown(view, event)) {
        event.preventDefault();
    }
    else {
        setSelectionOrigin(view, "key");
    }
};
editHandlers.keyup = (view, event) => {
    if (event.keyCode == 16)
        view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
    let event = _event;
    if (inOrNearComposition(view, event) || !event.charCode ||
        event.ctrlKey && !event.altKey || mac$2 && event.metaKey)
        return;
    if (view.someProp("handleKeyPress", f => f(view, event))) {
        event.preventDefault();
        return;
    }
    let sel = view.state.selection;
    if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
        let text = String.fromCharCode(event.charCode);
        if (!view.someProp("handleTextInput", f => f(view, sel.$from.pos, sel.$to.pos, text)))
            view.dispatch(view.state.tr.insertText(text).scrollIntoView());
        event.preventDefault();
    }
};
function eventCoords(event) { return { left: event.clientX, top: event.clientY }; }
function isNear(event, click) {
    let dx = click.x - event.clientX, dy = click.y - event.clientY;
    return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
    if (inside == -1)
        return false;
    let $pos = view.state.doc.resolve(inside);
    for (let i = $pos.depth + 1; i > 0; i--) {
        if (view.someProp(propName, f => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)
            : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
            return true;
    }
    return false;
}
function updateSelection(view, selection, origin) {
    if (!view.focused)
        view.focus();
    let tr = view.state.tr.setSelection(selection);
    if (origin == "pointer")
        tr.setMeta("pointer", true);
    view.dispatch(tr);
}
function selectClickedLeaf(view, inside) {
    if (inside == -1)
        return false;
    let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
    if (node && node.isAtom && NodeSelection.isSelectable(node)) {
        updateSelection(view, new NodeSelection($pos), "pointer");
        return true;
    }
    return false;
}
function selectClickedNode(view, inside) {
    if (inside == -1)
        return false;
    let sel = view.state.selection, selectedNode, selectAt;
    if (sel instanceof NodeSelection)
        selectedNode = sel.node;
    let $pos = view.state.doc.resolve(inside);
    for (let i = $pos.depth + 1; i > 0; i--) {
        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
        if (NodeSelection.isSelectable(node)) {
            if (selectedNode && sel.$from.depth > 0 &&
                i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
                selectAt = $pos.before(sel.$from.depth);
            else
                selectAt = $pos.before(i);
            break;
        }
    }
    if (selectAt != null) {
        updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
        return true;
    }
    else {
        return false;
    }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
    return runHandlerOnContext(view, "handleClickOn", pos, inside, event) ||
        view.someProp("handleClick", f => f(view, pos, event)) ||
        (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) ||
        view.someProp("handleDoubleClick", f => f(view, pos, event));
}
function handleTripleClick$1(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) ||
        view.someProp("handleTripleClick", f => f(view, pos, event)) ||
        defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
    if (event.button != 0)
        return false;
    let doc = view.state.doc;
    if (inside == -1) {
        if (doc.inlineContent) {
            updateSelection(view, TextSelection.create(doc, 0, doc.content.size), "pointer");
            return true;
        }
        return false;
    }
    let $pos = doc.resolve(inside);
    for (let i = $pos.depth + 1; i > 0; i--) {
        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
        let nodePos = $pos.before(i);
        if (node.inlineContent)
            updateSelection(view, TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
        else if (NodeSelection.isSelectable(node))
            updateSelection(view, NodeSelection.create(doc, nodePos), "pointer");
        else
            continue;
        return true;
    }
}
function forceDOMFlush(view) {
    return endComposition(view);
}
const selectNodeModifier = mac$2 ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
    let event = _event;
    view.input.shiftKey = event.shiftKey;
    let flushed = forceDOMFlush(view);
    let now = Date.now(), type = "singleClick";
    if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
        if (view.input.lastClick.type == "singleClick")
            type = "doubleClick";
        else if (view.input.lastClick.type == "doubleClick")
            type = "tripleClick";
    }
    view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type };
    let pos = view.posAtCoords(eventCoords(event));
    if (!pos)
        return;
    if (type == "singleClick") {
        if (view.input.mouseDown)
            view.input.mouseDown.done();
        view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
    }
    else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick$1)(view, pos.pos, pos.inside, event)) {
        event.preventDefault();
    }
    else {
        setSelectionOrigin(view, "pointer");
    }
};
class MouseDown {
    constructor(view, pos, event, flushed) {
        this.view = view;
        this.pos = pos;
        this.event = event;
        this.flushed = flushed;
        this.delayedSelectionSync = false;
        this.mightDrag = null;
        this.startDoc = view.state.doc;
        this.selectNode = !!event[selectNodeModifier];
        this.allowDefault = event.shiftKey;
        let targetNode, targetPos;
        if (pos.inside > -1) {
            targetNode = view.state.doc.nodeAt(pos.inside);
            targetPos = pos.inside;
        }
        else {
            let $pos = view.state.doc.resolve(pos.pos);
            targetNode = $pos.parent;
            targetPos = $pos.depth ? $pos.before() : 0;
        }
        const target = flushed ? null : event.target;
        const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
        this.target = targetDesc ? targetDesc.dom : null;
        let { selection } = view.state;
        if (event.button == 0 &&
            targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false ||
            selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
            this.mightDrag = {
                node: targetNode,
                pos: targetPos,
                addAttr: !!(this.target && !this.target.draggable),
                setUneditable: !!(this.target && gecko$1 && !this.target.hasAttribute("contentEditable"))
            };
        if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
            this.view.domObserver.stop();
            if (this.mightDrag.addAttr)
                this.target.draggable = true;
            if (this.mightDrag.setUneditable)
                setTimeout(() => {
                    if (this.view.input.mouseDown == this)
                        this.target.setAttribute("contentEditable", "false");
                }, 20);
            this.view.domObserver.start();
        }
        view.root.addEventListener("mouseup", this.up = this.up.bind(this));
        view.root.addEventListener("mousemove", this.move = this.move.bind(this));
        setSelectionOrigin(view, "pointer");
    }
    done() {
        this.view.root.removeEventListener("mouseup", this.up);
        this.view.root.removeEventListener("mousemove", this.move);
        if (this.mightDrag && this.target) {
            this.view.domObserver.stop();
            if (this.mightDrag.addAttr)
                this.target.removeAttribute("draggable");
            if (this.mightDrag.setUneditable)
                this.target.removeAttribute("contentEditable");
            this.view.domObserver.start();
        }
        if (this.delayedSelectionSync)
            setTimeout(() => selectionToDOM(this.view));
        this.view.input.mouseDown = null;
    }
    up(event) {
        this.done();
        if (!this.view.dom.contains(event.target))
            return;
        let pos = this.pos;
        if (this.view.state.doc != this.startDoc)
            pos = this.view.posAtCoords(eventCoords(event));
        if (this.allowDefault || !pos) {
            setSelectionOrigin(this.view, "pointer");
        }
        else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
            event.preventDefault();
        }
        else if (event.button == 0 &&
            (this.flushed ||
                // Safari ignores clicks on draggable elements
                (safari$1 && this.mightDrag && !this.mightDrag.node.isAtom) ||
                // Chrome will sometimes treat a node selection as a
                // cursor, but still report that the node is selected
                // when asked through getSelection. You'll then get a
                // situation where clicking at the point where that
                // (hidden) cursor is doesn't change the selection, and
                // thus doesn't get a reaction from ProseMirror. This
                // works around that.
                (chrome$1 && !(this.view.state.selection instanceof TextSelection) &&
                    Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2))) {
            updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
            event.preventDefault();
        }
        else {
            setSelectionOrigin(this.view, "pointer");
        }
    }
    move(event) {
        if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 ||
            Math.abs(this.event.y - event.clientY) > 4))
            this.allowDefault = true;
        setSelectionOrigin(this.view, "pointer");
        if (event.buttons == 0)
            this.done();
    }
}
handlers.touchdown = view => {
    forceDOMFlush(view);
    setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = view => forceDOMFlush(view);
function inOrNearComposition(view, event) {
    if (view.composing)
        return true;
    // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
    // On Japanese input method editors (IMEs), the Enter key is used to confirm character
    // selection. On Safari, when Enter is pressed, compositionend and keydown events are
    // emitted. The keydown event triggers newline insertion, which we don't want.
    // This method returns true if the keydown event should be ignored.
    // We only ignore it once, as pressing Enter a second time *should* insert a newline.
    // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.
    // This guards against the case where compositionend is triggered without the keyboard
    // (e.g. character confirmation may be done with the mouse), and keydown is triggered
    // afterwards- we wouldn't want to ignore the keydown event in this case.
    if (safari$1 && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
        view.input.compositionEndedAt = -2e8;
        return true;
    }
    return false;
}
// Drop active composition after 5 seconds of inactivity on Android
const timeoutComposition = android ? 5000 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = view => {
    if (!view.composing) {
        view.domObserver.flush();
        let { state } = view, $pos = state.selection.$from;
        if (state.selection.empty &&
            (state.storedMarks ||
                (!$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(m => m.type.spec.inclusive === false)))) {
            // Need to wrap the cursor in mark nodes different from the ones in the DOM context
            view.markCursor = view.state.storedMarks || $pos.marks();
            endComposition(view, true);
            view.markCursor = null;
        }
        else {
            endComposition(view);
            // In firefox, if the cursor is after but outside a marked node,
            // the inserted text won't inherit the marks. So this moves it
            // inside if necessary.
            if (gecko$1 && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
                let sel = view.domSelection();
                for (let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {
                    let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
                    if (!before)
                        break;
                    if (before.nodeType == 3) {
                        sel.collapse(before, before.nodeValue.length);
                        break;
                    }
                    else {
                        node = before;
                        offset = -1;
                    }
                }
            }
        }
        view.input.composing = true;
    }
    scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
    if (view.composing) {
        view.input.composing = false;
        view.input.compositionEndedAt = event.timeStamp;
        scheduleComposeEnd(view, 20);
    }
};
function scheduleComposeEnd(view, delay) {
    clearTimeout(view.input.composingTimeout);
    if (delay > -1)
        view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
    if (view.composing) {
        view.input.composing = false;
        view.input.compositionEndedAt = timestampFromCustomEvent();
    }
    while (view.input.compositionNodes.length > 0)
        view.input.compositionNodes.pop().markParentsDirty();
}
function timestampFromCustomEvent() {
    let event = document.createEvent("Event");
    event.initEvent("event", true, true);
    return event.timeStamp;
}
/**
@internal
*/
function endComposition(view, forceUpdate = false) {
    if (android && view.domObserver.flushingSoon >= 0)
        return;
    view.domObserver.forceFlush();
    clearComposition(view);
    if (forceUpdate || view.docView && view.docView.dirty) {
        let sel = selectionFromDOM(view);
        if (sel && !sel.eq(view.state.selection))
            view.dispatch(view.state.tr.setSelection(sel));
        else
            view.updateState(view.state);
        return true;
    }
    return false;
}
function captureCopy(view, dom) {
    // The extra wrapper is somehow necessary on IE/Edge to prevent the
    // content from being mangled when it is put onto the clipboard
    if (!view.dom.parentNode)
        return;
    let wrap = view.dom.parentNode.appendChild(document.createElement("div"));
    wrap.appendChild(dom);
    wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
    let sel = getSelection(), range = document.createRange();
    range.selectNodeContents(dom);
    // Done because IE will fire a selectionchange moving the selection
    // to its start when removeAllRanges is called and the editor still
    // has focus (which will mess up the editor's selection state).
    view.dom.blur();
    sel.removeAllRanges();
    sel.addRange(range);
    setTimeout(() => {
        if (wrap.parentNode)
            wrap.parentNode.removeChild(wrap);
        view.focus();
    }, 50);
}
// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard API—all the objects and methods are
// there, they just don't work, and they are hard to test.
const brokenClipboardAPI = (ie$1 && ie_version < 15) ||
    (ios && webkit_version < 604);
handlers.copy = editHandlers.cut = (view, _event) => {
    let event = _event;
    let sel = view.state.selection, cut = event.type == "cut";
    if (sel.empty)
        return;
    // IE and Edge's clipboard interface is completely broken
    let data = brokenClipboardAPI ? null : event.clipboardData;
    let slice = sel.content(), { dom, text } = serializeForClipboard(view, slice);
    if (data) {
        event.preventDefault();
        data.clearData();
        data.setData("text/html", dom.innerHTML);
        data.setData("text/plain", text);
    }
    else {
        captureCopy(view, dom);
    }
    if (cut)
        view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice) {
    return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;
}
function capturePaste(view, event) {
    if (!view.dom.parentNode)
        return;
    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
    if (!plainText)
        target.contentEditable = "true";
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
        view.focus();
        if (target.parentNode)
            target.parentNode.removeChild(target);
        if (plainText)
            doPaste(view, target.value, null, event);
        else
            doPaste(view, target.textContent, target.innerHTML, event);
    }, 50);
}
function doPaste(view, text, html, event) {
    let slice = parseFromClipboard(view, text, html, view.input.shiftKey, view.state.selection.$from);
    if (view.someProp("handlePaste", f => f(view, event, slice || Slice.empty)))
        return true;
    if (!slice)
        return false;
    let singleNode = sliceSingleNode(slice);
    let tr = singleNode
        ? view.state.tr.replaceSelectionWith(singleNode, view.input.shiftKey)
        : view.state.tr.replaceSelection(slice);
    view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
    return true;
}
editHandlers.paste = (view, _event) => {
    let event = _event;
    // Handling paste from JavaScript during composition is very poorly
    // handled by browsers, so as a dodgy but preferable kludge, we just
    // let the browser do its native thing there, except on Android,
    // where the editor is almost always composing.
    if (view.composing && !android)
        return;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), event))
        event.preventDefault();
    else
        capturePaste(view, event);
};
class Dragging {
    constructor(slice, move) {
        this.slice = slice;
        this.move = move;
    }
}
const dragCopyModifier = mac$2 ? "altKey" : "ctrlKey";
handlers.dragstart = (view, _event) => {
    let event = _event;
    let mouseDown = view.input.mouseDown;
    if (mouseDown)
        mouseDown.done();
    if (!event.dataTransfer)
        return;
    let sel = view.state.selection;
    let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
    else if (mouseDown && mouseDown.mightDrag) {
        view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
    }
    else if (event.target && event.target.nodeType == 1) {
        let desc = view.docView.nearestDesc(event.target, true);
        if (desc && desc.node.type.spec.draggable && desc != view.docView)
            view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore)));
    }
    let slice = view.state.selection.content(), { dom, text } = serializeForClipboard(view, slice);
    event.dataTransfer.clearData();
    event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
    // See https://github.com/ProseMirror/prosemirror/issues/1156
    event.dataTransfer.effectAllowed = "copyMove";
    if (!brokenClipboardAPI)
        event.dataTransfer.setData("text/plain", text);
    view.dragging = new Dragging(slice, !event[dragCopyModifier]);
};
handlers.dragend = view => {
    let dragging = view.dragging;
    window$1.setTimeout(() => {
        if (view.dragging == dragging)
            view.dragging = null;
    }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
editHandlers.drop = (view, _event) => {
    let event = _event;
    let dragging = view.dragging;
    view.dragging = null;
    if (!event.dataTransfer)
        return;
    let eventPos = view.posAtCoords(eventCoords(event));
    if (!eventPos)
        return;
    let $mouse = view.state.doc.resolve(eventPos.pos);
    if (!$mouse)
        return;
    let slice = dragging && dragging.slice;
    if (slice) {
        view.someProp("transformPasted", f => { slice = f(slice); });
    }
    else {
        slice = parseFromClipboard(view, event.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
    }
    let move = !!(dragging && !event[dragCopyModifier]);
    if (view.someProp("handleDrop", f => f(view, event, slice || Slice.empty, move))) {
        event.preventDefault();
        return;
    }
    if (!slice)
        return;
    event.preventDefault();
    let insertPos = slice ? dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;
    if (insertPos == null)
        insertPos = $mouse.pos;
    let tr = view.state.tr;
    if (move)
        tr.deleteSelection();
    let pos = tr.mapping.map(insertPos);
    let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
    let beforeInsert = tr.doc;
    if (isNode)
        tr.replaceRangeWith(pos, pos, slice.content.firstChild);
    else
        tr.replaceRange(pos, pos, slice);
    if (tr.doc.eq(beforeInsert))
        return;
    let $pos = tr.doc.resolve(pos);
    if (isNode && NodeSelection.isSelectable(slice.content.firstChild) &&
        $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
        tr.setSelection(new NodeSelection($pos));
    }
    else {
        let end = tr.mapping.map(insertPos);
        tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);
        tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
    }
    view.focus();
    view.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers.focus = view => {
    if (!view.focused) {
        view.domObserver.stop();
        view.dom.classList.add("ProseMirror-focused");
        view.domObserver.start();
        view.focused = true;
        setTimeout(() => {
            if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelection()))
                selectionToDOM(view);
        }, 20);
    }
};
handlers.blur = (view, _event) => {
    let event = _event;
    if (view.focused) {
        view.domObserver.stop();
        view.dom.classList.remove("ProseMirror-focused");
        view.domObserver.start();
        if (event.relatedTarget && view.dom.contains(event.relatedTarget))
            view.domObserver.currentSelection.clear();
        view.focused = false;
    }
};
handlers.beforeinput = (view, _event) => {
    let event = _event;
    // We should probably do more with beforeinput events, but support
    // is so spotty that I'm still waiting to see where they are going.
    // Very specific hack to deal with backspace sometimes failing on
    // Chrome Android when after an uneditable node.
    if (chrome$1 && android && event.inputType == "deleteContentBackward") {
        view.domObserver.flushSoon();
        let { domChangeCount } = view.input;
        setTimeout(() => {
            if (view.input.domChangeCount != domChangeCount)
                return; // Event already had some effect
            // This bug tends to close the virtual keyboard, so we refocus
            view.dom.blur();
            view.focus();
            if (view.someProp("handleKeyDown", f => f(view, keyEvent(8, "Backspace"))))
                return;
            let { $cursor } = view.state.selection;
            // Crude approximation of backspace behavior when no command handled it
            if ($cursor && $cursor.pos > 0)
                view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
        }, 50);
    }
};
// Make sure all handlers get registered
for (let prop in editHandlers)
    handlers[prop] = editHandlers[prop];

function compareObjs(a, b) {
    if (a == b)
        return true;
    for (let p in a)
        if (a[p] !== b[p])
            return false;
    for (let p in b)
        if (!(p in a))
            return false;
    return true;
}
class WidgetType {
    constructor(toDOM, spec) {
        this.toDOM = toDOM;
        this.spec = spec || noSpec;
        this.side = this.spec.side || 0;
    }
    map(mapping, span, offset, oldOffset) {
        let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
        return deleted ? null : new Decoration(pos - offset, pos - offset, this);
    }
    valid() { return true; }
    eq(other) {
        return this == other ||
            (other instanceof WidgetType &&
                (this.spec.key && this.spec.key == other.spec.key ||
                    this.toDOM == other.toDOM && compareObjs(this.spec, other.spec)));
    }
    destroy(node) {
        if (this.spec.destroy)
            this.spec.destroy(node);
    }
}
class InlineType {
    constructor(attrs, spec) {
        this.attrs = attrs;
        this.spec = spec || noSpec;
    }
    map(mapping, span, offset, oldOffset) {
        let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
        let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
        return from >= to ? null : new Decoration(from, to, this);
    }
    valid(_, span) { return span.from < span.to; }
    eq(other) {
        return this == other ||
            (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&
                compareObjs(this.spec, other.spec));
    }
    static is(span) { return span.type instanceof InlineType; }
    destroy() { }
}
class NodeType {
    constructor(attrs, spec) {
        this.attrs = attrs;
        this.spec = spec || noSpec;
    }
    map(mapping, span, offset, oldOffset) {
        let from = mapping.mapResult(span.from + oldOffset, 1);
        if (from.deleted)
            return null;
        let to = mapping.mapResult(span.to + oldOffset, -1);
        if (to.deleted || to.pos <= from.pos)
            return null;
        return new Decoration(from.pos - offset, to.pos - offset, this);
    }
    valid(node, span) {
        let { index, offset } = node.content.findIndex(span.from), child;
        return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;
    }
    eq(other) {
        return this == other ||
            (other instanceof NodeType && compareObjs(this.attrs, other.attrs) &&
                compareObjs(this.spec, other.spec));
    }
    destroy() { }
}
/**
Decoration objects can be provided to the view through the
[`decorations` prop](https://prosemirror.net/docs/ref/#view.EditorProps.decorations). They come in
several variants—see the static members of this class for details.
*/
class Decoration {
    /**
    @internal
    */
    constructor(
    /**
    The start position of the decoration.
    */
    from, 
    /**
    The end position. Will be the same as `from` for [widget
    decorations](https://prosemirror.net/docs/ref/#view.Decoration^widget).
    */
    to, 
    /**
    @internal
    */
    type) {
        this.from = from;
        this.to = to;
        this.type = type;
    }
    /**
    @internal
    */
    copy(from, to) {
        return new Decoration(from, to, this.type);
    }
    /**
    @internal
    */
    eq(other, offset = 0) {
        return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;
    }
    /**
    @internal
    */
    map(mapping, offset, oldOffset) {
        return this.type.map(mapping, this, offset, oldOffset);
    }
    /**
    Creates a widget decoration, which is a DOM node that's shown in
    the document at the given position. It is recommended that you
    delay rendering the widget by passing a function that will be
    called when the widget is actually drawn in a view, but you can
    also directly pass a DOM node. `getPos` can be used to find the
    widget's current document position.
    */
    static widget(pos, toDOM, spec) {
        return new Decoration(pos, pos, new WidgetType(toDOM, spec));
    }
    /**
    Creates an inline decoration, which adds the given attributes to
    each inline node between `from` and `to`.
    */
    static inline(from, to, attrs, spec) {
        return new Decoration(from, to, new InlineType(attrs, spec));
    }
    /**
    Creates a node decoration. `from` and `to` should point precisely
    before and after a node in the document. That node, and only that
    node, will receive the given attributes.
    */
    static node(from, to, attrs, spec) {
        return new Decoration(from, to, new NodeType(attrs, spec));
    }
    /**
    The spec provided when creating this decoration. Can be useful
    if you've stored extra information in that object.
    */
    get spec() { return this.type.spec; }
    /**
    @internal
    */
    get inline() { return this.type instanceof InlineType; }
}
const none = [], noSpec = {};
/**
A collection of [decorations](https://prosemirror.net/docs/ref/#view.Decoration), organized in such
a way that the drawing algorithm can efficiently use and compare
them. This is a persistent data structure—it is not modified,
updates create a new value.
*/
class DecorationSet {
    /**
    @internal
    */
    constructor(local, children) {
        this.local = local.length ? local : none;
        this.children = children.length ? children : none;
    }
    /**
    Create a set of decorations, using the structure of the given
    document.
    */
    static create(doc, decorations) {
        return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty;
    }
    /**
    Find all decorations in this set which touch the given range
    (including decorations that start or end directly at the
    boundaries) and match the given predicate on their spec. When
    `start` and `end` are omitted, all decorations in the set are
    considered. When `predicate` isn't given, all decorations are
    assumed to match.
    */
    find(start, end, predicate) {
        let result = [];
        this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
        return result;
    }
    findInner(start, end, result, offset, predicate) {
        for (let i = 0; i < this.local.length; i++) {
            let span = this.local[i];
            if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
                result.push(span.copy(span.from + offset, span.to + offset));
        }
        for (let i = 0; i < this.children.length; i += 3) {
            if (this.children[i] < end && this.children[i + 1] > start) {
                let childOff = this.children[i] + 1;
                this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
            }
        }
    }
    /**
    Map the set of decorations in response to a change in the
    document.
    */
    map(mapping, doc, options) {
        if (this == empty || mapping.maps.length == 0)
            return this;
        return this.mapInner(mapping, doc, 0, 0, options || noSpec);
    }
    /**
    @internal
    */
    mapInner(mapping, node, offset, oldOffset, options) {
        let newLocal;
        for (let i = 0; i < this.local.length; i++) {
            let mapped = this.local[i].map(mapping, offset, oldOffset);
            if (mapped && mapped.type.valid(node, mapped))
                (newLocal || (newLocal = [])).push(mapped);
            else if (options.onRemove)
                options.onRemove(this.local[i].spec);
        }
        if (this.children.length)
            return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);
        else
            return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
    }
    /**
    Add the given array of decorations to the ones in the set,
    producing a new set. Needs access to the current document to
    create the appropriate tree structure.
    */
    add(doc, decorations) {
        if (!decorations.length)
            return this;
        if (this == empty)
            return DecorationSet.create(doc, decorations);
        return this.addInner(doc, decorations, 0);
    }
    addInner(doc, decorations, offset) {
        let children, childIndex = 0;
        doc.forEach((childNode, childOffset) => {
            let baseOffset = childOffset + offset, found;
            if (!(found = takeSpansForNode(decorations, childNode, baseOffset)))
                return;
            if (!children)
                children = this.children.slice();
            while (childIndex < children.length && children[childIndex] < childOffset)
                childIndex += 3;
            if (children[childIndex] == childOffset)
                children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);
            else
                children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));
            childIndex += 3;
        });
        let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
        for (let i = 0; i < local.length; i++)
            if (!local[i].type.valid(doc, local[i]))
                local.splice(i--, 1);
        return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
    }
    /**
    Create a new set that contains the decorations in this set, minus
    the ones in the given array.
    */
    remove(decorations) {
        if (decorations.length == 0 || this == empty)
            return this;
        return this.removeInner(decorations, 0);
    }
    removeInner(decorations, offset) {
        let children = this.children, local = this.local;
        for (let i = 0; i < children.length; i += 3) {
            let found;
            let from = children[i] + offset, to = children[i + 1] + offset;
            for (let j = 0, span; j < decorations.length; j++)
                if (span = decorations[j]) {
                    if (span.from > from && span.to < to) {
                        decorations[j] = null;
                        (found || (found = [])).push(span);
                    }
                }
            if (!found)
                continue;
            if (children == this.children)
                children = this.children.slice();
            let removed = children[i + 2].removeInner(found, from + 1);
            if (removed != empty) {
                children[i + 2] = removed;
            }
            else {
                children.splice(i, 3);
                i -= 3;
            }
        }
        if (local.length)
            for (let i = 0, span; i < decorations.length; i++)
                if (span = decorations[i]) {
                    for (let j = 0; j < local.length; j++)
                        if (local[j].eq(span, offset)) {
                            if (local == this.local)
                                local = this.local.slice();
                            local.splice(j--, 1);
                        }
                }
        if (children == this.children && local == this.local)
            return this;
        return local.length || children.length ? new DecorationSet(local, children) : empty;
    }
    /**
    @internal
    */
    forChild(offset, node) {
        if (this == empty)
            return this;
        if (node.isLeaf)
            return DecorationSet.empty;
        let child, local;
        for (let i = 0; i < this.children.length; i += 3)
            if (this.children[i] >= offset) {
                if (this.children[i] == offset)
                    child = this.children[i + 2];
                break;
            }
        let start = offset + 1, end = start + node.content.size;
        for (let i = 0; i < this.local.length; i++) {
            let dec = this.local[i];
            if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {
                let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
                if (from < to)
                    (local || (local = [])).push(dec.copy(from, to));
            }
        }
        if (local) {
            let localSet = new DecorationSet(local.sort(byPos), none);
            return child ? new DecorationGroup([localSet, child]) : localSet;
        }
        return child || empty;
    }
    /**
    @internal
    */
    eq(other) {
        if (this == other)
            return true;
        if (!(other instanceof DecorationSet) ||
            this.local.length != other.local.length ||
            this.children.length != other.children.length)
            return false;
        for (let i = 0; i < this.local.length; i++)
            if (!this.local[i].eq(other.local[i]))
                return false;
        for (let i = 0; i < this.children.length; i += 3)
            if (this.children[i] != other.children[i] ||
                this.children[i + 1] != other.children[i + 1] ||
                !this.children[i + 2].eq(other.children[i + 2]))
                return false;
        return true;
    }
    /**
    @internal
    */
    locals(node) {
        return removeOverlap(this.localsInner(node));
    }
    /**
    @internal
    */
    localsInner(node) {
        if (this == empty)
            return none;
        if (node.inlineContent || !this.local.some(InlineType.is))
            return this.local;
        let result = [];
        for (let i = 0; i < this.local.length; i++) {
            if (!(this.local[i].type instanceof InlineType))
                result.push(this.local[i]);
        }
        return result;
    }
}
/**
The empty set of decorations.
*/
DecorationSet.empty = new DecorationSet([], []);
/**
@internal
*/
DecorationSet.removeOverlap = removeOverlap;
const empty = DecorationSet.empty;
// An abstraction that allows the code dealing with decorations to
// treat multiple DecorationSet objects as if it were a single object
// with (a subset of) the same interface.
class DecorationGroup {
    constructor(members) {
        this.members = members;
    }
    map(mapping, doc) {
        const mappedDecos = this.members.map(member => member.map(mapping, doc, noSpec));
        return DecorationGroup.from(mappedDecos);
    }
    forChild(offset, child) {
        if (child.isLeaf)
            return DecorationSet.empty;
        let found = [];
        for (let i = 0; i < this.members.length; i++) {
            let result = this.members[i].forChild(offset, child);
            if (result == empty)
                continue;
            if (result instanceof DecorationGroup)
                found = found.concat(result.members);
            else
                found.push(result);
        }
        return DecorationGroup.from(found);
    }
    eq(other) {
        if (!(other instanceof DecorationGroup) ||
            other.members.length != this.members.length)
            return false;
        for (let i = 0; i < this.members.length; i++)
            if (!this.members[i].eq(other.members[i]))
                return false;
        return true;
    }
    locals(node) {
        let result, sorted = true;
        for (let i = 0; i < this.members.length; i++) {
            let locals = this.members[i].localsInner(node);
            if (!locals.length)
                continue;
            if (!result) {
                result = locals;
            }
            else {
                if (sorted) {
                    result = result.slice();
                    sorted = false;
                }
                for (let j = 0; j < locals.length; j++)
                    result.push(locals[j]);
            }
        }
        return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
    }
    // Create a group for the given array of decoration sets, or return
    // a single set when possible.
    static from(members) {
        switch (members.length) {
            case 0: return empty;
            case 1: return members[0];
            default: return new DecorationGroup(members);
        }
    }
}
function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
    let children = oldChildren.slice();
    // Mark the children that are directly touched by changes, and
    // move those that are after the changes.
    let shift = (oldStart, oldEnd, newStart, newEnd) => {
        for (let i = 0; i < children.length; i += 3) {
            let end = children[i + 1], dSize;
            if (end < 0 || oldStart > end + oldOffset)
                continue;
            let start = children[i] + oldOffset;
            if (oldEnd >= start) {
                children[i + 1] = oldStart <= start ? -2 : -1;
            }
            else if (newStart >= offset && (dSize = (newEnd - newStart) - (oldEnd - oldStart))) {
                children[i] += dSize;
                children[i + 1] += dSize;
            }
        }
    };
    for (let i = 0; i < mapping.maps.length; i++)
        mapping.maps[i].forEach(shift);
    // Find the child nodes that still correspond to a single node,
    // recursively call mapInner on them and update their positions.
    let mustRebuild = false;
    for (let i = 0; i < children.length; i += 3)
        if (children[i + 1] < 0) { // Touched nodes
            if (children[i + 1] == -2) {
                mustRebuild = true;
                children[i + 1] = -1;
                continue;
            }
            let from = mapping.map(oldChildren[i] + oldOffset), fromLocal = from - offset;
            if (fromLocal < 0 || fromLocal >= node.content.size) {
                mustRebuild = true;
                continue;
            }
            // Must read oldChildren because children was tagged with -1
            let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset;
            let { index, offset: childOffset } = node.content.findIndex(fromLocal);
            let childNode = node.maybeChild(index);
            if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
                let mapped = children[i + 2]
                    .mapInner(mapping, childNode, from + 1, oldChildren[i] + oldOffset + 1, options);
                if (mapped != empty) {
                    children[i] = fromLocal;
                    children[i + 1] = toLocal;
                    children[i + 2] = mapped;
                }
                else {
                    children[i + 1] = -2;
                    mustRebuild = true;
                }
            }
            else {
                mustRebuild = true;
            }
        }
    // Remaining children must be collected and rebuilt into the appropriate structure
    if (mustRebuild) {
        let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);
        let built = buildTree(decorations, node, 0, options);
        newLocal = built.local;
        for (let i = 0; i < children.length; i += 3)
            if (children[i + 1] < 0) {
                children.splice(i, 3);
                i -= 3;
            }
        for (let i = 0, j = 0; i < built.children.length; i += 3) {
            let from = built.children[i];
            while (j < children.length && children[j] < from)
                j += 3;
            children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
        }
    }
    return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset) {
    if (!offset || !spans.length)
        return spans;
    let result = [];
    for (let i = 0; i < spans.length; i++) {
        let span = spans[i];
        result.push(new Decoration(span.from + offset, span.to + offset, span.type));
    }
    return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
    // Gather all decorations from the remaining marked children
    function gather(set, oldOffset) {
        for (let i = 0; i < set.local.length; i++) {
            let mapped = set.local[i].map(mapping, offset, oldOffset);
            if (mapped)
                decorations.push(mapped);
            else if (options.onRemove)
                options.onRemove(set.local[i].spec);
        }
        for (let i = 0; i < set.children.length; i += 3)
            gather(set.children[i + 2], set.children[i] + oldOffset + 1);
    }
    for (let i = 0; i < children.length; i += 3)
        if (children[i + 1] == -1)
            gather(children[i + 2], oldChildren[i] + oldOffset + 1);
    return decorations;
}
function takeSpansForNode(spans, node, offset) {
    if (node.isLeaf)
        return null;
    let end = offset + node.nodeSize, found = null;
    for (let i = 0, span; i < spans.length; i++) {
        if ((span = spans[i]) && span.from > offset && span.to < end) {
            (found || (found = [])).push(span);
            spans[i] = null;
        }
    }
    return found;
}
function withoutNulls(array) {
    let result = [];
    for (let i = 0; i < array.length; i++)
        if (array[i] != null)
            result.push(array[i]);
    return result;
}
// Build up a tree that corresponds to a set of decorations. `offset`
// is a base offset that should be subtracted from the `from` and `to`
// positions in the spans (so that we don't have to allocate new spans
// for recursive calls).
function buildTree(spans, node, offset, options) {
    let children = [], hasNulls = false;
    node.forEach((childNode, localStart) => {
        let found = takeSpansForNode(spans, childNode, localStart + offset);
        if (found) {
            hasNulls = true;
            let subtree = buildTree(found, childNode, offset + localStart + 1, options);
            if (subtree != empty)
                children.push(localStart, localStart + childNode.nodeSize, subtree);
        }
    });
    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
    for (let i = 0; i < locals.length; i++)
        if (!locals[i].type.valid(node, locals[i])) {
            if (options.onRemove)
                options.onRemove(locals[i].spec);
            locals.splice(i--, 1);
        }
    return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
// Used to sort decorations so that ones with a low start position
// come first, and within a set with the same start position, those
// with an smaller end position come first.
function byPos(a, b) {
    return a.from - b.from || a.to - b.to;
}
// Scan a sorted array of decorations for partially overlapping spans,
// and split those so that only fully overlapping spans are left (to
// make subsequent rendering easier). Will return the input array if
// no partially overlapping spans are found (the common case).
function removeOverlap(spans) {
    let working = spans;
    for (let i = 0; i < working.length - 1; i++) {
        let span = working[i];
        if (span.from != span.to)
            for (let j = i + 1; j < working.length; j++) {
                let next = working[j];
                if (next.from == span.from) {
                    if (next.to != span.to) {
                        if (working == spans)
                            working = spans.slice();
                        // Followed by a partially overlapping larger span. Split that
                        // span.
                        working[j] = next.copy(next.from, span.to);
                        insertAhead(working, j + 1, next.copy(span.to, next.to));
                    }
                    continue;
                }
                else {
                    if (next.from < span.to) {
                        if (working == spans)
                            working = spans.slice();
                        // The end of this one overlaps with a subsequent span. Split
                        // this one.
                        working[i] = span.copy(span.from, next.from);
                        insertAhead(working, j, span.copy(next.from, span.to));
                    }
                    break;
                }
            }
    }
    return working;
}
function insertAhead(array, i, deco) {
    while (i < array.length && byPos(deco, array[i]) > 0)
        i++;
    array.splice(i, 0, deco);
}
// Get the decorations associated with the current props of a view.
function viewDecorations(view) {
    let found = [];
    view.someProp("decorations", f => {
        let result = f(view.state);
        if (result && result != empty)
            found.push(result);
    });
    if (view.cursorWrapper)
        found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
    return DecorationGroup.from(found);
}

const observeOptions = {
    childList: true,
    characterData: true,
    characterDataOldValue: true,
    attributes: true,
    attributeOldValue: true,
    subtree: true
};
// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified
const useCharData = ie$1 && ie_version <= 11;
class SelectionState {
    constructor() {
        this.anchorNode = null;
        this.anchorOffset = 0;
        this.focusNode = null;
        this.focusOffset = 0;
    }
    set(sel) {
        this.anchorNode = sel.anchorNode;
        this.anchorOffset = sel.anchorOffset;
        this.focusNode = sel.focusNode;
        this.focusOffset = sel.focusOffset;
    }
    clear() {
        this.anchorNode = this.focusNode = null;
    }
    eq(sel) {
        return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset &&
            sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
    }
}
class DOMObserver {
    constructor(view, handleDOMChange) {
        this.view = view;
        this.handleDOMChange = handleDOMChange;
        this.queue = [];
        this.flushingSoon = -1;
        this.observer = null;
        this.currentSelection = new SelectionState;
        this.onCharData = null;
        this.suppressingSelectionUpdates = false;
        this.observer = window$1.MutationObserver &&
            new window$1.MutationObserver(mutations => {
                for (let i = 0; i < mutations.length; i++)
                    this.queue.push(mutations[i]);
                // IE11 will sometimes (on backspacing out a single character
                // text node after a BR node) call the observer callback
                // before actually updating the DOM, which will cause
                // ProseMirror to miss the change (see #930)
                if (ie$1 && ie_version <= 11 && mutations.some(m => m.type == "childList" && m.removedNodes.length ||
                    m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
                    this.flushSoon();
                else
                    this.flush();
            });
        if (useCharData) {
            this.onCharData = e => {
                this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
                this.flushSoon();
            };
        }
        this.onSelectionChange = this.onSelectionChange.bind(this);
    }
    flushSoon() {
        if (this.flushingSoon < 0)
            this.flushingSoon = window$1.setTimeout(() => { this.flushingSoon = -1; this.flush(); }, 20);
    }
    forceFlush() {
        if (this.flushingSoon > -1) {
            window$1.clearTimeout(this.flushingSoon);
            this.flushingSoon = -1;
            this.flush();
        }
    }
    start() {
        if (this.observer)
            this.observer.observe(this.view.dom, observeOptions);
        if (this.onCharData)
            this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
        this.connectSelection();
    }
    stop() {
        if (this.observer) {
            let take = this.observer.takeRecords();
            if (take.length) {
                for (let i = 0; i < take.length; i++)
                    this.queue.push(take[i]);
                window$1.setTimeout(() => this.flush(), 20);
            }
            this.observer.disconnect();
        }
        if (this.onCharData)
            this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
        this.disconnectSelection();
    }
    connectSelection() {
        this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    }
    disconnectSelection() {
        this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    }
    suppressSelectionUpdates() {
        this.suppressingSelectionUpdates = true;
        setTimeout(() => this.suppressingSelectionUpdates = false, 50);
    }
    onSelectionChange() {
        if (!hasFocusAndSelection(this.view))
            return;
        if (this.suppressingSelectionUpdates)
            return selectionToDOM(this.view);
        // Deletions on IE11 fire their events in the wrong order, giving
        // us a selection change event before the DOM changes are
        // reported.
        if (ie$1 && ie_version <= 11 && !this.view.state.selection.empty) {
            let sel = this.view.domSelection();
            // Selection.isCollapsed isn't reliable on IE
            if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
                return this.flushSoon();
        }
        this.flush();
    }
    setCurSelection() {
        this.currentSelection.set(this.view.domSelection());
    }
    ignoreSelectionChange(sel) {
        if (sel.rangeCount == 0)
            return true;
        let container = sel.getRangeAt(0).commonAncestorContainer;
        let desc = this.view.docView.nearestDesc(container);
        if (desc && desc.ignoreMutation({
            type: "selection",
            target: container.nodeType == 3 ? container.parentNode : container
        })) {
            this.setCurSelection();
            return true;
        }
    }
    flush() {
        if (!this.view.docView || this.flushingSoon > -1)
            return;
        let mutations = this.observer ? this.observer.takeRecords() : [];
        if (this.queue.length) {
            mutations = this.queue.concat(mutations);
            this.queue.length = 0;
        }
        let sel = this.view.domSelection();
        let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(this.view) && !this.ignoreSelectionChange(sel);
        let from = -1, to = -1, typeOver = false, added = [];
        if (this.view.editable) {
            for (let i = 0; i < mutations.length; i++) {
                let result = this.registerMutation(mutations[i], added);
                if (result) {
                    from = from < 0 ? result.from : Math.min(result.from, from);
                    to = to < 0 ? result.to : Math.max(result.to, to);
                    if (result.typeOver)
                        typeOver = true;
                }
            }
        }
        if (gecko$1 && added.length > 1) {
            let brs = added.filter(n => n.nodeName == "BR");
            if (brs.length == 2) {
                let a = brs[0], b = brs[1];
                if (a.parentNode && a.parentNode.parentNode == b.parentNode)
                    b.remove();
                else
                    a.remove();
            }
        }
        if (from > -1 || newSel) {
            if (from > -1) {
                this.view.docView.markDirty(from, to);
                checkCSS(this.view);
            }
            this.handleDOMChange(from, to, typeOver, added);
            if (this.view.docView && this.view.docView.dirty)
                this.view.updateState(this.view.state);
            else if (!this.currentSelection.eq(sel))
                selectionToDOM(this.view);
            this.currentSelection.set(sel);
        }
    }
    registerMutation(mut, added) {
        // Ignore mutations inside nodes that were already noted as inserted
        if (added.indexOf(mut.target) > -1)
            return null;
        let desc = this.view.docView.nearestDesc(mut.target);
        if (mut.type == "attributes" &&
            (desc == this.view.docView || mut.attributeName == "contenteditable" ||
                // Firefox sometimes fires spurious events for null/empty styles
                (mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))))
            return null;
        if (!desc || desc.ignoreMutation(mut))
            return null;
        if (mut.type == "childList") {
            for (let i = 0; i < mut.addedNodes.length; i++)
                added.push(mut.addedNodes[i]);
            if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
                return { from: desc.posBefore, to: desc.posAfter };
            let prev = mut.previousSibling, next = mut.nextSibling;
            if (ie$1 && ie_version <= 11 && mut.addedNodes.length) {
                // IE11 gives us incorrect next/prev siblings for some
                // insertions, so if there are added nodes, recompute those
                for (let i = 0; i < mut.addedNodes.length; i++) {
                    let { previousSibling, nextSibling } = mut.addedNodes[i];
                    if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
                        prev = previousSibling;
                    if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
                        next = nextSibling;
                }
            }
            let fromOffset = prev && prev.parentNode == mut.target
                ? domIndex(prev) + 1 : 0;
            let from = desc.localPosFromDOM(mut.target, fromOffset, -1);
            let toOffset = next && next.parentNode == mut.target
                ? domIndex(next) : mut.target.childNodes.length;
            let to = desc.localPosFromDOM(mut.target, toOffset, 1);
            return { from, to };
        }
        else if (mut.type == "attributes") {
            return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
        }
        else { // "characterData"
            return {
                from: desc.posAtStart,
                to: desc.posAtEnd,
                // An event was generated for a text change that didn't change
                // any text. Mark the dom change to fall back to assuming the
                // selection was typed over with an identical value if it can't
                // find another change.
                typeOver: mut.target.nodeValue == mut.oldValue
            };
        }
    }
}
let cssChecked = false;
function checkCSS(view) {
    if (cssChecked)
        return;
    cssChecked = true;
    if (getComputedStyle(view.dom).whiteSpace == "normal")
        console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
}

// Note that all referencing and parsing is done with the
// start-of-operation selection and document, since that's the one
// that the DOM represents. If any changes came in in the meantime,
// the modification is mapped over those before it is applied, in
// readDOMChange.
function parseBetween(view, from_, to_) {
    let { node: parent, fromOffset, toOffset, from, to } = view.docView.parseRange(from_, to_);
    let domSel = view.domSelection();
    let find;
    let anchor = domSel.anchorNode;
    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
        find = [{ node: anchor, offset: domSel.anchorOffset }];
        if (!selectionCollapsed(domSel))
            find.push({ node: domSel.focusNode, offset: domSel.focusOffset });
    }
    // Work around issue in Chrome where backspacing sometimes replaces
    // the deleted content with a random BR node (issues #799, #831)
    if (chrome$1 && view.input.lastKeyCode === 8) {
        for (let off = toOffset; off > fromOffset; off--) {
            let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
            if (node.nodeName == "BR" && !desc) {
                toOffset = off;
                break;
            }
            if (!desc || desc.size)
                break;
        }
    }
    let startDoc = view.state.doc;
    let parser = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    let $from = startDoc.resolve(from);
    let sel = null, doc = parser.parse(parent, {
        topNode: $from.parent,
        topMatch: $from.parent.contentMatchAt($from.index()),
        topOpen: true,
        from: fromOffset,
        to: toOffset,
        preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
        findPositions: find,
        ruleFromNode,
        context: $from
    });
    if (find && find[0].pos != null) {
        let anchor = find[0].pos, head = find[1] && find[1].pos;
        if (head == null)
            head = anchor;
        sel = { anchor: anchor + from, head: head + from };
    }
    return { doc, sel, from, to };
}
function ruleFromNode(dom) {
    let desc = dom.pmViewDesc;
    if (desc) {
        return desc.parseRule();
    }
    else if (dom.nodeName == "BR" && dom.parentNode) {
        // Safari replaces the list item or table cell with a BR
        // directly in the list node (?!) if you delete the last
        // character in a list item or table cell (#708, #862)
        if (safari$1 && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
            let skip = document.createElement("div");
            skip.appendChild(document.createElement("li"));
            return { skip };
        }
        else if (dom.parentNode.lastChild == dom || safari$1 && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
            return { ignore: true };
        }
    }
    else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
        return { ignore: true };
    }
    return null;
}
function readDOMChange(view, from, to, typeOver, addedNodes) {
    if (from < 0) {
        let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
        let newSel = selectionFromDOM(view, origin);
        if (newSel && !view.state.selection.eq(newSel)) {
            let tr = view.state.tr.setSelection(newSel);
            if (origin == "pointer")
                tr.setMeta("pointer", true);
            else if (origin == "key")
                tr.scrollIntoView();
            view.dispatch(tr);
        }
        return;
    }
    let $before = view.state.doc.resolve(from);
    let shared = $before.sharedDepth(to);
    from = $before.before(shared + 1);
    to = view.state.doc.resolve(to).after(shared + 1);
    let sel = view.state.selection;
    let parse = parseBetween(view, from, to);
    // Chrome sometimes leaves the cursor before the inserted text when
    // composing after a cursor wrapper. This moves it forward.
    if (chrome$1 && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from) {
        let text = view.cursorWrapper.deco.type.toDOM.nextSibling;
        let size = text && text.nodeValue ? text.nodeValue.length : 1;
        parse.sel = { anchor: parse.sel.anchor + size, head: parse.sel.anchor + size };
    }
    let doc = view.state.doc, compare = doc.slice(parse.from, parse.to);
    let preferredPos, preferredSide;
    // Prefer anchoring to end when Backspace is pressed
    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
        preferredPos = view.state.selection.to;
        preferredSide = "end";
    }
    else {
        preferredPos = view.state.selection.from;
        preferredSide = "start";
    }
    view.input.lastKeyCode = null;
    let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) &&
        addedNodes.some(n => n.nodeName == "DIV" || n.nodeName == "P") &&
        (!change || change.endA >= change.endB) &&
        view.someProp("handleKeyDown", f => f(view, keyEvent(13, "Enter")))) {
        view.input.lastIOSEnter = 0;
        return;
    }
    if (!change) {
        if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) &&
            !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
            change = { start: sel.from, endA: sel.to, endB: sel.to };
        }
        else {
            if (parse.sel) {
                let sel = resolveSelection(view, view.state.doc, parse.sel);
                if (sel && !sel.eq(view.state.selection))
                    view.dispatch(view.state.tr.setSelection(sel));
            }
            return;
        }
    }
    view.input.domChangeCount++;
    // Handle the case where overwriting a selection by typing matches
    // the start or end of the selected content, creating a change
    // that's smaller than what was actually overwritten.
    if (view.state.selection.from < view.state.selection.to &&
        change.start == change.endB &&
        view.state.selection instanceof TextSelection) {
        if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 &&
            view.state.selection.from >= parse.from) {
            change.start = view.state.selection.from;
        }
        else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 &&
            view.state.selection.to <= parse.to) {
            change.endB += (view.state.selection.to - change.endA);
            change.endA = view.state.selection.to;
        }
    }
    // IE11 will insert a non-breaking space _ahead_ of the space after
    // the cursor space when adding a space before another space. When
    // that happened, adjust the change to cover the space instead.
    if (ie$1 && ie_version <= 11 && change.endB == change.start + 1 &&
        change.endA == change.start && change.start > parse.from &&
        parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \u00a0") {
        change.start--;
        change.endA--;
        change.endB--;
    }
    let $from = parse.doc.resolveNoCache(change.start - parse.from);
    let $to = parse.doc.resolveNoCache(change.endB - parse.from);
    let $fromA = doc.resolve(change.start);
    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
    let nextSel;
    // If this looks like the effect of pressing Enter (or was recorded
    // as being an iOS enter press), just dispatch an Enter key instead.
    if (((ios && view.input.lastIOSEnter > Date.now() - 225 &&
        (!inlineChange || addedNodes.some(n => n.nodeName == "DIV" || n.nodeName == "P"))) ||
        (!inlineChange && $from.pos < parse.doc.content.size &&
            (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) &&
            nextSel.head == $to.pos)) &&
        view.someProp("handleKeyDown", f => f(view, keyEvent(13, "Enter")))) {
        view.input.lastIOSEnter = 0;
        return;
    }
    // Same for backspace
    if (view.state.selection.anchor > change.start &&
        looksLikeJoin(doc, change.start, change.endA, $from, $to) &&
        view.someProp("handleKeyDown", f => f(view, keyEvent(8, "Backspace")))) {
        if (android && chrome$1)
            view.domObserver.suppressSelectionUpdates(); // #820
        return;
    }
    // Chrome Android will occasionally, during composition, delete the
    // entire composition and then immediately insert it again. This is
    // used to detect that situation.
    if (chrome$1 && android && change.endB == change.start)
        view.input.lastAndroidDelete = Date.now();
    // This tries to detect Android virtual keyboard
    // enter-and-pick-suggestion action. That sometimes (see issue
    // #1059) first fires a DOM mutation, before moving the selection to
    // the newly created block. And then, because ProseMirror cleans up
    // the DOM selection, it gives up moving the selection entirely,
    // leaving the cursor in the wrong place. When that happens, we drop
    // the new paragraph from the initial change, and fire a simulated
    // enter key afterwards.
    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth &&
        parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
        change.endB -= 2;
        $to = parse.doc.resolveNoCache(change.endB - parse.from);
        setTimeout(() => {
            view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); });
        }, 20);
    }
    let chFrom = change.start, chTo = change.endA;
    let tr, storedMarks, markChange;
    if (inlineChange) {
        if ($from.pos == $to.pos) { // Deletion
            // IE11 sometimes weirdly moves the DOM selection around after
            // backspacing out the first element in a textblock
            if (ie$1 && ie_version <= 11 && $from.parentOffset == 0) {
                view.domObserver.suppressSelectionUpdates();
                setTimeout(() => selectionToDOM(view), 20);
            }
            tr = view.state.tr.delete(chFrom, chTo);
            storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));
        }
        else if ( // Adding or removing a mark
        change.endA == change.endB &&
            (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {
            tr = view.state.tr;
            if (markChange.type == "add")
                tr.addMark(chFrom, chTo, markChange.mark);
            else
                tr.removeMark(chFrom, chTo, markChange.mark);
        }
        else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
            // Both positions in the same text node -- simply insert text
            let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
            if (view.someProp("handleTextInput", f => f(view, chFrom, chTo, text)))
                return;
            tr = view.state.tr.insertText(text, chFrom, chTo);
        }
    }
    if (!tr)
        tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
    if (parse.sel) {
        let sel = resolveSelection(view, tr.doc, parse.sel);
        // Chrome Android will sometimes, during composition, report the
        // selection in the wrong place. If it looks like that is
        // happening, don't update the selection.
        // Edge just doesn't move the cursor forward when you start typing
        // in an empty block or between br nodes.
        if (sel && !(chrome$1 && android && view.composing && sel.empty &&
            (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) &&
            (sel.head == chFrom || sel.head == tr.mapping.map(chTo) - 1) ||
            ie$1 && sel.empty && sel.head == chFrom))
            tr.setSelection(sel);
    }
    if (storedMarks)
        tr.ensureMarks(storedMarks);
    view.dispatch(tr.scrollIntoView());
}
function resolveSelection(view, doc, parsedSel) {
    if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size)
        return null;
    return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head));
}
// Given two same-length, non-empty fragments of inline content,
// determine whether the first could be created from the second by
// removing or adding a single mark type.
function isMarkChange(cur, prev) {
    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
    let added = curMarks, removed = prevMarks, type, mark, update;
    for (let i = 0; i < prevMarks.length; i++)
        added = prevMarks[i].removeFromSet(added);
    for (let i = 0; i < curMarks.length; i++)
        removed = curMarks[i].removeFromSet(removed);
    if (added.length == 1 && removed.length == 0) {
        mark = added[0];
        type = "add";
        update = (node) => node.mark(mark.addToSet(node.marks));
    }
    else if (added.length == 0 && removed.length == 1) {
        mark = removed[0];
        type = "remove";
        update = (node) => node.mark(mark.removeFromSet(node.marks));
    }
    else {
        return null;
    }
    let updated = [];
    for (let i = 0; i < prev.childCount; i++)
        updated.push(update(prev.child(i)));
    if (Fragment.from(updated).eq(cur))
        return { mark, type };
}
function looksLikeJoin(old, start, end, $newStart, $newEnd) {
    if (!$newStart.parent.isTextblock ||
        // The content must have shrunk
        end - start <= $newEnd.pos - $newStart.pos ||
        // newEnd must point directly at or after the end of the block that newStart points into
        skipClosingAndOpening($newStart, true, false) < $newEnd.pos)
        return false;
    let $start = old.resolve(start);
    // Start must be at the end of a block
    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
        return false;
    let $next = old.resolve(skipClosingAndOpening($start, true, true));
    // The next textblock must start before end and end near it
    if (!$next.parent.isTextblock || $next.pos > end ||
        skipClosingAndOpening($next, true, false) < end)
        return false;
    // The fragments after the join point must match
    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
    let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
    while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
        depth--;
        end++;
        fromEnd = false;
    }
    if (mayOpen) {
        let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
        while (next && !next.isLeaf) {
            next = next.firstChild;
            end++;
        }
    }
    return end;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
    let start = a.findDiffStart(b, pos);
    if (start == null)
        return null;
    let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
    if (preferredSide == "end") {
        let adjust = Math.max(0, start - Math.min(endA, endB));
        preferredPos -= endA + adjust - start;
    }
    if (endA < start && a.size < b.size) {
        let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
        start -= move;
        endB = start + (endB - endA);
        endA = start;
    }
    else if (endB < start) {
        let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
        start -= move;
        endA = start + (endA - endB);
        endB = start;
    }
    return { start, endA, endB };
}
/**
An editor view manages the DOM structure that represents an
editable document. Its state and behavior are determined by its
[props](https://prosemirror.net/docs/ref/#view.DirectEditorProps).
*/
class EditorView {
    /**
    Create a view. `place` may be a DOM node that the editor should
    be appended to, a function that will place it into the document,
    or an object whose `mount` property holds the node to use as the
    document container. If it is `null`, the editor will not be
    added to the document.
    */
    constructor(place, props) {
        this._root = null;
        /**
        @internal
        */
        this.focused = false;
        /**
        Kludge used to work around a Chrome bug @internal
        */
        this.trackWrites = null;
        this.mounted = false;
        /**
        @internal
        */
        this.markCursor = null;
        /**
        @internal
        */
        this.cursorWrapper = null;
        /**
        @internal
        */
        this.lastSelectedViewDesc = undefined;
        /**
        @internal
        */
        this.input = new InputState;
        this.prevDirectPlugins = [];
        this.pluginViews = [];
        /**
        When editor content is being dragged, this object contains
        information about the dragged slice and whether it is being
        copied or moved. At any other time, it is null.
        */
        this.dragging = null;
        this._props = props;
        this.state = props.state;
        this.directPlugins = props.plugins || [];
        this.directPlugins.forEach(checkStateComponent);
        this.dispatch = this.dispatch.bind(this);
        this.dom = (place && place.mount) || document.createElement("div");
        if (place) {
            if (place.appendChild)
                place.appendChild(this.dom);
            else if (typeof place == "function")
                place(this.dom);
            else if (place.mount)
                this.mounted = true;
        }
        this.editable = getEditable(this);
        updateCursorWrapper(this);
        this.nodeViews = buildNodeViews(this);
        this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
        this.domObserver = new DOMObserver(this, (from, to, typeOver, added) => readDOMChange(this, from, to, typeOver, added));
        this.domObserver.start();
        initInput(this);
        this.updatePluginViews();
    }
    /**
    Holds `true` when a
    [composition](https://w3c.github.io/uievents/#events-compositionevents)
    is active.
    */
    get composing() { return this.input.composing; }
    /**
    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
    */
    get props() {
        if (this._props.state != this.state) {
            let prev = this._props;
            this._props = {};
            for (let name in prev)
                this._props[name] = prev[name];
            this._props.state = this.state;
        }
        return this._props;
    }
    /**
    Update the view's props. Will immediately cause an update to
    the DOM.
    */
    update(props) {
        if (props.handleDOMEvents != this._props.handleDOMEvents)
            ensureListeners(this);
        this._props = props;
        if (props.plugins) {
            props.plugins.forEach(checkStateComponent);
            this.directPlugins = props.plugins;
        }
        this.updateStateInner(props.state, true);
    }
    /**
    Update the view by updating existing props object with the object
    given as argument. Equivalent to `view.update(Object.assign({},
    view.props, props))`.
    */
    setProps(props) {
        let updated = {};
        for (let name in this._props)
            updated[name] = this._props[name];
        updated.state = this.state;
        for (let name in props)
            updated[name] = props[name];
        this.update(updated);
    }
    /**
    Update the editor's `state` prop, without touching any of the
    other props.
    */
    updateState(state) {
        this.updateStateInner(state, this.state.plugins != state.plugins);
    }
    updateStateInner(state, reconfigured) {
        let prev = this.state, redraw = false, updateSel = false;
        // When stored marks are added, stop composition, so that they can
        // be displayed.
        if (state.storedMarks && this.composing) {
            clearComposition(this);
            updateSel = true;
        }
        this.state = state;
        if (reconfigured) {
            let nodeViews = buildNodeViews(this);
            if (changedNodeViews(nodeViews, this.nodeViews)) {
                this.nodeViews = nodeViews;
                redraw = true;
            }
            ensureListeners(this);
        }
        this.editable = getEditable(this);
        updateCursorWrapper(this);
        let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
        let scroll = reconfigured ? "reset"
            : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
        let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
        if (updateDoc || !state.selection.eq(prev.selection))
            updateSel = true;
        let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
        if (updateSel) {
            this.domObserver.stop();
            // Work around an issue in Chrome, IE, and Edge where changing
            // the DOM around an active selection puts it into a broken
            // state where the thing the user sees differs from the
            // selection reported by the Selection object (#710, #973,
            // #1011, #1013, #1035).
            let forceSelUpdate = updateDoc && (ie$1 || chrome$1) && !this.composing &&
                !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
            if (updateDoc) {
                // If the node that the selection points into is written to,
                // Chrome sometimes starts misreporting the selection, so this
                // tracks that and forces a selection reset when our update
                // did write to the node.
                let chromeKludge = chrome$1 ? (this.trackWrites = this.domSelection().focusNode) : null;
                if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
                    this.docView.updateOuterDeco([]);
                    this.docView.destroy();
                    this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
                }
                if (chromeKludge && !this.trackWrites)
                    forceSelUpdate = true;
            }
            // Work around for an issue where an update arriving right between
            // a DOM selection change and the "selectionchange" event for it
            // can cause a spurious DOM selection update, disrupting mouse
            // drag selection.
            if (forceSelUpdate ||
                !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelection()) && anchorInRightPlace(this))) {
                selectionToDOM(this, forceSelUpdate);
            }
            else {
                syncNodeSelection(this, state.selection);
                this.domObserver.setCurSelection();
            }
            this.domObserver.start();
        }
        this.updatePluginViews(prev);
        if (scroll == "reset") {
            this.dom.scrollTop = 0;
        }
        else if (scroll == "to selection") {
            let startDOM = this.domSelection().focusNode;
            if (this.someProp("handleScrollToSelection", f => f(this))) ;
            else if (state.selection instanceof NodeSelection) {
                let target = this.docView.domAfterPos(state.selection.from);
                if (target.nodeType == 1)
                    scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
            }
            else {
                scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM);
            }
        }
        else if (oldScrollPos) {
            resetScrollPos(oldScrollPos);
        }
    }
    destroyPluginViews() {
        let view;
        while (view = this.pluginViews.pop())
            if (view.destroy)
                view.destroy();
    }
    updatePluginViews(prevState) {
        if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
            this.prevDirectPlugins = this.directPlugins;
            this.destroyPluginViews();
            for (let i = 0; i < this.directPlugins.length; i++) {
                let plugin = this.directPlugins[i];
                if (plugin.spec.view)
                    this.pluginViews.push(plugin.spec.view(this));
            }
            for (let i = 0; i < this.state.plugins.length; i++) {
                let plugin = this.state.plugins[i];
                if (plugin.spec.view)
                    this.pluginViews.push(plugin.spec.view(this));
            }
        }
        else {
            for (let i = 0; i < this.pluginViews.length; i++) {
                let pluginView = this.pluginViews[i];
                if (pluginView.update)
                    pluginView.update(this, prevState);
            }
        }
    }
    someProp(propName, f) {
        let prop = this._props && this._props[propName], value;
        if (prop != null && (value = f ? f(prop) : prop))
            return value;
        for (let i = 0; i < this.directPlugins.length; i++) {
            let prop = this.directPlugins[i].props[propName];
            if (prop != null && (value = f ? f(prop) : prop))
                return value;
        }
        let plugins = this.state.plugins;
        if (plugins)
            for (let i = 0; i < plugins.length; i++) {
                let prop = plugins[i].props[propName];
                if (prop != null && (value = f ? f(prop) : prop))
                    return value;
            }
    }
    /**
    Query whether the view has focus.
    */
    hasFocus() {
        return this.root.activeElement == this.dom;
    }
    /**
    Focus the editor.
    */
    focus() {
        this.domObserver.stop();
        if (this.editable)
            focusPreventScroll(this.dom);
        selectionToDOM(this);
        this.domObserver.start();
    }
    /**
    Get the document root in which the editor exists. This will
    usually be the top-level `document`, but might be a [shadow
    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
    root if the editor is inside one.
    */
    get root() {
        let cached = this._root;
        if (cached == null)
            for (let search = this.dom.parentNode; search; search = search.parentNode) {
                if (search.nodeType == 9 || (search.nodeType == 11 && search.host)) {
                    if (!search.getSelection)
                        Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
                    return this._root = search;
                }
            }
        return cached || document;
    }
    /**
    Given a pair of viewport coordinates, return the document
    position that corresponds to them. May return null if the given
    coordinates aren't inside of the editor. When an object is
    returned, its `pos` property is the position nearest to the
    coordinates, and its `inside` property holds the position of the
    inner node that the position falls inside of, or -1 if it is at
    the top level, not in any node.
    */
    posAtCoords(coords) {
        return posAtCoords(this, coords);
    }
    /**
    Returns the viewport rectangle at a given document position.
    `left` and `right` will be the same number, as this returns a
    flat cursor-ish rectangle. If the position is between two things
    that aren't directly adjacent, `side` determines which element
    is used. When < 0, the element before the position is used,
    otherwise the element after.
    */
    coordsAtPos(pos, side = 1) {
        return coordsAtPos(this, pos, side);
    }
    /**
    Find the DOM position that corresponds to the given document
    position. When `side` is negative, find the position as close as
    possible to the content before the position. When positive,
    prefer positions close to the content after the position. When
    zero, prefer as shallow a position as possible.
    
    Note that you should **not** mutate the editor's internal DOM,
    only inspect it (and even that is usually not necessary).
    */
    domAtPos(pos, side = 0) {
        return this.docView.domFromPos(pos, side);
    }
    /**
    Find the DOM node that represents the document node after the
    given position. May return `null` when the position doesn't point
    in front of a node or if the node is inside an opaque node view.
    
    This is intended to be able to call things like
    `getBoundingClientRect` on that DOM node. Do **not** mutate the
    editor DOM directly, or add styling this way, since that will be
    immediately overriden by the editor as it redraws the node.
    */
    nodeDOM(pos) {
        let desc = this.docView.descAt(pos);
        return desc ? desc.nodeDOM : null;
    }
    /**
    Find the document position that corresponds to a given DOM
    position. (Whenever possible, it is preferable to inspect the
    document structure directly, rather than poking around in the
    DOM, but sometimes—for example when interpreting an event
    target—you don't have a choice.)
    
    The `bias` parameter can be used to influence which side of a DOM
    node to use when the position is inside a leaf node.
    */
    posAtDOM(node, offset, bias = -1) {
        let pos = this.docView.posFromDOM(node, offset, bias);
        if (pos == null)
            throw new RangeError("DOM position not inside the editor");
        return pos;
    }
    /**
    Find out whether the selection is at the end of a textblock when
    moving in a given direction. When, for example, given `"left"`,
    it will return true if moving left from the current cursor
    position would leave that position's parent textblock. Will apply
    to the view's current state by default, but it is possible to
    pass a different state.
    */
    endOfTextblock(dir, state) {
        return endOfTextblock(this, state || this.state, dir);
    }
    /**
    Removes the editor from the DOM and destroys all [node
    views](https://prosemirror.net/docs/ref/#view.NodeView).
    */
    destroy() {
        if (!this.docView)
            return;
        destroyInput(this);
        this.destroyPluginViews();
        if (this.mounted) {
            this.docView.update(this.state.doc, [], viewDecorations(this), this);
            this.dom.textContent = "";
        }
        else if (this.dom.parentNode) {
            this.dom.parentNode.removeChild(this.dom);
        }
        this.docView.destroy();
        this.docView = null;
    }
    /**
    This is true when the view has been
    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
    used anymore).
    */
    get isDestroyed() {
        return this.docView == null;
    }
    /**
    Used for testing.
    */
    dispatchEvent(event) {
        return dispatchEvent(this, event);
    }
    /**
    Dispatch a transaction. Will call
    [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
    when given, and otherwise defaults to applying the transaction to
    the current state and calling
    [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
    This method is bound to the view instance, so that it can be
    easily passed around.
    */
    dispatch(tr) {
        let dispatchTransaction = this._props.dispatchTransaction;
        if (dispatchTransaction)
            dispatchTransaction.call(this, tr);
        else
            this.updateState(this.state.apply(tr));
    }
    /**
    @internal
    */
    domSelection() {
        return this.root.getSelection();
    }
}
function computeDocDeco(view) {
    let attrs = Object.create(null);
    attrs.class = "ProseMirror";
    attrs.contenteditable = String(view.editable);
    attrs.translate = "no";
    view.someProp("attributes", value => {
        if (typeof value == "function")
            value = value(view.state);
        if (value)
            for (let attr in value) {
                if (attr == "class")
                    attrs.class += " " + value[attr];
                if (attr == "style") {
                    attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
                }
                else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
                    attrs[attr] = String(value[attr]);
            }
    });
    return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
    if (view.markCursor) {
        let dom = document.createElement("img");
        dom.className = "ProseMirror-separator";
        dom.setAttribute("mark-placeholder", "true");
        dom.setAttribute("alt", "");
        view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
    }
    else {
        view.cursorWrapper = null;
    }
}
function getEditable(view) {
    return !view.someProp("editable", value => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
    let result = Object.create(null);
    function add(obj) {
        for (let prop in obj)
            if (!Object.prototype.hasOwnProperty.call(result, prop))
                result[prop] = obj[prop];
    }
    view.someProp("nodeViews", add);
    view.someProp("markViews", add);
    return result;
}
function changedNodeViews(a, b) {
    let nA = 0, nB = 0;
    for (let prop in a) {
        if (a[prop] != b[prop])
            return true;
        nA++;
    }
    for (let _ in b)
        nB++;
    return nA != nB;
}
function checkStateComponent(plugin) {
    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
        throw new RangeError("Plugins passed directly to the view must not have a state component");
}

var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
};

var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\"",
  229: "Q"
};

var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = chrome && (mac$1 || +chrome[1] < 57) || gecko && mac$1;

// Fill in the digit keys
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);

// The function keys
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;

// And the alphabetic keys
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}

// For each code that doesn't have a shift-equivalent, copy the base name
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];

function keyName(event) {
  // Don't trust event.key in Chrome when there are modifiers until
  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||
    (safari || ie) && event.shiftKey && event.key && event.key.length == 1;
  var name = (!ignoreKey && event.key) ||
    (event.shiftKey ? shift : base)[event.keyCode] ||
    event.key || "Unidentified";
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name
}

const mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName$1(name) {
    let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
    if (result == "Space")
        result = " ";
    let alt, ctrl, shift, meta;
    for (let i = 0; i < parts.length - 1; i++) {
        let mod = parts[i];
        if (/^(cmd|meta|m)$/i.test(mod))
            meta = true;
        else if (/^a(lt)?$/i.test(mod))
            alt = true;
        else if (/^(c|ctrl|control)$/i.test(mod))
            ctrl = true;
        else if (/^s(hift)?$/i.test(mod))
            shift = true;
        else if (/^mod$/i.test(mod)) {
            if (mac)
                meta = true;
            else
                ctrl = true;
        }
        else
            throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
        result = "Alt-" + result;
    if (ctrl)
        result = "Ctrl-" + result;
    if (meta)
        result = "Meta-" + result;
    if (shift)
        result = "Shift-" + result;
    return result;
}
function normalize(map) {
    let copy = Object.create(null);
    for (let prop in map)
        copy[normalizeKeyName$1(prop)] = map[prop];
    return copy;
}
function modifiers(name, event, shift) {
    if (event.altKey)
        name = "Alt-" + name;
    if (event.ctrlKey)
        name = "Ctrl-" + name;
    if (event.metaKey)
        name = "Meta-" + name;
    if (shift !== false && event.shiftKey)
        name = "Shift-" + name;
    return name;
}
/**
Create a keymap plugin for the given set of bindings.

Bindings should map key names to [command](https://prosemirror.net/docs/ref/#commands)-style
functions, which will be called with `(EditorState, dispatch,
EditorView)` arguments, and should return true when they've handled
the key. Note that the view argument isn't part of the command
protocol, but can be used as an escape hatch if a binding needs to
directly interact with the UI.

Key names may be strings like `"Shift-Ctrl-Enter"`—a key
identifier prefixed with zero or more modifiers. Key identifiers
are based on the strings that can appear in
[`KeyEvent.key`](https:developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).
Use lowercase letters to refer to letter keys (or uppercase letters
if you want shift to be held). You may use `"Space"` as an alias
for the `" "` name.

Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or
`a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or
`Meta-`) are recognized. For characters that are created by holding
shift, the `Shift-` prefix is implied, and should not be added
explicitly.

You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on
other platforms.

You can add multiple keymap plugins to an editor. The order in
which they appear determines their precedence (the ones early in
the array get to dispatch first).
*/
function keymap(bindings) {
    return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
/**
Given a set of bindings (using the same format as
[`keymap`](https://prosemirror.net/docs/ref/#keymap.keymap)), return a [keydown
handler](https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown) that handles them.
*/
function keydownHandler(bindings) {
    let map = normalize(bindings);
    return function (view, event) {
        let name = keyName(event), isChar = name.length == 1 && name != " ", baseName;
        let direct = map[modifiers(name, event, !isChar)];
        if (direct && direct(view.state, view.dispatch, view))
            return true;
        if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&
            (baseName = base[event.keyCode]) && baseName != name) {
            // Try falling back to the keyCode when there's a modifier
            // active or the character produced isn't ASCII, and our table
            // produces a different name from the the keyCode. See #668,
            // #1060
            let fromCode = map[modifiers(baseName, event, true)];
            if (fromCode && fromCode(view.state, view.dispatch, view))
                return true;
        }
        else if (isChar && event.shiftKey) {
            // Otherwise, if shift is active, also try the binding with the
            // Shift- prefix enabled. See #997
            let withShift = map[modifiers(name, event, true)];
            if (withShift && withShift(view.state, view.dispatch, view))
                return true;
        }
        return false;
    };
}

// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts
function getType(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
    if (getType(value) !== 'Object') {
        return false;
    }
    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}

function mergeDeep(target, source) {
    const output = { ...target };
    if (isPlainObject(target) && isPlainObject(source)) {
        Object.keys(source).forEach(key => {
            if (isPlainObject(source[key])) {
                if (!(key in target)) {
                    Object.assign(output, { [key]: source[key] });
                }
                else {
                    output[key] = mergeDeep(target[key], source[key]);
                }
            }
            else {
                Object.assign(output, { [key]: source[key] });
            }
        });
    }
    return output;
}

function isFunction(value) {
    return typeof value === 'function';
}

/**
 * Optionally calls `value` as a function.
 * Otherwise it is returned directly.
 * @param value Function or any value.
 * @param context Optional context to bind to function.
 * @param props Optional props to pass to function.
 */
function callOrReturn(value, context = undefined, ...props) {
    if (isFunction(value)) {
        if (context) {
            return value.bind(context)(...props);
        }
        return value(...props);
    }
    return value;
}

function getExtensionField(extension, field, context) {
    if (extension.config[field] === undefined && extension.parent) {
        return getExtensionField(extension.parent, field, context);
    }
    if (typeof extension.config[field] === 'function') {
        const value = extension.config[field].bind({
            ...context,
            parent: extension.parent
                ? getExtensionField(extension.parent, field, context)
                : null,
        });
        return value;
    }
    return extension.config[field];
}

class Extension {
    constructor(config = {}) {
        this.type = 'extension';
        this.name = 'extension';
        this.parent = null;
        this.child = null;
        this.config = {
            name: this.name,
            defaultOptions: {},
        };
        this.config = {
            ...this.config,
            ...config,
        };
        this.name = this.config.name;
        if (config.defaultOptions) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
        }
        // TODO: remove `addOptions` fallback
        this.options = this.config.defaultOptions;
        if (this.config.addOptions) {
            this.options = callOrReturn(getExtensionField(this, 'addOptions', {
                name: this.name,
            }));
        }
        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {
            name: this.name,
            options: this.options,
        })) || {};
    }
    static create(config = {}) {
        return new Extension(config);
    }
    configure(options = {}) {
        // return a new instance so we can use the same extension
        // with different calls of `configure`
        const extension = this.extend();
        extension.options = mergeDeep(this.options, options);
        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {
            name: extension.name,
            options: extension.options,
        }));
        return extension;
    }
    extend(extendedConfig = {}) {
        const extension = new Extension(extendedConfig);
        extension.parent = this;
        this.child = extension;
        extension.name = extendedConfig.name
            ? extendedConfig.name
            : extension.parent.name;
        if (extendedConfig.defaultOptions) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
        }
        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {
            name: extension.name,
        }));
        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {
            name: extension.name,
            options: extension.options,
        }));
        return extension;
    }
}

function getTextBetween(startNode, range, options) {
    const { from, to } = range;
    const { blockSeparator = '\n\n', textSerializers = {}, } = options || {};
    let text = '';
    let separated = true;
    startNode.nodesBetween(from, to, (node, pos, parent, index) => {
        var _a;
        const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
        if (textSerializer) {
            if (node.isBlock && !separated) {
                text += blockSeparator;
                separated = true;
            }
            text += textSerializer({
                node,
                pos,
                parent,
                index,
                range,
            });
        }
        else if (node.isText) {
            text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos);
            separated = false;
        }
        else if (node.isBlock && !separated) {
            text += blockSeparator;
            separated = true;
        }
    });
    return text;
}

function getTextSerializersFromSchema(schema) {
    return Object.fromEntries(Object
        .entries(schema.nodes)
        .filter(([, node]) => node.spec.toText)
        .map(([name, node]) => [name, node.spec.toText]));
}

const ClipboardTextSerializer = Extension.create({
    name: 'clipboardTextSerializer',
    addProseMirrorPlugins() {
        return [
            new Plugin({
                key: new PluginKey('clipboardTextSerializer'),
                props: {
                    clipboardTextSerializer: () => {
                        const { editor } = this;
                        const { state, schema } = editor;
                        const { doc, selection } = state;
                        const { ranges } = selection;
                        const from = Math.min(...ranges.map(range => range.$from.pos));
                        const to = Math.max(...ranges.map(range => range.$to.pos));
                        const textSerializers = getTextSerializersFromSchema(schema);
                        const range = { from, to };
                        return getTextBetween(doc, range, {
                            textSerializers,
                        });
                    },
                },
            }),
        ];
    },
});

const blur = () => ({ editor, view }) => {
    requestAnimationFrame(() => {
        var _a;
        if (!editor.isDestroyed) {
            view.dom.blur();
            // Browsers should remove the caret on blur but safari does not.
            // See: https://github.com/ueberdosis/tiptap/issues/2405
            (_a = window$1 === null || window$1 === void 0 ? void 0 : window$1.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
        }
    });
    return true;
};

var blur$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  blur: blur
});

const clearContent = (emitUpdate = false) => ({ commands }) => {
    return commands.setContent('', emitUpdate);
};

var clearContent$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  clearContent: clearContent
});

const clearNodes = () => ({ state, tr, dispatch }) => {
    const { selection } = tr;
    const { ranges } = selection;
    if (!dispatch) {
        return true;
    }
    ranges.forEach(({ $from, $to }) => {
        state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
            if (node.type.isText) {
                return;
            }
            const { doc, mapping } = tr;
            const $mappedFrom = doc.resolve(mapping.map(pos));
            const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));
            const nodeRange = $mappedFrom.blockRange($mappedTo);
            if (!nodeRange) {
                return;
            }
            const targetLiftDepth = liftTarget(nodeRange);
            if (node.type.isTextblock) {
                const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
                tr.setNodeMarkup(nodeRange.start, defaultType);
            }
            if (targetLiftDepth || targetLiftDepth === 0) {
                tr.lift(nodeRange, targetLiftDepth);
            }
        });
    });
    return true;
};

var clearNodes$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  clearNodes: clearNodes
});

const command = fn => props => {
    return fn(props);
};

var command$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  command: command
});

const createParagraphNear = () => ({ state, dispatch }) => {
    return createParagraphNear$2(state, dispatch);
};

var createParagraphNear$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createParagraphNear: createParagraphNear
});

function getNodeType(nameOrType, schema) {
    if (typeof nameOrType === 'string') {
        if (!schema.nodes[nameOrType]) {
            throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
        }
        return schema.nodes[nameOrType];
    }
    return nameOrType;
}

const deleteNode = typeOrName => ({ tr, state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    const $pos = tr.selection.$anchor;
    for (let depth = $pos.depth; depth > 0; depth -= 1) {
        const node = $pos.node(depth);
        if (node.type === type) {
            if (dispatch) {
                const from = $pos.before(depth);
                const to = $pos.after(depth);
                tr.delete(from, to).scrollIntoView();
            }
            return true;
        }
    }
    return false;
};

var deleteNode$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  deleteNode: deleteNode
});

const deleteRange = range => ({ tr, dispatch }) => {
    const { from, to } = range;
    if (dispatch) {
        tr.delete(from, to);
    }
    return true;
};

var deleteRange$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  deleteRange: deleteRange
});

const deleteSelection = () => ({ state, dispatch }) => {
    return deleteSelection$2(state, dispatch);
};

var deleteSelection$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  deleteSelection: deleteSelection
});

const enter = () => ({ commands }) => {
    return commands.keyboardShortcut('Enter');
};

var enter$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  enter: enter
});

const exitCode = () => ({ state, dispatch }) => {
    return exitCode$2(state, dispatch);
};

var exitCode$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  exitCode: exitCode
});

function getMarkType(nameOrType, schema) {
    if (typeof nameOrType === 'string') {
        if (!schema.marks[nameOrType]) {
            throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
        }
        return schema.marks[nameOrType];
    }
    return nameOrType;
}

function isRegExp(value) {
    return Object.prototype.toString.call(value) === '[object RegExp]';
}

/**
 * Check if object1 includes object2
 * @param object1 Object
 * @param object2 Object
 */
function objectIncludes(object1, object2, options = { strict: true }) {
    const keys = Object.keys(object2);
    if (!keys.length) {
        return true;
    }
    return keys.every(key => {
        if (options.strict) {
            return object2[key] === object1[key];
        }
        if (isRegExp(object2[key])) {
            return object2[key].test(object1[key]);
        }
        return object2[key] === object1[key];
    });
}

function findMarkInSet(marks, type, attributes = {}) {
    return marks.find(item => {
        return item.type === type && objectIncludes(item.attrs, attributes);
    });
}
function isMarkInSet(marks, type, attributes = {}) {
    return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes = {}) {
    if (!$pos || !type) {
        return;
    }
    let start = $pos.parent.childAfter($pos.parentOffset);
    if ($pos.parentOffset === start.offset && start.offset !== 0) {
        start = $pos.parent.childBefore($pos.parentOffset);
    }
    if (!start.node) {
        return;
    }
    const mark = findMarkInSet(start.node.marks, type, attributes);
    if (!mark) {
        return;
    }
    let startIndex = start.index;
    let startPos = $pos.start() + start.offset;
    let endIndex = startIndex + 1;
    let endPos = startPos + start.node.nodeSize;
    findMarkInSet(start.node.marks, type, attributes);
    while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
        startIndex -= 1;
        startPos -= $pos.parent.child(startIndex).nodeSize;
    }
    while (endIndex < $pos.parent.childCount
        && isMarkInSet($pos.parent.child(endIndex).marks, type, attributes)) {
        endPos += $pos.parent.child(endIndex).nodeSize;
        endIndex += 1;
    }
    return {
        from: startPos,
        to: endPos,
    };
}

const extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
    const type = getMarkType(typeOrName, state.schema);
    const { doc, selection } = tr;
    const { $from, from, to } = selection;
    if (dispatch) {
        const range = getMarkRange($from, type, attributes);
        if (range && range.from <= from && range.to >= to) {
            const newSelection = TextSelection.create(doc, range.from, range.to);
            tr.setSelection(newSelection);
        }
    }
    return true;
};

var extendMarkRange$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  extendMarkRange: extendMarkRange
});

const first = commands => props => {
    const items = typeof commands === 'function'
        ? commands(props)
        : commands;
    for (let i = 0; i < items.length; i += 1) {
        if (items[i](props)) {
            return true;
        }
    }
    return false;
};

var first$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  first: first
});

function isClass(value) {
    var _a;
    if (((_a = value.constructor) === null || _a === void 0 ? void 0 : _a.toString().substring(0, 5)) !== 'class') {
        return false;
    }
    return true;
}

function isObject(value) {
    return (value
        && typeof value === 'object'
        && !Array.isArray(value)
        && !isClass(value));
}

function isTextSelection(value) {
    return isObject(value) && value instanceof TextSelection;
}

function isiOS() {
    return [
        'iPad Simulator',
        'iPhone Simulator',
        'iPod Simulator',
        'iPad',
        'iPhone',
        'iPod',
    ].includes(navigator.platform)
        // iPad on iOS 13 detection
        || (navigator.userAgent.includes('Mac') && 'ontouchend' in document);
}

function minMax(value = 0, min = 0, max = 0) {
    return Math.min(Math.max(value, min), max);
}

function resolveFocusPosition(doc, position = null) {
    if (!position) {
        return null;
    }
    const selectionAtStart = Selection.atStart(doc);
    const selectionAtEnd = Selection.atEnd(doc);
    if (position === 'start' || position === true) {
        return selectionAtStart;
    }
    if (position === 'end') {
        return selectionAtEnd;
    }
    const minPos = selectionAtStart.from;
    const maxPos = selectionAtEnd.to;
    if (position === 'all') {
        return TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));
    }
    return TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
}

const focus = (position = null, options) => ({ editor, view, tr, dispatch, }) => {
    options = {
        scrollIntoView: true,
        ...options,
    };
    const delayedFocus = () => {
        // focus within `requestAnimationFrame` breaks focus on iOS
        // so we have to call this
        if (isiOS()) {
            view.dom.focus();
        }
        // For React we have to focus asynchronously. Otherwise wild things happen.
        // see: https://github.com/ueberdosis/tiptap/issues/1520
        requestAnimationFrame(() => {
            if (!editor.isDestroyed) {
                view.focus();
                if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
                    editor.commands.scrollIntoView();
                }
            }
        });
    };
    if ((view.hasFocus() && position === null) || position === false) {
        return true;
    }
    // we don’t try to resolve a NodeSelection or CellSelection
    if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
        delayedFocus();
        return true;
    }
    const selection = resolveFocusPosition(editor.state.doc, position) || editor.state.selection;
    const isSameSelection = editor.state.selection.eq(selection);
    if (dispatch) {
        if (!isSameSelection) {
            tr.setSelection(selection);
        }
        // `tr.setSelection` resets the stored marks
        // so we’ll restore them if the selection is the same as before
        if (isSameSelection && tr.storedMarks) {
            tr.setStoredMarks(tr.storedMarks);
        }
        delayedFocus();
    }
    return true;
};

var focus$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  focus: focus
});

const forEach = (items, fn) => props => {
    return items.every((item, index) => fn(item, { ...props, index }));
};

var forEach$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  forEach: forEach
});

const insertContent = (value, options) => ({ tr, commands }) => {
    return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);
};

var insertContent$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  insertContent: insertContent
});

function elementFromString(value) {
    // add a wrapper to preserve leading and trailing whitespace
    const wrappedValue = `<body>${value}</body>`;
    return new window$1.DOMParser().parseFromString(wrappedValue, 'text/html').body;
}

function createNodeFromContent(content, schema, options) {
    options = {
        slice: true,
        parseOptions: {},
        ...options,
    };
    if (typeof content === 'object' && content !== null) {
        try {
            if (Array.isArray(content)) {
                return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)));
            }
            return schema.nodeFromJSON(content);
        }
        catch (error) {
            console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error);
            return createNodeFromContent('', schema, options);
        }
    }
    if (typeof content === 'string') {
        const parser = DOMParser.fromSchema(schema);
        return options.slice
            ? parser.parseSlice(elementFromString(content), options.parseOptions).content
            : parser.parse(elementFromString(content), options.parseOptions);
    }
    return createNodeFromContent('', schema, options);
}

// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466
function selectionToInsertionEnd(tr, startLen, bias) {
    const last = tr.steps.length - 1;
    if (last < startLen) {
        return;
    }
    const step = tr.steps[last];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
        return;
    }
    const map = tr.mapping.maps[last];
    let end = 0;
    map.forEach((_from, _to, _newFrom, newTo) => {
        if (end === 0) {
            end = newTo;
        }
    });
    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}

const isFragment = (nodeOrFragment) => {
    return nodeOrFragment.toString().startsWith('<');
};
const insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {
    if (dispatch) {
        options = {
            parseOptions: {},
            updateSelection: true,
            ...options,
        };
        const content = createNodeFromContent(value, editor.schema, {
            parseOptions: {
                preserveWhitespace: 'full',
                ...options.parseOptions,
            },
        });
        // don’t dispatch an empty fragment because this can lead to strange errors
        if (content.toString() === '<>') {
            return true;
        }
        let { from, to } = typeof position === 'number'
            ? { from: position, to: position }
            : position;
        let isOnlyTextContent = true;
        let isOnlyBlockContent = true;
        const nodes = isFragment(content)
            ? content
            : [content];
        nodes.forEach(node => {
            // check if added node is valid
            node.check();
            isOnlyTextContent = isOnlyTextContent
                ? node.isText && node.marks.length === 0
                : false;
            isOnlyBlockContent = isOnlyBlockContent
                ? node.isBlock
                : false;
        });
        // check if we can replace the wrapping node by
        // the newly inserted content
        // example:
        // replace an empty paragraph by an inserted image
        // instead of inserting the image below the paragraph
        if (from === to && isOnlyBlockContent) {
            const { parent } = tr.doc.resolve(from);
            const isEmptyTextBlock = parent.isTextblock
                && !parent.type.spec.code
                && !parent.childCount;
            if (isEmptyTextBlock) {
                from -= 1;
                to += 1;
            }
        }
        // if there is only plain text we have to use `insertText`
        // because this will keep the current marks
        if (isOnlyTextContent) {
            tr.insertText(value, from, to);
        }
        else {
            tr.replaceWith(from, to, content);
        }
        // set cursor at end of inserted content
        if (options.updateSelection) {
            selectionToInsertionEnd(tr, tr.steps.length - 1, -1);
        }
    }
    return true;
};

var insertContentAt$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  insertContentAt: insertContentAt
});

const joinBackward = () => ({ state, dispatch }) => {
    return joinBackward$2(state, dispatch);
};

var joinBackward$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  joinBackward: joinBackward
});

const joinForward = () => ({ state, dispatch }) => {
    return joinForward$2(state, dispatch);
};

var joinForward$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  joinForward: joinForward
});

function isMacOS() {
    return typeof navigator !== 'undefined'
        ? /Mac/.test(navigator.platform)
        : false;
}

function normalizeKeyName(name) {
    const parts = name.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result === 'Space') {
        result = ' ';
    }
    let alt;
    let ctrl;
    let shift;
    let meta;
    for (let i = 0; i < parts.length - 1; i += 1) {
        const mod = parts[i];
        if (/^(cmd|meta|m)$/i.test(mod)) {
            meta = true;
        }
        else if (/^a(lt)?$/i.test(mod)) {
            alt = true;
        }
        else if (/^(c|ctrl|control)$/i.test(mod)) {
            ctrl = true;
        }
        else if (/^s(hift)?$/i.test(mod)) {
            shift = true;
        }
        else if (/^mod$/i.test(mod)) {
            if (isiOS() || isMacOS()) {
                meta = true;
            }
            else {
                ctrl = true;
            }
        }
        else {
            throw new Error(`Unrecognized modifier name: ${mod}`);
        }
    }
    if (alt) {
        result = `Alt-${result}`;
    }
    if (ctrl) {
        result = `Ctrl-${result}`;
    }
    if (meta) {
        result = `Meta-${result}`;
    }
    if (shift) {
        result = `Shift-${result}`;
    }
    return result;
}
const keyboardShortcut = name => ({ editor, view, tr, dispatch, }) => {
    const keys = normalizeKeyName(name).split(/-(?!$)/);
    const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item));
    const event = new KeyboardEvent('keydown', {
        key: key === 'Space'
            ? ' '
            : key,
        altKey: keys.includes('Alt'),
        ctrlKey: keys.includes('Ctrl'),
        metaKey: keys.includes('Meta'),
        shiftKey: keys.includes('Shift'),
        bubbles: true,
        cancelable: true,
    });
    const capturedTransaction = editor.captureTransaction(() => {
        view.someProp('handleKeyDown', f => f(view, event));
    });
    capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(step => {
        const newStep = step.map(tr.mapping);
        if (newStep && dispatch) {
            tr.maybeStep(newStep);
        }
    });
    return true;
};

var keyboardShortcut$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  keyboardShortcut: keyboardShortcut
});

function isNodeActive(state, typeOrName, attributes = {}) {
    const { from, to, empty } = state.selection;
    const type = typeOrName
        ? getNodeType(typeOrName, state.schema)
        : null;
    const nodeRanges = [];
    state.doc.nodesBetween(from, to, (node, pos) => {
        if (node.isText) {
            return;
        }
        const relativeFrom = Math.max(from, pos);
        const relativeTo = Math.min(to, pos + node.nodeSize);
        nodeRanges.push({
            node,
            from: relativeFrom,
            to: relativeTo,
        });
    });
    const selectionRange = to - from;
    const matchedNodeRanges = nodeRanges
        .filter(nodeRange => {
        if (!type) {
            return true;
        }
        return type.name === nodeRange.node.type.name;
    })
        .filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
    if (empty) {
        return !!matchedNodeRanges.length;
    }
    const range = matchedNodeRanges
        .reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
    return range >= selectionRange;
}

const lift = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    const isActive = isNodeActive(state, type, attributes);
    if (!isActive) {
        return false;
    }
    return lift$2(state, dispatch);
};

var lift$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  lift: lift
});

const liftEmptyBlock = () => ({ state, dispatch }) => {
    return liftEmptyBlock$2(state, dispatch);
};

var liftEmptyBlock$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  liftEmptyBlock: liftEmptyBlock
});

const liftListItem = typeOrName => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return liftListItem$2(type)(state, dispatch);
};

var liftListItem$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  liftListItem: liftListItem
});

const newlineInCode = () => ({ state, dispatch }) => {
    return newlineInCode$2(state, dispatch);
};

var newlineInCode$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  newlineInCode: newlineInCode
});

function getSchemaTypeNameByName(name, schema) {
    if (schema.nodes[name]) {
        return 'node';
    }
    if (schema.marks[name]) {
        return 'mark';
    }
    return null;
}

/**
 * Remove a property or an array of properties from an object
 * @param obj Object
 * @param key Key to remove
 */
function deleteProps(obj, propOrProps) {
    const props = typeof propOrProps === 'string'
        ? [propOrProps]
        : propOrProps;
    return Object
        .keys(obj)
        .reduce((newObj, prop) => {
        if (!props.includes(prop)) {
            newObj[prop] = obj[prop];
        }
        return newObj;
    }, {});
}

const resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {
    let nodeType = null;
    let markType = null;
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string'
        ? typeOrName
        : typeOrName.name, state.schema);
    if (!schemaType) {
        return false;
    }
    if (schemaType === 'node') {
        nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === 'mark') {
        markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch) {
        tr.selection.ranges.forEach(range => {
            state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
                if (nodeType && nodeType === node.type) {
                    tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));
                }
                if (markType && node.marks.length) {
                    node.marks.forEach(mark => {
                        if (markType === mark.type) {
                            tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
                        }
                    });
                }
            });
        });
    }
    return true;
};

var resetAttributes$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  resetAttributes: resetAttributes
});

const scrollIntoView = () => ({ tr, dispatch }) => {
    if (dispatch) {
        tr.scrollIntoView();
    }
    return true;
};

var scrollIntoView$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  scrollIntoView: scrollIntoView
});

const selectAll = () => ({ tr, commands }) => {
    return commands.setTextSelection({
        from: 0,
        to: tr.doc.content.size,
    });
};

var selectAll$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  selectAll: selectAll
});

const selectNodeBackward = () => ({ state, dispatch }) => {
    return selectNodeBackward$2(state, dispatch);
};

var selectNodeBackward$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  selectNodeBackward: selectNodeBackward
});

const selectNodeForward = () => ({ state, dispatch }) => {
    return selectNodeForward$2(state, dispatch);
};

var selectNodeForward$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  selectNodeForward: selectNodeForward
});

const selectParentNode = () => ({ state, dispatch }) => {
    return selectParentNode$2(state, dispatch);
};

var selectParentNode$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  selectParentNode: selectParentNode
});

// @ts-ignore
const selectTextblockEnd = () => ({ state, dispatch }) => {
    return selectTextblockEnd$2(state, dispatch);
};

var selectTextblockEnd$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  selectTextblockEnd: selectTextblockEnd
});

// @ts-ignore
const selectTextblockStart = () => ({ state, dispatch }) => {
    return selectTextblockStart$2(state, dispatch);
};

var selectTextblockStart$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  selectTextblockStart: selectTextblockStart
});

function createDocument(content, schema, parseOptions = {}) {
    return createNodeFromContent(content, schema, { slice: false, parseOptions });
}

const setContent = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {
    const { doc } = tr;
    const document = createDocument(content, editor.schema, parseOptions);
    const selection = TextSelection.create(doc, 0, doc.content.size);
    if (dispatch) {
        tr.setSelection(selection)
            .replaceSelectionWith(document, false)
            .setMeta('preventUpdate', !emitUpdate);
    }
    return true;
};

var setContent$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  setContent: setContent
});

function getMarkAttributes(state, typeOrName) {
    const type = getMarkType(typeOrName, state.schema);
    const { from, to, empty } = state.selection;
    const marks = [];
    if (empty) {
        if (state.storedMarks) {
            marks.push(...state.storedMarks);
        }
        marks.push(...state.selection.$head.marks());
    }
    else {
        state.doc.nodesBetween(from, to, node => {
            marks.push(...node.marks);
        });
    }
    const mark = marks.find(markItem => markItem.type.name === type.name);
    if (!mark) {
        return {};
    }
    return { ...mark.attrs };
}

const setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
    const { selection } = tr;
    const { empty, ranges } = selection;
    const type = getMarkType(typeOrName, state.schema);
    if (dispatch) {
        if (empty) {
            const oldAttributes = getMarkAttributes(state, type);
            tr.addStoredMark(type.create({
                ...oldAttributes,
                ...attributes,
            }));
        }
        else {
            ranges.forEach(range => {
                const from = range.$from.pos;
                const to = range.$to.pos;
                state.doc.nodesBetween(from, to, (node, pos) => {
                    const trimmedFrom = Math.max(pos, from);
                    const trimmedTo = Math.min(pos + node.nodeSize, to);
                    const someHasMark = node.marks.find(mark => mark.type === type);
                    // if there is already a mark of this type
                    // we know that we have to merge its attributes
                    // otherwise we add a fresh new mark
                    if (someHasMark) {
                        node.marks.forEach(mark => {
                            if (type === mark.type) {
                                tr.addMark(trimmedFrom, trimmedTo, type.create({
                                    ...mark.attrs,
                                    ...attributes,
                                }));
                            }
                        });
                    }
                    else {
                        tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
                    }
                });
            });
        }
    }
    return true;
};

var setMark$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  setMark: setMark
});

const setMeta = (key, value) => ({ tr }) => {
    tr.setMeta(key, value);
    return true;
};

var setMeta$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  setMeta: setMeta
});

const setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
    const type = getNodeType(typeOrName, state.schema);
    // TODO: use a fallback like insertContent?
    if (!type.isTextblock) {
        console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
        return false;
    }
    return chain()
        // try to convert node to default node if needed
        .command(({ commands }) => {
        const canSetBlock = setBlockType(type, attributes)(state);
        if (canSetBlock) {
            return true;
        }
        return commands.clearNodes();
    })
        .command(({ state: updatedState }) => {
        return setBlockType(type, attributes)(updatedState, dispatch);
    })
        .run();
};

var setNode$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  setNode: setNode
});

const setNodeSelection = position => ({ tr, dispatch }) => {
    if (dispatch) {
        const { doc } = tr;
        const minPos = Selection.atStart(doc).from;
        const maxPos = Selection.atEnd(doc).to;
        const resolvedPos = minMax(position, minPos, maxPos);
        const selection = NodeSelection.create(doc, resolvedPos);
        tr.setSelection(selection);
    }
    return true;
};

var setNodeSelection$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  setNodeSelection: setNodeSelection
});

const setTextSelection = position => ({ tr, dispatch }) => {
    if (dispatch) {
        const { doc } = tr;
        const { from, to } = typeof position === 'number'
            ? { from: position, to: position }
            : position;
        const minPos = TextSelection.atStart(doc).from;
        const maxPos = TextSelection.atEnd(doc).to;
        const resolvedFrom = minMax(from, minPos, maxPos);
        const resolvedEnd = minMax(to, minPos, maxPos);
        const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd);
        tr.setSelection(selection);
    }
    return true;
};

var setTextSelection$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  setTextSelection: setTextSelection
});

const sinkListItem = typeOrName => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return sinkListItem$2(type)(state, dispatch);
};

var sinkListItem$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sinkListItem: sinkListItem
});

function getSplittedAttributes(extensionAttributes, typeName, attributes) {
    return Object.fromEntries(Object
        .entries(attributes)
        .filter(([name]) => {
        const extensionAttribute = extensionAttributes.find(item => {
            return item.type === typeName && item.name === name;
        });
        if (!extensionAttribute) {
            return false;
        }
        return extensionAttribute.attribute.keepOnSplit;
    }));
}

function defaultBlockAt$1(match) {
    for (let i = 0; i < match.edgeCount; i += 1) {
        const { type } = match.edge(i);
        if (type.isTextblock && !type.hasRequiredAttrs()) {
            return type;
        }
    }
    return null;
}
function ensureMarks(state, splittableMarks) {
    const marks = state.storedMarks
        || (state.selection.$to.parentOffset && state.selection.$from.marks());
    if (marks) {
        const filteredMarks = marks.filter(mark => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
        state.tr.ensureMarks(filteredMarks);
    }
}
const splitBlock = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor, }) => {
    const { selection, doc } = tr;
    const { $from, $to } = selection;
    const extensionAttributes = editor.extensionManager.attributes;
    const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
    if (selection instanceof NodeSelection && selection.node.isBlock) {
        if (!$from.parentOffset || !canSplit(doc, $from.pos)) {
            return false;
        }
        if (dispatch) {
            if (keepMarks) {
                ensureMarks(state, editor.extensionManager.splittableMarks);
            }
            tr.split($from.pos).scrollIntoView();
        }
        return true;
    }
    if (!$from.parent.isBlock) {
        return false;
    }
    if (dispatch) {
        const atEnd = $to.parentOffset === $to.parent.content.size;
        if (selection instanceof TextSelection) {
            tr.deleteSelection();
        }
        const deflt = $from.depth === 0
            ? undefined
            : defaultBlockAt$1($from.node(-1).contentMatchAt($from.indexAfter(-1)));
        let types = atEnd && deflt
            ? [{
                    type: deflt,
                    attrs: newAttributes,
                }]
            : undefined;
        let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
        if (!types
            && !can
            && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)) {
            can = true;
            types = deflt
                ? [{
                        type: deflt,
                        attrs: newAttributes,
                    }]
                : undefined;
        }
        if (can) {
            tr.split(tr.mapping.map($from.pos), 1, types);
            if (deflt
                && !atEnd
                && !$from.parentOffset
                && $from.parent.type !== deflt) {
                const first = tr.mapping.map($from.before());
                const $first = tr.doc.resolve(first);
                if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
                    tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
                }
            }
        }
        if (keepMarks) {
            ensureMarks(state, editor.extensionManager.splittableMarks);
        }
        tr.scrollIntoView();
    }
    return true;
};

var splitBlock$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  splitBlock: splitBlock
});

const splitListItem = typeOrName => ({ tr, state, dispatch, editor, }) => {
    var _a;
    const type = getNodeType(typeOrName, state.schema);
    const { $from, $to } = state.selection;
    // @ts-ignore
    // eslint-disable-next-line
    const node = state.selection.node;
    if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {
        return false;
    }
    const grandParent = $from.node(-1);
    if (grandParent.type !== type) {
        return false;
    }
    const extensionAttributes = editor.extensionManager.attributes;
    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
        // In an empty block. If this is a nested list, the wrapping
        // list item should be split. Otherwise, bail out and let next
        // command handle lifting.
        if ($from.depth === 2
            || $from.node(-3).type !== type
            || $from.index(-2) !== $from.node(-2).childCount - 1) {
            return false;
        }
        if (dispatch) {
            let wrap = Fragment.empty;
            // eslint-disable-next-line
            const depthBefore = $from.index(-1)
                ? 1
                : $from.index(-2)
                    ? 2
                    : 3;
            // Build a fragment containing empty versions of the structure
            // from the outer list item to the parent node of the cursor
            for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
                wrap = Fragment.from($from.node(d).copy(wrap));
            }
            // eslint-disable-next-line
            const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount
                ? 1
                : $from.indexAfter(-2) < $from.node(-3).childCount
                    ? 2
                    : 3;
            // Add a second list item with an empty default start node
            const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
            const nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes)) || undefined;
            wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined));
            const start = $from.before($from.depth - (depthBefore - 1));
            tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));
            let sel = -1;
            tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {
                if (sel > -1) {
                    return false;
                }
                if (n.isTextblock && n.content.size === 0) {
                    sel = pos + 1;
                }
            });
            if (sel > -1) {
                tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));
            }
            tr.scrollIntoView();
        }
        return true;
    }
    const nextType = $to.pos === $from.end()
        ? grandParent.contentMatchAt(0).defaultType
        : null;
    const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
    const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
    tr.delete($from.pos, $to.pos);
    const types = nextType
        ? [{ type, attrs: newTypeAttributes }, { type: nextType, attrs: newNextTypeAttributes }]
        : [{ type, attrs: newTypeAttributes }];
    if (!canSplit(tr.doc, $from.pos, 2)) {
        return false;
    }
    if (dispatch) {
        tr.split($from.pos, 2, types).scrollIntoView();
    }
    return true;
};

var splitListItem$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  splitListItem: splitListItem
});

function findParentNodeClosestToPos($pos, predicate) {
    for (let i = $pos.depth; i > 0; i -= 1) {
        const node = $pos.node(i);
        if (predicate(node)) {
            return {
                pos: i > 0 ? $pos.before(i) : 0,
                start: $pos.start(i),
                depth: i,
                node,
            };
        }
    }
}

function findParentNode(predicate) {
    return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}

function splitExtensions(extensions) {
    const baseExtensions = extensions.filter(extension => extension.type === 'extension');
    const nodeExtensions = extensions.filter(extension => extension.type === 'node');
    const markExtensions = extensions.filter(extension => extension.type === 'mark');
    return {
        baseExtensions,
        nodeExtensions,
        markExtensions,
    };
}

function isList(name, extensions) {
    const { nodeExtensions } = splitExtensions(extensions);
    const extension = nodeExtensions.find(item => item.name === name);
    if (!extension) {
        return false;
    }
    const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
    };
    const group = callOrReturn(getExtensionField(extension, 'group', context));
    if (typeof group !== 'string') {
        return false;
    }
    return group.split(' ').includes('list');
}

const joinListBackwards = (tr, listType) => {
    const list = findParentNode(node => node.type === listType)(tr.selection);
    if (!list) {
        return true;
    }
    const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
    if (before === undefined) {
        return true;
    }
    const nodeBefore = tr.doc.nodeAt(before);
    const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type)
        && canJoin(tr.doc, list.pos);
    if (!canJoinBackwards) {
        return true;
    }
    tr.join(list.pos);
    return true;
};
const joinListForwards = (tr, listType) => {
    const list = findParentNode(node => node.type === listType)(tr.selection);
    if (!list) {
        return true;
    }
    const after = tr.doc.resolve(list.start).after(list.depth);
    if (after === undefined) {
        return true;
    }
    const nodeAfter = tr.doc.nodeAt(after);
    const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type)
        && canJoin(tr.doc, after);
    if (!canJoinForwards) {
        return true;
    }
    tr.join(after);
    return true;
};
const toggleList = (listTypeOrName, itemTypeOrName) => ({ editor, tr, state, dispatch, chain, commands, can, }) => {
    const { extensions } = editor.extensionManager;
    const listType = getNodeType(listTypeOrName, state.schema);
    const itemType = getNodeType(itemTypeOrName, state.schema);
    const { selection } = state;
    const { $from, $to } = selection;
    const range = $from.blockRange($to);
    if (!range) {
        return false;
    }
    const parentList = findParentNode(node => isList(node.type.name, extensions))(selection);
    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
        // remove list
        if (parentList.node.type === listType) {
            return commands.liftListItem(itemType);
        }
        // change list type
        if (isList(parentList.node.type.name, extensions)
            && listType.validContent(parentList.node.content)
            && dispatch) {
            return chain()
                .command(() => {
                tr.setNodeMarkup(parentList.pos, listType);
                return true;
            })
                .command(() => joinListBackwards(tr, listType))
                .command(() => joinListForwards(tr, listType))
                .run();
        }
    }
    return chain()
        // try to convert node to default node if needed
        .command(() => {
        const canWrapInList = can().wrapInList(listType);
        if (canWrapInList) {
            return true;
        }
        return commands.clearNodes();
    })
        .wrapInList(listType)
        .command(() => joinListBackwards(tr, listType))
        .command(() => joinListForwards(tr, listType))
        .run();
};

var toggleList$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  toggleList: toggleList
});

function isMarkActive(state, typeOrName, attributes = {}) {
    const { empty, ranges } = state.selection;
    const type = typeOrName
        ? getMarkType(typeOrName, state.schema)
        : null;
    if (empty) {
        return !!(state.storedMarks || state.selection.$from.marks())
            .filter(mark => {
            if (!type) {
                return true;
            }
            return type.name === mark.type.name;
        })
            .find(mark => objectIncludes(mark.attrs, attributes, { strict: false }));
    }
    let selectionRange = 0;
    const markRanges = [];
    ranges.forEach(({ $from, $to }) => {
        const from = $from.pos;
        const to = $to.pos;
        state.doc.nodesBetween(from, to, (node, pos) => {
            if (!node.isText && !node.marks.length) {
                return;
            }
            const relativeFrom = Math.max(from, pos);
            const relativeTo = Math.min(to, pos + node.nodeSize);
            const range = relativeTo - relativeFrom;
            selectionRange += range;
            markRanges.push(...node.marks.map(mark => ({
                mark,
                from: relativeFrom,
                to: relativeTo,
            })));
        });
    });
    if (selectionRange === 0) {
        return false;
    }
    // calculate range of matched mark
    const matchedRange = markRanges
        .filter(markRange => {
        if (!type) {
            return true;
        }
        return type.name === markRange.mark.type.name;
    })
        .filter(markRange => objectIncludes(markRange.mark.attrs, attributes, { strict: false }))
        .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    // calculate range of marks that excludes the searched mark
    // for example `code` doesn’t allow any other marks
    const excludedRange = markRanges
        .filter(markRange => {
        if (!type) {
            return true;
        }
        return markRange.mark.type !== type
            && markRange.mark.type.excludes(type);
    })
        .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    // we only include the result of `excludedRange`
    // if there is a match at all
    const range = matchedRange > 0
        ? matchedRange + excludedRange
        : matchedRange;
    return range >= selectionRange;
}

const toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {
    const { extendEmptyMarkRange = false } = options;
    const type = getMarkType(typeOrName, state.schema);
    const isActive = isMarkActive(state, type, attributes);
    if (isActive) {
        return commands.unsetMark(type, { extendEmptyMarkRange });
    }
    return commands.setMark(type, attributes);
};

var toggleMark$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  toggleMark: toggleMark
});

const toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {
    const type = getNodeType(typeOrName, state.schema);
    const toggleType = getNodeType(toggleTypeOrName, state.schema);
    const isActive = isNodeActive(state, type, attributes);
    if (isActive) {
        return commands.setNode(toggleType);
    }
    return commands.setNode(type, attributes);
};

var toggleNode$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  toggleNode: toggleNode
});

const toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {
    const type = getNodeType(typeOrName, state.schema);
    const isActive = isNodeActive(state, type, attributes);
    if (isActive) {
        return commands.lift(type);
    }
    return commands.wrapIn(type, attributes);
};

var toggleWrap$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  toggleWrap: toggleWrap
});

const undoInputRule = () => ({ state, dispatch }) => {
    const plugins = state.plugins;
    for (let i = 0; i < plugins.length; i += 1) {
        const plugin = plugins[i];
        let undoable;
        // @ts-ignore
        // eslint-disable-next-line
        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
            if (dispatch) {
                const tr = state.tr;
                const toUndo = undoable.transform;
                for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
                    tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
                }
                if (undoable.text) {
                    const marks = tr.doc.resolve(undoable.from).marks();
                    tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
                }
                else {
                    tr.delete(undoable.from, undoable.to);
                }
            }
            return true;
        }
    }
    return false;
};

var undoInputRule$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  undoInputRule: undoInputRule
});

const unsetAllMarks = () => ({ tr, dispatch }) => {
    const { selection } = tr;
    const { empty, ranges } = selection;
    if (empty) {
        return true;
    }
    if (dispatch) {
        ranges.forEach(range => {
            tr.removeMark(range.$from.pos, range.$to.pos);
        });
    }
    return true;
};

var unsetAllMarks$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unsetAllMarks: unsetAllMarks
});

const unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {
    var _a;
    const { extendEmptyMarkRange = false } = options;
    const { selection } = tr;
    const type = getMarkType(typeOrName, state.schema);
    const { $from, empty, ranges } = selection;
    if (!dispatch) {
        return true;
    }
    if (empty && extendEmptyMarkRange) {
        let { from, to } = selection;
        const attrs = (_a = $from.marks().find(mark => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
        const range = getMarkRange($from, type, attrs);
        if (range) {
            from = range.from;
            to = range.to;
        }
        tr.removeMark(from, to, type);
    }
    else {
        ranges.forEach(range => {
            tr.removeMark(range.$from.pos, range.$to.pos, type);
        });
    }
    tr.removeStoredMark(type);
    return true;
};

var unsetMark$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  unsetMark: unsetMark
});

const updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
    let nodeType = null;
    let markType = null;
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string'
        ? typeOrName
        : typeOrName.name, state.schema);
    if (!schemaType) {
        return false;
    }
    if (schemaType === 'node') {
        nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === 'mark') {
        markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch) {
        tr.selection.ranges.forEach(range => {
            const from = range.$from.pos;
            const to = range.$to.pos;
            state.doc.nodesBetween(from, to, (node, pos) => {
                if (nodeType && nodeType === node.type) {
                    tr.setNodeMarkup(pos, undefined, {
                        ...node.attrs,
                        ...attributes,
                    });
                }
                if (markType && node.marks.length) {
                    node.marks.forEach(mark => {
                        if (markType === mark.type) {
                            const trimmedFrom = Math.max(pos, from);
                            const trimmedTo = Math.min(pos + node.nodeSize, to);
                            tr.addMark(trimmedFrom, trimmedTo, markType.create({
                                ...mark.attrs,
                                ...attributes,
                            }));
                        }
                    });
                }
            });
        });
    }
    return true;
};

var updateAttributes$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  updateAttributes: updateAttributes
});

const wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return wrapIn$2(type, attributes)(state, dispatch);
};

var wrapIn$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  wrapIn: wrapIn
});

const wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return wrapInList$2(type, attributes)(state, dispatch);
};

var wrapInList$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  wrapInList: wrapInList
});

const Commands = Extension.create({
    name: 'commands',
    addCommands() {
        return {
            ...blur$1,
            ...clearContent$1,
            ...clearNodes$1,
            ...command$1,
            ...createParagraphNear$1,
            ...deleteNode$1,
            ...deleteRange$1,
            ...deleteSelection$1,
            ...enter$1,
            ...exitCode$1,
            ...extendMarkRange$1,
            ...first$1,
            ...focus$1,
            ...forEach$1,
            ...insertContent$1,
            ...insertContentAt$1,
            ...joinBackward$1,
            ...joinForward$1,
            ...keyboardShortcut$1,
            ...lift$1,
            ...liftEmptyBlock$1,
            ...liftListItem$1,
            ...newlineInCode$1,
            ...resetAttributes$1,
            ...scrollIntoView$1,
            ...selectAll$1,
            ...selectNodeBackward$1,
            ...selectNodeForward$1,
            ...selectParentNode$1,
            ...selectTextblockEnd$1,
            ...selectTextblockStart$1,
            ...setContent$1,
            ...setMark$1,
            ...setMeta$1,
            ...setNode$1,
            ...setNodeSelection$1,
            ...setTextSelection$1,
            ...sinkListItem$1,
            ...splitBlock$1,
            ...splitListItem$1,
            ...toggleList$1,
            ...toggleMark$1,
            ...toggleNode$1,
            ...toggleWrap$1,
            ...undoInputRule$1,
            ...unsetAllMarks$1,
            ...unsetMark$1,
            ...updateAttributes$1,
            ...wrapIn$1,
            ...wrapInList$1,
        };
    },
});

const Editable = Extension.create({
    name: 'editable',
    addProseMirrorPlugins() {
        return [
            new Plugin({
                key: new PluginKey('editable'),
                props: {
                    editable: () => this.editor.options.editable,
                },
            }),
        ];
    },
});

const FocusEvents = Extension.create({
    name: 'focusEvents',
    addProseMirrorPlugins() {
        const { editor } = this;
        return [
            new Plugin({
                key: new PluginKey('focusEvents'),
                props: {
                    handleDOMEvents: {
                        focus: (view, event) => {
                            editor.isFocused = true;
                            const transaction = editor.state.tr
                                .setMeta('focus', { event })
                                .setMeta('addToHistory', false);
                            view.dispatch(transaction);
                            return false;
                        },
                        blur: (view, event) => {
                            editor.isFocused = false;
                            const transaction = editor.state.tr
                                .setMeta('blur', { event })
                                .setMeta('addToHistory', false);
                            view.dispatch(transaction);
                            return false;
                        },
                    },
                },
            }),
        ];
    },
});

function createChainableState(config) {
    const { state, transaction } = config;
    let { selection } = transaction;
    let { doc } = transaction;
    let { storedMarks } = transaction;
    return {
        ...state,
        schema: state.schema,
        plugins: state.plugins,
        apply: state.apply.bind(state),
        applyTransaction: state.applyTransaction.bind(state),
        reconfigure: state.reconfigure.bind(state),
        toJSON: state.toJSON.bind(state),
        get storedMarks() {
            return storedMarks;
        },
        get selection() {
            return selection;
        },
        get doc() {
            return doc;
        },
        get tr() {
            selection = transaction.selection;
            doc = transaction.doc;
            storedMarks = transaction.storedMarks;
            return transaction;
        },
    };
}

class CommandManager {
    constructor(props) {
        this.editor = props.editor;
        this.rawCommands = this.editor.extensionManager.commands;
        this.customState = props.state;
    }
    get hasCustomState() {
        return !!this.customState;
    }
    get state() {
        return this.customState || this.editor.state;
    }
    get commands() {
        const { rawCommands, editor, state } = this;
        const { view } = editor;
        const { tr } = state;
        const props = this.buildProps(tr);
        return Object.fromEntries(Object
            .entries(rawCommands)
            .map(([name, command]) => {
            const method = (...args) => {
                const callback = command(...args)(props);
                if (!tr.getMeta('preventDispatch') && !this.hasCustomState) {
                    view.dispatch(tr);
                }
                return callback;
            };
            return [name, method];
        }));
    }
    get chain() {
        return () => this.createChain();
    }
    get can() {
        return () => this.createCan();
    }
    createChain(startTr, shouldDispatch = true) {
        const { rawCommands, editor, state } = this;
        const { view } = editor;
        const callbacks = [];
        const hasStartTransaction = !!startTr;
        const tr = startTr || state.tr;
        const run = () => {
            if (!hasStartTransaction
                && shouldDispatch
                && !tr.getMeta('preventDispatch')
                && !this.hasCustomState) {
                view.dispatch(tr);
            }
            return callbacks.every(callback => callback === true);
        };
        const chain = {
            ...Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {
                const chainedCommand = (...args) => {
                    const props = this.buildProps(tr, shouldDispatch);
                    const callback = command(...args)(props);
                    callbacks.push(callback);
                    return chain;
                };
                return [name, chainedCommand];
            })),
            run,
        };
        return chain;
    }
    createCan(startTr) {
        const { rawCommands, state } = this;
        const dispatch = undefined;
        const tr = startTr || state.tr;
        const props = this.buildProps(tr, dispatch);
        const formattedCommands = Object.fromEntries(Object
            .entries(rawCommands)
            .map(([name, command]) => {
            return [name, (...args) => command(...args)({ ...props, dispatch })];
        }));
        return {
            ...formattedCommands,
            chain: () => this.createChain(tr, dispatch),
        };
    }
    buildProps(tr, shouldDispatch = true) {
        const { rawCommands, editor, state } = this;
        const { view } = editor;
        if (state.storedMarks) {
            tr.setStoredMarks(state.storedMarks);
        }
        const props = {
            tr,
            editor,
            view,
            state: createChainableState({
                state,
                transaction: tr,
            }),
            dispatch: shouldDispatch
                ? () => undefined
                : undefined,
            chain: () => this.createChain(tr),
            can: () => this.createCan(tr),
            get commands() {
                return Object.fromEntries(Object
                    .entries(rawCommands)
                    .map(([name, command]) => {
                    return [name, (...args) => command(...args)(props)];
                }));
            },
        };
        return props;
    }
}

const Keymap = Extension.create({
    name: 'keymap',
    addKeyboardShortcuts() {
        const handleBackspace = () => this.editor.commands.first(({ commands }) => [
            () => commands.undoInputRule(),
            // maybe convert first text block node to default node
            () => commands.command(({ tr }) => {
                const { selection, doc } = tr;
                const { empty, $anchor } = selection;
                const { pos, parent } = $anchor;
                const isAtStart = Selection.atStart(doc).from === pos;
                if (!empty
                    || !isAtStart
                    || !parent.type.isTextblock
                    || parent.textContent.length) {
                    return false;
                }
                return commands.clearNodes();
            }),
            () => commands.deleteSelection(),
            () => commands.joinBackward(),
            () => commands.selectNodeBackward(),
        ]);
        const handleDelete = () => this.editor.commands.first(({ commands }) => [
            () => commands.deleteSelection(),
            () => commands.joinForward(),
            () => commands.selectNodeForward(),
        ]);
        const handleEnter = () => this.editor.commands.first(({ commands }) => [
            () => commands.newlineInCode(),
            () => commands.createParagraphNear(),
            () => commands.liftEmptyBlock(),
            () => commands.splitBlock(),
        ]);
        const baseKeymap = {
            Enter: handleEnter,
            'Mod-Enter': () => this.editor.commands.exitCode(),
            Backspace: handleBackspace,
            'Mod-Backspace': handleBackspace,
            'Shift-Backspace': handleBackspace,
            Delete: handleDelete,
            'Mod-Delete': handleDelete,
            'Mod-a': () => this.editor.commands.selectAll(),
        };
        const pcKeymap = {
            ...baseKeymap,
        };
        const macKeymap = {
            ...baseKeymap,
            'Ctrl-h': handleBackspace,
            'Alt-Backspace': handleBackspace,
            'Ctrl-d': handleDelete,
            'Ctrl-Alt-Backspace': handleDelete,
            'Alt-Delete': handleDelete,
            'Alt-d': handleDelete,
            'Ctrl-a': () => this.editor.commands.selectTextblockStart(),
            'Ctrl-e': () => this.editor.commands.selectTextblockEnd(),
        };
        if (isiOS() || isMacOS()) {
            return macKeymap;
        }
        return pcKeymap;
    },
    addProseMirrorPlugins() {
        return [
            // With this plugin we check if the whole document was selected and deleted.
            // In this case we will additionally call `clearNodes()` to convert e.g. a heading
            // to a paragraph if necessary.
            // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
            // with many other commands.
            new Plugin({
                key: new PluginKey('clearDocument'),
                appendTransaction: (transactions, oldState, newState) => {
                    const docChanges = transactions.some(transaction => transaction.docChanged)
                        && !oldState.doc.eq(newState.doc);
                    if (!docChanges) {
                        return;
                    }
                    const { empty, from, to } = oldState.selection;
                    const allFrom = Selection.atStart(oldState.doc).from;
                    const allEnd = Selection.atEnd(oldState.doc).to;
                    const allWasSelected = from === allFrom && to === allEnd;
                    const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, ' ', ' ').length === 0;
                    if (empty || !allWasSelected || !isEmpty) {
                        return;
                    }
                    const tr = newState.tr;
                    const state = createChainableState({
                        state: newState,
                        transaction: tr,
                    });
                    const { commands } = new CommandManager({
                        editor: this.editor,
                        state,
                    });
                    commands.clearNodes();
                    if (!tr.steps.length) {
                        return;
                    }
                    return tr;
                },
            }),
        ];
    },
});

const Tabindex = Extension.create({
    name: 'tabindex',
    addProseMirrorPlugins() {
        return [
            new Plugin({
                key: new PluginKey('tabindex'),
                props: {
                    attributes: () => {
                        if (this.editor.isEditable) {
                            return {
                                tabindex: '0',
                            };
                        }
                    },
                },
            }),
        ];
    },
});

var extensions = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ClipboardTextSerializer: ClipboardTextSerializer,
  Commands: Commands,
  Editable: Editable,
  FocusEvents: FocusEvents,
  Keymap: Keymap,
  Tabindex: Tabindex
});

function getNodeAttributes(state, typeOrName) {
    const type = getNodeType(typeOrName, state.schema);
    const { from, to } = state.selection;
    const nodes = [];
    state.doc.nodesBetween(from, to, node => {
        nodes.push(node);
    });
    const node = nodes
        .reverse()
        .find(nodeItem => nodeItem.type.name === type.name);
    if (!node) {
        return {};
    }
    return { ...node.attrs };
}

function getAttributes(state, typeOrName) {
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string'
        ? typeOrName
        : typeOrName.name, state.schema);
    if (schemaType === 'node') {
        return getNodeAttributes(state, typeOrName);
    }
    if (schemaType === 'mark') {
        return getMarkAttributes(state, typeOrName);
    }
    return {};
}

function isActive(state, name, attributes = {}) {
    if (!name) {
        return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
    }
    const schemaType = getSchemaTypeNameByName(name, state.schema);
    if (schemaType === 'node') {
        return isNodeActive(state, name, attributes);
    }
    if (schemaType === 'mark') {
        return isMarkActive(state, name, attributes);
    }
    return false;
}

function getHTMLFromFragment(fragment, schema) {
    const documentFragment = DOMSerializer
        .fromSchema(schema)
        .serializeFragment(fragment);
    const temporaryDocument = document.implementation.createHTMLDocument();
    const container = temporaryDocument.createElement('div');
    container.appendChild(documentFragment);
    return container.innerHTML;
}

function getText(node, options) {
    const range = {
        from: 0,
        to: node.content.size,
    };
    return getTextBetween(node, range, options);
}

function isNodeEmpty(node) {
    var _a;
    const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();
    const content = node.toJSON();
    return JSON.stringify(defaultContent) === JSON.stringify(content);
}

function createStyleTag(style, nonce) {
    const tipTapStyleTag = document.querySelector('style[data-tiptap-style]');
    if (tipTapStyleTag !== null) {
        return tipTapStyleTag;
    }
    const styleNode = document.createElement('style');
    if (nonce) {
        styleNode.setAttribute('nonce', nonce);
    }
    styleNode.setAttribute('data-tiptap-style', '');
    styleNode.innerHTML = style;
    document.getElementsByTagName('head')[0].appendChild(styleNode);
    return styleNode;
}

class InputRule {
    constructor(config) {
        this.find = config.find;
        this.handler = config.handler;
    }
}
const inputRuleMatcherHandler = (text, find) => {
    if (isRegExp(find)) {
        return find.exec(text);
    }
    const inputRuleMatch = find(text);
    if (!inputRuleMatch) {
        return null;
    }
    const result = [];
    result.push(inputRuleMatch.text);
    result.index = inputRuleMatch.index;
    result.input = text;
    result.data = inputRuleMatch.data;
    if (inputRuleMatch.replaceWith) {
        if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
            console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
        }
        result.push(inputRuleMatch.replaceWith);
    }
    return result;
};
function run$1$1(config) {
    var _a;
    const { editor, from, to, text, rules, plugin, } = config;
    const { view } = editor;
    if (view.composing) {
        return false;
    }
    const $from = view.state.doc.resolve(from);
    if (
    // check for code node
    $from.parent.type.spec.code
        // check for code mark
        || !!((_a = ($from.nodeBefore || $from.nodeAfter)) === null || _a === void 0 ? void 0 : _a.marks.find(mark => mark.type.spec.code))) {
        return false;
    }
    let matched = false;
    const maxMatch = 500;
    const textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - maxMatch), $from.parentOffset, undefined, ' ') + text;
    rules.forEach(rule => {
        if (matched) {
            return;
        }
        const match = inputRuleMatcherHandler(textBefore, rule.find);
        if (!match) {
            return;
        }
        const tr = view.state.tr;
        const state = createChainableState({
            state: view.state,
            transaction: tr,
        });
        const range = {
            from: from - (match[0].length - text.length),
            to,
        };
        const { commands, chain, can } = new CommandManager({
            editor,
            state,
        });
        const handler = rule.handler({
            state,
            range,
            match,
            commands,
            chain,
            can,
        });
        // stop if there are no changes
        if (handler === null || !tr.steps.length) {
            return;
        }
        // store transform as meta data
        // so we can undo input rules within the `undoInputRules` command
        tr.setMeta(plugin, {
            transform: tr,
            from,
            to,
            text,
        });
        view.dispatch(tr);
        matched = true;
    });
    return matched;
}
/**
 * Create an input rules plugin. When enabled, it will cause text
 * input that matches any of the given rules to trigger the rule’s
 * action.
 */
function inputRulesPlugin(props) {
    const { editor, rules } = props;
    const plugin = new Plugin({
        state: {
            init() {
                return null;
            },
            apply(tr, prev) {
                const stored = tr.getMeta(this);
                if (stored) {
                    return stored;
                }
                return tr.selectionSet || tr.docChanged
                    ? null
                    : prev;
            },
        },
        props: {
            handleTextInput(view, from, to, text) {
                return run$1$1({
                    editor,
                    from,
                    to,
                    text,
                    rules,
                    plugin,
                });
            },
            handleDOMEvents: {
                compositionend: view => {
                    setTimeout(() => {
                        const { $cursor } = view.state.selection;
                        if ($cursor) {
                            run$1$1({
                                editor,
                                from: $cursor.pos,
                                to: $cursor.pos,
                                text: '',
                                rules,
                                plugin,
                            });
                        }
                    });
                    return false;
                },
            },
            // add support for input rules to trigger on enter
            // this is useful for example for code blocks
            handleKeyDown(view, event) {
                if (event.key !== 'Enter') {
                    return false;
                }
                const { $cursor } = view.state.selection;
                if ($cursor) {
                    return run$1$1({
                        editor,
                        from: $cursor.pos,
                        to: $cursor.pos,
                        text: '\n',
                        rules,
                        plugin,
                    });
                }
                return false;
            },
        },
        // @ts-ignore
        isInputRules: true,
    });
    return plugin;
}

function isNumber(value) {
    return typeof value === 'number';
}

class PasteRule {
    constructor(config) {
        this.find = config.find;
        this.handler = config.handler;
    }
}
const pasteRuleMatcherHandler = (text, find) => {
    if (isRegExp(find)) {
        return [...text.matchAll(find)];
    }
    const matches = find(text);
    if (!matches) {
        return [];
    }
    return matches.map(pasteRuleMatch => {
        const result = [];
        result.push(pasteRuleMatch.text);
        result.index = pasteRuleMatch.index;
        result.input = text;
        result.data = pasteRuleMatch.data;
        if (pasteRuleMatch.replaceWith) {
            if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
                console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
            }
            result.push(pasteRuleMatch.replaceWith);
        }
        return result;
    });
};
function run$2(config) {
    const { editor, state, from, to, rule, } = config;
    const { commands, chain, can } = new CommandManager({
        editor,
        state,
    });
    const handlers = [];
    state.doc.nodesBetween(from, to, (node, pos) => {
        if (!node.isTextblock || node.type.spec.code) {
            return;
        }
        const resolvedFrom = Math.max(from, pos);
        const resolvedTo = Math.min(to, pos + node.content.size);
        const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\ufffc');
        const matches = pasteRuleMatcherHandler(textToMatch, rule.find);
        matches.forEach(match => {
            if (match.index === undefined) {
                return;
            }
            const start = resolvedFrom + match.index + 1;
            const end = start + match[0].length;
            const range = {
                from: state.tr.mapping.map(start),
                to: state.tr.mapping.map(end),
            };
            const handler = rule.handler({
                state,
                range,
                match,
                commands,
                chain,
                can,
            });
            handlers.push(handler);
        });
    });
    const success = handlers.every(handler => handler !== null);
    return success;
}
/**
 * Create an paste rules plugin. When enabled, it will cause pasted
 * text that matches any of the given rules to trigger the rule’s
 * action.
 */
function pasteRulesPlugin(props) {
    const { editor, rules } = props;
    let dragSourceElement = null;
    let isPastedFromProseMirror = false;
    let isDroppedFromProseMirror = false;
    const plugins = rules.map(rule => {
        return new Plugin({
            // we register a global drag handler to track the current drag source element
            view(view) {
                const handleDragstart = (event) => {
                    var _a;
                    dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target))
                        ? view.dom.parentElement
                        : null;
                };
                window$1.addEventListener('dragstart', handleDragstart);
                return {
                    destroy() {
                        window$1.removeEventListener('dragstart', handleDragstart);
                    },
                };
            },
            props: {
                handleDOMEvents: {
                    drop: view => {
                        isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
                        return false;
                    },
                    paste: (view, event) => {
                        var _a;
                        const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/html');
                        isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes('data-pm-slice'));
                        return false;
                    },
                },
            },
            appendTransaction: (transactions, oldState, state) => {
                const transaction = transactions[0];
                const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror;
                const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror;
                if (!isPaste && !isDrop) {
                    return;
                }
                // stop if there is no changed range
                const from = oldState.doc.content.findDiffStart(state.doc.content);
                const to = oldState.doc.content.findDiffEnd(state.doc.content);
                if (!isNumber(from) || !to || from === to.b) {
                    return;
                }
                // build a chainable state
                // so we can use a single transaction for all paste rules
                const tr = state.tr;
                const chainableState = createChainableState({
                    state,
                    transaction: tr,
                });
                const handler = run$2({
                    editor,
                    state: chainableState,
                    from: Math.max(from - 1, 0),
                    to: to.b,
                    rule,
                });
                // stop if there are no changes
                if (!handler || !tr.steps.length) {
                    return;
                }
                return tr;
            },
        });
    });
    return plugins;
}

/**
 * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.
 * @param extensions List of extensions
 */
function getAttributesFromExtensions(extensions) {
    const extensionAttributes = [];
    const { nodeExtensions, markExtensions } = splitExtensions(extensions);
    const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
    const defaultAttribute = {
        default: null,
        rendered: true,
        renderHTML: null,
        parseHTML: null,
        keepOnSplit: true,
    };
    extensions.forEach(extension => {
        const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
        };
        const addGlobalAttributes = getExtensionField(extension, 'addGlobalAttributes', context);
        if (!addGlobalAttributes) {
            return;
        }
        // TODO: remove `as GlobalAttributes`
        const globalAttributes = addGlobalAttributes();
        globalAttributes.forEach(globalAttribute => {
            globalAttribute.types.forEach(type => {
                Object
                    .entries(globalAttribute.attributes)
                    .forEach(([name, attribute]) => {
                    extensionAttributes.push({
                        type,
                        name,
                        attribute: {
                            ...defaultAttribute,
                            ...attribute,
                        },
                    });
                });
            });
        });
    });
    nodeAndMarkExtensions.forEach(extension => {
        const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
        };
        const addAttributes = getExtensionField(extension, 'addAttributes', context);
        if (!addAttributes) {
            return;
        }
        // TODO: remove `as Attributes`
        const attributes = addAttributes();
        Object
            .entries(attributes)
            .forEach(([name, attribute]) => {
            extensionAttributes.push({
                type: extension.name,
                name,
                attribute: {
                    ...defaultAttribute,
                    ...attribute,
                },
            });
        });
    });
    return extensionAttributes;
}

function mergeAttributes(...objects) {
    return objects
        .filter(item => !!item)
        .reduce((items, item) => {
        const mergedAttributes = { ...items };
        Object.entries(item).forEach(([key, value]) => {
            const exists = mergedAttributes[key];
            if (!exists) {
                mergedAttributes[key] = value;
                return;
            }
            if (key === 'class') {
                mergedAttributes[key] = [mergedAttributes[key], value].join(' ');
            }
            else if (key === 'style') {
                mergedAttributes[key] = [mergedAttributes[key], value].join('; ');
            }
            else {
                mergedAttributes[key] = value;
            }
        });
        return mergedAttributes;
    }, {});
}

function getRenderedAttributes(nodeOrMark, extensionAttributes) {
    return extensionAttributes
        .filter(item => item.attribute.rendered)
        .map(item => {
        if (!item.attribute.renderHTML) {
            return {
                [item.name]: nodeOrMark.attrs[item.name],
            };
        }
        return item.attribute.renderHTML(nodeOrMark.attrs) || {};
    })
        .reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}

function isEmptyObject(value = {}) {
    return Object.keys(value).length === 0 && value.constructor === Object;
}

function fromString(value) {
    if (typeof value !== 'string') {
        return value;
    }
    if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
        return Number(value);
    }
    if (value === 'true') {
        return true;
    }
    if (value === 'false') {
        return false;
    }
    return value;
}

/**
 * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).
 * Cancels when `getAttrs` returned `false`.
 * @param parseRule ProseMirror ParseRule
 * @param extensionAttributes List of attributes to inject
 */
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
    if (parseRule.style) {
        return parseRule;
    }
    return {
        ...parseRule,
        getAttrs: node => {
            const oldAttributes = parseRule.getAttrs
                ? parseRule.getAttrs(node)
                : parseRule.attrs;
            if (oldAttributes === false) {
                return false;
            }
            const newAttributes = extensionAttributes.reduce((items, item) => {
                const value = item.attribute.parseHTML
                    ? item.attribute.parseHTML(node)
                    : fromString(node.getAttribute(item.name));
                if (value === null || value === undefined) {
                    return items;
                }
                return {
                    ...items,
                    [item.name]: value,
                };
            }, {});
            return { ...oldAttributes, ...newAttributes };
        },
    };
}

function cleanUpSchemaItem(data) {
    return Object.fromEntries(Object.entries(data).filter(([key, value]) => {
        if (key === 'attrs' && isEmptyObject(value)) {
            return false;
        }
        return value !== null && value !== undefined;
    }));
}
function getSchemaByResolvedExtensions(extensions) {
    var _a;
    const allAttributes = getAttributesFromExtensions(extensions);
    const { nodeExtensions, markExtensions } = splitExtensions(extensions);
    const topNode = (_a = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))) === null || _a === void 0 ? void 0 : _a.name;
    const nodes = Object.fromEntries(nodeExtensions.map(extension => {
        const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);
        const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
        };
        const extraNodeFields = extensions.reduce((fields, e) => {
            const extendNodeSchema = getExtensionField(e, 'extendNodeSchema', context);
            return {
                ...fields,
                ...(extendNodeSchema ? extendNodeSchema(extension) : {}),
            };
        }, {});
        const schema = cleanUpSchemaItem({
            ...extraNodeFields,
            content: callOrReturn(getExtensionField(extension, 'content', context)),
            marks: callOrReturn(getExtensionField(extension, 'marks', context)),
            group: callOrReturn(getExtensionField(extension, 'group', context)),
            inline: callOrReturn(getExtensionField(extension, 'inline', context)),
            atom: callOrReturn(getExtensionField(extension, 'atom', context)),
            selectable: callOrReturn(getExtensionField(extension, 'selectable', context)),
            draggable: callOrReturn(getExtensionField(extension, 'draggable', context)),
            code: callOrReturn(getExtensionField(extension, 'code', context)),
            defining: callOrReturn(getExtensionField(extension, 'defining', context)),
            isolating: callOrReturn(getExtensionField(extension, 'isolating', context)),
            attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {
                var _a;
                return [extensionAttribute.name, { default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default }];
            })),
        });
        const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));
        if (parseHTML) {
            schema.parseDOM = parseHTML
                .map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
        }
        const renderHTML = getExtensionField(extension, 'renderHTML', context);
        if (renderHTML) {
            schema.toDOM = node => renderHTML({
                node,
                HTMLAttributes: getRenderedAttributes(node, extensionAttributes),
            });
        }
        const renderText = getExtensionField(extension, 'renderText', context);
        if (renderText) {
            schema.toText = renderText;
        }
        return [extension.name, schema];
    }));
    const marks = Object.fromEntries(markExtensions.map(extension => {
        const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);
        const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
        };
        const extraMarkFields = extensions.reduce((fields, e) => {
            const extendMarkSchema = getExtensionField(e, 'extendMarkSchema', context);
            return {
                ...fields,
                ...(extendMarkSchema ? extendMarkSchema(extension) : {}),
            };
        }, {});
        const schema = cleanUpSchemaItem({
            ...extraMarkFields,
            inclusive: callOrReturn(getExtensionField(extension, 'inclusive', context)),
            excludes: callOrReturn(getExtensionField(extension, 'excludes', context)),
            group: callOrReturn(getExtensionField(extension, 'group', context)),
            spanning: callOrReturn(getExtensionField(extension, 'spanning', context)),
            code: callOrReturn(getExtensionField(extension, 'code', context)),
            attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {
                var _a;
                return [extensionAttribute.name, { default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default }];
            })),
        });
        const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));
        if (parseHTML) {
            schema.parseDOM = parseHTML
                .map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
        }
        const renderHTML = getExtensionField(extension, 'renderHTML', context);
        if (renderHTML) {
            schema.toDOM = mark => renderHTML({
                mark,
                HTMLAttributes: getRenderedAttributes(mark, extensionAttributes),
            });
        }
        return [extension.name, schema];
    }));
    return new Schema({
        topNode,
        nodes,
        marks,
    });
}

function getSchemaTypeByName(name, schema) {
    return schema.nodes[name] || schema.marks[name] || null;
}

function isExtensionRulesEnabled(extension, enabled) {
    if (Array.isArray(enabled)) {
        return enabled.some(enabledExtension => {
            const name = typeof enabledExtension === 'string'
                ? enabledExtension
                : enabledExtension.name;
            return name === extension.name;
        });
    }
    return enabled;
}

function findDuplicates(items) {
    const filtered = items.filter((el, index) => items.indexOf(el) !== index);
    return [...new Set(filtered)];
}

class ExtensionManager {
    constructor(extensions, editor) {
        this.splittableMarks = [];
        this.editor = editor;
        this.extensions = ExtensionManager.resolve(extensions);
        this.schema = getSchemaByResolvedExtensions(this.extensions);
        this.extensions.forEach(extension => {
            var _a;
            // store extension storage in editor
            this.editor.extensionStorage[extension.name] = extension.storage;
            const context = {
                name: extension.name,
                options: extension.options,
                storage: extension.storage,
                editor: this.editor,
                type: getSchemaTypeByName(extension.name, this.schema),
            };
            if (extension.type === 'mark') {
                const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, 'keepOnSplit', context))) !== null && _a !== void 0 ? _a : true;
                if (keepOnSplit) {
                    this.splittableMarks.push(extension.name);
                }
            }
            const onBeforeCreate = getExtensionField(extension, 'onBeforeCreate', context);
            if (onBeforeCreate) {
                this.editor.on('beforeCreate', onBeforeCreate);
            }
            const onCreate = getExtensionField(extension, 'onCreate', context);
            if (onCreate) {
                this.editor.on('create', onCreate);
            }
            const onUpdate = getExtensionField(extension, 'onUpdate', context);
            if (onUpdate) {
                this.editor.on('update', onUpdate);
            }
            const onSelectionUpdate = getExtensionField(extension, 'onSelectionUpdate', context);
            if (onSelectionUpdate) {
                this.editor.on('selectionUpdate', onSelectionUpdate);
            }
            const onTransaction = getExtensionField(extension, 'onTransaction', context);
            if (onTransaction) {
                this.editor.on('transaction', onTransaction);
            }
            const onFocus = getExtensionField(extension, 'onFocus', context);
            if (onFocus) {
                this.editor.on('focus', onFocus);
            }
            const onBlur = getExtensionField(extension, 'onBlur', context);
            if (onBlur) {
                this.editor.on('blur', onBlur);
            }
            const onDestroy = getExtensionField(extension, 'onDestroy', context);
            if (onDestroy) {
                this.editor.on('destroy', onDestroy);
            }
        });
    }
    static resolve(extensions) {
        const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));
        const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name));
        if (duplicatedNames.length) {
            console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map(item => `'${item}'`).join(', ')}]. This can lead to issues.`);
        }
        return resolvedExtensions;
    }
    static flatten(extensions) {
        return extensions
            .map(extension => {
            const context = {
                name: extension.name,
                options: extension.options,
                storage: extension.storage,
            };
            const addExtensions = getExtensionField(extension, 'addExtensions', context);
            if (addExtensions) {
                return [
                    extension,
                    ...this.flatten(addExtensions()),
                ];
            }
            return extension;
        })
            // `Infinity` will break TypeScript so we set a number that is probably high enough
            .flat(10);
    }
    static sort(extensions) {
        const defaultPriority = 100;
        return extensions.sort((a, b) => {
            const priorityA = getExtensionField(a, 'priority') || defaultPriority;
            const priorityB = getExtensionField(b, 'priority') || defaultPriority;
            if (priorityA > priorityB) {
                return -1;
            }
            if (priorityA < priorityB) {
                return 1;
            }
            return 0;
        });
    }
    get commands() {
        return this.extensions.reduce((commands, extension) => {
            const context = {
                name: extension.name,
                options: extension.options,
                storage: extension.storage,
                editor: this.editor,
                type: getSchemaTypeByName(extension.name, this.schema),
            };
            const addCommands = getExtensionField(extension, 'addCommands', context);
            if (!addCommands) {
                return commands;
            }
            return {
                ...commands,
                ...addCommands(),
            };
        }, {});
    }
    get plugins() {
        const { editor } = this;
        // With ProseMirror, first plugins within an array are executed first.
        // In tiptap, we provide the ability to override plugins,
        // so it feels more natural to run plugins at the end of an array first.
        // That’s why we have to reverse the `extensions` array and sort again
        // based on the `priority` option.
        const extensions = ExtensionManager.sort([...this.extensions].reverse());
        const inputRules = [];
        const pasteRules = [];
        const allPlugins = extensions
            .map(extension => {
            const context = {
                name: extension.name,
                options: extension.options,
                storage: extension.storage,
                editor,
                type: getSchemaTypeByName(extension.name, this.schema),
            };
            const plugins = [];
            const addKeyboardShortcuts = getExtensionField(extension, 'addKeyboardShortcuts', context);
            if (addKeyboardShortcuts) {
                const bindings = Object.fromEntries(Object
                    .entries(addKeyboardShortcuts())
                    .map(([shortcut, method]) => {
                    return [shortcut, () => method({ editor })];
                }));
                const keyMapPlugin = keymap(bindings);
                plugins.push(keyMapPlugin);
            }
            const addInputRules = getExtensionField(extension, 'addInputRules', context);
            if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
                inputRules.push(...addInputRules());
            }
            const addPasteRules = getExtensionField(extension, 'addPasteRules', context);
            if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
                pasteRules.push(...addPasteRules());
            }
            const addProseMirrorPlugins = getExtensionField(extension, 'addProseMirrorPlugins', context);
            if (addProseMirrorPlugins) {
                const proseMirrorPlugins = addProseMirrorPlugins();
                plugins.push(...proseMirrorPlugins);
            }
            return plugins;
        })
            .flat();
        return [
            inputRulesPlugin({
                editor,
                rules: inputRules,
            }),
            ...pasteRulesPlugin({
                editor,
                rules: pasteRules,
            }),
            ...allPlugins,
        ];
    }
    get attributes() {
        return getAttributesFromExtensions(this.extensions);
    }
    get nodeViews() {
        const { editor } = this;
        const { nodeExtensions } = splitExtensions(this.extensions);
        return Object.fromEntries(nodeExtensions
            .filter(extension => !!getExtensionField(extension, 'addNodeView'))
            .map(extension => {
            const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name);
            const context = {
                name: extension.name,
                options: extension.options,
                storage: extension.storage,
                editor,
                type: getNodeType(extension.name, this.schema),
            };
            const addNodeView = getExtensionField(extension, 'addNodeView', context);
            if (!addNodeView) {
                return [];
            }
            const nodeview = (node, view, getPos, decorations) => {
                const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
                return addNodeView()({
                    editor,
                    node,
                    getPos,
                    decorations,
                    HTMLAttributes,
                    extension,
                });
            };
            return [extension.name, nodeview];
        }));
    }
}

class EventEmitter {
    constructor() {
        this.callbacks = {};
    }
    on(event, fn) {
        if (!this.callbacks[event]) {
            this.callbacks[event] = [];
        }
        this.callbacks[event].push(fn);
        return this;
    }
    emit(event, ...args) {
        const callbacks = this.callbacks[event];
        if (callbacks) {
            callbacks.forEach(callback => callback.apply(this, args));
        }
        return this;
    }
    off(event, fn) {
        const callbacks = this.callbacks[event];
        if (callbacks) {
            if (fn) {
                this.callbacks[event] = callbacks.filter(callback => callback !== fn);
            }
            else {
                delete this.callbacks[event];
            }
        }
        return this;
    }
    removeAllListeners() {
        this.callbacks = {};
    }
}

const style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;

class Editor$1 extends EventEmitter {
    constructor(options = {}) {
        super();
        this.isFocused = false;
        this.extensionStorage = {};
        this.options = {
            element: document.createElement('div'),
            content: '',
            injectCSS: true,
            injectNonce: undefined,
            extensions: [],
            autofocus: false,
            editable: true,
            editorProps: {},
            parseOptions: {},
            enableInputRules: true,
            enablePasteRules: true,
            enableCoreExtensions: true,
            onBeforeCreate: () => null,
            onCreate: () => null,
            onUpdate: () => null,
            onSelectionUpdate: () => null,
            onTransaction: () => null,
            onFocus: () => null,
            onBlur: () => null,
            onDestroy: () => null,
        };
        this.isCapturingTransaction = false;
        this.capturedTransaction = null;
        this.setOptions(options);
        this.createExtensionManager();
        this.createCommandManager();
        this.createSchema();
        this.on('beforeCreate', this.options.onBeforeCreate);
        this.emit('beforeCreate', { editor: this });
        this.createView();
        this.injectCSS();
        this.on('create', this.options.onCreate);
        this.on('update', this.options.onUpdate);
        this.on('selectionUpdate', this.options.onSelectionUpdate);
        this.on('transaction', this.options.onTransaction);
        this.on('focus', this.options.onFocus);
        this.on('blur', this.options.onBlur);
        this.on('destroy', this.options.onDestroy);
        window$1.setTimeout(() => {
            if (this.isDestroyed) {
                return;
            }
            this.commands.focus(this.options.autofocus);
            this.emit('create', { editor: this });
        }, 0);
    }
    /**
     * Returns the editor storage.
     */
    get storage() {
        return this.extensionStorage;
    }
    /**
     * An object of all registered commands.
     */
    get commands() {
        return this.commandManager.commands;
    }
    /**
     * Create a command chain to call multiple commands at once.
     */
    chain() {
        return this.commandManager.chain();
    }
    /**
     * Check if a command or a command chain can be executed. Without executing it.
     */
    can() {
        return this.commandManager.can();
    }
    /**
     * Inject CSS styles.
     */
    injectCSS() {
        if (this.options.injectCSS && document) {
            this.css = createStyleTag(style, this.options.injectNonce);
        }
    }
    /**
     * Update editor options.
     *
     * @param options A list of options
     */
    setOptions(options = {}) {
        this.options = {
            ...this.options,
            ...options,
        };
        if (!this.view || !this.state || this.isDestroyed) {
            return;
        }
        if (this.options.editorProps) {
            this.view.setProps(this.options.editorProps);
        }
        this.view.updateState(this.state);
    }
    /**
     * Update editable state of the editor.
     */
    setEditable(editable) {
        this.setOptions({ editable });
    }
    /**
     * Returns whether the editor is editable.
     */
    get isEditable() {
        // since plugins are applied after creating the view
        // `editable` is always `true` for one tick.
        // that’s why we also have to check for `options.editable`
        return this.options.editable
            && this.view
            && this.view.editable;
    }
    /**
     * Returns the editor state.
     */
    get state() {
        return this.view.state;
    }
    /**
     * Register a ProseMirror plugin.
     *
     * @param plugin A ProseMirror plugin
     * @param handlePlugins Control how to merge the plugin into the existing plugins.
     */
    registerPlugin(plugin, handlePlugins) {
        const plugins = isFunction(handlePlugins)
            ? handlePlugins(plugin, this.state.plugins)
            : [...this.state.plugins, plugin];
        const state = this.state.reconfigure({ plugins });
        this.view.updateState(state);
    }
    /**
     * Unregister a ProseMirror plugin.
     *
     * @param nameOrPluginKey The plugins name
     */
    unregisterPlugin(nameOrPluginKey) {
        if (this.isDestroyed) {
            return;
        }
        const name = typeof nameOrPluginKey === 'string'
            ? `${nameOrPluginKey}$`
            // @ts-ignore
            : nameOrPluginKey.key;
        const state = this.state.reconfigure({
            // @ts-ignore
            plugins: this.state.plugins.filter(plugin => !plugin.key.startsWith(name)),
        });
        this.view.updateState(state);
    }
    /**
     * Creates an extension manager.
     */
    createExtensionManager() {
        const coreExtensions = this.options.enableCoreExtensions
            ? Object.values(extensions)
            : [];
        const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {
            return ['extension', 'node', 'mark'].includes(extension === null || extension === void 0 ? void 0 : extension.type);
        });
        this.extensionManager = new ExtensionManager(allExtensions, this);
    }
    /**
     * Creates an command manager.
     */
    createCommandManager() {
        this.commandManager = new CommandManager({
            editor: this,
        });
    }
    /**
     * Creates a ProseMirror schema.
     */
    createSchema() {
        this.schema = this.extensionManager.schema;
    }
    /**
     * Creates a ProseMirror view.
     */
    createView() {
        const doc = createDocument(this.options.content, this.schema, this.options.parseOptions);
        const selection = resolveFocusPosition(doc, this.options.autofocus);
        this.view = new EditorView(this.options.element, {
            ...this.options.editorProps,
            dispatchTransaction: this.dispatchTransaction.bind(this),
            state: EditorState.create({
                doc,
                selection,
            }),
        });
        // `editor.view` is not yet available at this time.
        // Therefore we will add all plugins and node views directly afterwards.
        const newState = this.state.reconfigure({
            plugins: this.extensionManager.plugins,
        });
        this.view.updateState(newState);
        this.createNodeViews();
        // Let’s store the editor instance in the DOM element.
        // So we’ll have access to it for tests.
        const dom = this.view.dom;
        dom.editor = this;
    }
    /**
     * Creates all node views.
     */
    createNodeViews() {
        this.view.setProps({
            nodeViews: this.extensionManager.nodeViews,
        });
    }
    captureTransaction(fn) {
        this.isCapturingTransaction = true;
        fn();
        this.isCapturingTransaction = false;
        const tr = this.capturedTransaction;
        this.capturedTransaction = null;
        return tr;
    }
    /**
     * The callback over which to send transactions (state updates) produced by the view.
     *
     * @param transaction An editor state transaction
     */
    dispatchTransaction(transaction) {
        if (this.isCapturingTransaction) {
            if (!this.capturedTransaction) {
                this.capturedTransaction = transaction;
                return;
            }
            transaction.steps.forEach(step => { var _a; return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step); });
            return;
        }
        const state = this.state.apply(transaction);
        const selectionHasChanged = !this.state.selection.eq(state.selection);
        this.view.updateState(state);
        this.emit('transaction', {
            editor: this,
            transaction,
        });
        if (selectionHasChanged) {
            this.emit('selectionUpdate', {
                editor: this,
                transaction,
            });
        }
        const focus = transaction.getMeta('focus');
        const blur = transaction.getMeta('blur');
        if (focus) {
            this.emit('focus', {
                editor: this,
                event: focus.event,
                transaction,
            });
        }
        if (blur) {
            this.emit('blur', {
                editor: this,
                event: blur.event,
                transaction,
            });
        }
        if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {
            return;
        }
        this.emit('update', {
            editor: this,
            transaction,
        });
    }
    /**
     * Get attributes of the currently selected node or mark.
     */
    getAttributes(nameOrType) {
        return getAttributes(this.state, nameOrType);
    }
    isActive(nameOrAttributes, attributesOrUndefined) {
        const name = typeof nameOrAttributes === 'string'
            ? nameOrAttributes
            : null;
        const attributes = typeof nameOrAttributes === 'string'
            ? attributesOrUndefined
            : nameOrAttributes;
        return isActive(this.state, name, attributes);
    }
    /**
     * Get the document as JSON.
     */
    getJSON() {
        return this.state.doc.toJSON();
    }
    /**
     * Get the document as HTML.
     */
    getHTML() {
        return getHTMLFromFragment(this.state.doc.content, this.schema);
    }
    /**
     * Get the document as text.
     */
    getText(options) {
        const { blockSeparator = '\n\n', textSerializers = {}, } = options || {};
        return getText(this.state.doc, {
            blockSeparator,
            textSerializers: {
                ...textSerializers,
                ...getTextSerializersFromSchema(this.schema),
            },
        });
    }
    /**
     * Check if there is no content.
     */
    get isEmpty() {
        return isNodeEmpty(this.state.doc);
    }
    /**
     * Get the number of characters for the current document.
     *
     * @deprecated
     */
    getCharacterCount() {
        console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
        return this.state.doc.content.size - 2;
    }
    /**
     * Destroy the editor.
     */
    destroy() {
        this.emit('destroy');
        if (this.view) {
            this.view.destroy();
        }
        this.removeAllListeners();
    }
    /**
     * Check if the editor is already destroyed.
     */
    get isDestroyed() {
        var _a;
        // @ts-ignore
        return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
    }
}

class Node {
    constructor(config = {}) {
        this.type = 'node';
        this.name = 'node';
        this.parent = null;
        this.child = null;
        this.config = {
            name: this.name,
            defaultOptions: {},
        };
        this.config = {
            ...this.config,
            ...config,
        };
        this.name = this.config.name;
        if (config.defaultOptions) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
        }
        // TODO: remove `addOptions` fallback
        this.options = this.config.defaultOptions;
        if (this.config.addOptions) {
            this.options = callOrReturn(getExtensionField(this, 'addOptions', {
                name: this.name,
            }));
        }
        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {
            name: this.name,
            options: this.options,
        })) || {};
    }
    static create(config = {}) {
        return new Node(config);
    }
    configure(options = {}) {
        // return a new instance so we can use the same extension
        // with different calls of `configure`
        const extension = this.extend();
        extension.options = mergeDeep(this.options, options);
        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {
            name: extension.name,
            options: extension.options,
        }));
        return extension;
    }
    extend(extendedConfig = {}) {
        const extension = new Node(extendedConfig);
        extension.parent = this;
        this.child = extension;
        extension.name = extendedConfig.name
            ? extendedConfig.name
            : extension.parent.name;
        if (extendedConfig.defaultOptions) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
        }
        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {
            name: extension.name,
        }));
        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {
            name: extension.name,
            options: extension.options,
        }));
        return extension;
    }
}

class Mark {
    constructor(config = {}) {
        this.type = 'mark';
        this.name = 'mark';
        this.parent = null;
        this.child = null;
        this.config = {
            name: this.name,
            defaultOptions: {},
        };
        this.config = {
            ...this.config,
            ...config,
        };
        this.name = this.config.name;
        if (config.defaultOptions) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
        }
        // TODO: remove `addOptions` fallback
        this.options = this.config.defaultOptions;
        if (this.config.addOptions) {
            this.options = callOrReturn(getExtensionField(this, 'addOptions', {
                name: this.name,
            }));
        }
        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {
            name: this.name,
            options: this.options,
        })) || {};
    }
    static create(config = {}) {
        return new Mark(config);
    }
    configure(options = {}) {
        // return a new instance so we can use the same extension
        // with different calls of `configure`
        const extension = this.extend();
        extension.options = mergeDeep(this.options, options);
        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {
            name: extension.name,
            options: extension.options,
        }));
        return extension;
    }
    extend(extendedConfig = {}) {
        const extension = new Mark(extendedConfig);
        extension.parent = this;
        this.child = extension;
        extension.name = extendedConfig.name
            ? extendedConfig.name
            : extension.parent.name;
        if (extendedConfig.defaultOptions) {
            console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
        }
        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {
            name: extension.name,
        }));
        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {
            name: extension.name,
            options: extension.options,
        }));
        return extension;
    }
}

/**
 * Build an input rule that adds a node when the
 * matched text is typed into it.
 */
function nodeInputRule(config) {
    return new InputRule({
        find: config.find,
        handler: ({ state, range, match }) => {
            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};
            const { tr } = state;
            const start = range.from;
            let end = range.to;
            if (match[1]) {
                const offset = match[0].lastIndexOf(match[1]);
                let matchStart = start + offset;
                if (matchStart > end) {
                    matchStart = end;
                }
                else {
                    end = matchStart + match[1].length;
                }
                // insert last typed character
                const lastChar = match[0][match[0].length - 1];
                tr.insertText(lastChar, start + match[0].length - 1);
                // insert node from input rule
                tr.replaceWith(matchStart, end, config.type.create(attributes));
            }
            else if (match[0]) {
                tr.replaceWith(start, end, config.type.create(attributes));
            }
        },
    });
}

function getMarksBetween(from, to, doc) {
    const marks = [];
    // get all inclusive marks on empty selection
    if (from === to) {
        doc
            .resolve(from)
            .marks()
            .forEach(mark => {
            const $pos = doc.resolve(from - 1);
            const range = getMarkRange($pos, mark.type);
            if (!range) {
                return;
            }
            marks.push({
                mark,
                ...range,
            });
        });
    }
    else {
        doc.nodesBetween(from, to, (node, pos) => {
            marks.push(...node.marks.map(mark => ({
                from: pos,
                to: pos + node.nodeSize,
                mark,
            })));
        });
    }
    return marks;
}

/**
 * Build an input rule that adds a mark when the
 * matched text is typed into it.
 */
function markInputRule(config) {
    return new InputRule({
        find: config.find,
        handler: ({ state, range, match }) => {
            const attributes = callOrReturn(config.getAttributes, undefined, match);
            if (attributes === false || attributes === null) {
                return null;
            }
            const { tr } = state;
            const captureGroup = match[match.length - 1];
            const fullMatch = match[0];
            let markEnd = range.to;
            if (captureGroup) {
                const startSpaces = fullMatch.search(/\S/);
                const textStart = range.from + fullMatch.indexOf(captureGroup);
                const textEnd = textStart + captureGroup.length;
                const excludedMarks = getMarksBetween(range.from, range.to, state.doc)
                    .filter(item => {
                    // @ts-ignore
                    const excluded = item.mark.type.excluded;
                    return excluded.find(type => type === config.type && type !== item.mark.type);
                })
                    .filter(item => item.to > textStart);
                if (excludedMarks.length) {
                    return null;
                }
                if (textEnd < range.to) {
                    tr.delete(textEnd, range.to);
                }
                if (textStart > range.from) {
                    tr.delete(range.from + startSpaces, textStart);
                }
                markEnd = range.from + startSpaces + captureGroup.length;
                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
                tr.removeStoredMark(config.type);
            }
        },
    });
}

/**
 * Build an input rule that changes the type of a textblock when the
 * matched text is typed into it. When using a regular expresion you’ll
 * probably want the regexp to start with `^`, so that the pattern can
 * only occur at the start of a textblock.
 */
function textblockTypeInputRule(config) {
    return new InputRule({
        find: config.find,
        handler: ({ state, range, match }) => {
            const $start = state.doc.resolve(range.from);
            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};
            if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
                return null;
            }
            state.tr
                .delete(range.from, range.to)
                .setBlockType(range.from, range.from, config.type, attributes);
        },
    });
}

/**
 * Build an input rule for automatically wrapping a textblock when a
 * given string is typed. When using a regular expresion you’ll
 * probably want the regexp to start with `^`, so that the pattern can
 * only occur at the start of a textblock.
 *
 * `type` is the type of node to wrap in.
 *
 * By default, if there’s a node with the same type above the newly
 * wrapped node, the rule will try to join those
 * two nodes. You can pass a join predicate, which takes a regular
 * expression match and the node before the wrapped node, and can
 * return a boolean to indicate whether a join should happen.
 */
function wrappingInputRule(config) {
    return new InputRule({
        find: config.find,
        handler: ({ state, range, match }) => {
            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};
            const tr = state.tr.delete(range.from, range.to);
            const $start = tr.doc.resolve(range.from);
            const blockRange = $start.blockRange();
            const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
            if (!wrapping) {
                return null;
            }
            tr.wrap(blockRange, wrapping);
            const before = tr.doc.resolve(range.from - 1).nodeBefore;
            if (before
                && before.type === config.type
                && canJoin(tr.doc, range.from - 1)
                && (!config.joinPredicate || config.joinPredicate(match, before))) {
                tr.join(range.from - 1);
            }
        },
    });
}

/**
 * Build an paste rule that adds a mark when the
 * matched text is pasted into it.
 */
function markPasteRule(config) {
    return new PasteRule({
        find: config.find,
        handler: ({ state, range, match }) => {
            const attributes = callOrReturn(config.getAttributes, undefined, match);
            if (attributes === false || attributes === null) {
                return null;
            }
            const { tr } = state;
            const captureGroup = match[match.length - 1];
            const fullMatch = match[0];
            let markEnd = range.to;
            if (captureGroup) {
                const startSpaces = fullMatch.search(/\S/);
                const textStart = range.from + fullMatch.indexOf(captureGroup);
                const textEnd = textStart + captureGroup.length;
                const excludedMarks = getMarksBetween(range.from, range.to, state.doc)
                    .filter(item => {
                    // @ts-ignore
                    const excluded = item.mark.type.excluded;
                    return excluded.find(type => type === config.type && type !== item.mark.type);
                })
                    .filter(item => item.to > textStart);
                if (excludedMarks.length) {
                    return null;
                }
                if (textEnd < range.to) {
                    tr.delete(textEnd, range.to);
                }
                if (textStart > range.from) {
                    tr.delete(range.from + startSpaces, textStart);
                }
                markEnd = range.from + startSpaces + captureGroup.length;
                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
                tr.removeStoredMark(config.type);
            }
        },
    });
}

/**
 * Returns a new `Transform` based on all steps of the passed transactions.
 */
function combineTransactionSteps(oldDoc, transactions) {
    const transform = new Transform(oldDoc);
    transactions.forEach(transaction => {
        transaction.steps.forEach(step => {
            transform.step(step);
        });
    });
    return transform;
}

/**
 * Same as `findChildren` but searches only within a `range`.
 */
function findChildrenInRange(node, range, predicate) {
    const nodesWithPos = [];
    // if (range.from === range.to) {
    //   const nodeAt = node.nodeAt(range.from)
    //   if (nodeAt) {
    //     nodesWithPos.push({
    //       node: nodeAt,
    //       pos: range.from,
    //     })
    //   }
    // }
    node.nodesBetween(range.from, range.to, (child, pos) => {
        if (predicate(child)) {
            nodesWithPos.push({
                node: child,
                pos,
            });
        }
    });
    return nodesWithPos;
}

/**
 * Removes duplicated values within an array.
 * Supports numbers, strings and objects.
 */
function removeDuplicates(array, by = JSON.stringify) {
    const seen = {};
    return array.filter(item => {
        const key = by(item);
        return Object.prototype.hasOwnProperty.call(seen, key)
            ? false
            : (seen[key] = true);
    });
}

/**
 * Removes duplicated ranges and ranges that are
 * fully captured by other ranges.
 */
function simplifyChangedRanges(changes) {
    const uniqueChanges = removeDuplicates(changes);
    return uniqueChanges.length === 1
        ? uniqueChanges
        : uniqueChanges.filter((change, index) => {
            const rest = uniqueChanges.filter((_, i) => i !== index);
            return !rest.some(otherChange => {
                return change.oldRange.from >= otherChange.oldRange.from
                    && change.oldRange.to <= otherChange.oldRange.to
                    && change.newRange.from >= otherChange.newRange.from
                    && change.newRange.to <= otherChange.newRange.to;
            });
        });
}
/**
 * Returns a list of changed ranges
 * based on the first and last state of all steps.
 */
function getChangedRanges(transform) {
    const { mapping, steps } = transform;
    const changes = [];
    mapping.maps.forEach((stepMap, index) => {
        const ranges = [];
        // This accounts for step changes where no range was actually altered
        // e.g. when setting a mark, node attribute, etc.
        // @ts-ignore
        if (!stepMap.ranges.length) {
            const { from, to } = steps[index];
            if (from === undefined || to === undefined) {
                return;
            }
            ranges.push({ from, to });
        }
        else {
            stepMap.forEach((from, to) => {
                ranges.push({ from, to });
            });
        }
        ranges.forEach(({ from, to }) => {
            const newStart = mapping.slice(index).map(from, -1);
            const newEnd = mapping.slice(index).map(to);
            const oldStart = mapping.invert().map(newStart, -1);
            const oldEnd = mapping.invert().map(newEnd);
            changes.push({
                oldRange: {
                    from: oldStart,
                    to: oldEnd,
                },
                newRange: {
                    from: newStart,
                    to: newEnd,
                },
            });
        });
    });
    return simplifyChangedRanges(changes);
}

class Editor extends Editor$1 {
    constructor() {
        super(...arguments);
        this.contentComponent = null;
    }
}

function useForceUpdate() {
    const [, setValue] = useState(0);
    return () => setValue(value => value + 1);
}
const useEditor = (options = {}, deps = []) => {
    const [editor, setEditor] = useState(null);
    const forceUpdate = useForceUpdate();
    useEffect(() => {
        const instance = new Editor(options);
        setEditor(instance);
        instance.on('transaction', () => {
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    forceUpdate();
                });
            });
        });
        return () => {
            instance.destroy();
        };
    }, deps);
    return editor;
};

const ReactNodeViewContext = createContext({
    onDragStart: undefined,
});
const useReactNodeView = () => useContext(ReactNodeViewContext);

const Portals = ({ renderers }) => {
    return (React__default.createElement(React__default.Fragment, null, Array.from(renderers).map(([key, renderer]) => {
        return ReactDOM.createPortal(renderer.reactElement, renderer.element, key);
    })));
};
class PureEditorContent extends React__default.Component {
    constructor(props) {
        super(props);
        this.editorContentRef = React__default.createRef();
        this.state = {
            renderers: new Map(),
        };
    }
    componentDidMount() {
        this.init();
    }
    componentDidUpdate() {
        this.init();
    }
    init() {
        const { editor } = this.props;
        if (editor && editor.options.element) {
            if (editor.contentComponent) {
                return;
            }
            const element = this.editorContentRef.current;
            element.append(...editor.options.element.childNodes);
            editor.setOptions({
                element,
            });
            editor.contentComponent = this;
            editor.createNodeViews();
        }
    }
    componentWillUnmount() {
        const { editor } = this.props;
        if (!editor) {
            return;
        }
        if (!editor.isDestroyed) {
            editor.view.setProps({
                nodeViews: {},
            });
        }
        editor.contentComponent = null;
        if (!editor.options.element.firstChild) {
            return;
        }
        const newElement = document.createElement('div');
        newElement.append(...editor.options.element.childNodes);
        editor.setOptions({
            element: newElement,
        });
    }
    render() {
        const { editor, ...rest } = this.props;
        return (React__default.createElement(React__default.Fragment, null,
            React__default.createElement("div", { ref: this.editorContentRef, ...rest }),
            React__default.createElement(Portals, { renderers: this.state.renderers })));
    }
}
const EditorContent = React__default.memo(PureEditorContent);

React__default.forwardRef((props, ref) => {
    const { onDragStart } = useReactNodeView();
    const Tag = props.as || 'div';
    return (React__default.createElement(Tag, { ...props, ref: ref, "data-node-view-wrapper": "", onDragStart: onDragStart, style: {
            ...props.style,
            whiteSpace: 'normal',
        } }));
});

const TextStyle$1 = Mark.create({
    name: 'textStyle',
    addOptions() {
        return {
            HTMLAttributes: {},
        };
    },
    parseHTML() {
        return [
            {
                tag: 'span',
                getAttrs: element => {
                    const hasStyles = element.hasAttribute('style');
                    if (!hasStyles) {
                        return false;
                    }
                    return {};
                },
            },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['span', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
        return {
            removeEmptyTextStyle: () => ({ state, commands }) => {
                const attributes = getMarkAttributes(state, this.type);
                const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
                if (hasStyles) {
                    return true;
                }
                return commands.unsetMark(this.name);
            },
        };
    },
});

const Color = Extension.create({
    name: 'color',
    addOptions() {
        return {
            types: ['textStyle'],
        };
    },
    addGlobalAttributes() {
        return [
            {
                types: this.options.types,
                attributes: {
                    color: {
                        default: null,
                        parseHTML: element => element.style.color.replace(/['"]+/g, ''),
                        renderHTML: attributes => {
                            if (!attributes.color) {
                                return {};
                            }
                            return {
                                style: `color: ${attributes.color}`,
                            };
                        },
                    },
                },
            },
        ];
    },
    addCommands() {
        return {
            setColor: color => ({ chain }) => {
                return chain()
                    .setMark('textStyle', { color })
                    .run();
            },
            unsetColor: () => ({ chain }) => {
                return chain()
                    .setMark('textStyle', { color: null })
                    .removeEmptyTextStyle()
                    .run();
            },
        };
    },
});

const FontFamily = Extension.create({
    name: 'fontFamily',
    addOptions() {
        return {
            types: ['textStyle'],
        };
    },
    addGlobalAttributes() {
        return [
            {
                types: this.options.types,
                attributes: {
                    fontFamily: {
                        default: null,
                        parseHTML: element => element.style.fontFamily.replace(/['"]+/g, ''),
                        renderHTML: attributes => {
                            if (!attributes.fontFamily) {
                                return {};
                            }
                            return {
                                style: `font-family: ${attributes.fontFamily}`,
                            };
                        },
                    },
                },
            },
        ];
    },
    addCommands() {
        return {
            setFontFamily: fontFamily => ({ chain }) => {
                return chain()
                    .setMark('textStyle', { fontFamily })
                    .run();
            },
            unsetFontFamily: () => ({ chain }) => {
                return chain()
                    .setMark('textStyle', { fontFamily: null })
                    .removeEmptyTextStyle()
                    .run();
            },
        };
    },
});

const HardBreak = Node.create({
    name: 'hardBreak',
    addOptions() {
        return {
            keepMarks: true,
            HTMLAttributes: {},
        };
    },
    inline: true,
    group: 'inline',
    selectable: false,
    parseHTML() {
        return [
            { tag: 'br' },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['br', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
    },
    renderText() {
        return '\n';
    },
    addCommands() {
        return {
            setHardBreak: () => ({ commands, chain, state, editor, }) => {
                return commands.first([
                    () => commands.exitCode(),
                    () => commands.command(() => {
                        const { selection, storedMarks } = state;
                        if (selection.$from.parent.type.spec.isolating) {
                            return false;
                        }
                        const { keepMarks } = this.options;
                        const { splittableMarks } = editor.extensionManager;
                        const marks = storedMarks
                            || (selection.$to.parentOffset && selection.$from.marks());
                        return chain()
                            .insertContent({ type: this.name })
                            .command(({ tr, dispatch }) => {
                            if (dispatch && marks && keepMarks) {
                                const filteredMarks = marks
                                    .filter(mark => splittableMarks.includes(mark.type.name));
                                tr.ensureMarks(filteredMarks);
                            }
                            return true;
                        })
                            .run();
                    }),
                ]);
            },
        };
    },
    addKeyboardShortcuts() {
        return {
            'Mod-Enter': () => this.editor.commands.setHardBreak(),
            'Shift-Enter': () => this.editor.commands.setHardBreak(),
        };
    },
});

const inputRegex$5 = /(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/;
const Image$1 = Node.create({
    name: 'image',
    addOptions() {
        return {
            inline: false,
            allowBase64: false,
            HTMLAttributes: {},
        };
    },
    inline() {
        return this.options.inline;
    },
    group() {
        return this.options.inline ? 'inline' : 'block';
    },
    draggable: true,
    addAttributes() {
        return {
            src: {
                default: null,
            },
            alt: {
                default: null,
            },
            title: {
                default: null,
            },
        };
    },
    parseHTML() {
        return [
            {
                tag: this.options.allowBase64
                    ? 'img[src]'
                    : 'img[src]:not([src^="data:"])',
            },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['img', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
    },
    addCommands() {
        return {
            setImage: options => ({ commands }) => {
                return commands.insertContent({
                    type: this.name,
                    attrs: options,
                });
            },
        };
    },
    addInputRules() {
        return [
            nodeInputRule({
                find: inputRegex$5,
                type: this.type,
                getAttributes: match => {
                    const [, , alt, src, title] = match;
                    return { src, alt, title };
                },
            }),
        ];
    },
});

/**
 * Finite State Machine generation utilities
 */

/**
 * Define a basic state machine state. j is the list of character transitions,
 * jr is the list of regex-match transitions, jd is the default state to
 * transition to t is the accepting token type, if any. If this is the terminal
 * state, then it does not emit a token.
 * @param {string|class} token to emit
 */
function State(token) {
  this.j = {}; // IMPLEMENTATION 1
  // this.j = []; // IMPLEMENTATION 2

  this.jr = [];
  this.jd = null;
  this.t = token;
}
/**
 * Take the transition from this state to the next one on the given input.
 * If this state does not exist deterministically, will create it.
 *
 * @param {string} input character or token to transition on
 * @param {string|class} [token] token or multi-token to emit when reaching
 * this state
 */

State.prototype = {
  /**
   * @param {State} state
   */
  accepts: function accepts() {
    return !!this.t;
  },

  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * @param {string} input character or token to transition on
   * @param {Token|State} tokenOrState transition to a matching state
   * @returns State taken after the given input
   */
  tt: function tt(input, tokenOrState) {
    if (tokenOrState && tokenOrState.j) {
      // State, default a basic transition
      this.j[input] = tokenOrState;
      return tokenOrState;
    } // See if there's a direct state transition (not regex or default)


    var token = tokenOrState;
    var nextState = this.j[input];

    if (nextState) {
      if (token) {
        nextState.t = token;
      } // overrwites previous token


      return nextState;
    } // Create a new state for this input


    nextState = makeState(); // Take the transition using the usual default mechanisms

    var templateState = takeT(this, input);

    if (templateState) {
      // Some default state transition, make a prime state based on this one
      Object.assign(nextState.j, templateState.j);
      nextState.jr.append(templateState.jr);
      nextState.jr = templateState.jd;
      nextState.t = token || templateState.t;
    } else {
      nextState.t = token;
    }

    this.j[input] = nextState;
    return nextState;
  }
};
/**
 * Utility function to create state without using new keyword (reduced file size
 * when minified)
 */

var makeState = function makeState() {
  return new State();
};
/**
 * Similar to previous except it is an accepting state that emits a token
 * @param {Token} token
 */

var makeAcceptingState = function makeAcceptingState(token) {
  return new State(token);
};
/**
 * Create a transition from startState to nextState via the given character
 * @param {State} startState transition from thie starting state
 * @param {Token} input via this input character or other concrete token type
 * @param {State} nextState to this next state
 */

var makeT = function makeT(startState, input, nextState) {
  // IMPLEMENTATION 1: Add to object (fast)
  if (!startState.j[input]) {
    startState.j[input] = nextState;
  } // IMPLEMENTATION 2: Add to array (slower)
  // startState.j.push([input, nextState]);

};
/**
 *
 * @param {State} startState stransition from this starting state
 * @param {RegExp} regex Regular expression to match on input
 * @param {State} nextState transition to this next state if there's are regex match
 */

var makeRegexT = function makeRegexT(startState, regex, nextState) {
  startState.jr.push([regex, nextState]);
};
/**
 * Follow the transition from the given character to the next state
 * @param {State} state
 * @param {Token} input character or other concrete token type to transition
 * @returns {?State} the next state, if any
 */

var takeT = function takeT(state, input) {
  // IMPLEMENTATION 1: Object key lookup (faster)
  var nextState = state.j[input];

  if (nextState) {
    return nextState;
  } // IMPLEMENTATION 2: List lookup (slower)
  // Loop through all the state transitions and see if there's a match
  // for (let i = 0; i < state.j.length; i++) {
  //	const val = state.j[i][0];
  //	const nextState = state.j[i][1];
  // 	if (input === val) { return nextState; }
  // }


  for (var i = 0; i < state.jr.length; i++) {
    var regex = state.jr[i][0];
    var _nextState = state.jr[i][1];

    if (regex.test(input)) {
      return _nextState;
    }
  } // Nowhere left to jump! Return default, if any


  return state.jd;
};
/**
 * Similar to makeT, but takes a list of characters that all transition to the
 * same nextState startState
 * @param {State} startState
 * @param {Array} chars
 * @param {State} nextState
 */

var makeMultiT = function makeMultiT(startState, chars, nextState) {
  for (var i = 0; i < chars.length; i++) {
    makeT(startState, chars[i], nextState);
  }
};
/**
 * Set up a list of multiple transitions at once. transitions is a list of
 * tuples, where the first element is the transitions character and the second
 * is the state to transition to
 * @param {State} startState
 * @param {Array} transitions
 */

var makeBatchT = function makeBatchT(startState, transitions) {
  for (var i = 0; i < transitions.length; i++) {
    var input = transitions[i][0];
    var nextState = transitions[i][1];
    makeT(startState, input, nextState);
  }
};
/**
 * For state machines that transition on characters only; given a non-empty
 * target string, generates states (if required) for each consecutive substring
 * of characters starting from the beginning of the string. The final state will
 * have a special value, as specified in options. All other "in between"
 * substrings will have a default end state.
 *
 * This turns the state machine into a Trie-like data structure (rather than a
 * intelligently-designed DFA).
 * @param {State} state
 * @param {string} str
 * @param {Token} endStateFactory
 * @param {Token} defaultStateFactory
 */

var makeChainT = function makeChainT(state, str, endState, defaultStateFactory) {
  var i = 0,
      len = str.length,
      nextState; // Find the next state without a jump to the next character

  while (i < len && (nextState = state.j[str[i]])) {
    state = nextState;
    i++;
  }

  if (i >= len) {
    return [];
  } // no new tokens were added


  while (i < len - 1) {
    nextState = defaultStateFactory();
    makeT(state, str[i], nextState);
    state = nextState;
    i++;
  }

  makeT(state, str[len - 1], endState);
};

/******************************************************************************
	Text Tokens
	Tokens composed of strings
******************************************************************************/
// A valid web domain token
var DOMAIN = 'DOMAIN';
var LOCALHOST = 'LOCALHOST'; // special case of domain
// Valid top-level domain (see tlds.js)

var TLD = 'TLD'; // Any sequence of digits 0-9

var NUM = 'NUM'; // A web URL protocol. Supported types include
// - `http:`
// - `https:`
// - `ftp:`
// - `ftps:`
// - user-defined custom protocols

var PROTOCOL = 'PROTOCOL'; // Start of the email URI protocol

var MAILTO = 'MAILTO'; // mailto:
// Any number of consecutive whitespace characters that are not newline

var WS = 'WS'; // New line (unix style)

var NL = 'NL'; // \n
// Opening/closing bracket classes

var OPENBRACE = 'OPENBRACE'; // {

var OPENBRACKET = 'OPENBRACKET'; // [

var OPENANGLEBRACKET = 'OPENANGLEBRACKET'; // <

var OPENPAREN = 'OPENPAREN'; // (

var CLOSEBRACE = 'CLOSEBRACE'; // }

var CLOSEBRACKET = 'CLOSEBRACKET'; // ]

var CLOSEANGLEBRACKET = 'CLOSEANGLEBRACKET'; // >

var CLOSEPAREN = 'CLOSEPAREN'; // )
// Various symbols

var AMPERSAND = 'AMPERSAND'; // &

var APOSTROPHE = 'APOSTROPHE'; // '

var ASTERISK = 'ASTERISK'; // *

var AT = 'AT'; // @

var BACKSLASH = 'BACKSLASH'; // \

var BACKTICK = 'BACKTICK'; // `

var CARET = 'CARET'; // ^

var COLON = 'COLON'; // :

var COMMA = 'COMMA'; // ,

var DOLLAR = 'DOLLAR'; // $

var DOT = 'DOT'; // .

var EQUALS = 'EQUALS'; // =

var EXCLAMATION = 'EXCLAMATION'; // !

var HYPHEN = 'HYPHEN'; // -

var PERCENT = 'PERCENT'; // %

var PIPE = 'PIPE'; // |

var PLUS = 'PLUS'; // +

var POUND = 'POUND'; // #

var QUERY = 'QUERY'; // ?

var QUOTE = 'QUOTE'; // "

var SEMI = 'SEMI'; // ;

var SLASH = 'SLASH'; // /

var TILDE = 'TILDE'; // ~

var UNDERSCORE = 'UNDERSCORE'; // _
// Default token - anything that is not one of the above

var SYM = 'SYM';

var text = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DOMAIN: DOMAIN,
	LOCALHOST: LOCALHOST,
	TLD: TLD,
	NUM: NUM,
	PROTOCOL: PROTOCOL,
	MAILTO: MAILTO,
	WS: WS,
	NL: NL,
	OPENBRACE: OPENBRACE,
	OPENBRACKET: OPENBRACKET,
	OPENANGLEBRACKET: OPENANGLEBRACKET,
	OPENPAREN: OPENPAREN,
	CLOSEBRACE: CLOSEBRACE,
	CLOSEBRACKET: CLOSEBRACKET,
	CLOSEANGLEBRACKET: CLOSEANGLEBRACKET,
	CLOSEPAREN: CLOSEPAREN,
	AMPERSAND: AMPERSAND,
	APOSTROPHE: APOSTROPHE,
	ASTERISK: ASTERISK,
	AT: AT,
	BACKSLASH: BACKSLASH,
	BACKTICK: BACKTICK,
	CARET: CARET,
	COLON: COLON,
	COMMA: COMMA,
	DOLLAR: DOLLAR,
	DOT: DOT,
	EQUALS: EQUALS,
	EXCLAMATION: EXCLAMATION,
	HYPHEN: HYPHEN,
	PERCENT: PERCENT,
	PIPE: PIPE,
	PLUS: PLUS,
	POUND: POUND,
	QUERY: QUERY,
	QUOTE: QUOTE,
	SEMI: SEMI,
	SLASH: SLASH,
	TILDE: TILDE,
	UNDERSCORE: UNDERSCORE,
	SYM: SYM
});

// NOTE: punycode versions of IDNs are not included here because these will not
// be as commonly used without the http prefix anyway and linkify will already
// force-encode those.
// To be updated with the values in this list
// http://data.iana.org/TLD/tlds-alpha-by-domain.txt
// Version 2021022800, Last Updated Sun Feb 28 07:07:01 2021 UTC
var tlds = 'aaa \
aarp \
abarth \
abb \
abbott \
abbvie \
abc \
able \
abogado \
abudhabi \
ac \
academy \
accenture \
accountant \
accountants \
aco \
actor \
ad \
adac \
ads \
adult \
ae \
aeg \
aero \
aetna \
af \
afamilycompany \
afl \
africa \
ag \
agakhan \
agency \
ai \
aig \
airbus \
airforce \
airtel \
akdn \
al \
alfaromeo \
alibaba \
alipay \
allfinanz \
allstate \
ally \
alsace \
alstom \
am \
amazon \
americanexpress \
americanfamily \
amex \
amfam \
amica \
amsterdam \
analytics \
android \
anquan \
anz \
ao \
aol \
apartments \
app \
apple \
aq \
aquarelle \
ar \
arab \
aramco \
archi \
army \
arpa \
art \
arte \
as \
asda \
asia \
associates \
at \
athleta \
attorney \
au \
auction \
audi \
audible \
audio \
auspost \
author \
auto \
autos \
avianca \
aw \
aws \
ax \
axa \
az \
azure \
ba \
baby \
baidu \
banamex \
bananarepublic \
band \
bank \
bar \
barcelona \
barclaycard \
barclays \
barefoot \
bargains \
baseball \
basketball \
bauhaus \
bayern \
bb \
bbc \
bbt \
bbva \
bcg \
bcn \
bd \
be \
beats \
beauty \
beer \
bentley \
berlin \
best \
bestbuy \
bet \
bf \
bg \
bh \
bharti \
bi \
bible \
bid \
bike \
bing \
bingo \
bio \
biz \
bj \
black \
blackfriday \
blockbuster \
blog \
bloomberg \
blue \
bm \
bms \
bmw \
bn \
bnpparibas \
bo \
boats \
boehringer \
bofa \
bom \
bond \
boo \
book \
booking \
bosch \
bostik \
boston \
bot \
boutique \
box \
br \
bradesco \
bridgestone \
broadway \
broker \
brother \
brussels \
bs \
bt \
budapest \
bugatti \
build \
builders \
business \
buy \
buzz \
bv \
bw \
by \
bz \
bzh \
ca \
cab \
cafe \
cal \
call \
calvinklein \
cam \
camera \
camp \
cancerresearch \
canon \
capetown \
capital \
capitalone \
car \
caravan \
cards \
care \
career \
careers \
cars \
casa \
case \
cash \
casino \
cat \
catering \
catholic \
cba \
cbn \
cbre \
cbs \
cc \
cd \
center \
ceo \
cern \
cf \
cfa \
cfd \
cg \
ch \
chanel \
channel \
charity \
chase \
chat \
cheap \
chintai \
christmas \
chrome \
church \
ci \
cipriani \
circle \
cisco \
citadel \
citi \
citic \
city \
cityeats \
ck \
cl \
claims \
cleaning \
click \
clinic \
clinique \
clothing \
cloud \
club \
clubmed \
cm \
cn \
co \
coach \
codes \
coffee \
college \
cologne \
com \
comcast \
commbank \
community \
company \
compare \
computer \
comsec \
condos \
construction \
consulting \
contact \
contractors \
cooking \
cookingchannel \
cool \
coop \
corsica \
country \
coupon \
coupons \
courses \
cpa \
cr \
credit \
creditcard \
creditunion \
cricket \
crown \
crs \
cruise \
cruises \
csc \
cu \
cuisinella \
cv \
cw \
cx \
cy \
cymru \
cyou \
cz \
dabur \
dad \
dance \
data \
date \
dating \
datsun \
day \
dclk \
dds \
de \
deal \
dealer \
deals \
degree \
delivery \
dell \
deloitte \
delta \
democrat \
dental \
dentist \
desi \
design \
dev \
dhl \
diamonds \
diet \
digital \
direct \
directory \
discount \
discover \
dish \
diy \
dj \
dk \
dm \
dnp \
do \
docs \
doctor \
dog \
domains \
dot \
download \
drive \
dtv \
dubai \
duck \
dunlop \
dupont \
durban \
dvag \
dvr \
dz \
earth \
eat \
ec \
eco \
edeka \
edu \
education \
ee \
eg \
email \
emerck \
energy \
engineer \
engineering \
enterprises \
epson \
equipment \
er \
ericsson \
erni \
es \
esq \
estate \
et \
etisalat \
eu \
eurovision \
eus \
events \
exchange \
expert \
exposed \
express \
extraspace \
fage \
fail \
fairwinds \
faith \
family \
fan \
fans \
farm \
farmers \
fashion \
fast \
fedex \
feedback \
ferrari \
ferrero \
fi \
fiat \
fidelity \
fido \
film \
final \
finance \
financial \
fire \
firestone \
firmdale \
fish \
fishing \
fit \
fitness \
fj \
fk \
flickr \
flights \
flir \
florist \
flowers \
fly \
fm \
fo \
foo \
food \
foodnetwork \
football \
ford \
forex \
forsale \
forum \
foundation \
fox \
fr \
free \
fresenius \
frl \
frogans \
frontdoor \
frontier \
ftr \
fujitsu \
fujixerox \
fun \
fund \
furniture \
futbol \
fyi \
ga \
gal \
gallery \
gallo \
gallup \
game \
games \
gap \
garden \
gay \
gb \
gbiz \
gd \
gdn \
ge \
gea \
gent \
genting \
george \
gf \
gg \
ggee \
gh \
gi \
gift \
gifts \
gives \
giving \
gl \
glade \
glass \
gle \
global \
globo \
gm \
gmail \
gmbh \
gmo \
gmx \
gn \
godaddy \
gold \
goldpoint \
golf \
goo \
goodyear \
goog \
google \
gop \
got \
gov \
gp \
gq \
gr \
grainger \
graphics \
gratis \
green \
gripe \
grocery \
group \
gs \
gt \
gu \
guardian \
gucci \
guge \
guide \
guitars \
guru \
gw \
gy \
hair \
hamburg \
hangout \
haus \
hbo \
hdfc \
hdfcbank \
health \
healthcare \
help \
helsinki \
here \
hermes \
hgtv \
hiphop \
hisamitsu \
hitachi \
hiv \
hk \
hkt \
hm \
hn \
hockey \
holdings \
holiday \
homedepot \
homegoods \
homes \
homesense \
honda \
horse \
hospital \
host \
hosting \
hot \
hoteles \
hotels \
hotmail \
house \
how \
hr \
hsbc \
ht \
hu \
hughes \
hyatt \
hyundai \
ibm \
icbc \
ice \
icu \
id \
ie \
ieee \
ifm \
ikano \
il \
im \
imamat \
imdb \
immo \
immobilien \
in \
inc \
industries \
infiniti \
info \
ing \
ink \
institute \
insurance \
insure \
int \
international \
intuit \
investments \
io \
ipiranga \
iq \
ir \
irish \
is \
ismaili \
ist \
istanbul \
it \
itau \
itv \
iveco \
jaguar \
java \
jcb \
je \
jeep \
jetzt \
jewelry \
jio \
jll \
jm \
jmp \
jnj \
jo \
jobs \
joburg \
jot \
joy \
jp \
jpmorgan \
jprs \
juegos \
juniper \
kaufen \
kddi \
ke \
kerryhotels \
kerrylogistics \
kerryproperties \
kfh \
kg \
kh \
ki \
kia \
kim \
kinder \
kindle \
kitchen \
kiwi \
km \
kn \
koeln \
komatsu \
kosher \
kp \
kpmg \
kpn \
kr \
krd \
kred \
kuokgroup \
kw \
ky \
kyoto \
kz \
la \
lacaixa \
lamborghini \
lamer \
lancaster \
lancia \
land \
landrover \
lanxess \
lasalle \
lat \
latino \
latrobe \
law \
lawyer \
lb \
lc \
lds \
lease \
leclerc \
lefrak \
legal \
lego \
lexus \
lgbt \
li \
lidl \
life \
lifeinsurance \
lifestyle \
lighting \
like \
lilly \
limited \
limo \
lincoln \
linde \
link \
lipsy \
live \
living \
lixil \
lk \
llc \
llp \
loan \
loans \
locker \
locus \
loft \
lol \
london \
lotte \
lotto \
love \
lpl \
lplfinancial \
lr \
ls \
lt \
ltd \
ltda \
lu \
lundbeck \
luxe \
luxury \
lv \
ly \
ma \
macys \
madrid \
maif \
maison \
makeup \
man \
management \
mango \
map \
market \
marketing \
markets \
marriott \
marshalls \
maserati \
mattel \
mba \
mc \
mckinsey \
md \
me \
med \
media \
meet \
melbourne \
meme \
memorial \
men \
menu \
merckmsd \
mg \
mh \
miami \
microsoft \
mil \
mini \
mint \
mit \
mitsubishi \
mk \
ml \
mlb \
mls \
mm \
mma \
mn \
mo \
mobi \
mobile \
moda \
moe \
moi \
mom \
monash \
money \
monster \
mormon \
mortgage \
moscow \
moto \
motorcycles \
mov \
movie \
mp \
mq \
mr \
ms \
msd \
mt \
mtn \
mtr \
mu \
museum \
mutual \
mv \
mw \
mx \
my \
mz \
na \
nab \
nagoya \
name \
nationwide \
natura \
navy \
nba \
nc \
ne \
nec \
net \
netbank \
netflix \
network \
neustar \
new \
news \
next \
nextdirect \
nexus \
nf \
nfl \
ng \
ngo \
nhk \
ni \
nico \
nike \
nikon \
ninja \
nissan \
nissay \
nl \
no \
nokia \
northwesternmutual \
norton \
now \
nowruz \
nowtv \
np \
nr \
nra \
nrw \
ntt \
nu \
nyc \
nz \
obi \
observer \
off \
office \
okinawa \
olayan \
olayangroup \
oldnavy \
ollo \
om \
omega \
one \
ong \
onl \
online \
onyourside \
ooo \
open \
oracle \
orange \
org \
organic \
origins \
osaka \
otsuka \
ott \
ovh \
pa \
page \
panasonic \
paris \
pars \
partners \
parts \
party \
passagens \
pay \
pccw \
pe \
pet \
pf \
pfizer \
pg \
ph \
pharmacy \
phd \
philips \
phone \
photo \
photography \
photos \
physio \
pics \
pictet \
pictures \
pid \
pin \
ping \
pink \
pioneer \
pizza \
pk \
pl \
place \
play \
playstation \
plumbing \
plus \
pm \
pn \
pnc \
pohl \
poker \
politie \
porn \
post \
pr \
pramerica \
praxi \
press \
prime \
pro \
prod \
productions \
prof \
progressive \
promo \
properties \
property \
protection \
pru \
prudential \
ps \
pt \
pub \
pw \
pwc \
py \
qa \
qpon \
quebec \
quest \
qvc \
racing \
radio \
raid \
re \
read \
realestate \
realtor \
realty \
recipes \
red \
redstone \
redumbrella \
rehab \
reise \
reisen \
reit \
reliance \
ren \
rent \
rentals \
repair \
report \
republican \
rest \
restaurant \
review \
reviews \
rexroth \
rich \
richardli \
ricoh \
ril \
rio \
rip \
rmit \
ro \
rocher \
rocks \
rodeo \
rogers \
room \
rs \
rsvp \
ru \
rugby \
ruhr \
run \
rw \
rwe \
ryukyu \
sa \
saarland \
safe \
safety \
sakura \
sale \
salon \
samsclub \
samsung \
sandvik \
sandvikcoromant \
sanofi \
sap \
sarl \
sas \
save \
saxo \
sb \
sbi \
sbs \
sc \
sca \
scb \
schaeffler \
schmidt \
scholarships \
school \
schule \
schwarz \
science \
scjohnson \
scot \
sd \
se \
search \
seat \
secure \
security \
seek \
select \
sener \
services \
ses \
seven \
sew \
sex \
sexy \
sfr \
sg \
sh \
shangrila \
sharp \
shaw \
shell \
shia \
shiksha \
shoes \
shop \
shopping \
shouji \
show \
showtime \
si \
silk \
sina \
singles \
site \
sj \
sk \
ski \
skin \
sky \
skype \
sl \
sling \
sm \
smart \
smile \
sn \
sncf \
so \
soccer \
social \
softbank \
software \
sohu \
solar \
solutions \
song \
sony \
soy \
spa \
space \
sport \
spot \
spreadbetting \
sr \
srl \
ss \
st \
stada \
staples \
star \
statebank \
statefarm \
stc \
stcgroup \
stockholm \
storage \
store \
stream \
studio \
study \
style \
su \
sucks \
supplies \
supply \
support \
surf \
surgery \
suzuki \
sv \
swatch \
swiftcover \
swiss \
sx \
sy \
sydney \
systems \
sz \
tab \
taipei \
talk \
taobao \
target \
tatamotors \
tatar \
tattoo \
tax \
taxi \
tc \
tci \
td \
tdk \
team \
tech \
technology \
tel \
temasek \
tennis \
teva \
tf \
tg \
th \
thd \
theater \
theatre \
tiaa \
tickets \
tienda \
tiffany \
tips \
tires \
tirol \
tj \
tjmaxx \
tjx \
tk \
tkmaxx \
tl \
tm \
tmall \
tn \
to \
today \
tokyo \
tools \
top \
toray \
toshiba \
total \
tours \
town \
toyota \
toys \
tr \
trade \
trading \
training \
travel \
travelchannel \
travelers \
travelersinsurance \
trust \
trv \
tt \
tube \
tui \
tunes \
tushu \
tv \
tvs \
tw \
tz \
ua \
ubank \
ubs \
ug \
uk \
unicom \
university \
uno \
uol \
ups \
us \
uy \
uz \
va \
vacations \
vana \
vanguard \
vc \
ve \
vegas \
ventures \
verisign \
versicherung \
vet \
vg \
vi \
viajes \
video \
vig \
viking \
villas \
vin \
vip \
virgin \
visa \
vision \
viva \
vivo \
vlaanderen \
vn \
vodka \
volkswagen \
volvo \
vote \
voting \
voto \
voyage \
vu \
vuelos \
wales \
walmart \
walter \
wang \
wanggou \
watch \
watches \
weather \
weatherchannel \
webcam \
weber \
website \
wed \
wedding \
weibo \
weir \
wf \
whoswho \
wien \
wiki \
williamhill \
win \
windows \
wine \
winners \
wme \
wolterskluwer \
woodside \
work \
works \
world \
wow \
ws \
wtc \
wtf \
xbox \
xerox \
xfinity \
xihuan \
xin \
xxx \
xyz \
yachts \
yahoo \
yamaxun \
yandex \
ye \
yodobashi \
yoga \
yokohama \
you \
youtube \
yt \
yun \
za \
zappos \
zara \
zero \
zip \
zm \
zone \
zuerich \
zw \
vermögensberater-ctb \
vermögensberatung-pwb \
ελ \
ευ \
бг \
бел \
дети \
ею \
католик \
ком \
қаз \
мкд \
мон \
москва \
онлайн \
орг \
рус \
рф \
сайт \
срб \
укр \
გე \
հայ \
ישראל \
קום \
ابوظبي \
اتصالات \
ارامكو \
الاردن \
البحرين \
الجزائر \
السعودية \
العليان \
المغرب \
امارات \
ایران \
بارت \
بازار \
بھارت \
بيتك \
پاکستان \
ڀارت \
تونس \
سودان \
سورية \
شبكة \
عراق \
عرب \
عمان \
فلسطين \
قطر \
كاثوليك \
كوم \
مصر \
مليسيا \
موريتانيا \
موقع \
همراه \
कॉम \
नेट \
भारत \
भारतम् \
भारोत \
संगठन \
বাংলা \
ভারত \
ভাৰত \
ਭਾਰਤ \
ભારત \
ଭାରତ \
இந்தியா \
இலங்கை \
சிங்கப்பூர் \
భారత్ \
ಭಾರತ \
ഭാരതം \
ලංකා \
คอม \
ไทย \
ລາວ \
닷넷 \
닷컴 \
삼성 \
한국 \
アマゾン \
グーグル \
クラウド \
コム \
ストア \
セール \
ファッション \
ポイント \
みんな \
世界 \
中信 \
中国 \
中國 \
中文网 \
亚马逊 \
企业 \
佛山 \
信息 \
健康 \
八卦 \
公司 \
公益 \
台湾 \
台灣 \
商城 \
商店 \
商标 \
嘉里 \
嘉里大酒店 \
在线 \
大众汽车 \
大拿 \
天主教 \
娱乐 \
家電 \
广东 \
微博 \
慈善 \
我爱你 \
手机 \
招聘 \
政务 \
政府 \
新加坡 \
新闻 \
时尚 \
書籍 \
机构 \
淡马锡 \
游戏 \
澳門 \
点看 \
移动 \
组织机构 \
网址 \
网店 \
网站 \
网络 \
联通 \
诺基亚 \
谷歌 \
购物 \
通販 \
集团 \
電訊盈科 \
飞利浦 \
食品 \
餐厅 \
香格里拉 \
香港'.split(' ');

/**
	The scanner provides an interface that takes a string of text as input, and
	outputs an array of tokens instances that can be used for easy URL parsing.

	@module linkify
	@submodule scanner
	@main scanner
*/

var LETTER = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/; // Any Unicode character with letter data type

var EMOJI = /(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDD-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6])/; // Any Unicode emoji character

var EMOJI_VARIATION = /\uFE0F/; // Variation selector, follows heart and others

var DIGIT = /\d/;
var SPACE = /\s/;
/**
 * Initialize the scanner character-based state machine for the given start state
 * @return {State} scanner starting state
 */

function init$2() {
  var customProtocols = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  // Frequently used states
  var S_START = makeState();
  var S_NUM = makeAcceptingState(NUM);
  var S_DOMAIN = makeAcceptingState(DOMAIN);
  var S_DOMAIN_HYPHEN = makeState(); // domain followed by 1 or more hyphen characters

  var S_WS = makeAcceptingState(WS);
  var DOMAIN_REGEX_TRANSITIONS = [[DIGIT, S_DOMAIN], [LETTER, S_DOMAIN], [EMOJI, S_DOMAIN], [EMOJI_VARIATION, S_DOMAIN]]; // Create a state which emits a domain token

  var makeDomainState = function makeDomainState() {
    var state = makeAcceptingState(DOMAIN);
    state.j = {
      '-': S_DOMAIN_HYPHEN
    };
    state.jr = [].concat(DOMAIN_REGEX_TRANSITIONS);
    return state;
  }; // Create a state which does not emit a domain state but the usual alphanumeric
  // transitions are domains


  var makeNearDomainState = function makeNearDomainState(token) {
    var state = makeDomainState();
    state.t = token;
    return state;
  }; // States for special URL symbols that accept immediately after start


  makeBatchT(S_START, [["'", makeAcceptingState(APOSTROPHE)], ['{', makeAcceptingState(OPENBRACE)], ['[', makeAcceptingState(OPENBRACKET)], ['<', makeAcceptingState(OPENANGLEBRACKET)], ['(', makeAcceptingState(OPENPAREN)], ['}', makeAcceptingState(CLOSEBRACE)], [']', makeAcceptingState(CLOSEBRACKET)], ['>', makeAcceptingState(CLOSEANGLEBRACKET)], [')', makeAcceptingState(CLOSEPAREN)], ['&', makeAcceptingState(AMPERSAND)], ['*', makeAcceptingState(ASTERISK)], ['@', makeAcceptingState(AT)], ['`', makeAcceptingState(BACKTICK)], ['^', makeAcceptingState(CARET)], [':', makeAcceptingState(COLON)], [',', makeAcceptingState(COMMA)], ['$', makeAcceptingState(DOLLAR)], ['.', makeAcceptingState(DOT)], ['=', makeAcceptingState(EQUALS)], ['!', makeAcceptingState(EXCLAMATION)], ['-', makeAcceptingState(HYPHEN)], ['%', makeAcceptingState(PERCENT)], ['|', makeAcceptingState(PIPE)], ['+', makeAcceptingState(PLUS)], ['#', makeAcceptingState(POUND)], ['?', makeAcceptingState(QUERY)], ['"', makeAcceptingState(QUOTE)], ['/', makeAcceptingState(SLASH)], [';', makeAcceptingState(SEMI)], ['~', makeAcceptingState(TILDE)], ['_', makeAcceptingState(UNDERSCORE)], ['\\', makeAcceptingState(BACKSLASH)]]); // Whitespace jumps
  // Tokens of only non-newline whitespace are arbitrarily long

  makeT(S_START, '\n', makeAcceptingState(NL));
  makeRegexT(S_START, SPACE, S_WS); // If any whitespace except newline, more whitespace!

  makeT(S_WS, '\n', makeState()); // non-accepting state

  makeRegexT(S_WS, SPACE, S_WS); // Generates states for top-level domains
  // Note that this is most accurate when tlds are in alphabetical order

  for (var i = 0; i < tlds.length; i++) {
    makeChainT(S_START, tlds[i], makeNearDomainState(TLD), makeDomainState);
  } // Collect the states generated by different protocls


  var S_PROTOCOL_FILE = makeDomainState();
  var S_PROTOCOL_FTP = makeDomainState();
  var S_PROTOCOL_HTTP = makeDomainState();
  var S_MAILTO = makeDomainState();
  makeChainT(S_START, 'file', S_PROTOCOL_FILE, makeDomainState);
  makeChainT(S_START, 'ftp', S_PROTOCOL_FTP, makeDomainState);
  makeChainT(S_START, 'http', S_PROTOCOL_HTTP, makeDomainState);
  makeChainT(S_START, 'mailto', S_MAILTO, makeDomainState); // Protocol states

  var S_PROTOCOL_SECURE = makeDomainState();
  var S_FULL_PROTOCOL = makeAcceptingState(PROTOCOL); // Full protocol ends with COLON

  var S_FULL_MAILTO = makeAcceptingState(MAILTO); // Mailto ends with COLON
  // Secure protocols (end with 's')

  makeT(S_PROTOCOL_FTP, 's', S_PROTOCOL_SECURE);
  makeT(S_PROTOCOL_FTP, ':', S_FULL_PROTOCOL);
  makeT(S_PROTOCOL_HTTP, 's', S_PROTOCOL_SECURE);
  makeT(S_PROTOCOL_HTTP, ':', S_FULL_PROTOCOL); // Become protocol tokens after a COLON

  makeT(S_PROTOCOL_FILE, ':', S_FULL_PROTOCOL);
  makeT(S_PROTOCOL_SECURE, ':', S_FULL_PROTOCOL);
  makeT(S_MAILTO, ':', S_FULL_MAILTO); // Register custom protocols

  var S_CUSTOM_PROTOCOL = makeDomainState();

  for (var _i = 0; _i < customProtocols.length; _i++) {
    makeChainT(S_START, customProtocols[_i], S_CUSTOM_PROTOCOL, makeDomainState);
  }

  makeT(S_CUSTOM_PROTOCOL, ':', S_FULL_PROTOCOL); // Localhost

  makeChainT(S_START, 'localhost', makeNearDomainState(LOCALHOST), makeDomainState); // Everything else
  // DOMAINs make more DOMAINs
  // Number and character transitions

  makeRegexT(S_START, DIGIT, S_NUM);
  makeRegexT(S_START, LETTER, S_DOMAIN);
  makeRegexT(S_START, EMOJI, S_DOMAIN);
  makeRegexT(S_START, EMOJI_VARIATION, S_DOMAIN);
  makeRegexT(S_NUM, DIGIT, S_NUM);
  makeRegexT(S_NUM, LETTER, S_DOMAIN); // number becomes DOMAIN

  makeRegexT(S_NUM, EMOJI, S_DOMAIN); // number becomes DOMAIN

  makeRegexT(S_NUM, EMOJI_VARIATION, S_DOMAIN); // number becomes DOMAIN

  makeT(S_NUM, '-', S_DOMAIN_HYPHEN); // Default domain transitions

  makeT(S_DOMAIN, '-', S_DOMAIN_HYPHEN);
  makeT(S_DOMAIN_HYPHEN, '-', S_DOMAIN_HYPHEN);
  makeRegexT(S_DOMAIN, DIGIT, S_DOMAIN);
  makeRegexT(S_DOMAIN, LETTER, S_DOMAIN);
  makeRegexT(S_DOMAIN, EMOJI, S_DOMAIN);
  makeRegexT(S_DOMAIN, EMOJI_VARIATION, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, DIGIT, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, LETTER, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, EMOJI, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, EMOJI_VARIATION, S_DOMAIN); // Set default transition for start state (some symbol)

  S_START.jd = makeAcceptingState(SYM);
  return S_START;
}
/**
	Given a string, returns an array of TOKEN instances representing the
	composition of that string.

	@method run
	@param {State} start scanner starting state
	@param {string} str input string to scan
	@return {{t: string, v: string, s: number, l: number}[]} list of tokens, each with a type and value
*/

function run$1(start, str) {
  // State machine is not case sensitive, so input is tokenized in lowercased
  // form (still returns the regular case though) Uses selective `toLowerCase`
  // is used because lowercasing the entire string causes the length and
  // character position to vary in some non-English strings with V8-based
  // runtimes.
  var iterable = stringToArray(str.replace(/[A-Z]/g, function (c) {
    return c.toLowerCase();
  }));
  var charCount = iterable.length; // <= len if there are emojis, etc

  var tokens = []; // return value
  // cursor through the string itself, accounting for characters that have
  // width with length 2 such as emojis

  var cursor = 0; // Cursor through the array-representation of the string

  var charCursor = 0; // Tokenize the string

  while (charCursor < charCount) {
    var state = start;
    var nextState = null;
    var tokenLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;
    var charsSinceAccepts = -1;

    while (charCursor < charCount && (nextState = takeT(state, iterable[charCursor]))) {
      state = nextState; // Keep track of the latest accepting state

      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }

      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    } // Roll back to the latest accepting state


    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts; // No more jumps, just make a new token from the last accepting one
    // TODO: If possible, don't output v, instead output range where values ocur

    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str.substr(cursor - tokenLength, tokenLength),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor // end index (excluding)

    });
  }

  return tokens;
}
/**
 * Convert a String to an Array of characters, taking into account that some
 * characters like emojis take up two string indexes.
 *
 * Adapted from core-js (MIT license)
 * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js
 *
 * @function stringToArray
 * @param {string} str
 * @returns {string[]}
 */

function stringToArray(str) {
  var result = [];
  var len = str.length;
  var index = 0;

  while (index < len) {
    var first = str.charCodeAt(index);
    var second = void 0;
    var char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character
    : str.slice(index, index + 2); // two-index characters

    result.push(char);
    index += char.length;
  }

  return result;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

/**
 * @property {string} defaultProtocol
 * @property {{[string]: (event) => void}]} [events]
 */
var defaults = {
  defaultProtocol: 'http',
  events: null,
  format: noop,
  formatHref: noop,
  nl2br: false,
  tagName: 'a',
  target: null,
  rel: null,
  validate: true,
  truncate: 0,
  className: null,
  attributes: null,
  ignoreTags: []
};
/**
 * @class Options
 * @param {Object} [opts] Set option properties besides the defaults
 */

function Options(opts) {
  opts = opts || {};
  this.defaultProtocol = 'defaultProtocol' in opts ? opts.defaultProtocol : defaults.defaultProtocol;
  this.events = 'events' in opts ? opts.events : defaults.events;
  this.format = 'format' in opts ? opts.format : defaults.format;
  this.formatHref = 'formatHref' in opts ? opts.formatHref : defaults.formatHref;
  this.nl2br = 'nl2br' in opts ? opts.nl2br : defaults.nl2br;
  this.tagName = 'tagName' in opts ? opts.tagName : defaults.tagName;
  this.target = 'target' in opts ? opts.target : defaults.target;
  this.rel = 'rel' in opts ? opts.rel : defaults.rel;
  this.validate = 'validate' in opts ? opts.validate : defaults.validate;
  this.truncate = 'truncate' in opts ? opts.truncate : defaults.truncate;
  this.className = 'className' in opts ? opts.className : defaults.className;
  this.attributes = opts.attributes || defaults.attributes;
  this.ignoreTags = []; // Make all tags names upper case

  var ignoredTags = 'ignoreTags' in opts ? opts.ignoreTags : defaults.ignoreTags;

  for (var i = 0; i < ignoredTags.length; i++) {
    this.ignoreTags.push(ignoredTags[i].toUpperCase());
  }
}
Options.prototype = {
  /**
   * Given the token, return all options for how it should be displayed
   */
  resolve: function resolve(token) {
    var href = token.toHref(this.defaultProtocol);
    return {
      formatted: this.get('format', token.toString(), token),
      formattedHref: this.get('formatHref', href, token),
      tagName: this.get('tagName', href, token),
      className: this.get('className', href, token),
      target: this.get('target', href, token),
      rel: this.get('rel', href, token),
      events: this.getObject('events', href, token),
      attributes: this.getObject('attributes', href, token),
      truncate: this.get('truncate', href, token)
    };
  },

  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options. By default,
   */
  check: function check(token) {
    return this.get('validate', token.toString(), token);
  },
  // Private methods

  /**
   * Resolve an option's value based on the value of the option and the given
   * params.
   * @param {string} key Name of option to use
   * @param operator will be passed to the target option if it's method
   * @param {MultiToken} token The token from linkify.tokenize
   */
  get: function get(key, operator, token) {
    var option = this[key];

    if (!option) {
      return option;
    }

    var optionValue;

    switch (_typeof(option)) {
      case 'function':
        return option(operator, token.t);

      case 'object':
        optionValue = token.t in option ? option[token.t] : defaults[key];
        return typeof optionValue === 'function' ? optionValue(operator, token.t) : optionValue;
    }

    return option;
  },
  getObject: function getObject(key, operator, token) {
    var option = this[key];
    return typeof option === 'function' ? option(operator, token.t) : option;
  }
};

function noop(val) {
  return val;
}

/******************************************************************************
	Multi-Tokens
	Tokens composed of arrays of TextTokens
******************************************************************************/

function inherits(parent, child) {
  var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var extended = Object.create(parent.prototype);

  for (var p in props) {
    extended[p] = props[p];
  }

  extended.constructor = child;
  child.prototype = extended;
  return child;
}
/**
	Abstract class used for manufacturing tokens of text tokens. That is rather
	than the value for a token being a small string of text, it's value an array
	of text tokens.

	Used for grouping together URLs, emails, hashtags, and other potential
	creations.

	@class MultiToken
	@param {string} value
	@param {{t: string, v: string, s: number, e: number}[]} tokens
	@abstract
*/


function MultiToken() {}
MultiToken.prototype = {
  /**
  	String representing the type for this token
  	@property t
  	@default 'token'
  */
  t: 'token',

  /**
  	Is this multitoken a link?
  	@property isLink
  	@default false
  */
  isLink: false,

  /**
  	Return the string this token represents.
  	@method toString
  	@return {string}
  */
  toString: function toString() {
    return this.v;
  },

  /**
  	What should the value for this token be in the `href` HTML attribute?
  	Returns the `.toString` value by default.
  		@method toHref
  	@return {string}
  */
  toHref: function toHref() {
    return this.toString();
  },

  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex: function startIndex() {
    return this.tk[0].s;
  },

  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex: function endIndex() {
    return this.tk[this.tk.length - 1].e;
  },

  /**
  	Returns a hash of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject: function toObject() {
    var protocol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaults.defaultProtocol;
    return {
      type: this.t,
      value: this.v,
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  }
}; // Base token
/**
 * Create a new token that can be emitted by the parser state machine
 * @param {string} type readable type of the token
 * @param {object} props properties to assign or override, including isLink = true or false
 * @returns {(value: string, tokens: {t: string, v: string, s: number, e: number}) => MultiToken} new token class
 */

function createTokenClass(type, props) {
  function Token(value, tokens) {
    this.t = type;
    this.v = value;
    this.tk = tokens;
  }

  inherits(MultiToken, Token, props);
  return Token;
}
/**
	Represents an arbitrarily mailto email address with the prefix included
	@class MailtoEmail
	@extends MultiToken
*/

var MailtoEmail = createTokenClass('email', {
  isLink: true
});
/**
	Represents a list of tokens making up a valid email address
	@class Email
	@extends MultiToken
*/

var Email = createTokenClass('email', {
  isLink: true,
  toHref: function toHref() {
    return 'mailto:' + this.toString();
  }
});
/**
	Represents some plain text
	@class Text
	@extends MultiToken
*/

var Text$1 = createTokenClass('text');
/**
	Multi-linebreak token - represents a line break
	@class Nl
	@extends MultiToken
*/

var Nl = createTokenClass('nl');
/**
	Represents a list of text tokens making up a valid URL
	@class Url
	@extends MultiToken
*/

var Url = createTokenClass('url', {
  isLink: true,

  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@method href
  	@param {string} protocol
  	@return {string}
  */
  toHref: function toHref() {
    var protocol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaults.defaultProtocol;
    var tokens = this.tk;
    var hasProtocol = false;
    var hasSlashSlash = false;
    var result = [];
    var i = 0; // Make the first part of the domain lowercase
    // Lowercase protocol

    while (tokens[i].t === PROTOCOL) {
      hasProtocol = true;
      result.push(tokens[i].v);
      i++;
    } // Skip slash-slash


    while (tokens[i].t === SLASH) {
      hasSlashSlash = true;
      result.push(tokens[i].v);
      i++;
    } // Continue pushing characters


    for (; i < tokens.length; i++) {
      result.push(tokens[i].v);
    }

    result = result.join('');

    if (!(hasProtocol || hasSlashSlash)) {
      result = "".concat(protocol, "://").concat(result);
    }

    return result;
  },
  hasProtocol: function hasProtocol() {
    return this.tk[0].t === PROTOCOL;
  }
});

var multi = /*#__PURE__*/Object.freeze({
	__proto__: null,
	MultiToken: MultiToken,
	Base: MultiToken,
	createTokenClass: createTokenClass,
	MailtoEmail: MailtoEmail,
	Email: Email,
	Text: Text$1,
	Nl: Nl,
	Url: Url
});

/**
	Not exactly parser, more like the second-stage scanner (although we can
	theoretically hotswap the code here with a real parser in the future... but
	for a little URL-finding utility abstract syntax trees may be a little
	overkill).

	URL format: http://en.wikipedia.org/wiki/URI_scheme
	Email format: http://en.wikipedia.org/wiki/Email_address (links to RFC in
	reference)

	@module linkify
	@submodule parser
	@main run
*/
/**
 * Generate the parser multi token-based state machine
 * @returns {State} the starting state
 */

function init$1() {
  // The universal starting state.
  var S_START = makeState(); // Intermediate states for URLs. Note that domains that begin with a protocol
  // are treated slighly differently from those that don't.

  var S_PROTOCOL = makeState(); // e.g., 'http:'

  var S_MAILTO = makeState(); // 'mailto:'

  var S_PROTOCOL_SLASH = makeState(); // e.g., 'http:/''

  var S_PROTOCOL_SLASH_SLASH = makeState(); // e.g.,'http://'

  var S_DOMAIN = makeState(); // parsed string ends with a potential domain name (A)

  var S_DOMAIN_DOT = makeState(); // (A) domain followed by DOT

  var S_TLD = makeAcceptingState(Url); // (A) Simplest possible URL with no query string

  var S_TLD_COLON = makeState(); // (A) URL followed by colon (potential port number here)

  var S_TLD_PORT = makeAcceptingState(Url); // TLD followed by a port number

  var S_URL = makeAcceptingState(Url); // Long URL with optional port and maybe query string

  var S_URL_NON_ACCEPTING = makeState(); // URL followed by some symbols (will not be part of the final URL)

  var S_URL_OPENBRACE = makeState(); // URL followed by {

  var S_URL_OPENBRACKET = makeState(); // URL followed by [

  var S_URL_OPENANGLEBRACKET = makeState(); // URL followed by <

  var S_URL_OPENPAREN = makeState(); // URL followed by (

  var S_URL_OPENBRACE_Q = makeAcceptingState(Url); // URL followed by { and some symbols that the URL can end it

  var S_URL_OPENBRACKET_Q = makeAcceptingState(Url); // URL followed by [ and some symbols that the URL can end it

  var S_URL_OPENANGLEBRACKET_Q = makeAcceptingState(Url); // URL followed by < and some symbols that the URL can end it

  var S_URL_OPENPAREN_Q = makeAcceptingState(Url); // URL followed by ( and some symbols that the URL can end it

  var S_URL_OPENBRACE_SYMS = makeState(); // S_URL_OPENBRACE_Q followed by some symbols it cannot end it

  var S_URL_OPENBRACKET_SYMS = makeState(); // S_URL_OPENBRACKET_Q followed by some symbols it cannot end it

  var S_URL_OPENANGLEBRACKET_SYMS = makeState(); // S_URL_OPENANGLEBRACKET_Q followed by some symbols it cannot end it

  var S_URL_OPENPAREN_SYMS = makeState(); // S_URL_OPENPAREN_Q followed by some symbols it cannot end it

  var S_EMAIL_DOMAIN = makeState(); // parsed string starts with local email info + @ with a potential domain name (C)

  var S_EMAIL_DOMAIN_DOT = makeState(); // (C) domain followed by DOT

  var S_EMAIL = makeAcceptingState(Email); // (C) Possible email address (could have more tlds)

  var S_EMAIL_COLON = makeState(); // (C) URL followed by colon (potential port number here)

  var S_EMAIL_PORT = makeAcceptingState(Email); // (C) Email address with a port

  var S_MAILTO_EMAIL = makeAcceptingState(MailtoEmail); // Email that begins with the mailto prefix (D)

  var S_MAILTO_EMAIL_NON_ACCEPTING = makeState(); // (D) Followed by some non-query string chars

  var S_LOCALPART = makeState(); // Local part of the email address

  var S_LOCALPART_AT = makeState(); // Local part of the email address plus @

  var S_LOCALPART_DOT = makeState(); // Local part of the email address plus '.' (localpart cannot end in .)

  var S_NL = makeAcceptingState(Nl); // single new line
  // Make path from start to protocol (with '//')

  makeT(S_START, NL, S_NL);
  makeT(S_START, PROTOCOL, S_PROTOCOL);
  makeT(S_START, MAILTO, S_MAILTO);
  makeT(S_PROTOCOL, SLASH, S_PROTOCOL_SLASH);
  makeT(S_PROTOCOL_SLASH, SLASH, S_PROTOCOL_SLASH_SLASH); // The very first potential domain name

  makeT(S_START, TLD, S_DOMAIN);
  makeT(S_START, DOMAIN, S_DOMAIN);
  makeT(S_START, LOCALHOST, S_TLD);
  makeT(S_START, NUM, S_DOMAIN); // Force URL for protocol followed by anything sane

  makeT(S_PROTOCOL_SLASH_SLASH, TLD, S_URL);
  makeT(S_PROTOCOL_SLASH_SLASH, DOMAIN, S_URL);
  makeT(S_PROTOCOL_SLASH_SLASH, NUM, S_URL);
  makeT(S_PROTOCOL_SLASH_SLASH, LOCALHOST, S_URL); // Account for dots and hyphens
  // hyphens are usually parts of domain names

  makeT(S_DOMAIN, DOT, S_DOMAIN_DOT);
  makeT(S_EMAIL_DOMAIN, DOT, S_EMAIL_DOMAIN_DOT); // Hyphen can jump back to a domain name
  // After the first domain and a dot, we can find either a URL or another domain

  makeT(S_DOMAIN_DOT, TLD, S_TLD);
  makeT(S_DOMAIN_DOT, DOMAIN, S_DOMAIN);
  makeT(S_DOMAIN_DOT, NUM, S_DOMAIN);
  makeT(S_DOMAIN_DOT, LOCALHOST, S_DOMAIN);
  makeT(S_EMAIL_DOMAIN_DOT, TLD, S_EMAIL);
  makeT(S_EMAIL_DOMAIN_DOT, DOMAIN, S_EMAIL_DOMAIN);
  makeT(S_EMAIL_DOMAIN_DOT, NUM, S_EMAIL_DOMAIN);
  makeT(S_EMAIL_DOMAIN_DOT, LOCALHOST, S_EMAIL_DOMAIN); // S_TLD accepts! But the URL could be longer, try to find a match greedily
  // The `run` function should be able to "rollback" to the accepting state

  makeT(S_TLD, DOT, S_DOMAIN_DOT);
  makeT(S_EMAIL, DOT, S_EMAIL_DOMAIN_DOT); // Become real URLs after `SLASH` or `COLON NUM SLASH`
  // Here PSS and non-PSS converge

  makeT(S_TLD, COLON, S_TLD_COLON);
  makeT(S_TLD, SLASH, S_URL);
  makeT(S_TLD_COLON, NUM, S_TLD_PORT);
  makeT(S_TLD_PORT, SLASH, S_URL);
  makeT(S_EMAIL, COLON, S_EMAIL_COLON);
  makeT(S_EMAIL_COLON, NUM, S_EMAIL_PORT); // Types of characters the URL can definitely end in

  var qsAccepting = [AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, DOMAIN, EQUALS, HYPHEN, LOCALHOST, NUM, PERCENT, PIPE, PLUS, POUND, PROTOCOL, SLASH, SYM, TILDE, TLD, UNDERSCORE]; // Types of tokens that can follow a URL and be part of the query string
  // but cannot be the very last characters
  // Characters that cannot appear in the URL at all should be excluded

  var qsNonAccepting = [APOSTROPHE, CLOSEANGLEBRACKET, CLOSEBRACE, CLOSEBRACKET, CLOSEPAREN, COLON, COMMA, DOT, EXCLAMATION, OPENANGLEBRACKET, OPENBRACE, OPENBRACKET, OPENPAREN, QUERY, QUOTE, SEMI]; // These states are responsible primarily for determining whether or not to
  // include the final round bracket.
  // URL, followed by an opening bracket

  makeT(S_URL, OPENBRACE, S_URL_OPENBRACE);
  makeT(S_URL, OPENBRACKET, S_URL_OPENBRACKET);
  makeT(S_URL, OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET);
  makeT(S_URL, OPENPAREN, S_URL_OPENPAREN); // URL with extra symbols at the end, followed by an opening bracket

  makeT(S_URL_NON_ACCEPTING, OPENBRACE, S_URL_OPENBRACE);
  makeT(S_URL_NON_ACCEPTING, OPENBRACKET, S_URL_OPENBRACKET);
  makeT(S_URL_NON_ACCEPTING, OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET);
  makeT(S_URL_NON_ACCEPTING, OPENPAREN, S_URL_OPENPAREN); // Closing bracket component. This character WILL be included in the URL

  makeT(S_URL_OPENBRACE, CLOSEBRACE, S_URL);
  makeT(S_URL_OPENBRACKET, CLOSEBRACKET, S_URL);
  makeT(S_URL_OPENANGLEBRACKET, CLOSEANGLEBRACKET, S_URL);
  makeT(S_URL_OPENPAREN, CLOSEPAREN, S_URL);
  makeT(S_URL_OPENBRACE_Q, CLOSEBRACE, S_URL);
  makeT(S_URL_OPENBRACKET_Q, CLOSEBRACKET, S_URL);
  makeT(S_URL_OPENANGLEBRACKET_Q, CLOSEANGLEBRACKET, S_URL);
  makeT(S_URL_OPENPAREN_Q, CLOSEPAREN, S_URL);
  makeT(S_URL_OPENBRACE_SYMS, CLOSEBRACE, S_URL);
  makeT(S_URL_OPENBRACKET_SYMS, CLOSEBRACKET, S_URL);
  makeT(S_URL_OPENANGLEBRACKET_SYMS, CLOSEANGLEBRACKET, S_URL);
  makeT(S_URL_OPENPAREN_SYMS, CLOSEPAREN, S_URL); // URL that beings with an opening bracket, followed by a symbols.
  // Note that the final state can still be `S_URL_OPENBRACE_Q` (if the URL only
  // has a single opening bracket for some reason).

  makeMultiT(S_URL_OPENBRACE, qsAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET, qsAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN, qsAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE, qsNonAccepting, S_URL_OPENBRACE_SYMS);
  makeMultiT(S_URL_OPENBRACKET, qsNonAccepting, S_URL_OPENBRACKET_SYMS);
  makeMultiT(S_URL_OPENANGLEBRACKET, qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
  makeMultiT(S_URL_OPENPAREN, qsNonAccepting, S_URL_OPENPAREN_SYMS); // URL that begins with an opening bracket, followed by some symbols

  makeMultiT(S_URL_OPENBRACE_Q, qsAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET_Q, qsAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET_Q, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN_Q, qsAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE_Q, qsNonAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET_Q, qsNonAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET_Q, qsNonAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN_Q, qsNonAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE_SYMS, qsAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET_SYMS, qsAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET_SYMS, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN_SYMS, qsAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE_SYMS, qsNonAccepting, S_URL_OPENBRACE_SYMS);
  makeMultiT(S_URL_OPENBRACKET_SYMS, qsNonAccepting, S_URL_OPENBRACKET_SYMS);
  makeMultiT(S_URL_OPENANGLEBRACKET_SYMS, qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
  makeMultiT(S_URL_OPENPAREN_SYMS, qsNonAccepting, S_URL_OPENPAREN_SYMS); // Account for the query string

  makeMultiT(S_URL, qsAccepting, S_URL);
  makeMultiT(S_URL_NON_ACCEPTING, qsAccepting, S_URL);
  makeMultiT(S_URL, qsNonAccepting, S_URL_NON_ACCEPTING);
  makeMultiT(S_URL_NON_ACCEPTING, qsNonAccepting, S_URL_NON_ACCEPTING); // Email address-specific state definitions
  // Note: We are not allowing '/' in email addresses since this would interfere
  // with real URLs
  // For addresses with the mailto prefix
  // 'mailto:' followed by anything sane is a valid email

  makeT(S_MAILTO, TLD, S_MAILTO_EMAIL);
  makeT(S_MAILTO, DOMAIN, S_MAILTO_EMAIL);
  makeT(S_MAILTO, NUM, S_MAILTO_EMAIL);
  makeT(S_MAILTO, LOCALHOST, S_MAILTO_EMAIL); // Greedily get more potential valid email values

  makeMultiT(S_MAILTO_EMAIL, qsAccepting, S_MAILTO_EMAIL);
  makeMultiT(S_MAILTO_EMAIL, qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
  makeMultiT(S_MAILTO_EMAIL_NON_ACCEPTING, qsAccepting, S_MAILTO_EMAIL);
  makeMultiT(S_MAILTO_EMAIL_NON_ACCEPTING, qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING); // For addresses without the mailto prefix
  // Tokens allowed in the localpart of the email

  var localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, CLOSEBRACE, DOLLAR, DOMAIN, EQUALS, HYPHEN, NUM, OPENBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, TLD, UNDERSCORE]; // Some of the tokens in `localpartAccepting` are already accounted for here and
  // will not be overwritten (don't worry)

  makeMultiT(S_DOMAIN, localpartAccepting, S_LOCALPART);
  makeT(S_DOMAIN, AT, S_LOCALPART_AT);
  makeMultiT(S_TLD, localpartAccepting, S_LOCALPART);
  makeT(S_TLD, AT, S_LOCALPART_AT);
  makeMultiT(S_DOMAIN_DOT, localpartAccepting, S_LOCALPART); // Now in localpart of address
  // TODO: IP addresses and what if the email starts with numbers?

  makeMultiT(S_LOCALPART, localpartAccepting, S_LOCALPART);
  makeT(S_LOCALPART, AT, S_LOCALPART_AT); // close to an email address now

  makeT(S_LOCALPART, DOT, S_LOCALPART_DOT);
  makeMultiT(S_LOCALPART_DOT, localpartAccepting, S_LOCALPART);
  makeT(S_LOCALPART_AT, TLD, S_EMAIL_DOMAIN);
  makeT(S_LOCALPART_AT, DOMAIN, S_EMAIL_DOMAIN);
  makeT(S_LOCALPART_AT, NUM, S_EMAIL_DOMAIN);
  makeT(S_LOCALPART_AT, LOCALHOST, S_EMAIL); // States following `@` defined above

  return S_START;
}
/**
 * Run the parser state machine on a list of scanned string-based tokens to
 * create a list of multi tokens, each of which represents a URL, email address,
 * plain text, etc.
 *
 * @param {State} start parser start state
 * @param {string} input the original input used to generate the given tokens
 * @param {{t: string, v: string, s: number, e: number}[]} tokens list of scanned tokens
 * @returns {MultiToken[]}
 */

function run(start, input, tokens) {
  var len = tokens.length;
  var cursor = 0;
  var multis = [];
  var textTokens = [];

  while (cursor < len) {
    var state = start;
    var secondState = null;
    var nextState = null;
    var multiLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;

    while (cursor < len && !(secondState = takeT(state, tokens[cursor].t))) {
      // Starting tokens with nowhere to jump to.
      // Consider these to be just plain text
      textTokens.push(tokens[cursor++]);
    }

    while (cursor < len && (nextState = secondState || takeT(state, tokens[cursor].t))) {
      // Get the next state
      secondState = null;
      state = nextState; // Keep track of the latest accepting state

      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }

      cursor++;
      multiLength++;
    }

    if (sinceAccepts < 0) {
      // No accepting state was found, part of a regular text token
      // Add all the tokens we looked at to the text tokens array
      for (var i = cursor - multiLength; i < cursor; i++) {
        textTokens.push(tokens[i]);
      }
    } else {
      // Accepting state!
      // First close off the textTokens (if available)
      if (textTokens.length > 0) {
        multis.push(parserCreateMultiToken(Text$1, input, textTokens));
        textTokens = [];
      } // Roll back to the latest accepting state


      cursor -= sinceAccepts;
      multiLength -= sinceAccepts; // Create a new multitoken

      var Multi = latestAccepting.t;
      var subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(parserCreateMultiToken(Multi, input, subtokens));
    }
  } // Finally close off the textTokens (if available)


  if (textTokens.length > 0) {
    multis.push(parserCreateMultiToken(Text$1, input, textTokens));
  }

  return multis;
}
/**
 * Utility function for instantiating a new multitoken with all the relevant
 * fields during parsing.
 * @param {Class<MultiToken>} Multi class to instantiate
 * @param {string} input original input string
 * @param {{t: string, v: string, s: number, e: number}[]} tokens consecutive tokens scanned from input string
 * @returns {MultiToken}
 */

function parserCreateMultiToken(Multi, input, tokens) {
  var startIdx = tokens[0].s;
  var endIdx = tokens[tokens.length - 1].e;
  var value = input.substr(startIdx, endIdx - startIdx);
  return new Multi(value, tokens);
}


var INIT = {
  scanner: null,
  parser: null,
  pluginQueue: [],
  customProtocols: [],
  initialized: false
};
/**
 * Initialize the linkify state machine. Called automatically the first time
 * linkify is called on a string, but may be called manually as well.
 */

function init() {
  // Initialize state machines
  INIT.scanner = {
    start: init$2(INIT.customProtocols),
    tokens: text
  };
  INIT.parser = {
    start: init$1(),
    tokens: multi
  };
  var utils = {
    createTokenClass: createTokenClass
  }; // Initialize plugins

  for (var i = 0; i < INIT.pluginQueue.length; i++) {
    INIT.pluginQueue[i][1]({
      scanner: INIT.scanner,
      parser: INIT.parser,
      utils: utils
    });
  }

  INIT.initialized = true;
}
/**
	Parse a string into tokens that represent linkable and non-linkable sub-components
	@param {string} str
	@return {MultiToken[]} tokens
*/

function tokenize(str) {
  if (!INIT.initialized) {
    init();
  }

  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
}
/**
	Find a list of linkable items in the given string.
	@param {string} str string to find links in
	@param {string} [type] (optional) only find links of a specific type, e.g.,
	'url' or 'email'
*/

function find(str) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var tokens = tokenize(str);
  var filtered = [];

  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (token.isLink && (!type || token.t === type)) {
      filtered.push(token.toObject());
    }
  }

  return filtered;
}
/**
 * Is the given string valid linkable text of some sort. Note that this does not
 * trim the text for you.
 *
 * Optionally pass in a second `type` param, which is the type of link to test
 * for.
 *
 * For example,
 *
 *     linkify.test(str, 'email');
 *
 * Returns `true` if str is a valid email.
 * @param {string} str string to test for links
 * @param {string} [type] optional specific link type to look for
 * @returns boolean true/false
 */

function test(str) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var tokens = tokenize(str);
  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);
}

function autolink(options) {
    return new Plugin({
        key: new PluginKey('autolink'),
        appendTransaction: (transactions, oldState, newState) => {
            const docChanges = transactions.some(transaction => transaction.docChanged)
                && !oldState.doc.eq(newState.doc);
            const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'));
            if (!docChanges || preventAutolink) {
                return;
            }
            const { tr } = newState;
            const transform = combineTransactionSteps(oldState.doc, transactions);
            const { mapping } = transform;
            const changes = getChangedRanges(transform);
            changes.forEach(({ oldRange, newRange }) => {
                // at first we check if we have to remove links
                getMarksBetween(oldRange.from, oldRange.to, oldState.doc)
                    .filter(item => item.mark.type === options.type)
                    .forEach(oldMark => {
                    const newFrom = mapping.map(oldMark.from);
                    const newTo = mapping.map(oldMark.to);
                    const newMarks = getMarksBetween(newFrom, newTo, newState.doc)
                        .filter(item => item.mark.type === options.type);
                    if (!newMarks.length) {
                        return;
                    }
                    const newMark = newMarks[0];
                    const oldLinkText = oldState.doc.textBetween(oldMark.from, oldMark.to, undefined, ' ');
                    const newLinkText = newState.doc.textBetween(newMark.from, newMark.to, undefined, ' ');
                    const wasLink = test(oldLinkText);
                    const isLink = test(newLinkText);
                    // remove only the link, if it was a link before too
                    // because we don’t want to remove links that were set manually
                    if (wasLink && !isLink) {
                        tr.removeMark(newMark.from, newMark.to, options.type);
                    }
                });
                // now let’s see if we can add new links
                findChildrenInRange(newState.doc, newRange, node => node.isTextblock)
                    .forEach(textBlock => {
                    // we need to define a placeholder for leaf nodes
                    // so that the link position can be calculated correctly
                    const text = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, undefined, ' ');
                    find(text)
                        .filter(link => link.isLink)
                        .filter(link => {
                        if (options.validate) {
                            return options.validate(link.value);
                        }
                        return true;
                    })
                        // calculate link position
                        .map(link => ({
                        ...link,
                        from: textBlock.pos + link.start + 1,
                        to: textBlock.pos + link.end + 1,
                    }))
                        // check if link is within the changed range
                        .filter(link => {
                        const fromIsInRange = newRange.from >= link.from && newRange.from <= link.to;
                        const toIsInRange = newRange.to >= link.from && newRange.to <= link.to;
                        return fromIsInRange || toIsInRange;
                    })
                        // add link mark
                        .forEach(link => {
                        tr.addMark(link.from, link.to, options.type.create({
                            href: link.href,
                        }));
                    });
                });
            });
            if (!tr.steps.length) {
                return;
            }
            return tr;
        },
    });
}

function clickHandler(options) {
    return new Plugin({
        key: new PluginKey('handleClickLink'),
        props: {
            handleClick: (view, pos, event) => {
                var _a;
                const attrs = getAttributes(view.state, options.type.name);
                const link = (_a = event.target) === null || _a === void 0 ? void 0 : _a.closest('a');
                if (link && attrs.href) {
                    window$1.open(attrs.href, attrs.target);
                    return true;
                }
                return false;
            },
        },
    });
}

function pasteHandler(options) {
    return new Plugin({
        key: new PluginKey('handlePasteLink'),
        props: {
            handlePaste: (view, event, slice) => {
                const { state } = view;
                const { selection } = state;
                const { empty } = selection;
                if (empty) {
                    return false;
                }
                let textContent = '';
                slice.content.forEach(node => {
                    textContent += node.textContent;
                });
                const link = find(textContent).find(item => item.isLink && item.value === textContent);
                if (!textContent || !link) {
                    return false;
                }
                options.editor.commands.setMark(options.type, {
                    href: link.href,
                });
                return true;
            },
        },
    });
}

const Link = Mark.create({
    name: 'link',
    priority: 1000,
    keepOnSplit: false,
    inclusive() {
        return this.options.autolink;
    },
    addOptions() {
        return {
            openOnClick: true,
            linkOnPaste: true,
            autolink: true,
            HTMLAttributes: {
                target: '_blank',
                rel: 'noopener noreferrer nofollow',
                class: null,
            },
            validate: undefined,
        };
    },
    addAttributes() {
        return {
            href: {
                default: null,
            },
            target: {
                default: this.options.HTMLAttributes.target,
            },
            class: {
                default: this.options.HTMLAttributes.class,
            },
        };
    },
    parseHTML() {
        return [
            { tag: 'a[href]:not([href *= "javascript:" i])' },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return [
            'a',
            mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
            0,
        ];
    },
    addCommands() {
        return {
            setLink: attributes => ({ chain }) => {
                return chain()
                    .setMark(this.name, attributes)
                    .setMeta('preventAutolink', true)
                    .run();
            },
            toggleLink: attributes => ({ chain }) => {
                return chain()
                    .toggleMark(this.name, attributes, { extendEmptyMarkRange: true })
                    .setMeta('preventAutolink', true)
                    .run();
            },
            unsetLink: () => ({ chain }) => {
                return chain()
                    .unsetMark(this.name, { extendEmptyMarkRange: true })
                    .setMeta('preventAutolink', true)
                    .run();
            },
        };
    },
    addPasteRules() {
        return [
            markPasteRule({
                find: text => find(text)
                    .filter(link => {
                    if (this.options.validate) {
                        return this.options.validate(link.value);
                    }
                    return true;
                })
                    .filter(link => link.isLink)
                    .map(link => ({
                    text: link.value,
                    index: link.start,
                    data: link,
                })),
                type: this.type,
                getAttributes: match => {
                    var _a;
                    return ({
                        href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href,
                    });
                },
            }),
        ];
    },
    addProseMirrorPlugins() {
        const plugins = [];
        if (this.options.autolink) {
            plugins.push(autolink({
                type: this.type,
                validate: this.options.validate,
            }));
        }
        if (this.options.openOnClick) {
            plugins.push(clickHandler({
                type: this.type,
            }));
        }
        if (this.options.linkOnPaste) {
            plugins.push(pasteHandler({
                editor: this.editor,
                type: this.type,
            }));
        }
        return plugins;
    },
});

// Because working with row and column-spanning cells is not quite
// trivial, this code builds up a descriptive structure for a given
// table node. The structures are cached with the (persistent) table
// nodes as key, so that they only have to be recomputed when the
// content of the table changes.
//
// This does mean that they have to store table-relative, not
// document-relative positions. So code that uses them will typically
// compute the start position of the table and offset positions passed
// to or gotten from this structure by that amount.

var readFromCache, addToCache;
// Prefer using a weak map to cache table maps. Fall back on a
// fixed-size cache if that's not supported.
if (typeof WeakMap != "undefined") {
  var cache = new WeakMap;
  readFromCache = function (key) { return cache.get(key); };
  addToCache = function (key, value) {
    cache.set(key, value);
    return value
  };
} else {
  var cache$1 = [], cacheSize = 10, cachePos = 0;
  readFromCache = function (key) {
    for (var i = 0; i < cache$1.length; i += 2)
      { if (cache$1[i] == key) { return cache$1[i + 1] } }
  };
  addToCache = function (key, value) {
    if (cachePos == cacheSize) { cachePos = 0; }
    cache$1[cachePos++] = key;
    return cache$1[cachePos++] = value
  };
}

var Rect = function Rect(left, top, right, bottom) {
  this.left = left; this.top = top; this.right = right; this.bottom = bottom;
};

// ::- A table map describes the structore of a given table. To avoid
// recomputing them all the time, they are cached per table node. To
// be able to do that, positions saved in the map are relative to the
// start of the table, rather than the start of the document.
var TableMap = function TableMap(width, height, map, problems) {
  // :: number The width of the table
  this.width = width;
  // :: number The table's height
  this.height = height;
  // :: [number] A width * height array with the start position of
  // the cell covering that part of the table in each slot
  this.map = map;
  // An optional array of problems (cell overlap or non-rectangular
  // shape) for the table, used by the table normalizer.
  this.problems = problems;
};

// :: (number) → Rect
// Find the dimensions of the cell at the given position.
TableMap.prototype.findCell = function findCell (pos) {
  for (var i = 0; i < this.map.length; i++) {
    var curPos = this.map[i];
    if (curPos != pos) { continue }
    var left = i % this.width, top = (i / this.width) | 0;
    var right = left + 1, bottom = top + 1;
    for (var j = 1; right < this.width && this.map[i + j] == curPos; j++) { right++; }
    for (var j$1 = 1; bottom < this.height && this.map[i + (this.width * j$1)] == curPos; j$1++) { bottom++; }
    return new Rect(left, top, right, bottom)
  }
  throw new RangeError("No cell with offset " + pos + " found")
};

// :: (number) → number
// Find the left side of the cell at the given position.
TableMap.prototype.colCount = function colCount (pos) {
  for (var i = 0; i < this.map.length; i++)
    { if (this.map[i] == pos) { return i % this.width } }
  throw new RangeError("No cell with offset " + pos + " found")
};

// :: (number, string, number) → ?number
// Find the next cell in the given direction, starting from the cell
// at `pos`, if any.
TableMap.prototype.nextCell = function nextCell (pos, axis, dir) {
  var ref = this.findCell(pos);
    var left = ref.left;
    var right = ref.right;
    var top = ref.top;
    var bottom = ref.bottom;
  if (axis == "horiz") {
    if (dir < 0 ? left == 0 : right == this.width) { return null }
    return this.map[top * this.width + (dir < 0 ? left - 1 : right)]
  } else {
    if (dir < 0 ? top == 0 : bottom == this.height) { return null }
    return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)]
  }
};

// :: (number, number) → Rect
// Get the rectangle spanning the two given cells.
TableMap.prototype.rectBetween = function rectBetween (a, b) {
  var ref = this.findCell(a);
    var leftA = ref.left;
    var rightA = ref.right;
    var topA = ref.top;
    var bottomA = ref.bottom;
  var ref$1 = this.findCell(b);
    var leftB = ref$1.left;
    var rightB = ref$1.right;
    var topB = ref$1.top;
    var bottomB = ref$1.bottom;
  return new Rect(Math.min(leftA, leftB), Math.min(topA, topB),
                  Math.max(rightA, rightB), Math.max(bottomA, bottomB))
};

// :: (Rect) → [number]
// Return the position of all cells that have the top left corner in
// the given rectangle.
TableMap.prototype.cellsInRect = function cellsInRect (rect) {
  var result = [], seen = {};
  for (var row = rect.top; row < rect.bottom; row++) {
    for (var col = rect.left; col < rect.right; col++) {
      var index = row * this.width + col, pos = this.map[index];
      if (seen[pos]) { continue }
      seen[pos] = true;
      if ((col != rect.left || !col || this.map[index - 1] != pos) &&
          (row != rect.top || !row || this.map[index - this.width] != pos))
        { result.push(pos); }
    }
  }
  return result
};

// :: (number, number, Node) → number
// Return the position at which the cell at the given row and column
// starts, or would start, if a cell started there.
TableMap.prototype.positionAt = function positionAt (row, col, table) {
  for (var i = 0, rowStart = 0;; i++) {
    var rowEnd = rowStart + table.child(i).nodeSize;
    if (i == row) {
      var index = col + row * this.width, rowEndIndex = (row + 1) * this.width;
      // Skip past cells from previous rows (via rowspan)
      while (index < rowEndIndex && this.map[index] < rowStart) { index++; }
      return index == rowEndIndex ? rowEnd - 1 : this.map[index]
    }
    rowStart = rowEnd;
  }
};

// :: (Node) → TableMap
// Find the table map for the given table node.
TableMap.get = function get (table) {
  return readFromCache(table) || addToCache(table, computeMap(table))
};

// Compute a table map.
function computeMap(table) {
  if (table.type.spec.tableRole != "table") { throw new RangeError("Not a table node: " + table.type.name) }
  var width = findWidth(table), height = table.childCount;
  var map = [], mapPos = 0, problems = null, colWidths = [];
  for (var i = 0, e = width * height; i < e; i++) { map[i] = 0; }

  for (var row = 0, pos = 0; row < height; row++) {
    var rowNode = table.child(row);
    pos++;
    for (var i$1 = 0;; i$1++) {
      while (mapPos < map.length && map[mapPos] != 0) { mapPos++; }
      if (i$1 == rowNode.childCount) { break }
      var cellNode = rowNode.child(i$1);
      var ref = cellNode.attrs;
      var colspan = ref.colspan;
      var rowspan = ref.rowspan;
      var colwidth = ref.colwidth;
      for (var h = 0; h < rowspan; h++) {
        if (h + row >= height) {
          (problems || (problems = [])).push({type: "overlong_rowspan", pos: pos, n: rowspan - h});
          break
        }
        var start = mapPos + (h * width);
        for (var w = 0; w < colspan; w++) {
          if (map[start + w] == 0)
            { map[start + w] = pos; }
          else
            { (problems || (problems = [])).push({type: "collision", row: row, pos: pos, n: colspan - w}); }
          var colW = colwidth && colwidth[w];
          if (colW) {
            var widthIndex = ((start + w) % width) * 2, prev = colWidths[widthIndex];
            if (prev == null || (prev != colW && colWidths[widthIndex + 1] == 1)) {
              colWidths[widthIndex] = colW;
              colWidths[widthIndex + 1] = 1;
            } else if (prev == colW) {
              colWidths[widthIndex + 1]++;
            }
          }
        }
      }
      mapPos += colspan;
      pos += cellNode.nodeSize;
    }
    var expectedPos = (row + 1) * width, missing = 0;
    while (mapPos < expectedPos) { if (map[mapPos++] == 0) { missing++; } }
    if (missing) { (problems || (problems = [])).push({type: "missing", row: row, n: missing}); }
    pos++;
  }

  var tableMap = new TableMap(width, height, map, problems), badWidths = false;

  // For columns that have defined widths, but whose widths disagree
  // between rows, fix up the cells whose width doesn't match the
  // computed one.
  for (var i$2 = 0; !badWidths && i$2 < colWidths.length; i$2 += 2)
    { if (colWidths[i$2] != null && colWidths[i$2 + 1] < height) { badWidths = true; } }
  if (badWidths) { findBadColWidths(tableMap, colWidths, table); }

  return tableMap
}

function findWidth(table) {
  var width = -1, hasRowSpan = false;
  for (var row = 0; row < table.childCount; row++) {
    var rowNode = table.child(row), rowWidth = 0;
    if (hasRowSpan) { for (var j = 0; j < row; j++) {
      var prevRow = table.child(j);
      for (var i = 0; i < prevRow.childCount; i++) {
        var cell = prevRow.child(i);
        if (j + cell.attrs.rowspan > row) { rowWidth += cell.attrs.colspan; }
      }
    } }
    for (var i$1 = 0; i$1 < rowNode.childCount; i$1++) {
      var cell$1 = rowNode.child(i$1);
      rowWidth += cell$1.attrs.colspan;
      if (cell$1.attrs.rowspan > 1) { hasRowSpan = true; }
    }
    if (width == -1)
      { width = rowWidth; }
    else if (width != rowWidth)
      { width = Math.max(width, rowWidth); }
  }
  return width
}

function findBadColWidths(map, colWidths, table) {
  if (!map.problems) { map.problems = []; }
  for (var i = 0, seen = {}; i < map.map.length; i++) {
    var pos = map.map[i];
    if (seen[pos]) { continue }
    seen[pos] = true;
    var node = table.nodeAt(pos), updated = null;
    for (var j = 0; j < node.attrs.colspan; j++) {
      var col = (i + j) % map.width, colWidth = colWidths[col * 2];
      if (colWidth != null && (!node.attrs.colwidth || node.attrs.colwidth[j] != colWidth))
        { (updated || (updated = freshColWidth(node.attrs)))[j] = colWidth; }
    }
    if (updated) { map.problems.unshift({type: "colwidth mismatch", pos: pos, colwidth: updated}); }
  }
}

function freshColWidth(attrs) {
  if (attrs.colwidth) { return attrs.colwidth.slice() }
  var result = [];
  for (var i = 0; i < attrs.colspan; i++) { result.push(0); }
  return result
}

function tableNodeTypes(schema) {
  var result = schema.cached.tableNodeTypes;
  if (!result) {
    result = schema.cached.tableNodeTypes = {};
    for (var name in schema.nodes) {
      var type = schema.nodes[name], role = type.spec.tableRole;
      if (role) { result[role] = type; }
    }
  }
  return result
}

// Various helper function for working with tables

var key = new PluginKey("selectingCells");

function cellAround($pos) {
  for (var d = $pos.depth - 1; d > 0; d--)
    { if ($pos.node(d).type.spec.tableRole == "row") { return $pos.node(0).resolve($pos.before(d + 1)) } }
  return null
}

function cellWrapping($pos) {
  for (var d = $pos.depth; d > 0; d--) { // Sometimes the cell can be in the same depth.
    var role = $pos.node(d).type.spec.tableRole;
    if (role === "cell" || role === 'header_cell') { return $pos.node(d) }
  }
  return null
}

function isInTable(state) {
  var $head = state.selection.$head;
  for (var d = $head.depth; d > 0; d--) { if ($head.node(d).type.spec.tableRole == "row") { return true } }
  return false
}

function selectionCell(state) {
  var sel = state.selection;
  if (sel.$anchorCell) {
    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
  } else if (sel.node && sel.node.type.spec.tableRole == "cell") {
    return sel.$anchor
  }
  return cellAround(sel.$head) || cellNear(sel.$head)
}

function cellNear($pos) {
  for (var after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {
    var role = after.type.spec.tableRole;
    if (role == "cell" || role == "header_cell") { return $pos.doc.resolve(pos) }
  }
  for (var before = $pos.nodeBefore, pos$1 = $pos.pos; before; before = before.lastChild, pos$1--) {
    var role$1 = before.type.spec.tableRole;
    if (role$1 == "cell" || role$1 == "header_cell") { return $pos.doc.resolve(pos$1 - before.nodeSize) }
  }
}

function pointsAtCell($pos) {
  return $pos.parent.type.spec.tableRole == "row" && $pos.nodeAfter
}

function moveCellForward($pos) {
  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize)
}

function inSameTable($a, $b) {
  return $a.depth == $b.depth && $a.pos >= $b.start(-1) && $a.pos <= $b.end(-1)
}

function nextCell($pos, axis, dir) {
  var start = $pos.start(-1), map = TableMap.get($pos.node(-1));
  var moved = map.nextCell($pos.pos - start, axis, dir);
  return moved == null ? null : $pos.node(0).resolve(start + moved)
}

function setAttr(attrs, name, value) {
  var result = {};
  for (var prop in attrs) { result[prop] = attrs[prop]; }
  result[name] = value;
  return result
}

function removeColSpan(attrs, pos, n) {
  if ( n === void 0 ) n=1;

  var result = setAttr(attrs, "colspan", attrs.colspan - n);
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    result.colwidth.splice(pos, n);
    if (!result.colwidth.some(function (w) { return w > 0; })) { result.colwidth = null; }
  }
  return result
}

function addColSpan(attrs, pos, n) {
  if ( n === void 0 ) n=1;

  var result = setAttr(attrs, "colspan", attrs.colspan + n);
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    for (var i = 0; i < n; i++) { result.colwidth.splice(pos, 0, 0); }
  }
  return result
}

function columnIsHeader(map, table, col) {
  var headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (var row = 0; row < map.height; row++)
    { if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)
      { return false } }
  return true
}

// This file defines a ProseMirror selection subclass that models

// ::- A [`Selection`](http://prosemirror.net/docs/ref/#state.Selection)
// subclass that represents a cell selection spanning part of a table.
// With the plugin enabled, these will be created when the user
// selects across cells, and will be drawn by giving selected cells a
// `selectedCell` CSS class.
var CellSelection = /*@__PURE__*/(function (Selection) {
  function CellSelection($anchorCell, $headCell) {
    if ( $headCell === void 0 ) $headCell = $anchorCell;

    var table = $anchorCell.node(-1), map = TableMap.get(table), start = $anchorCell.start(-1);
    var rect = map.rectBetween($anchorCell.pos - start, $headCell.pos - start);
    var doc = $anchorCell.node(0);
    var cells = map.cellsInRect(rect).filter(function (p) { return p != $headCell.pos - start; });
    // Make the head cell the first range, so that it counts as the
    // primary part of the selection
    cells.unshift($headCell.pos - start);
    var ranges = cells.map(function (pos) {
      var cell = table.nodeAt(pos), from = pos + start + 1;
      return new SelectionRange(doc.resolve(from), doc.resolve(from + cell.content.size))
    });
    Selection.call(this, ranges[0].$from, ranges[0].$to, ranges);
    // :: ResolvedPos
    // A resolved position pointing _in front of_ the anchor cell (the one
    // that doesn't move when extending the selection).
    this.$anchorCell = $anchorCell;
    // :: ResolvedPos
    // A resolved position pointing in front of the head cell (the one
    // moves when extending the selection).
    this.$headCell = $headCell;
  }

  if ( Selection ) CellSelection.__proto__ = Selection;
  CellSelection.prototype = Object.create( Selection && Selection.prototype );
  CellSelection.prototype.constructor = CellSelection;

  CellSelection.prototype.map = function map (doc, mapping) {
    var $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));
    var $headCell = doc.resolve(mapping.map(this.$headCell.pos));
    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
      var tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
      if (tableChanged && this.isRowSelection())
        { return CellSelection.rowSelection($anchorCell, $headCell) }
      else if (tableChanged && this.isColSelection())
        { return CellSelection.colSelection($anchorCell, $headCell) }
      else
        { return new CellSelection($anchorCell, $headCell) }
    }
    return TextSelection.between($anchorCell, $headCell)
  };

  // :: () → Slice
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  CellSelection.prototype.content = function content () {
    var table = this.$anchorCell.node(-1), map = TableMap.get(table), start = this.$anchorCell.start(-1);
    var rect = map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start);
    var seen = {}, rows = [];
    for (var row = rect.top; row < rect.bottom; row++) {
      var rowContent = [];
      for (var index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {
        var pos = map.map[index];
        if (!seen[pos]) {
          seen[pos] = true;
          var cellRect = map.findCell(pos), cell = table.nodeAt(pos);
          var extraLeft = rect.left - cellRect.left, extraRight = cellRect.right - rect.right;
          if (extraLeft > 0 || extraRight > 0) {
            var attrs = cell.attrs;
            if (extraLeft > 0) { attrs = removeColSpan(attrs, 0, extraLeft); }
            if (extraRight > 0) { attrs = removeColSpan(attrs, attrs.colspan - extraRight, extraRight); }
            if (cellRect.left < rect.left) { cell = cell.type.createAndFill(attrs); }
            else { cell = cell.type.create(attrs, cell.content); }
          }
          if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
            var attrs$1 = setAttr(cell.attrs, "rowspan", Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top));
            if (cellRect.top < rect.top) { cell = cell.type.createAndFill(attrs$1); }
            else { cell = cell.type.create(attrs$1, cell.content); }
          }
          rowContent.push(cell);
        }
      }
      rows.push(table.child(row).copy(Fragment.from(rowContent)));
    }

    var fragment = this.isColSelection() && this.isRowSelection() ? table : rows;
    return new Slice(Fragment.from(fragment), 1, 1)
  };

  CellSelection.prototype.replace = function replace (tr, content) {
    if ( content === void 0 ) content = Slice.empty;

    var mapFrom = tr.steps.length, ranges = this.ranges;
    for (var i = 0; i < ranges.length; i++) {
      var ref = ranges[i];
      var $from = ref.$from;
      var $to = ref.$to;
      var mapping = tr.mapping.slice(mapFrom);
      tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
    }
    var sel = Selection.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);
    if (sel) { tr.setSelection(sel); }
  };

  CellSelection.prototype.replaceWith = function replaceWith (tr, node) {
    this.replace(tr, new Slice(Fragment.from(node), 0, 0));
  };

  CellSelection.prototype.forEachCell = function forEachCell (f) {
    var table = this.$anchorCell.node(-1), map = TableMap.get(table), start = this.$anchorCell.start(-1);
    var cells = map.cellsInRect(map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start));
    for (var i = 0; i < cells.length; i++)
      { f(table.nodeAt(cells[i]), start + cells[i]); }
  };

  // :: () → bool
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  CellSelection.prototype.isColSelection = function isColSelection () {
    var anchorTop = this.$anchorCell.index(-1), headTop = this.$headCell.index(-1);
    if (Math.min(anchorTop, headTop) > 0) { return false }
    var anchorBot = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan,
        headBot = headTop + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(anchorBot, headBot) == this.$headCell.node(-1).childCount
  };

  // :: (ResolvedPos, ?ResolvedPos) → CellSelection
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  CellSelection.colSelection = function colSelection ($anchorCell, $headCell) {
    if ( $headCell === void 0 ) $headCell = $anchorCell;

    var map = TableMap.get($anchorCell.node(-1)), start = $anchorCell.start(-1);
    var anchorRect = map.findCell($anchorCell.pos - start), headRect = map.findCell($headCell.pos - start);
    var doc = $anchorCell.node(0);
    if (anchorRect.top <= headRect.top) {
      if (anchorRect.top > 0)
        { $anchorCell = doc.resolve(start + map.map[anchorRect.left]); }
      if (headRect.bottom < map.height)
        { $headCell = doc.resolve(start + map.map[map.width * (map.height - 1) + headRect.right - 1]); }
    } else {
      if (headRect.top > 0)
        { $headCell = doc.resolve(start + map.map[headRect.left]); }
      if (anchorRect.bottom < map.height)
        { $anchorCell = doc.resolve(start + map.map[map.width * (map.height - 1) + anchorRect.right - 1]); }
    }
    return new CellSelection($anchorCell, $headCell)
  };

  // :: () → bool
  // True if this selection goes all the way from the left to the
  // right of the table.
  CellSelection.prototype.isRowSelection = function isRowSelection () {
    var map = TableMap.get(this.$anchorCell.node(-1)), start = this.$anchorCell.start(-1);
    var anchorLeft = map.colCount(this.$anchorCell.pos - start),
        headLeft = map.colCount(this.$headCell.pos - start);
    if (Math.min(anchorLeft, headLeft) > 0) { return false }
    var anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan,
        headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(anchorRight, headRight) == map.width
  };

  CellSelection.prototype.eq = function eq (other) {
    return other instanceof CellSelection && other.$anchorCell.pos == this.$anchorCell.pos &&
      other.$headCell.pos == this.$headCell.pos
  };

  // :: (ResolvedPos, ?ResolvedPos) → CellSelection
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  CellSelection.rowSelection = function rowSelection ($anchorCell, $headCell) {
    if ( $headCell === void 0 ) $headCell = $anchorCell;

    var map = TableMap.get($anchorCell.node(-1)), start = $anchorCell.start(-1);
    var anchorRect = map.findCell($anchorCell.pos - start), headRect = map.findCell($headCell.pos - start);
    var doc = $anchorCell.node(0);
    if (anchorRect.left <= headRect.left) {
      if (anchorRect.left > 0)
        { $anchorCell = doc.resolve(start + map.map[anchorRect.top * map.width]); }
      if (headRect.right < map.width)
        { $headCell = doc.resolve(start + map.map[map.width * (headRect.top + 1) - 1]); }
    } else {
      if (headRect.left > 0)
        { $headCell = doc.resolve(start + map.map[headRect.top * map.width]); }
      if (anchorRect.right < map.width)
        { $anchorCell = doc.resolve(start + map.map[map.width * (anchorRect.top + 1) - 1]); }
    }
    return new CellSelection($anchorCell, $headCell)
  };

  CellSelection.prototype.toJSON = function toJSON () {
    return {type: "cell", anchor: this.$anchorCell.pos, head: this.$headCell.pos}
  };

  CellSelection.fromJSON = function fromJSON (doc, json) {
    return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head))
  };

  // :: (Node, number, ?number) → CellSelection
  CellSelection.create = function create (doc, anchorCell, headCell) {
    if ( headCell === void 0 ) headCell = anchorCell;

    return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell))
  };

  CellSelection.prototype.getBookmark = function getBookmark () { return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos) };

  return CellSelection;
}(Selection));

CellSelection.prototype.visible = false;

Selection.jsonID("cell", CellSelection);

var CellBookmark = function CellBookmark(anchor, head) {
  this.anchor = anchor;
  this.head = head;
};
CellBookmark.prototype.map = function map (mapping) {
  return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head))
};
CellBookmark.prototype.resolve = function resolve (doc) {
  var $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);
  if ($anchorCell.parent.type.spec.tableRole == "row" &&
      $headCell.parent.type.spec.tableRole == "row" &&
      $anchorCell.index() < $anchorCell.parent.childCount &&
      $headCell.index() < $headCell.parent.childCount &&
      inSameTable($anchorCell, $headCell))
    { return new CellSelection($anchorCell, $headCell) }
  else
    { return Selection.near($headCell, 1) }
};

function drawCellSelection(state) {
  if (!(state.selection instanceof CellSelection)) { return null }
  var cells = [];
  state.selection.forEachCell(function (node, pos) {
    cells.push(Decoration.node(pos, pos + node.nodeSize, {class: "selectedCell"}));
  });
  return DecorationSet.create(state.doc, cells)
}

function isCellBoundarySelection(ref) {
  var $from = ref.$from;
  var $to = ref.$to;

  if ($from.pos == $to.pos || $from.pos < $from.pos - 6) { return false } // Cheap elimination
  var afterFrom = $from.pos, beforeTo = $to.pos, depth = $from.depth;
  for (; depth >= 0; depth--, afterFrom++)
    { if ($from.after(depth + 1) < $from.end(depth)) { break } }
  for (var d = $to.depth; d >= 0; d--, beforeTo--)
    { if ($to.before(d + 1) > $to.start(d)) { break } }
  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole)
}

function isTextSelectionAcrossCells(ref) {
  var $from = ref.$from;
  var $to = ref.$to;

  var fromCellBoundaryNode;
  var toCellBoundaryNode;

  for (var i = $from.depth; i > 0; i--) {
    var node = $from.node(i);
    if (node.type.spec.tableRole === 'cell' || node.type.spec.tableRole === 'header_cell') {
      fromCellBoundaryNode = node;
      break;
    }
  }

  for (var i$1 = $to.depth; i$1 > 0; i$1--) {
    var node$1 = $to.node(i$1);
    if (node$1.type.spec.tableRole === 'cell' || node$1.type.spec.tableRole === 'header_cell') {
      toCellBoundaryNode = node$1;
      break;
    }
  }

  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0
}

function normalizeSelection(state, tr, allowTableNodeSelection) {
  var sel = (tr || state).selection, doc = (tr || state).doc, normalize, role;
  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {
    if (role == "cell" || role == "header_cell") {
      normalize = CellSelection.create(doc, sel.from);
    } else if (role == "row") {
      var $cell = doc.resolve(sel.from + 1);
      normalize = CellSelection.rowSelection($cell, $cell);
    } else if (!allowTableNodeSelection) {
      var map = TableMap.get(sel.node), start = sel.from + 1;
      var lastCell = start + map.map[map.width * map.height - 1];
      normalize = CellSelection.create(doc, start + 1, lastCell);
    }
  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {
    normalize = TextSelection.create(doc, sel.from);
  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {
    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());
  }
  if (normalize)
    { (tr || (tr = state.tr)).setSelection(normalize); }
  return tr
}

// Utilities used for copy/paste handling.

// Utilities to help with copying and pasting table cells

// : (Slice) → ?{width: number, height: number, rows: [Fragment]}
// Get a rectangular area of cells from a slice, or null if the outer
// nodes of the slice aren't table cells or rows.
function pastedCells(slice) {
  if (!slice.size) { return null }
  var content = slice.content;
  var openStart = slice.openStart;
  var openEnd = slice.openEnd;
  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.firstChild.type.spec.tableRole == "table")) {
    openStart--;
    openEnd--;
    content = content.firstChild.content;
  }
  var first = content.firstChild, role = first.type.spec.tableRole;
  var schema = first.type.schema, rows = [];
  if (role == "row") {
    for (var i = 0; i < content.childCount; i++) {
      var cells = content.child(i).content;
      var left = i ? 0 : Math.max(0, openStart - 1);
      var right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
      if (left || right) { cells = fitSlice(tableNodeTypes(schema).row, new Slice(cells, left, right)).content; }
      rows.push(cells);
    }
  } else if (role == "cell" || role == "header_cell") {
    rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new Slice(content, openStart, openEnd)).content : content);
  } else {
    return null
  }
  return ensureRectangular(schema, rows)
}

// : (Schema, [Fragment]) → {width: number, height: number, rows: [Fragment]}
// Compute the width and height of a set of cells, and make sure each
// row has the same number of cells.
function ensureRectangular(schema, rows) {
  var widths = [];
  for (var i = 0; i < rows.length; i++) {
    var row = rows[i];
    for (var j = row.childCount - 1; j >= 0; j--) {
      var ref = row.child(j).attrs;
      var rowspan = ref.rowspan;
      var colspan = ref.colspan;
      for (var r = i; r < i + rowspan; r++)
        { widths[r] = (widths[r] || 0) + colspan; }
    }
  }
  var width = 0;
  for (var r$1 = 0; r$1 < widths.length; r$1++) { width = Math.max(width, widths[r$1]); }
  for (var r$2 = 0; r$2 < widths.length; r$2++) {
    if (r$2 >= rows.length) { rows.push(Fragment.empty); }
    if (widths[r$2] < width) {
      var empty = tableNodeTypes(schema).cell.createAndFill(), cells = [];
      for (var i$1 = widths[r$2]; i$1 < width; i$1++) { cells.push(empty); }
      rows[r$2] = rows[r$2].append(Fragment.from(cells));
    }
  }
  return {height: rows.length, width: width, rows: rows}
}

function fitSlice(nodeType, slice) {
  var node = nodeType.createAndFill();
  var tr = new Transform(node).replace(0, node.content.size, slice);
  return tr.doc
}

// : ({width: number, height: number, rows: [Fragment]}, number, number) → {width: number, height: number, rows: [Fragment]}
// Clip or extend (repeat) the given set of cells to cover the given
// width and height. Will clip rowspan/colspan cells at the edges when
// they stick out.
function clipCells(ref, newWidth, newHeight) {
  var width = ref.width;
  var height = ref.height;
  var rows = ref.rows;

  if (width != newWidth) {
    var added = [], newRows = [];
    for (var row = 0; row < rows.length; row++) {
      var frag = rows[row], cells = [];
      for (var col = added[row] || 0, i = 0; col < newWidth; i++) {
        var cell = frag.child(i % frag.childCount);
        if (col + cell.attrs.colspan > newWidth)
          { cell = cell.type.create(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content); }
        cells.push(cell);
        col += cell.attrs.colspan;
        for (var j = 1; j < cell.attrs.rowspan; j++)
          { added[row + j] = (added[row + j] || 0) + cell.attrs.colspan; }
      }
      newRows.push(Fragment.from(cells));
    }
    rows = newRows;
    width = newWidth;
  }

  if (height != newHeight) {
    var newRows$1 = [];
    for (var row$1 = 0, i$1 = 0; row$1 < newHeight; row$1++, i$1++) {
      var cells$1 = [], source = rows[i$1 % height];
      for (var j$1 = 0; j$1 < source.childCount; j$1++) {
        var cell$1 = source.child(j$1);
        if (row$1 + cell$1.attrs.rowspan > newHeight)
          { cell$1 = cell$1.type.create(setAttr(cell$1.attrs, "rowspan", Math.max(1, newHeight - cell$1.attrs.rowspan)), cell$1.content); }
        cells$1.push(cell$1);
      }
      newRows$1.push(Fragment.from(cells$1));
    }
    rows = newRows$1;
    height = newHeight;
  }

  return {width: width, height: height, rows: rows}
}

// Make sure a table has at least the given width and height. Return
// true if something was changed.
function growTable(tr, map, table, start, width, height, mapFrom) {
  var schema = tr.doc.type.schema, types = tableNodeTypes(schema), empty, emptyHead;
  if (width > map.width) {
    for (var row = 0, rowEnd = 0; row < map.height; row++) {
      var rowNode = table.child(row);
      rowEnd += rowNode.nodeSize;
      var cells = [], add = (void 0);
      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)
        { add = empty || (empty = types.cell.createAndFill()); }
      else
        { add = emptyHead || (emptyHead = types.header_cell.createAndFill()); }
      for (var i = map.width; i < width; i++) { cells.push(add); }
      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);
    }
  }
  if (height > map.height) {
    var cells$1 = [];
    for (var i$1 = 0, start$1 = (map.height - 1) * map.width; i$1 < Math.max(map.width, width); i$1++) {
      var header = i$1 >= map.width ? false :
          table.nodeAt(map.map[start$1 + i$1]).type == types.header_cell;
      cells$1.push(header
                 ? (emptyHead || (emptyHead = types.header_cell.createAndFill()))
                 : (empty || (empty = types.cell.createAndFill())));
    }

    var emptyRow = types.row.create(null, Fragment.from(cells$1)), rows = [];
    for (var i$2 = map.height; i$2 < height; i$2++) { rows.push(emptyRow); }
    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);
  }
  return !!(empty || emptyHead)
}

// Make sure the given line (left, top) to (right, top) doesn't cross
// any rowspan cells by splitting cells that cross it. Return true if
// something changed.
function isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {
  if (top == 0 || top == map.height) { return false }
  var found = false;
  for (var col = left; col < right; col++) {
    var index = top * map.width + col, pos = map.map[index];
    if (map.map[index - map.width] == pos) {
      found = true;
      var cell = table.nodeAt(pos);
      var ref = map.findCell(pos);
      var cellTop = ref.top;
      var cellLeft = ref.left;
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, setAttr(cell.attrs, "rowspan", top - cellTop));
      tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),
                cell.type.createAndFill(setAttr(cell.attrs, "rowspan", (cellTop + cell.attrs.rowspan) - top)));
      col += cell.attrs.colspan - 1;
    }
  }
  return found
}

// Make sure the given line (left, top) to (left, bottom) doesn't
// cross any colspan cells by splitting cells that cross it. Return
// true if something changed.
function isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {
  if (left == 0 || left == map.width) { return false }
  var found = false;
  for (var row = top; row < bottom; row++) {
    var index = row * map.width + left, pos = map.map[index];
    if (map.map[index - 1] == pos) {
      found = true;
      var cell = table.nodeAt(pos), cellLeft = map.colCount(pos);
      var updatePos = tr.mapping.slice(mapFrom).map(pos + start);
      tr.setNodeMarkup(updatePos, null, removeColSpan(cell.attrs, left - cellLeft, cell.attrs.colspan - (left - cellLeft)));
      tr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft)));
      row += cell.attrs.rowspan - 1;
    }
  }
  return found
}

// Insert the given set of cells (as returned by `pastedCells`) into a
// table, at the position pointed at by rect.
function insertCells(state, dispatch, tableStart, rect, cells) {
  var table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc, map = TableMap.get(table);
  var top = rect.top;
  var left = rect.left;
  var right = left + cells.width, bottom = top + cells.height;
  var tr = state.tr, mapFrom = 0;
  function recomp() {
    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;
    map = TableMap.get(table);
    mapFrom = tr.mapping.maps.length;
  }
  // Prepare the table to be large enough and not have any cells
  // crossing the boundaries of the rectangle that we want to
  // insert into. If anything about it changes, recompute the table
  // map so that subsequent operations can see the current shape.
  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) { recomp(); }
  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom)) { recomp(); }
  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)) { recomp(); }
  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom)) { recomp(); }
  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom)) { recomp(); }

  for (var row = top; row < bottom; row++) {
    var from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);
    tr.replace(tr.mapping.slice(mapFrom).map(from + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart),
               new Slice(cells.rows[row - top], 0, 0));
  }
  recomp();
  tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map.positionAt(top, left, table)),
                                    tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))));
  dispatch(tr);
}

// This file defines a number of helpers for wiring up user input to

var handleKeyDown$1 = keydownHandler({
  "ArrowLeft": arrow$1("horiz", -1),
  "ArrowRight": arrow$1("horiz", 1),
  "ArrowUp": arrow$1("vert", -1),
  "ArrowDown": arrow$1("vert", 1),

  "Shift-ArrowLeft": shiftArrow("horiz", -1),
  "Shift-ArrowRight": shiftArrow("horiz", 1),
  "Shift-ArrowUp": shiftArrow("vert", -1),
  "Shift-ArrowDown": shiftArrow("vert", 1),

  "Backspace": deleteCellSelection,
  "Mod-Backspace": deleteCellSelection,
  "Delete": deleteCellSelection,
  "Mod-Delete": deleteCellSelection
});

function maybeSetSelection(state, dispatch, selection) {
  if (selection.eq(state.selection)) { return false }
  if (dispatch) { dispatch(state.tr.setSelection(selection).scrollIntoView()); }
  return true
}

function arrow$1(axis, dir) {
  return function (state, dispatch, view) {
    var sel = state.selection;
    if (sel instanceof CellSelection) {
      return maybeSetSelection(state, dispatch, Selection.near(sel.$headCell, dir))
    }
    if (axis != "horiz" && !sel.empty) { return false }
    var end = atEndOfCell(view, axis, dir);
    if (end == null) { return false }
    if (axis == "horiz") {
      return maybeSetSelection(state, dispatch, Selection.near(state.doc.resolve(sel.head + dir), dir))
    } else {
      var $cell = state.doc.resolve(end), $next = nextCell($cell, axis, dir), newSel;
      if ($next) { newSel = Selection.near($next, 1); }
      else if (dir < 0) { newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1); }
      else { newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1); }
      return maybeSetSelection(state, dispatch, newSel)
    }
  }
}

function shiftArrow(axis, dir) {
  return function (state, dispatch, view) {
    var sel = state.selection;
    if (!(sel instanceof CellSelection)) {
      var end = atEndOfCell(view, axis, dir);
      if (end == null) { return false }
      sel = new CellSelection(state.doc.resolve(end));
    }
    var $head = nextCell(sel.$headCell, axis, dir);
    if (!$head) { return false }
    return maybeSetSelection(state, dispatch, new CellSelection(sel.$anchorCell, $head))
  }
}

function deleteCellSelection(state, dispatch) {
  var sel = state.selection;
  if (!(sel instanceof CellSelection)) { return false }
  if (dispatch) {
    var tr = state.tr, baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;
    sel.forEachCell(function (cell, pos) {
      if (!cell.content.eq(baseContent))
        { tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1),
                   new Slice(baseContent, 0, 0)); }
    });
    if (tr.docChanged) { dispatch(tr); }
  }
  return true
}

function handleTripleClick(view, pos) {
  var doc = view.state.doc, $cell = cellAround(doc.resolve(pos));
  if (!$cell) { return false }
  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
  return true
}

function handlePaste(view, _, slice) {
  if (!isInTable(view.state)) { return false }
  var cells = pastedCells(slice), sel = view.state.selection;
  if (sel instanceof CellSelection) {
    if (!cells) { cells = {width: 1, height: 1, rows: [Fragment.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice))]}; }
    var table = sel.$anchorCell.node(-1), start = sel.$anchorCell.start(-1);
    var rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - start, sel.$headCell.pos - start);
    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);
    insertCells(view.state, view.dispatch, start, rect, cells);
    return true
  } else if (cells) {
    var $cell = selectionCell(view.state), start$1 = $cell.start(-1);
    insertCells(view.state, view.dispatch, start$1, TableMap.get($cell.node(-1)).findCell($cell.pos - start$1), cells);
    return true
  } else {
    return false
  }
}

function handleMouseDown(view, startEvent) {
  if (startEvent.ctrlKey || startEvent.metaKey) { return }

  var startDOMCell = domInCell(view, startEvent.target), $anchor;
  if (startEvent.shiftKey && (view.state.selection instanceof CellSelection)) {
    // Adding to an existing cell selection
    setCellSelection(view.state.selection.$anchorCell, startEvent);
    startEvent.preventDefault();
  } else if (startEvent.shiftKey && startDOMCell &&
             ($anchor = cellAround(view.state.selection.$anchor)) != null &&
             cellUnderMouse(view, startEvent).pos != $anchor.pos) {
    // Adding to a selection that starts in another cell (causing a
    // cell selection to be created).
    setCellSelection($anchor, startEvent);
    startEvent.preventDefault();
  } else if (!startDOMCell) {
    // Not in a cell, let the default behavior happen.
    return
  }

  // Create and dispatch a cell selection between the given anchor and
  // the position under the mouse.
  function setCellSelection($anchor, event) {
    var $head = cellUnderMouse(view, event);
    var starting = key.getState(view.state) == null;
    if (!$head || !inSameTable($anchor, $head)) {
      if (starting) { $head = $anchor; }
      else { return }
    }
    var selection = new CellSelection($anchor, $head);
    if (starting || !view.state.selection.eq(selection)) {
      var tr = view.state.tr.setSelection(selection);
      if (starting) { tr.setMeta(key, $anchor.pos); }
      view.dispatch(tr);
    }
  }

  // Stop listening to mouse motion events.
  function stop() {
    view.root.removeEventListener("mouseup", stop);
    view.root.removeEventListener("dragstart", stop);
    view.root.removeEventListener("mousemove", move);
    if (key.getState(view.state) != null) { view.dispatch(view.state.tr.setMeta(key, -1)); }
  }

  function move(event) {
    var anchor = key.getState(view.state), $anchor;
    if (anchor != null) {
      // Continuing an existing cross-cell selection
      $anchor = view.state.doc.resolve(anchor);
    } else if (domInCell(view, event.target) != startDOMCell) {
      // Moving out of the initial cell -- start a new cell selection
      $anchor = cellUnderMouse(view, startEvent);
      if (!$anchor) { return stop() }
    }
    if ($anchor) { setCellSelection($anchor, event); }
  }
  view.root.addEventListener("mouseup", stop);
  view.root.addEventListener("dragstart", stop);
  view.root.addEventListener("mousemove", move);
}

// Check whether the cursor is at the end of a cell (so that further
// motion would move out of the cell)
function atEndOfCell(view, axis, dir) {
  if (!(view.state.selection instanceof TextSelection)) { return null }
  var ref = view.state.selection;
  var $head = ref.$head;
  for (var d = $head.depth - 1; d >= 0; d--) {
    var parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);
    if (index != (dir < 0 ? 0 : parent.childCount)) { return null }
    if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
      var cellPos = $head.before(d);
      var dirStr = axis == "vert" ? (dir > 0 ? "down" : "up") : (dir > 0 ? "right" : "left");
      return view.endOfTextblock(dirStr) ? cellPos : null
    }
  }
  return null
}

function domInCell(view, dom) {
  for (; dom && dom != view.dom; dom = dom.parentNode)
    { if (dom.nodeName == "TD" || dom.nodeName == "TH") { return dom } }
}

function cellUnderMouse(view, event) {
  var mousePos = view.posAtCoords({left: event.clientX, top: event.clientY});
  if (!mousePos) { return null }
  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null
}

// This file defines helpers for normalizing tables, making sure no

var fixTablesKey = new PluginKey("fix-tables");

// Helper for iterating through the nodes in a document that changed
// compared to the given previous document. Useful for avoiding
// duplicate work on each transaction.
function changedDescendants(old, cur, offset, f) {
  var oldSize = old.childCount, curSize = cur.childCount;
  outer: for (var i = 0, j = 0; i < curSize; i++) {
    var child = cur.child(i);
    for (var scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {
      if (old.child(scan) == child) {
        j = scan + 1;
        offset += child.nodeSize;
        continue outer
      }
    }
    f(child, offset);
    if (j < oldSize && old.child(j).sameMarkup(child))
      { changedDescendants(old.child(j), child, offset + 1, f); }
    else
      { child.nodesBetween(0, child.content.size, f, offset + 1); }
    offset += child.nodeSize;
  }
}

// :: (EditorState, ?EditorState) → ?Transaction
// Inspect all tables in the given state's document and return a
// transaction that fixes them, if necessary. If `oldState` was
// provided, that is assumed to hold a previous, known-good state,
// which will be used to avoid re-scanning unchanged parts of the
// document.
function fixTables(state, oldState) {
  var tr, check = function (node, pos) {
    if (node.type.spec.tableRole == "table") { tr = fixTable(state, node, pos, tr); }
  };
  if (!oldState) { state.doc.descendants(check); }
  else if (oldState.doc != state.doc) { changedDescendants(oldState.doc, state.doc, 0, check); }
  return tr
}

// : (EditorState, Node, number, ?Transaction) → ?Transaction
// Fix the given table, if necessary. Will append to the transaction
// it was given, if non-null, or create a new one if necessary.
function fixTable(state, table, tablePos, tr) {
  var map = TableMap.get(table);
  if (!map.problems) { return tr }
  if (!tr) { tr = state.tr; }

  // Track which rows we must add cells to, so that we can adjust that
  // when fixing collisions.
  var mustAdd = [];
  for (var i = 0; i < map.height; i++) { mustAdd.push(0); }
  for (var i$1 = 0; i$1 < map.problems.length; i$1++) {
    var prob = map.problems[i$1];
    if (prob.type == "collision") {
      var cell = table.nodeAt(prob.pos);
      for (var j = 0; j < cell.attrs.rowspan; j++) { mustAdd[prob.row + j] += prob.n; }
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, removeColSpan(cell.attrs, cell.attrs.colspan - prob.n, prob.n));
    } else if (prob.type == "missing") {
      mustAdd[prob.row] += prob.n;
    } else if (prob.type == "overlong_rowspan") {
      var cell$1 = table.nodeAt(prob.pos);
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell$1.attrs, "rowspan", cell$1.attrs.rowspan - prob.n));
    } else if (prob.type == "colwidth mismatch") {
      var cell$2 = table.nodeAt(prob.pos);
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell$2.attrs, "colwidth", prob.colwidth));
    }
  }
  var first, last;
  for (var i$2 = 0; i$2 < mustAdd.length; i$2++) { if (mustAdd[i$2]) {
    if (first == null) { first = i$2; }
    last = i$2;
  } }
  // Add the necessary cells, using a heuristic for whether to add the
  // cells at the start or end of the rows (if it looks like a 'bite'
  // was taken out of the table, add cells at the start of the row
  // after the bite. Otherwise add them at the end).
  for (var i$3 = 0, pos = tablePos + 1; i$3 < map.height; i$3++) {
    var row = table.child(i$3);
    var end = pos + row.nodeSize;
    var add = mustAdd[i$3];
    if (add > 0) {
      var tableNodeType = 'cell';
      if (row.firstChild) {
        tableNodeType = row.firstChild.type.spec.tableRole;
      }
      var nodes = [];
      for (var j$1 = 0; j$1 < add; j$1++)
        { nodes.push(tableNodeTypes(state.schema)[tableNodeType].createAndFill()); }
      var side = (i$3 == 0 || first == i$3 - 1) && last == i$3 ? pos + 1 : end - 1;
      tr.insert(tr.mapping.map(side), nodes);
    }
    pos = end;
  }
  return tr.setMeta(fixTablesKey, { fixTables: true })
}

// This file defines a number of table-related commands.

// Helper to get the selected rectangle in a table, if any. Adds table
// map, table node, and table start offset to the object for
// convenience.
function selectedRect(state) {
  var sel = state.selection, $pos = selectionCell(state);
  var table = $pos.node(-1), tableStart = $pos.start(-1), map = TableMap.get(table);
  var rect;
  if (sel instanceof CellSelection)
    { rect = map.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart); }
  else
    { rect = map.findCell($pos.pos - tableStart); }
  rect.tableStart = tableStart;
  rect.map = map;
  rect.table = table;
  return rect
}

// Add a column at the given position in a table.
function addColumn(tr, ref, col) {
  var map = ref.map;
  var tableStart = ref.tableStart;
  var table = ref.table;

  var refColumn = col > 0 ? -1 : 0;
  if (columnIsHeader(map, table, col + refColumn))
    { refColumn = col == 0 || col == map.width ? null : 0; }

  for (var row = 0; row < map.height; row++) {
    var index = row * map.width + col;
    // If this position falls inside a col-spanning cell
    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {
      var pos = map.map[index], cell = table.nodeAt(pos);
      tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null,
                       addColSpan(cell.attrs, col - map.colCount(pos)));
      // Skip ahead if rowspan > 1
      row += cell.attrs.rowspan - 1;
    } else {
      var type = refColumn == null ? tableNodeTypes(table.type.schema).cell
          : table.nodeAt(map.map[index + refColumn]).type;
      var pos$1 = map.positionAt(row, col, table);
      tr.insert(tr.mapping.map(tableStart + pos$1), type.createAndFill());
    }
  }
  return tr
}

// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Command to add a column before the column with the selection.
function addColumnBefore(state, dispatch) {
  if (!isInTable(state)) { return false }
  if (dispatch) {
    var rect = selectedRect(state);
    dispatch(addColumn(state.tr, rect, rect.left));
  }
  return true
}

// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Command to add a column after the column with the selection.
function addColumnAfter(state, dispatch) {
  if (!isInTable(state)) { return false }
  if (dispatch) {
    var rect = selectedRect(state);
    dispatch(addColumn(state.tr, rect, rect.right));
  }
  return true
}

function removeColumn(tr, ref, col) {
  var map = ref.map;
  var table = ref.table;
  var tableStart = ref.tableStart;

  var mapStart = tr.mapping.maps.length;
  for (var row = 0; row < map.height;) {
    var index = row * map.width + col, pos = map.map[index], cell = table.nodeAt(pos);
    // If this is part of a col-spanning cell
    if ((col > 0 && map.map[index - 1] == pos) || (col < map.width - 1 && map.map[index + 1] == pos)) {
      tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null,
                       removeColSpan(cell.attrs, col - map.colCount(pos)));
    } else {
      var start = tr.mapping.slice(mapStart).map(tableStart + pos);
      tr.delete(start, start + cell.nodeSize);
    }
    row += cell.attrs.rowspan;
  }
}

// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Command function that removes the selected columns from a table.
function deleteColumn(state, dispatch) {
  if (!isInTable(state)) { return false }
  if (dispatch) {
    var rect = selectedRect(state), tr = state.tr;
    if (rect.left == 0 && rect.right == rect.map.width) { return false }
    for (var i = rect.right - 1;; i--) {
      removeColumn(tr, rect, i);
      if (i == rect.left) { break }
      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      rect.map = TableMap.get(rect.table);
    }
    dispatch(tr);
  }
  return true
}

function rowIsHeader(map, table, row) {
  var headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (var col = 0; col < map.width; col++)
    { if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)
      { return false } }
  return true
}

function addRow(tr, ref, row) {
  var map = ref.map;
  var tableStart = ref.tableStart;
  var table = ref.table;

  var rowPos = tableStart;
  for (var i = 0; i < row; i++) { rowPos += table.child(i).nodeSize; }
  var cells = [], refRow = row > 0 ? -1 : 0;
  if (rowIsHeader(map, table, row + refRow))
    { refRow = row == 0 || row == map.height ? null : 0; }
  for (var col = 0, index = map.width * row; col < map.width; col++, index++) {
    // Covered by a rowspan cell
    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {
      var pos = map.map[index], attrs = table.nodeAt(pos).attrs;
      tr.setNodeMarkup(tableStart + pos, null, setAttr(attrs, "rowspan", attrs.rowspan + 1));
      col += attrs.colspan - 1;
    } else {
      var type = refRow == null ? tableNodeTypes(table.type.schema).cell
          : table.nodeAt(map.map[index + refRow * map.width]).type;
      cells.push(type.createAndFill());
    }
  }
  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));
  return tr
}

// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Add a table row before the selection.
function addRowBefore(state, dispatch) {
  if (!isInTable(state)) { return false }
  if (dispatch) {
    var rect = selectedRect(state);
    dispatch(addRow(state.tr, rect, rect.top));
  }
  return true
}

// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Add a table row after the selection.
function addRowAfter(state, dispatch) {
  if (!isInTable(state)) { return false }
  if (dispatch) {
    var rect = selectedRect(state);
    dispatch(addRow(state.tr, rect, rect.bottom));
  }
  return true
}

function removeRow(tr, ref, row) {
  var map = ref.map;
  var table = ref.table;
  var tableStart = ref.tableStart;

  var rowPos = 0;
  for (var i = 0; i < row; i++) { rowPos += table.child(i).nodeSize; }
  var nextRow = rowPos + table.child(row).nodeSize;

  var mapFrom = tr.mapping.maps.length;
  tr.delete(rowPos + tableStart, nextRow + tableStart);

  for (var col = 0, index = row * map.width; col < map.width; col++, index++) {
    var pos = map.map[index];
    if (row > 0 && pos == map.map[index - map.width]) {
      // If this cell starts in the row above, simply reduce its rowspan
      var attrs = table.nodeAt(pos).attrs;
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, setAttr(attrs, "rowspan", attrs.rowspan - 1));
      col += attrs.colspan - 1;
    } else if (row < map.width && pos == map.map[index + map.width]) {
      // Else, if it continues in the row below, it has to be moved down
      var cell = table.nodeAt(pos);
      var copy = cell.type.create(setAttr(cell.attrs, "rowspan", cell.attrs.rowspan - 1), cell.content);
      var newPos = map.positionAt(row + 1, col, table);
      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);
      col += cell.attrs.colspan - 1;
    }
  }
}

// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Remove the selected rows from a table.
function deleteRow(state, dispatch) {
  if (!isInTable(state)) { return false }
  if (dispatch) {
    var rect = selectedRect(state), tr = state.tr;
    if (rect.top == 0 && rect.bottom == rect.map.height) { return false }
    for (var i = rect.bottom - 1;; i--) {
      removeRow(tr, rect, i);
      if (i == rect.top) { break }
      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      rect.map = TableMap.get(rect.table);
    }
    dispatch(tr);
  }
  return true
}

function isEmpty(cell) {
  var c = cell.content;
  return c.childCount == 1 && c.firstChild.isTextblock && c.firstChild.childCount == 0
}

function cellsOverlapRectangle(ref, rect) {
  var width = ref.width;
  var height = ref.height;
  var map = ref.map;

  var indexTop = rect.top * width + rect.left, indexLeft = indexTop;
  var indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);
  for (var i = rect.top; i < rect.bottom; i++) {
    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] ||
        rect.right < width && map[indexRight] == map[indexRight + 1]) { return true }
    indexLeft += width; indexRight += width;
  }
  for (var i$1 = rect.left; i$1 < rect.right; i$1++) {
    if (rect.top > 0 && map[indexTop] == map[indexTop - width] ||
        rect.bottom < height && map[indexBottom] == map[indexBottom + width]) { return true }
    indexTop++; indexBottom++;
  }
  return false
}

// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Merge the selected cells into a single cell. Only available when
// the selected cells' outline forms a rectangle.
function mergeCells(state, dispatch) {
  var sel = state.selection;
  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) { return false }
  var rect = selectedRect(state);
  var map = rect.map;
  if (cellsOverlapRectangle(map, rect)) { return false }
  if (dispatch) {
    var tr = state.tr, seen = {}, content = Fragment.empty, mergedPos, mergedCell;
    for (var row = rect.top; row < rect.bottom; row++) {
      for (var col = rect.left; col < rect.right; col++) {
        var cellPos = map.map[row * map.width + col], cell = rect.table.nodeAt(cellPos);
        if (seen[cellPos]) { continue }
        seen[cellPos] = true;
        if (mergedPos == null) {
          mergedPos = cellPos;
          mergedCell = cell;
        } else {
          if (!isEmpty(cell)) { content = content.append(cell.content); }
          var mapped = tr.mapping.map(cellPos + rect.tableStart);
          tr.delete(mapped, mapped + cell.nodeSize);
        }
      }
    }
    tr.setNodeMarkup(mergedPos + rect.tableStart, null,
                     setAttr(addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, (rect.right - rect.left) - mergedCell.attrs.colspan),
                             "rowspan", rect.bottom - rect.top));
    if (content.size) {
      var end = mergedPos + 1 + mergedCell.content.size;
      var start = isEmpty(mergedCell) ? mergedPos + 1 : end;
      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);
    }
    tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)));
    dispatch(tr);
  }
  return true
}
// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Split a selected cell, whose rowpan or colspan is greater than one,
// into smaller cells. Use the first cell type for the new cells.
function splitCell(state, dispatch) {
  var nodeTypes = tableNodeTypes(state.schema);
  return splitCellWithType(function (ref) {
    var node = ref.node;

    return nodeTypes[node.type.spec.tableRole]
  })(state, dispatch)
}

// :: (getCellType: ({ row: number, col: number, node: Node}) → NodeType) → (EditorState, dispatch: ?(tr: Transaction)) → bool
// Split a selected cell, whose rowpan or colspan is greater than one,
// into smaller cells with the cell type (th, td) returned by getType function.
function splitCellWithType(getCellType) {
  return function (state, dispatch) {
    var sel = state.selection;
    var cellNode, cellPos;
    if (!(sel instanceof CellSelection)) {
      cellNode = cellWrapping(sel.$from);
      if (!cellNode) { return false }
      cellPos = cellAround(sel.$from).pos;
    } else {
      if (sel.$anchorCell.pos != sel.$headCell.pos) { return false }
      cellNode = sel.$anchorCell.nodeAfter;
      cellPos = sel.$anchorCell.pos;
    }
    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {return false}
    if (dispatch) {
      var baseAttrs = cellNode.attrs, attrs = [], colwidth = baseAttrs.colwidth;
      if (baseAttrs.rowspan > 1) { baseAttrs = setAttr(baseAttrs, "rowspan", 1); }
      if (baseAttrs.colspan > 1) { baseAttrs = setAttr(baseAttrs, "colspan", 1); }
      var rect = selectedRect(state), tr = state.tr;
      for (var i = 0; i < rect.right - rect.left; i++)
        { attrs.push(colwidth ? setAttr(baseAttrs, "colwidth", colwidth && colwidth[i] ? [colwidth[i]] : null) : baseAttrs); }
      var lastCell;
      for (var row = rect.top; row < rect.bottom; row++) {
        var pos = rect.map.positionAt(row, rect.left, rect.table);
        if (row == rect.top) { pos += cellNode.nodeSize; }
        for (var col = rect.left, i$1 = 0; col < rect.right; col++, i$1++) {
          if (col == rect.left && row == rect.top) { continue }
          tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), getCellType({ node: cellNode, row: row, col: col}).createAndFill(attrs[i$1]));
        }
      }
      tr.setNodeMarkup(cellPos, getCellType({ node: cellNode, row: rect.top, col: rect.left}), attrs[0]);
      if (sel instanceof CellSelection)
        { tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos),
                                          lastCell && tr.doc.resolve(lastCell))); }
      dispatch(tr);
    }
    return true
  }
}

// :: (string, any) → (EditorState, dispatch: ?(tr: Transaction)) → bool
// Returns a command that sets the given attribute to the given value,
// and is only available when the currently selected cell doesn't
// already have that attribute set to that value.
function setCellAttr(name, value) {
  return function(state, dispatch) {
    if (!isInTable(state)) { return false }
    var $cell = selectionCell(state);
    if ($cell.nodeAfter.attrs[name] === value) { return false }
    if (dispatch) {
      var tr = state.tr;
      if (state.selection instanceof CellSelection)
        { state.selection.forEachCell(function (node, pos) {
          if (node.attrs[name] !== value)
            { tr.setNodeMarkup(pos, null, setAttr(node.attrs, name, value)); }
        }); }
      else
        { tr.setNodeMarkup($cell.pos, null, setAttr($cell.nodeAfter.attrs, name, value)); }
      dispatch(tr);
    }
    return true
  }
}

function deprecated_toggleHeader(type) {
  return function(state, dispatch) {
    if (!isInTable(state)) { return false }
    if (dispatch) {
      var types = tableNodeTypes(state.schema);
      var rect = selectedRect(state), tr = state.tr;
      var cells = rect.map.cellsInRect(type == "column" ? new Rect(rect.left, 0, rect.right, rect.map.height) :
                                       type == "row" ? new Rect(0, rect.top, rect.map.width, rect.bottom) : rect);
      var nodes = cells.map(function (pos) { return rect.table.nodeAt(pos); });
      for (var i = 0; i < cells.length; i++) // Remove headers, if any
        { if (nodes[i].type == types.header_cell)
          { tr.setNodeMarkup(rect.tableStart + cells[i], types.cell, nodes[i].attrs); } }
      if (tr.steps.length == 0) { for (var i$1 = 0; i$1 < cells.length; i$1++) // No headers removed, add instead
        { tr.setNodeMarkup(rect.tableStart + cells[i$1], types.header_cell, nodes[i$1].attrs); } }
      dispatch(tr);
    }
    return true
  }
}

function isHeaderEnabledByType(type, rect, types) {
  // Get cell positions for first row or first column
  var cellPositions = rect.map.cellsInRect({
    left: 0,
    top: 0,
    right: type == "row" ? rect.map.width : 1,
    bottom: type == "column" ? rect.map.height : 1,
  });

  for (var i = 0; i < cellPositions.length; i++) {
    var cell = rect.table.nodeAt(cellPositions[i]);
    if (cell && cell.type !== types.header_cell) {
      return false
    }
  }

  return true
}

// :: (string, ?{ useDeprecatedLogic: bool }) → (EditorState, dispatch: ?(tr: Transaction)) → bool
// Toggles between row/column header and normal cells (Only applies to first row/column).
// For deprecated behavior pass `useDeprecatedLogic` in options with true.
function toggleHeader(type, options) {
  options = options || { useDeprecatedLogic: false };

  if (options.useDeprecatedLogic)
    { return deprecated_toggleHeader(type) }

  return function(state, dispatch) {
    if (!isInTable(state)) { return false }
    if (dispatch) {
      var types = tableNodeTypes(state.schema);
      var rect = selectedRect(state), tr = state.tr;

      var isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types);
      var isHeaderColumnEnabled = isHeaderEnabledByType("column", rect, types);

      var isHeaderEnabled = type === "column" ? isHeaderRowEnabled :
                            type === "row"    ? isHeaderColumnEnabled : false;

      var selectionStartsAt = isHeaderEnabled ? 1 : 0;

      var cellsRect = type == "column" ? new Rect(0, selectionStartsAt, 1, rect.map.height) :
                      type == "row" ? new Rect(selectionStartsAt, 0, rect.map.width, 1) : rect;

      var newType = type == "column" ? isHeaderColumnEnabled ? types.cell : types.header_cell :
                    type == "row" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;

      rect.map.cellsInRect(cellsRect).forEach(function (relativeCellPos) {
        var cellPos = relativeCellPos + rect.tableStart;
        var cell = tr.doc.nodeAt(cellPos);

        if (cell) {
          tr.setNodeMarkup(cellPos, newType, cell.attrs);
        }
      });

      dispatch(tr);
    }
    return true
  }
}

// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Toggles whether the selected row contains header cells.
toggleHeader("row", { useDeprecatedLogic: true });

// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Toggles whether the selected column contains header cells.
toggleHeader("column", { useDeprecatedLogic: true });

// :: (EditorState, dispatch: ?(tr: Transaction)) → bool
// Toggles whether the selected cells are header cells.
var toggleHeaderCell = toggleHeader("cell", { useDeprecatedLogic: true });

function findNextCell($cell, dir) {
  if (dir < 0) {
    var before = $cell.nodeBefore;
    if (before) { return $cell.pos - before.nodeSize }
    for (var row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {
      var rowNode = $cell.node(-1).child(row);
      if (rowNode.childCount) { return rowEnd - 1 - rowNode.lastChild.nodeSize }
      rowEnd -= rowNode.nodeSize;
    }
  } else {
    if ($cell.index() < $cell.parent.childCount - 1) { return $cell.pos + $cell.nodeAfter.nodeSize }
    var table = $cell.node(-1);
    for (var row$1 = $cell.indexAfter(-1), rowStart = $cell.after(); row$1 < table.childCount; row$1++) {
      var rowNode$1 = table.child(row$1);
      if (rowNode$1.childCount) { return rowStart + 1 }
      rowStart += rowNode$1.nodeSize;
    }
  }
}

// :: (number) → (EditorState, dispatch: ?(tr: Transaction)) → bool
// Returns a command for selecting the next (direction=1) or previous
// (direction=-1) cell in a table.
function goToNextCell(direction) {
  return function(state, dispatch) {
    if (!isInTable(state)) { return false }
    var cell = findNextCell(selectionCell(state), direction);
    if (cell == null) { return }
    if (dispatch) {
      var $cell = state.doc.resolve(cell);
      dispatch(state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView());
    }
    return true
  }
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Deletes the table around the selection, if any.
function deleteTable(state, dispatch) {
  var $pos = state.selection.$anchor;
  for (var d = $pos.depth; d > 0; d--) {
    var node = $pos.node(d);
    if (node.type.spec.tableRole == "table") {
      if (dispatch) { dispatch(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()); }
      return true
    }
  }
  return false
}

var TableView$1 = function TableView(node, cellMinWidth) {
  this.node = node;
  this.cellMinWidth = cellMinWidth;
  this.dom = document.createElement("div");
  this.dom.className = "tableWrapper";
  this.table = this.dom.appendChild(document.createElement("table"));
  this.colgroup = this.table.appendChild(document.createElement("colgroup"));
  updateColumns$1(node, this.colgroup, this.table, cellMinWidth);
  this.contentDOM = this.table.appendChild(document.createElement("tbody"));
};

TableView$1.prototype.update = function update (node) {
  if (node.type != this.node.type) { return false }
  this.node = node;
  updateColumns$1(node, this.colgroup, this.table, this.cellMinWidth);
  return true
};

TableView$1.prototype.ignoreMutation = function ignoreMutation (record) {
  return record.type == "attributes" && (record.target == this.table || this.colgroup.contains(record.target))
};

function updateColumns$1(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {
  var totalWidth = 0, fixedWidth = true;
  var nextDOM = colgroup.firstChild, row = node.firstChild;
  for (var i = 0, col = 0; i < row.childCount; i++) {
    var ref = row.child(i).attrs;
    var colspan = ref.colspan;
    var colwidth = ref.colwidth;
    for (var j = 0; j < colspan; j++, col++) {
      var hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];
      var cssWidth = hasWidth ? hasWidth + "px" : "";
      totalWidth += hasWidth || cellMinWidth;
      if (!hasWidth) { fixedWidth = false; }
      if (!nextDOM) {
        colgroup.appendChild(document.createElement("col")).style.width = cssWidth;
      } else {
        if (nextDOM.style.width != cssWidth) { nextDOM.style.width = cssWidth; }
        nextDOM = nextDOM.nextSibling;
      }
    }
  }

  while (nextDOM) {
    var after = nextDOM.nextSibling;
    nextDOM.parentNode.removeChild(nextDOM);
    nextDOM = after;
  }

  if (fixedWidth) {
    table.style.width = totalWidth + "px";
    table.style.minWidth = "";
  } else {
    table.style.width = "";
    table.style.minWidth = totalWidth + "px";
  }
}

var key$1 = new PluginKey("tableColumnResizing");

function columnResizing(ref) {
  if ( ref === void 0 ) ref = {};
  var handleWidth = ref.handleWidth; if ( handleWidth === void 0 ) handleWidth = 5;
  var cellMinWidth = ref.cellMinWidth; if ( cellMinWidth === void 0 ) cellMinWidth = 25;
  var View = ref.View; if ( View === void 0 ) View = TableView$1;
  var lastColumnResizable = ref.lastColumnResizable; if ( lastColumnResizable === void 0 ) lastColumnResizable = true;

  var plugin = new Plugin({
    key: key$1,
    state: {
      init: function init(_, state) {
        this.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] =
          function (node, view) { return new View(node, cellMinWidth, view); };
        return new ResizeState(-1, false)
      },
      apply: function apply(tr, prev) {
        return prev.apply(tr)
      }
    },
    props: {
      attributes: function attributes(state) {
        var pluginState = key$1.getState(state);
        return pluginState.activeHandle > -1 ? {class: "resize-cursor"} : null
      },

      handleDOMEvents: {
        mousemove: function mousemove(view, event) { handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable); },
        mouseleave: function mouseleave(view) { handleMouseLeave(view); },
        mousedown: function mousedown(view, event) { handleMouseDown$1(view, event, cellMinWidth); }
      },

      decorations: function decorations(state) {
        var pluginState = key$1.getState(state);
        if (pluginState.activeHandle > -1) { return handleDecorations(state, pluginState.activeHandle) }
      },

      nodeViews: {}
    }
  });
  return plugin
}

var ResizeState = function ResizeState(activeHandle, dragging) {
  this.activeHandle = activeHandle;
  this.dragging = dragging;
};

ResizeState.prototype.apply = function apply (tr) {
  var state = this, action = tr.getMeta(key$1);
  if (action && action.setHandle != null)
    { return new ResizeState(action.setHandle, null) }
  if (action && action.setDragging !== undefined)
    { return new ResizeState(state.activeHandle, action.setDragging) }
  if (state.activeHandle > -1 && tr.docChanged) {
    var handle = tr.mapping.map(state.activeHandle, -1);
    if (!pointsAtCell(tr.doc.resolve(handle))) { handle = null; }
    state = new ResizeState(handle, state.dragging);
  }
  return state
};

function handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {
  var pluginState = key$1.getState(view.state);

  if (!pluginState.dragging) {
    var target = domCellAround(event.target), cell = -1;
    if (target) {
      var ref = target.getBoundingClientRect();
      var left = ref.left;
      var right = ref.right;
      if (event.clientX - left <= handleWidth)
        { cell = edgeCell(view, event, "left"); }
      else if (right - event.clientX <= handleWidth)
        { cell = edgeCell(view, event, "right"); }
    }

    if (cell != pluginState.activeHandle) {
      if (!lastColumnResizable && cell !== -1) {
        var $cell = view.state.doc.resolve(cell);
        var table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);
        var col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;

        if (col == map.width - 1) {
          return
        }
      }

      updateHandle(view, cell);
    }
  }
}

function handleMouseLeave(view) {
  var pluginState = key$1.getState(view.state);
  if (pluginState.activeHandle > -1 && !pluginState.dragging) { updateHandle(view, -1); }
}

function handleMouseDown$1(view, event, cellMinWidth) {
  var pluginState = key$1.getState(view.state);
  if (pluginState.activeHandle == -1 || pluginState.dragging) { return false }

  var cell = view.state.doc.nodeAt(pluginState.activeHandle);
  var width = currentColWidth(view, pluginState.activeHandle, cell.attrs);
  view.dispatch(view.state.tr.setMeta(key$1, {setDragging: {startX: event.clientX, startWidth: width}}));

  function finish(event) {
    window$1.removeEventListener("mouseup", finish);
    window$1.removeEventListener("mousemove", move);
    var pluginState = key$1.getState(view.state);
    if (pluginState.dragging) {
      updateColumnWidth(view, pluginState.activeHandle, draggedWidth(pluginState.dragging, event, cellMinWidth));
      view.dispatch(view.state.tr.setMeta(key$1, {setDragging: null}));
    }
  }
  function move(event) {
    if (!event.which) { return finish(event) }
    var pluginState = key$1.getState(view.state);
    var dragged = draggedWidth(pluginState.dragging, event, cellMinWidth);
    displayColumnWidth(view, pluginState.activeHandle, dragged, cellMinWidth);
  }

  window$1.addEventListener("mouseup", finish);
  window$1.addEventListener("mousemove", move);
  event.preventDefault();
  return true
}

function currentColWidth(view, cellPos, ref) {
  var colspan = ref.colspan;
  var colwidth = ref.colwidth;

  var width = colwidth && colwidth[colwidth.length - 1];
  if (width) { return width }
  var dom = view.domAtPos(cellPos);
  var node = dom.node.childNodes[dom.offset];
  var domWidth = node.offsetWidth, parts = colspan;
  if (colwidth) { for (var i = 0; i < colspan; i++) { if (colwidth[i]) {
    domWidth -= colwidth[i];
    parts--;
  } } }
  return domWidth / parts
}

function domCellAround(target) {
  while (target && target.nodeName != "TD" && target.nodeName != "TH")
    { target = target.classList.contains("ProseMirror") ? null : target.parentNode; }
  return target
}

function edgeCell(view, event, side) {
  var found = view.posAtCoords({left: event.clientX, top: event.clientY});
  if (!found) { return -1 }
  var pos = found.pos;
  var $cell = cellAround(view.state.doc.resolve(pos));
  if (!$cell) { return -1 }
  if (side == "right") { return $cell.pos }
  var map = TableMap.get($cell.node(-1)), start = $cell.start(-1);
  var index = map.map.indexOf($cell.pos - start);
  return index % map.width == 0 ? -1 : start + map.map[index - 1]
}

function draggedWidth(dragging, event, cellMinWidth) {
  var offset = event.clientX - dragging.startX;
  return Math.max(cellMinWidth, dragging.startWidth + offset)
}

function updateHandle(view, value) {
  view.dispatch(view.state.tr.setMeta(key$1, {setHandle: value}));
}

function updateColumnWidth(view, cell, width) {
  var $cell = view.state.doc.resolve(cell);
  var table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);
  var col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
  var tr = view.state.tr;
  for (var row = 0; row < map.height; row++) {
    var mapIndex = row * map.width + col;
    // Rowspanning cell that has already been handled
    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) { continue }
    var pos = map.map[mapIndex];
    var ref = table.nodeAt(pos);
    var attrs = ref.attrs;
    var index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);
    if (attrs.colwidth && attrs.colwidth[index] == width) { continue }
    var colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);
    colwidth[index] = width;
    tr.setNodeMarkup(start + pos, null, setAttr(attrs, "colwidth", colwidth));
  }
  if (tr.docChanged) { view.dispatch(tr); }
}

function displayColumnWidth(view, cell, width, cellMinWidth) {
  var $cell = view.state.doc.resolve(cell);
  var table = $cell.node(-1), start = $cell.start(-1);
  var col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
  var dom = view.domAtPos($cell.start(-1)).node;
  while (dom.nodeName != "TABLE") { dom = dom.parentNode; }
  updateColumns$1(table, dom.firstChild, dom, cellMinWidth, col, width);
}

function zeroes(n) {
  var result = [];
  for (var i = 0; i < n; i++) { result.push(0); }
  return result
}

function handleDecorations(state, cell) {
  var decorations = [];
  var $cell = state.doc.resolve(cell);
  var table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);
  var col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;
  for (var row = 0; row < map.height; row++) {
    var index = col + row * map.width - 1;
    // For positions that are have either a different cell or the end
    // of the table to their right, and either the top of the table or
    // a different cell above them, add a decoration
    if ((col == map.width || map.map[index] != map.map[index + 1]) &&
        (row == 0 || map.map[index - 1] != map.map[index - 1 - map.width])) {
      var cellPos = map.map[index];
      var pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;
      var dom = document.createElement("div");
      dom.className = "column-resize-handle";
      decorations.push(Decoration.widget(pos, dom));
    }
  }
  return DecorationSet.create(state.doc, decorations)
}

// This file defines a plugin that handles the drawing of cell

// :: () → Plugin
//
// Creates a [plugin](http://prosemirror.net/docs/ref/#state.Plugin)
// that, when added to an editor, enables cell-selection, handles
// cell-based copy/paste, and makes sure tables stay well-formed (each
// row has the same width, and cells don't overlap).
//
// You should probably put this plugin near the end of your array of
// plugins, since it handles mouse and arrow key events in tables
// rather broadly, and other plugins, like the gap cursor or the
// column-width dragging plugin, might want to get a turn first to
// perform more specific behavior.
function tableEditing(ref) {
  if ( ref === void 0 ) ref = {};
  var allowTableNodeSelection = ref.allowTableNodeSelection; if ( allowTableNodeSelection === void 0 ) allowTableNodeSelection = false;

  return new Plugin({
    key: key,

    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init: function init() { return null },
      apply: function apply(tr, cur) {
        var set = tr.getMeta(key);
        if (set != null) { return set == -1 ? null : set }
        if (cur == null || !tr.docChanged) { return cur }
        var ref = tr.mapping.mapResult(cur);
        var deleted = ref.deleted;
        var pos = ref.pos;
        return deleted ? null : pos
      }
    },

    props: {
      decorations: drawCellSelection,

      handleDOMEvents: {
        mousedown: handleMouseDown
      },

      createSelectionBetween: function createSelectionBetween(view) {
        if (key.getState(view.state) != null) { return view.state.selection }
      },

      handleTripleClick: handleTripleClick,

      handleKeyDown: handleKeyDown$1,

      handlePaste: handlePaste
    },

    appendTransaction: function appendTransaction(_, oldState, state) {
      return normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection)
    }
  })
}

function createCell(cellType, cellContent) {
    if (cellContent) {
        return cellType.createChecked(null, cellContent);
    }
    return cellType.createAndFill();
}

function getTableNodeTypes(schema) {
    if (schema.cached.tableNodeTypes) {
        return schema.cached.tableNodeTypes;
    }
    const roles = {};
    Object.keys(schema.nodes).forEach(type => {
        const nodeType = schema.nodes[type];
        if (nodeType.spec.tableRole) {
            roles[nodeType.spec.tableRole] = nodeType;
        }
    });
    schema.cached.tableNodeTypes = roles;
    return roles;
}

function createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {
    const types = getTableNodeTypes(schema);
    const headerCells = [];
    const cells = [];
    for (let index = 0; index < colsCount; index += 1) {
        const cell = createCell(types.cell, cellContent);
        if (cell) {
            cells.push(cell);
        }
        if (withHeaderRow) {
            const headerCell = createCell(types.header_cell, cellContent);
            if (headerCell) {
                headerCells.push(headerCell);
            }
        }
    }
    const rows = [];
    for (let index = 0; index < rowsCount; index += 1) {
        rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells));
    }
    return types.table.createChecked(null, rows);
}

function isCellSelection(value) {
    return value instanceof CellSelection;
}

const deleteTableWhenAllCellsSelected = ({ editor }) => {
    const { selection } = editor.state;
    if (!isCellSelection(selection)) {
        return false;
    }
    let cellCount = 0;
    const table = findParentNodeClosestToPos(selection.ranges[0].$from, node => {
        return node.type.name === 'table';
    });
    table === null || table === void 0 ? void 0 : table.node.descendants(node => {
        if (node.type.name === 'table') {
            return false;
        }
        if (['tableCell', 'tableHeader'].includes(node.type.name)) {
            cellCount += 1;
        }
    });
    const allCellsSelected = cellCount === selection.ranges.length;
    if (!allCellsSelected) {
        return false;
    }
    editor.commands.deleteTable();
    return true;
};

function updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {
    let totalWidth = 0;
    let fixedWidth = true;
    let nextDOM = colgroup.firstChild;
    const row = node.firstChild;
    for (let i = 0, col = 0; i < row.childCount; i += 1) {
        const { colspan, colwidth } = row.child(i).attrs;
        for (let j = 0; j < colspan; j += 1, col += 1) {
            const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];
            const cssWidth = hasWidth ? `${hasWidth}px` : '';
            totalWidth += hasWidth || cellMinWidth;
            if (!hasWidth) {
                fixedWidth = false;
            }
            if (!nextDOM) {
                colgroup.appendChild(document.createElement('col')).style.width = cssWidth;
            }
            else {
                if (nextDOM.style.width !== cssWidth) {
                    nextDOM.style.width = cssWidth;
                }
                nextDOM = nextDOM.nextSibling;
            }
        }
    }
    while (nextDOM) {
        const after = nextDOM.nextSibling;
        nextDOM.parentNode.removeChild(nextDOM);
        nextDOM = after;
    }
    if (fixedWidth) {
        table.style.width = `${totalWidth}px`;
        table.style.minWidth = '';
    }
    else {
        table.style.width = '';
        table.style.minWidth = `${totalWidth}px`;
    }
}
class TableView {
    constructor(node, cellMinWidth) {
        this.node = node;
        this.cellMinWidth = cellMinWidth;
        this.dom = document.createElement('div');
        this.dom.className = 'tableWrapper';
        this.table = this.dom.appendChild(document.createElement('table'));
        this.colgroup = this.table.appendChild(document.createElement('colgroup'));
        updateColumns(node, this.colgroup, this.table, cellMinWidth);
        this.contentDOM = this.table.appendChild(document.createElement('tbody'));
    }
    update(node) {
        if (node.type !== this.node.type) {
            return false;
        }
        this.node = node;
        updateColumns(node, this.colgroup, this.table, this.cellMinWidth);
        return true;
    }
    ignoreMutation(mutation) {
        return mutation.type === 'attributes' && (mutation.target === this.table || this.colgroup.contains(mutation.target));
    }
}

const Table = Node.create({
    name: 'table',
    // @ts-ignore
    addOptions() {
        return {
            HTMLAttributes: {},
            resizable: false,
            handleWidth: 5,
            cellMinWidth: 25,
            // TODO: fix
            View: TableView,
            lastColumnResizable: true,
            allowTableNodeSelection: false,
        };
    },
    content: 'tableRow+',
    tableRole: 'table',
    isolating: true,
    group: 'block',
    parseHTML() {
        return [
            { tag: 'table' },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['table', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), ['tbody', 0]];
    },
    addCommands() {
        return {
            insertTable: ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch, editor }) => {
                const node = createTable(editor.schema, rows, cols, withHeaderRow);
                if (dispatch) {
                    const offset = tr.selection.anchor + 1;
                    tr.replaceSelectionWith(node)
                        .scrollIntoView()
                        .setSelection(TextSelection.near(tr.doc.resolve(offset)));
                }
                return true;
            },
            addColumnBefore: () => ({ state, dispatch }) => {
                return addColumnBefore(state, dispatch);
            },
            addColumnAfter: () => ({ state, dispatch }) => {
                return addColumnAfter(state, dispatch);
            },
            deleteColumn: () => ({ state, dispatch }) => {
                return deleteColumn(state, dispatch);
            },
            addRowBefore: () => ({ state, dispatch }) => {
                return addRowBefore(state, dispatch);
            },
            addRowAfter: () => ({ state, dispatch }) => {
                return addRowAfter(state, dispatch);
            },
            deleteRow: () => ({ state, dispatch }) => {
                return deleteRow(state, dispatch);
            },
            deleteTable: () => ({ state, dispatch }) => {
                return deleteTable(state, dispatch);
            },
            mergeCells: () => ({ state, dispatch }) => {
                return mergeCells(state, dispatch);
            },
            splitCell: () => ({ state, dispatch }) => {
                return splitCell(state, dispatch);
            },
            toggleHeaderColumn: () => ({ state, dispatch }) => {
                return toggleHeader('column')(state, dispatch);
            },
            toggleHeaderRow: () => ({ state, dispatch }) => {
                return toggleHeader('row')(state, dispatch);
            },
            toggleHeaderCell: () => ({ state, dispatch }) => {
                return toggleHeaderCell(state, dispatch);
            },
            mergeOrSplit: () => ({ state, dispatch }) => {
                if (mergeCells(state, dispatch)) {
                    return true;
                }
                return splitCell(state, dispatch);
            },
            setCellAttribute: (name, value) => ({ state, dispatch }) => {
                return setCellAttr(name, value)(state, dispatch);
            },
            goToNextCell: () => ({ state, dispatch }) => {
                return goToNextCell(1)(state, dispatch);
            },
            goToPreviousCell: () => ({ state, dispatch }) => {
                return goToNextCell(-1)(state, dispatch);
            },
            fixTables: () => ({ state, dispatch }) => {
                if (dispatch) {
                    fixTables(state);
                }
                return true;
            },
            setCellSelection: position => ({ tr, dispatch }) => {
                if (dispatch) {
                    const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell);
                    // @ts-ignore
                    tr.setSelection(selection);
                }
                return true;
            },
        };
    },
    addKeyboardShortcuts() {
        return {
            Tab: () => {
                if (this.editor.commands.goToNextCell()) {
                    return true;
                }
                if (!this.editor.can().addRowAfter()) {
                    return false;
                }
                return this.editor
                    .chain()
                    .addRowAfter()
                    .goToNextCell()
                    .run();
            },
            'Shift-Tab': () => this.editor.commands.goToPreviousCell(),
            Backspace: deleteTableWhenAllCellsSelected,
            'Mod-Backspace': deleteTableWhenAllCellsSelected,
            Delete: deleteTableWhenAllCellsSelected,
            'Mod-Delete': deleteTableWhenAllCellsSelected,
        };
    },
    addProseMirrorPlugins() {
        const isResizable = this.options.resizable && this.editor.isEditable;
        return [
            ...(isResizable ? [columnResizing({
                    handleWidth: this.options.handleWidth,
                    cellMinWidth: this.options.cellMinWidth,
                    View: this.options.View,
                    // TODO: PR for @types/prosemirror-tables
                    // @ts-ignore (incorrect type)
                    lastColumnResizable: this.options.lastColumnResizable,
                })] : []),
            tableEditing({
                allowTableNodeSelection: this.options.allowTableNodeSelection,
            }),
        ];
    },
    extendNodeSchema(extension) {
        const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
        };
        return {
            tableRole: callOrReturn(getExtensionField(extension, 'tableRole', context)),
        };
    },
});

const TableCell = Node.create({
    name: 'tableCell',
    addOptions() {
        return {
            HTMLAttributes: {},
        };
    },
    content: 'block+',
    addAttributes() {
        return {
            colspan: {
                default: 1,
            },
            rowspan: {
                default: 1,
            },
            colwidth: {
                default: null,
                parseHTML: element => {
                    const colwidth = element.getAttribute('colwidth');
                    const value = colwidth
                        ? [parseInt(colwidth, 10)]
                        : null;
                    return value;
                },
            },
        };
    },
    tableRole: 'cell',
    isolating: true,
    parseHTML() {
        return [
            { tag: 'td' },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['td', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
});

const TableHeader = Node.create({
    name: 'tableHeader',
    addOptions() {
        return {
            HTMLAttributes: {},
        };
    },
    content: 'block+',
    addAttributes() {
        return {
            colspan: {
                default: 1,
            },
            rowspan: {
                default: 1,
            },
            colwidth: {
                default: null,
                parseHTML: element => {
                    const colwidth = element.getAttribute('colwidth');
                    const value = colwidth
                        ? [parseInt(colwidth, 10)]
                        : null;
                    return value;
                },
            },
        };
    },
    tableRole: 'header_cell',
    isolating: true,
    parseHTML() {
        return [
            { tag: 'th' },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['th', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
});

const TableRow = Node.create({
    name: 'tableRow',
    addOptions() {
        return {
            HTMLAttributes: {},
        };
    },
    content: '(tableCell | tableHeader)*',
    tableRole: 'row',
    parseHTML() {
        return [
            { tag: 'tr' },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['tr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
});

const TextAlign = Extension.create({
    name: 'textAlign',
    addOptions() {
        return {
            types: [],
            alignments: ['left', 'center', 'right', 'justify'],
            defaultAlignment: 'left',
        };
    },
    addGlobalAttributes() {
        return [
            {
                types: this.options.types,
                attributes: {
                    textAlign: {
                        default: this.options.defaultAlignment,
                        parseHTML: element => element.style.textAlign || this.options.defaultAlignment,
                        renderHTML: attributes => {
                            if (attributes.textAlign === this.options.defaultAlignment) {
                                return {};
                            }
                            return { style: `text-align: ${attributes.textAlign}` };
                        },
                    },
                },
            },
        ];
    },
    addCommands() {
        return {
            setTextAlign: (alignment) => ({ commands }) => {
                if (!this.options.alignments.includes(alignment)) {
                    return false;
                }
                return this.options.types.every(type => commands.updateAttributes(type, { textAlign: alignment }));
            },
            unsetTextAlign: () => ({ commands }) => {
                return this.options.types.every(type => commands.resetAttributes(type, 'textAlign'));
            },
        };
    },
    addKeyboardShortcuts() {
        return {
            'Mod-Shift-l': () => this.editor.commands.setTextAlign('left'),
            'Mod-Shift-e': () => this.editor.commands.setTextAlign('center'),
            'Mod-Shift-r': () => this.editor.commands.setTextAlign('right'),
            'Mod-Shift-j': () => this.editor.commands.setTextAlign('justify'),
        };
    },
});

const Underline = Mark.create({
    name: 'underline',
    addOptions() {
        return {
            HTMLAttributes: {},
        };
    },
    parseHTML() {
        return [
            {
                tag: 'u',
            },
            {
                style: 'text-decoration',
                consuming: false,
                getAttrs: style => (style.includes('underline') ? {} : false),
            },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['u', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
        return {
            setUnderline: () => ({ commands }) => {
                return commands.setMark(this.name);
            },
            toggleUnderline: () => ({ commands }) => {
                return commands.toggleMark(this.name);
            },
            unsetUnderline: () => ({ commands }) => {
                return commands.unsetMark(this.name);
            },
        };
    },
    addKeyboardShortcuts() {
        return {
            'Mod-u': () => this.editor.commands.toggleUnderline(),
            'Mod-U': () => this.editor.commands.toggleUnderline(),
        };
    },
});

const inputRegex$4 = /^\s*>\s$/;
const Blockquote = Node.create({
    name: 'blockquote',
    addOptions() {
        return {
            HTMLAttributes: {},
        };
    },
    content: 'block+',
    group: 'block',
    defining: true,
    parseHTML() {
        return [
            { tag: 'blockquote' },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['blockquote', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
        return {
            setBlockquote: () => ({ commands }) => {
                return commands.wrapIn(this.name);
            },
            toggleBlockquote: () => ({ commands }) => {
                return commands.toggleWrap(this.name);
            },
            unsetBlockquote: () => ({ commands }) => {
                return commands.lift(this.name);
            },
        };
    },
    addKeyboardShortcuts() {
        return {
            'Mod-Shift-b': () => this.editor.commands.toggleBlockquote(),
        };
    },
    addInputRules() {
        return [
            wrappingInputRule({
                find: inputRegex$4,
                type: this.type,
            }),
        ];
    },
});

const starInputRegex$1 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/;
const starPasteRegex$1 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g;
const underscoreInputRegex$1 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/;
const underscorePasteRegex$1 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;
const Bold = Mark.create({
    name: 'bold',
    addOptions() {
        return {
            HTMLAttributes: {},
        };
    },
    parseHTML() {
        return [
            {
                tag: 'strong',
            },
            {
                tag: 'b',
                getAttrs: node => node.style.fontWeight !== 'normal' && null,
            },
            {
                style: 'font-weight',
                getAttrs: value => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null,
            },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['strong', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
        return {
            setBold: () => ({ commands }) => {
                return commands.setMark(this.name);
            },
            toggleBold: () => ({ commands }) => {
                return commands.toggleMark(this.name);
            },
            unsetBold: () => ({ commands }) => {
                return commands.unsetMark(this.name);
            },
        };
    },
    addKeyboardShortcuts() {
        return {
            'Mod-b': () => this.editor.commands.toggleBold(),
            'Mod-B': () => this.editor.commands.toggleBold(),
        };
    },
    addInputRules() {
        return [
            markInputRule({
                find: starInputRegex$1,
                type: this.type,
            }),
            markInputRule({
                find: underscoreInputRegex$1,
                type: this.type,
            }),
        ];
    },
    addPasteRules() {
        return [
            markPasteRule({
                find: starPasteRegex$1,
                type: this.type,
            }),
            markPasteRule({
                find: underscorePasteRegex$1,
                type: this.type,
            }),
        ];
    },
});

const inputRegex$3 = /^\s*([-+*])\s$/;
const BulletList = Node.create({
    name: 'bulletList',
    addOptions() {
        return {
            itemTypeName: 'listItem',
            HTMLAttributes: {},
        };
    },
    group: 'block list',
    content() {
        return `${this.options.itemTypeName}+`;
    },
    parseHTML() {
        return [
            { tag: 'ul' },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
        return {
            toggleBulletList: () => ({ commands }) => {
                return commands.toggleList(this.name, this.options.itemTypeName);
            },
        };
    },
    addKeyboardShortcuts() {
        return {
            'Mod-Shift-8': () => this.editor.commands.toggleBulletList(),
        };
    },
    addInputRules() {
        return [
            wrappingInputRule({
                find: inputRegex$3,
                type: this.type,
            }),
        ];
    },
});

const inputRegex$2 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/;
const pasteRegex$1 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g;
const Code = Mark.create({
    name: 'code',
    addOptions() {
        return {
            HTMLAttributes: {},
        };
    },
    excludes: '_',
    code: true,
    parseHTML() {
        return [
            { tag: 'code' },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['code', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
        return {
            setCode: () => ({ commands }) => {
                return commands.setMark(this.name);
            },
            toggleCode: () => ({ commands }) => {
                return commands.toggleMark(this.name);
            },
            unsetCode: () => ({ commands }) => {
                return commands.unsetMark(this.name);
            },
        };
    },
    addKeyboardShortcuts() {
        return {
            'Mod-e': () => this.editor.commands.toggleCode(),
        };
    },
    addInputRules() {
        return [
            markInputRule({
                find: inputRegex$2,
                type: this.type,
            }),
        ];
    },
    addPasteRules() {
        return [
            markPasteRule({
                find: pasteRegex$1,
                type: this.type,
            }),
        ];
    },
});

const backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
const tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
const CodeBlock = Node.create({
    name: 'codeBlock',
    addOptions() {
        return {
            languageClassPrefix: 'language-',
            exitOnTripleEnter: true,
            exitOnArrowDown: true,
            HTMLAttributes: {},
        };
    },
    content: 'text*',
    marks: '',
    group: 'block',
    code: true,
    defining: true,
    addAttributes() {
        return {
            language: {
                default: null,
                parseHTML: element => {
                    var _a;
                    const { languageClassPrefix } = this.options;
                    const classNames = [...((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []];
                    const languages = classNames
                        .filter(className => className.startsWith(languageClassPrefix))
                        .map(className => className.replace(languageClassPrefix, ''));
                    const language = languages[0];
                    if (!language) {
                        return null;
                    }
                    return language;
                },
                rendered: false,
            },
        };
    },
    parseHTML() {
        return [
            {
                tag: 'pre',
                preserveWhitespace: 'full',
            },
        ];
    },
    renderHTML({ node, HTMLAttributes }) {
        return [
            'pre',
            mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
            [
                'code',
                {
                    class: node.attrs.language
                        ? this.options.languageClassPrefix + node.attrs.language
                        : null,
                },
                0,
            ],
        ];
    },
    addCommands() {
        return {
            setCodeBlock: attributes => ({ commands }) => {
                return commands.setNode(this.name, attributes);
            },
            toggleCodeBlock: attributes => ({ commands }) => {
                return commands.toggleNode(this.name, 'paragraph', attributes);
            },
        };
    },
    addKeyboardShortcuts() {
        return {
            'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),
            // remove code block when at start of document or code block is empty
            Backspace: () => {
                const { empty, $anchor } = this.editor.state.selection;
                const isAtStart = $anchor.pos === 1;
                if (!empty || $anchor.parent.type.name !== this.name) {
                    return false;
                }
                if (isAtStart || !$anchor.parent.textContent.length) {
                    return this.editor.commands.clearNodes();
                }
                return false;
            },
            // exit node on triple enter
            Enter: ({ editor }) => {
                if (!this.options.exitOnTripleEnter) {
                    return false;
                }
                const { state } = editor;
                const { selection } = state;
                const { $from, empty } = selection;
                if (!empty || $from.parent.type !== this.type) {
                    return false;
                }
                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
                const endsWithDoubleNewline = $from.parent.textContent.endsWith('\n\n');
                if (!isAtEnd || !endsWithDoubleNewline) {
                    return false;
                }
                return editor
                    .chain()
                    .command(({ tr }) => {
                    tr.delete($from.pos - 2, $from.pos);
                    return true;
                })
                    .exitCode()
                    .run();
            },
            // exit node on arrow down
            ArrowDown: ({ editor }) => {
                if (!this.options.exitOnArrowDown) {
                    return false;
                }
                const { state } = editor;
                const { selection, doc } = state;
                const { $from, empty } = selection;
                if (!empty || $from.parent.type !== this.type) {
                    return false;
                }
                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
                if (!isAtEnd) {
                    return false;
                }
                const after = $from.after();
                if (after === undefined) {
                    return false;
                }
                const nodeAfter = doc.nodeAt(after);
                if (nodeAfter) {
                    return false;
                }
                return editor.commands.exitCode();
            },
        };
    },
    addInputRules() {
        return [
            textblockTypeInputRule({
                find: backtickInputRegex,
                type: this.type,
                getAttributes: match => ({
                    language: match[1],
                }),
            }),
            textblockTypeInputRule({
                find: tildeInputRegex,
                type: this.type,
                getAttributes: match => ({
                    language: match[1],
                }),
            }),
        ];
    },
    addProseMirrorPlugins() {
        return [
            // this plugin creates a code block for pasted content from VS Code
            // we can also detect the copied code language
            new Plugin({
                key: new PluginKey('codeBlockVSCodeHandler'),
                props: {
                    handlePaste: (view, event) => {
                        if (!event.clipboardData) {
                            return false;
                        }
                        // don’t create a new code block within code blocks
                        if (this.editor.isActive(this.type.name)) {
                            return false;
                        }
                        const text = event.clipboardData.getData('text/plain');
                        const vscode = event.clipboardData.getData('vscode-editor-data');
                        const vscodeData = vscode
                            ? JSON.parse(vscode)
                            : undefined;
                        const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
                        if (!text || !language) {
                            return false;
                        }
                        const { tr } = view.state;
                        // create an empty code block
                        tr.replaceSelectionWith(this.type.create({ language }));
                        // put cursor inside the newly created code block
                        tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));
                        // add text to code block
                        // strip carriage return chars from text pasted as code
                        // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd
                        tr.insertText(text.replace(/\r\n?/g, '\n'));
                        // store meta information
                        // this is useful for other plugins that depends on the paste event
                        // like the paste rule plugin
                        tr.setMeta('paste', true);
                        view.dispatch(tr);
                        return true;
                    },
                },
            }),
        ];
    },
});

const Document = Node.create({
    name: 'doc',
    topNode: true,
    content: 'block+',
});

/**
Create a plugin that, when added to a ProseMirror instance,
causes a decoration to show up at the drop position when something
is dragged over the editor.

Nodes may add a `disableDropCursor` property to their spec to
control the showing of a drop cursor inside them. This may be a
boolean or a function, which will be called with a view and a
position, and should return a boolean.
*/
function dropCursor(options = {}) {
    return new Plugin({
        view(editorView) { return new DropCursorView(editorView, options); }
    });
}
class DropCursorView {
    constructor(editorView, options) {
        this.editorView = editorView;
        this.cursorPos = null;
        this.element = null;
        this.timeout = -1;
        this.width = options.width || 1;
        this.color = options.color || "black";
        this.class = options.class;
        this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(name => {
            let handler = (e) => { this[name](e); };
            editorView.dom.addEventListener(name, handler);
            return { name, handler };
        });
    }
    destroy() {
        this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
    }
    update(editorView, prevState) {
        if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
            if (this.cursorPos > editorView.state.doc.content.size)
                this.setCursor(null);
            else
                this.updateOverlay();
        }
    }
    setCursor(pos) {
        if (pos == this.cursorPos)
            return;
        this.cursorPos = pos;
        if (pos == null) {
            this.element.parentNode.removeChild(this.element);
            this.element = null;
        }
        else {
            this.updateOverlay();
        }
    }
    updateOverlay() {
        let $pos = this.editorView.state.doc.resolve(this.cursorPos), rect;
        if (!$pos.parent.inlineContent) {
            let before = $pos.nodeBefore, after = $pos.nodeAfter;
            if (before || after) {
                let nodeRect = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0))
                    .getBoundingClientRect();
                let top = before ? nodeRect.bottom : nodeRect.top;
                if (before && after)
                    top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
                rect = { left: nodeRect.left, right: nodeRect.right, top: top - this.width / 2, bottom: top + this.width / 2 };
            }
        }
        if (!rect) {
            let coords = this.editorView.coordsAtPos(this.cursorPos);
            rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };
        }
        let parent = this.editorView.dom.offsetParent;
        if (!this.element) {
            this.element = parent.appendChild(document.createElement("div"));
            if (this.class)
                this.element.className = this.class;
            this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none; background-color: " + this.color;
        }
        let parentLeft, parentTop;
        if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
            parentLeft = -pageXOffset;
            parentTop = -pageYOffset;
        }
        else {
            let rect = parent.getBoundingClientRect();
            parentLeft = rect.left - parent.scrollLeft;
            parentTop = rect.top - parent.scrollTop;
        }
        this.element.style.left = (rect.left - parentLeft) + "px";
        this.element.style.top = (rect.top - parentTop) + "px";
        this.element.style.width = (rect.right - rect.left) + "px";
        this.element.style.height = (rect.bottom - rect.top) + "px";
    }
    scheduleRemoval(timeout) {
        clearTimeout(this.timeout);
        this.timeout = setTimeout(() => this.setCursor(null), timeout);
    }
    dragover(event) {
        if (!this.editorView.editable)
            return;
        let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
        let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
        let disableDropCursor = node && node.type.spec.disableDropCursor;
        let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos) : disableDropCursor;
        if (pos && !disabled) {
            let target = pos.pos;
            if (this.editorView.dragging && this.editorView.dragging.slice) {
                target = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
                if (target == null)
                    return this.setCursor(null);
            }
            this.setCursor(target);
            this.scheduleRemoval(5000);
        }
    }
    dragend() {
        this.scheduleRemoval(20);
    }
    drop() {
        this.scheduleRemoval(20);
    }
    dragleave(event) {
        if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))
            this.setCursor(null);
    }
}

const Dropcursor = Extension.create({
    name: 'dropCursor',
    addOptions() {
        return {
            color: 'currentColor',
            width: 1,
            class: null,
        };
    },
    addProseMirrorPlugins() {
        return [
            dropCursor(this.options),
        ];
    },
});

/**
Gap cursor selections are represented using this class. Its
`$anchor` and `$head` properties both point at the cursor position.
*/
class GapCursor extends Selection {
    /**
    Create a gap cursor.
    */
    constructor($pos) {
        super($pos, $pos);
    }
    map(doc, mapping) {
        let $pos = doc.resolve(mapping.map(this.head));
        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
    }
    content() { return Slice.empty; }
    eq(other) {
        return other instanceof GapCursor && other.head == this.head;
    }
    toJSON() {
        return { type: "gapcursor", pos: this.head };
    }
    /**
    @internal
    */
    static fromJSON(doc, json) {
        if (typeof json.pos != "number")
            throw new RangeError("Invalid input for GapCursor.fromJSON");
        return new GapCursor(doc.resolve(json.pos));
    }
    /**
    @internal
    */
    getBookmark() { return new GapBookmark(this.anchor); }
    /**
    @internal
    */
    static valid($pos) {
        let parent = $pos.parent;
        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
            return false;
        let override = parent.type.spec.allowGapCursor;
        if (override != null)
            return override;
        let deflt = parent.contentMatchAt($pos.index()).defaultType;
        return deflt && deflt.isTextblock;
    }
    /**
    @internal
    */
    static findGapCursorFrom($pos, dir, mustMove = false) {
        search: for (;;) {
            if (!mustMove && GapCursor.valid($pos))
                return $pos;
            let pos = $pos.pos, next = null;
            // Scan up from this position
            for (let d = $pos.depth;; d--) {
                let parent = $pos.node(d);
                if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
                    next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
                    break;
                }
                else if (d == 0) {
                    return null;
                }
                pos += dir;
                let $cur = $pos.doc.resolve(pos);
                if (GapCursor.valid($cur))
                    return $cur;
            }
            // And then down into the next node
            for (;;) {
                let inside = dir > 0 ? next.firstChild : next.lastChild;
                if (!inside) {
                    if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
                        $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
                        mustMove = false;
                        continue search;
                    }
                    break;
                }
                next = inside;
                pos += dir;
                let $cur = $pos.doc.resolve(pos);
                if (GapCursor.valid($cur))
                    return $cur;
            }
            return null;
        }
    }
}
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
class GapBookmark {
    constructor(pos) {
        this.pos = pos;
    }
    map(mapping) {
        return new GapBookmark(mapping.map(this.pos));
    }
    resolve(doc) {
        let $pos = doc.resolve(this.pos);
        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
    }
}
function closedBefore($pos) {
    for (let d = $pos.depth; d >= 0; d--) {
        let index = $pos.index(d), parent = $pos.node(d);
        // At the start of this parent, look at next one
        if (index == 0) {
            if (parent.type.spec.isolating)
                return true;
            continue;
        }
        // See if the node before (or its first ancestor) is closed
        for (let before = parent.child(index - 1);; before = before.lastChild) {
            if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating)
                return true;
            if (before.inlineContent)
                return false;
        }
    }
    // Hit start of document
    return true;
}
function closedAfter($pos) {
    for (let d = $pos.depth; d >= 0; d--) {
        let index = $pos.indexAfter(d), parent = $pos.node(d);
        if (index == parent.childCount) {
            if (parent.type.spec.isolating)
                return true;
            continue;
        }
        for (let after = parent.child(index);; after = after.firstChild) {
            if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating)
                return true;
            if (after.inlineContent)
                return false;
        }
    }
    return true;
}

/**
Create a gap cursor plugin. When enabled, this will capture clicks
near and arrow-key-motion past places that don't have a normally
selectable position nearby, and create a gap cursor selection for
them. The cursor is drawn as an element with class
`ProseMirror-gapcursor`. You can either include
`style/gapcursor.css` from the package's directory or add your own
styles to make it visible.
*/
function gapCursor() {
    return new Plugin({
        props: {
            decorations: drawGapCursor,
            createSelectionBetween(_view, $anchor, $head) {
                return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
            },
            handleClick,
            handleKeyDown,
            handleDOMEvents: { beforeinput: beforeinput }
        }
    });
}
const handleKeyDown = keydownHandler({
    "ArrowLeft": arrow("horiz", -1),
    "ArrowRight": arrow("horiz", 1),
    "ArrowUp": arrow("vert", -1),
    "ArrowDown": arrow("vert", 1)
});
function arrow(axis, dir) {
    const dirStr = axis == "vert" ? (dir > 0 ? "down" : "up") : (dir > 0 ? "right" : "left");
    return function (state, dispatch, view) {
        let sel = state.selection;
        let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
        if (sel instanceof TextSelection) {
            if (!view.endOfTextblock(dirStr) || $start.depth == 0)
                return false;
            mustMove = false;
            $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
        }
        let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
        if (!$found)
            return false;
        if (dispatch)
            dispatch(state.tr.setSelection(new GapCursor($found)));
        return true;
    };
}
function handleClick(view, pos, event) {
    if (!view || !view.editable)
        return false;
    let $pos = view.state.doc.resolve(pos);
    if (!GapCursor.valid($pos))
        return false;
    let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
    if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
        return false;
    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
    return true;
}
// This is a hack that, when a composition starts while a gap cursor
// is active, quickly creates an inline context for the composition to
// happen in, to avoid it being aborted by the DOM selection being
// moved into a valid position.
function beforeinput(view, event) {
    if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
        return false;
    let { $from } = view.state.selection;
    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
    if (!insert)
        return false;
    let frag = Fragment.empty;
    for (let i = insert.length - 1; i >= 0; i--)
        frag = Fragment.from(insert[i].createAndFill(null, frag));
    let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
    tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));
    view.dispatch(tr);
    return false;
}
function drawGapCursor(state) {
    if (!(state.selection instanceof GapCursor))
        return null;
    let node = document.createElement("div");
    node.className = "ProseMirror-gapcursor";
    return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}

const Gapcursor = Extension.create({
    name: 'gapCursor',
    addProseMirrorPlugins() {
        return [
            gapCursor(),
        ];
    },
    extendNodeSchema(extension) {
        var _a;
        const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
        };
        return {
            allowGapCursor: (_a = callOrReturn(getExtensionField(extension, 'allowGapCursor', context))) !== null && _a !== void 0 ? _a : null,
        };
    },
});

const Heading = Node.create({
    name: 'heading',
    addOptions() {
        return {
            levels: [1, 2, 3, 4, 5, 6],
            HTMLAttributes: {},
        };
    },
    content: 'inline*',
    group: 'block',
    defining: true,
    addAttributes() {
        return {
            level: {
                default: 1,
                rendered: false,
            },
        };
    },
    parseHTML() {
        return this.options.levels
            .map((level) => ({
            tag: `h${level}`,
            attrs: { level },
        }));
    },
    renderHTML({ node, HTMLAttributes }) {
        const hasLevel = this.options.levels.includes(node.attrs.level);
        const level = hasLevel
            ? node.attrs.level
            : this.options.levels[0];
        return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
        return {
            setHeading: attributes => ({ commands }) => {
                if (!this.options.levels.includes(attributes.level)) {
                    return false;
                }
                return commands.setNode(this.name, attributes);
            },
            toggleHeading: attributes => ({ commands }) => {
                if (!this.options.levels.includes(attributes.level)) {
                    return false;
                }
                return commands.toggleNode(this.name, 'paragraph', attributes);
            },
        };
    },
    addKeyboardShortcuts() {
        return this.options.levels.reduce((items, level) => ({
            ...items,
            ...{
                [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level }),
            },
        }), {});
    },
    addInputRules() {
        return this.options.levels.map(level => {
            return textblockTypeInputRule({
                find: new RegExp(`^(#{1,${level}})\\s$`),
                type: this.type,
                getAttributes: {
                    level,
                },
            });
        });
    },
});

var GOOD_LEAF_SIZE = 200;

// :: class<T> A rope sequence is a persistent sequence data structure
// that supports appending, prepending, and slicing without doing a
// full copy. It is represented as a mostly-balanced tree.
var RopeSequence = function RopeSequence () {};

RopeSequence.prototype.append = function append (other) {
  if (!other.length) { return this }
  other = RopeSequence.from(other);

  return (!this.length && other) ||
    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||
    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||
    this.appendInner(other)
};

// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>
// Prepend an array or other rope to this one, returning a new rope.
RopeSequence.prototype.prepend = function prepend (other) {
  if (!other.length) { return this }
  return RopeSequence.from(other).append(this)
};

RopeSequence.prototype.appendInner = function appendInner (other) {
  return new Append(this, other)
};

// :: (?number, ?number) → RopeSequence<T>
// Create a rope repesenting a sub-sequence of this rope.
RopeSequence.prototype.slice = function slice (from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  if (from >= to) { return RopeSequence.empty }
  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))
};

// :: (number) → T
// Retrieve the element at the given position from this rope.
RopeSequence.prototype.get = function get (i) {
  if (i < 0 || i >= this.length) { return undefined }
  return this.getInner(i)
};

// :: ((element: T, index: number) → ?bool, ?number, ?number)
// Call the given function for each element between the given
// indices. This tends to be more efficient than looping over the
// indices and calling `get`, because it doesn't have to descend the
// tree for every element.
RopeSequence.prototype.forEach = function forEach (f, from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  if (from <= to)
    { this.forEachInner(f, from, to, 0); }
  else
    { this.forEachInvertedInner(f, from, to, 0); }
};

// :: ((element: T, index: number) → U, ?number, ?number) → [U]
// Map the given functions over the elements of the rope, producing
// a flat array.
RopeSequence.prototype.map = function map (f, from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  var result = [];
  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);
  return result
};

// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>
// Create a rope representing the given array, or return the rope
// itself if a rope was given.
RopeSequence.from = function from (values) {
  if (values instanceof RopeSequence) { return values }
  return values && values.length ? new Leaf(values) : RopeSequence.empty
};

var Leaf = /*@__PURE__*/(function (RopeSequence) {
  function Leaf(values) {
    RopeSequence.call(this);
    this.values = values;
  }

  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;
  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );
  Leaf.prototype.constructor = Leaf;

  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };

  Leaf.prototype.flatten = function flatten () {
    return this.values
  };

  Leaf.prototype.sliceInner = function sliceInner (from, to) {
    if (from == 0 && to == this.length) { return this }
    return new Leaf(this.values.slice(from, to))
  };

  Leaf.prototype.getInner = function getInner (i) {
    return this.values[i]
  };

  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {
    for (var i = from; i < to; i++)
      { if (f(this.values[i], start + i) === false) { return false } }
  };

  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {
    for (var i = from - 1; i >= to; i--)
      { if (f(this.values[i], start + i) === false) { return false } }
  };

  Leaf.prototype.leafAppend = function leafAppend (other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE)
      { return new Leaf(this.values.concat(other.flatten())) }
  };

  Leaf.prototype.leafPrepend = function leafPrepend (other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE)
      { return new Leaf(other.flatten().concat(this.values)) }
  };

  prototypeAccessors.length.get = function () { return this.values.length };

  prototypeAccessors.depth.get = function () { return 0 };

  Object.defineProperties( Leaf.prototype, prototypeAccessors );

  return Leaf;
}(RopeSequence));

// :: RopeSequence
// The empty rope sequence.
RopeSequence.empty = new Leaf([]);

var Append = /*@__PURE__*/(function (RopeSequence) {
  function Append(left, right) {
    RopeSequence.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }

  if ( RopeSequence ) Append.__proto__ = RopeSequence;
  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );
  Append.prototype.constructor = Append;

  Append.prototype.flatten = function flatten () {
    return this.left.flatten().concat(this.right.flatten())
  };

  Append.prototype.getInner = function getInner (i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)
  };

  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {
    var leftLen = this.left.length;
    if (from < leftLen &&
        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)
      { return false }
    if (to > leftLen &&
        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)
      { return false }
  };

  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {
    var leftLen = this.left.length;
    if (from > leftLen &&
        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)
      { return false }
    if (to < leftLen &&
        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)
      { return false }
  };

  Append.prototype.sliceInner = function sliceInner (from, to) {
    if (from == 0 && to == this.length) { return this }
    var leftLen = this.left.length;
    if (to <= leftLen) { return this.left.slice(from, to) }
    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }
    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))
  };

  Append.prototype.leafAppend = function leafAppend (other) {
    var inner = this.right.leafAppend(other);
    if (inner) { return new Append(this.left, inner) }
  };

  Append.prototype.leafPrepend = function leafPrepend (other) {
    var inner = this.left.leafPrepend(other);
    if (inner) { return new Append(inner, this.right) }
  };

  Append.prototype.appendInner = function appendInner (other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)
      { return new Append(this.left, new Append(this.right, other)) }
    return new Append(this, other)
  };

  return Append;
}(RopeSequence));

var ropeSequence = RopeSequence;

// ProseMirror's history isn't simply a way to roll back to a previous
// state, because ProseMirror supports applying changes without adding
// them to the history (for example during collaboration).
//
// To this end, each 'Branch' (one for the undo history and one for
// the redo history) keeps an array of 'Items', which can optionally
// hold a step (an actual undoable change), and always hold a position
// map (which is needed to move changes below them to apply to the
// current document).
//
// An item that has both a step and a selection bookmark is the start
// of an 'event' — a group of changes that will be undone or redone at
// once. (It stores only the bookmark, since that way we don't have to
// provide a document until the selection is actually applied, which
// is useful when compressing.)
// Used to schedule history compression
const max_empty_items = 500;
class Branch {
    constructor(items, eventCount) {
        this.items = items;
        this.eventCount = eventCount;
    }
    // Pop the latest event off the branch's history and apply it
    // to a document transform.
    popEvent(state, preserveItems) {
        if (this.eventCount == 0)
            return null;
        let end = this.items.length;
        for (;; end--) {
            let next = this.items.get(end - 1);
            if (next.selection) {
                --end;
                break;
            }
        }
        let remap, mapFrom;
        if (preserveItems) {
            remap = this.remapping(end, this.items.length);
            mapFrom = remap.maps.length;
        }
        let transform = state.tr;
        let selection, remaining;
        let addAfter = [], addBefore = [];
        this.items.forEach((item, i) => {
            if (!item.step) {
                if (!remap) {
                    remap = this.remapping(end, i + 1);
                    mapFrom = remap.maps.length;
                }
                mapFrom--;
                addBefore.push(item);
                return;
            }
            if (remap) {
                addBefore.push(new Item(item.map));
                let step = item.step.map(remap.slice(mapFrom)), map;
                if (step && transform.maybeStep(step).doc) {
                    map = transform.mapping.maps[transform.mapping.maps.length - 1];
                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));
                }
                mapFrom--;
                if (map)
                    remap.appendMap(map, mapFrom);
            }
            else {
                transform.maybeStep(item.step);
            }
            if (item.selection) {
                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
                return false;
            }
        }, this.items.length, 0);
        return { remaining: remaining, transform, selection: selection };
    }
    // Create a new branch with the given transform added.
    addTransform(transform, selection, histOptions, preserveItems) {
        let newItems = [], eventCount = this.eventCount;
        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
        for (let i = 0; i < transform.steps.length; i++) {
            let step = transform.steps[i].invert(transform.docs[i]);
            let item = new Item(transform.mapping.maps[i], step, selection), merged;
            if (merged = lastItem && lastItem.merge(item)) {
                item = merged;
                if (i)
                    newItems.pop();
                else
                    oldItems = oldItems.slice(0, oldItems.length - 1);
            }
            newItems.push(item);
            if (selection) {
                eventCount++;
                selection = undefined;
            }
            if (!preserveItems)
                lastItem = item;
        }
        let overflow = eventCount - histOptions.depth;
        if (overflow > DEPTH_OVERFLOW) {
            oldItems = cutOffEvents(oldItems, overflow);
            eventCount -= overflow;
        }
        return new Branch(oldItems.append(newItems), eventCount);
    }
    remapping(from, to) {
        let maps = new Mapping;
        this.items.forEach((item, i) => {
            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from
                ? maps.maps.length - item.mirrorOffset : undefined;
            maps.appendMap(item.map, mirrorPos);
        }, from, to);
        return maps;
    }
    addMaps(array) {
        if (this.eventCount == 0)
            return this;
        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);
    }
    // When the collab module receives remote changes, the history has
    // to know about those, so that it can adjust the steps that were
    // rebased on top of the remote changes, and include the position
    // maps for the remote changes in its array of items.
    rebased(rebasedTransform, rebasedCount) {
        if (!this.eventCount)
            return this;
        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);
        let mapping = rebasedTransform.mapping;
        let newUntil = rebasedTransform.steps.length;
        let eventCount = this.eventCount;
        this.items.forEach(item => { if (item.selection)
            eventCount--; }, start);
        let iRebased = rebasedCount;
        this.items.forEach(item => {
            let pos = mapping.getMirror(--iRebased);
            if (pos == null)
                return;
            newUntil = Math.min(newUntil, pos);
            let map = mapping.maps[pos];
            if (item.step) {
                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
                if (selection)
                    eventCount++;
                rebasedItems.push(new Item(map, step, selection));
            }
            else {
                rebasedItems.push(new Item(map));
            }
        }, start);
        let newMaps = [];
        for (let i = rebasedCount; i < newUntil; i++)
            newMaps.push(new Item(mapping.maps[i]));
        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
        let branch = new Branch(items, eventCount);
        if (branch.emptyItemCount() > max_empty_items)
            branch = branch.compress(this.items.length - rebasedItems.length);
        return branch;
    }
    emptyItemCount() {
        let count = 0;
        this.items.forEach(item => { if (!item.step)
            count++; });
        return count;
    }
    // Compressing a branch means rewriting it to push the air (map-only
    // items) out. During collaboration, these naturally accumulate
    // because each remote change adds one. The `upto` argument is used
    // to ensure that only the items below a given level are compressed,
    // because `rebased` relies on a clean, untouched set of items in
    // order to associate old items with rebased steps.
    compress(upto = this.items.length) {
        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
        let items = [], events = 0;
        this.items.forEach((item, i) => {
            if (i >= upto) {
                items.push(item);
                if (item.selection)
                    events++;
            }
            else if (item.step) {
                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();
                mapFrom--;
                if (map)
                    remap.appendMap(map, mapFrom);
                if (step) {
                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));
                    if (selection)
                        events++;
                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;
                    if (merged = items.length && items[last].merge(newItem))
                        items[last] = merged;
                    else
                        items.push(newItem);
                }
            }
            else if (item.map) {
                mapFrom--;
            }
        }, this.items.length, 0);
        return new Branch(ropeSequence.from(items.reverse()), events);
    }
}
Branch.empty = new Branch(ropeSequence.empty, 0);
function cutOffEvents(items, n) {
    let cutPoint;
    items.forEach((item, i) => {
        if (item.selection && (n-- == 0)) {
            cutPoint = i;
            return false;
        }
    });
    return items.slice(cutPoint);
}
class Item {
    constructor(
    // The (forward) step map for this item.
    map, 
    // The inverted step
    step, 
    // If this is non-null, this item is the start of a group, and
    // this selection is the starting selection for the group (the one
    // that was active before the first step was applied)
    selection, 
    // If this item is the inverse of a previous mapping on the stack,
    // this points at the inverse's offset
    mirrorOffset) {
        this.map = map;
        this.step = step;
        this.selection = selection;
        this.mirrorOffset = mirrorOffset;
    }
    merge(other) {
        if (this.step && other.step && !other.selection) {
            let step = other.step.merge(this.step);
            if (step)
                return new Item(step.getMap().invert(), step, this.selection);
        }
    }
}
// The value of the state field that tracks undo/redo history for that
// state. Will be stored in the plugin state when the history plugin
// is active.
class HistoryState {
    constructor(done, undone, prevRanges, prevTime) {
        this.done = done;
        this.undone = undone;
        this.prevRanges = prevRanges;
        this.prevTime = prevTime;
    }
}
const DEPTH_OVERFLOW = 20;
// Record a transformation in undo history.
function applyTransaction(history, state, tr, options) {
    let historyTr = tr.getMeta(historyKey), rebased;
    if (historyTr)
        return historyTr.historyState;
    if (tr.getMeta(closeHistoryKey))
        history = new HistoryState(history.done, history.undone, null, 0);
    let appended = tr.getMeta("appendedTransaction");
    if (tr.steps.length == 0) {
        return history;
    }
    else if (appended && appended.getMeta(historyKey)) {
        if (appended.getMeta(historyKey).redo)
            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime);
        else
            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime);
    }
    else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
        // Group transforms that occur in quick succession into one event.
        let newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay ||
            !isAdjacentTo(tr, history.prevRanges));
        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);
    }
    else if (rebased = tr.getMeta("rebased")) {
        // Used by the collab module to tell the history that some of its
        // content has been rebased.
        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime);
    }
    else {
        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime);
    }
}
function isAdjacentTo(transform, prevRanges) {
    if (!prevRanges)
        return false;
    if (!transform.docChanged)
        return true;
    let adjacent = false;
    transform.mapping.maps[0].forEach((start, end) => {
        for (let i = 0; i < prevRanges.length; i += 2)
            if (start <= prevRanges[i + 1] && end >= prevRanges[i])
                adjacent = true;
    });
    return adjacent;
}
function rangesFor(map) {
    let result = [];
    map.forEach((_from, _to, from, to) => result.push(from, to));
    return result;
}
function mapRanges(ranges, mapping) {
    if (!ranges)
        return null;
    let result = [];
    for (let i = 0; i < ranges.length; i += 2) {
        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
        if (from <= to)
            result.push(from, to);
    }
    return result;
}
// Apply the latest event from one branch to the document and shift the event
// onto the other branch.
function histTransaction(history, state, dispatch, redo) {
    let preserveItems = mustPreserveItems(state);
    let histOptions = historyKey.get(state).spec.config;
    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);
    if (!pop)
        return;
    let selection = pop.selection.resolve(pop.transform.doc);
    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);
    dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist }).scrollIntoView());
}
let cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
// Check whether any plugin in the given state has a
// `historyPreserveItems` property in its spec, in which case we must
// preserve steps exactly as they came in, so that they can be
// rebased.
function mustPreserveItems(state) {
    let plugins = state.plugins;
    if (cachedPreserveItemsPlugins != plugins) {
        cachedPreserveItems = false;
        cachedPreserveItemsPlugins = plugins;
        for (let i = 0; i < plugins.length; i++)
            if (plugins[i].spec.historyPreserveItems) {
                cachedPreserveItems = true;
                break;
            }
    }
    return cachedPreserveItems;
}
const historyKey = new PluginKey("history");
const closeHistoryKey = new PluginKey("closeHistory");
/**
Returns a plugin that enables the undo history for an editor. The
plugin will track undo and redo stacks, which can be used with the
[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.

You can set an `"addToHistory"` [metadata
property](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction
to prevent it from being rolled back by undo.
*/
function history(config = {}) {
    config = { depth: config.depth || 100,
        newGroupDelay: config.newGroupDelay || 500 };
    return new Plugin({
        key: historyKey,
        state: {
            init() {
                return new HistoryState(Branch.empty, Branch.empty, null, 0);
            },
            apply(tr, hist, state) {
                return applyTransaction(hist, state, tr, config);
            }
        },
        config,
        props: {
            handleDOMEvents: {
                beforeinput(view, e) {
                    let inputType = e.inputType;
                    let command = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
                    if (!command)
                        return false;
                    e.preventDefault();
                    return command(view.state, view.dispatch);
                }
            }
        }
    });
}
/**
A command function that undoes the last change, if any.
*/
const undo = (state, dispatch) => {
    let hist = historyKey.getState(state);
    if (!hist || hist.done.eventCount == 0)
        return false;
    if (dispatch)
        histTransaction(hist, state, dispatch, false);
    return true;
};
/**
A command function that redoes the last undone change, if any.
*/
const redo = (state, dispatch) => {
    let hist = historyKey.getState(state);
    if (!hist || hist.undone.eventCount == 0)
        return false;
    if (dispatch)
        histTransaction(hist, state, dispatch, true);
    return true;
};

const History = Extension.create({
    name: 'history',
    addOptions() {
        return {
            depth: 100,
            newGroupDelay: 500,
        };
    },
    addCommands() {
        return {
            undo: () => ({ state, dispatch }) => {
                return undo(state, dispatch);
            },
            redo: () => ({ state, dispatch }) => {
                return redo(state, dispatch);
            },
        };
    },
    addProseMirrorPlugins() {
        return [
            history(this.options),
        ];
    },
    addKeyboardShortcuts() {
        return {
            'Mod-z': () => this.editor.commands.undo(),
            'Mod-y': () => this.editor.commands.redo(),
            'Shift-Mod-z': () => this.editor.commands.redo(),
            // Russian keyboard layouts
            'Mod-я': () => this.editor.commands.undo(),
            'Shift-Mod-я': () => this.editor.commands.redo(),
        };
    },
});

const HorizontalRule = Node.create({
    name: 'horizontalRule',
    addOptions() {
        return {
            HTMLAttributes: {},
        };
    },
    group: 'block',
    parseHTML() {
        return [
            { tag: 'hr' },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
    },
    addCommands() {
        return {
            setHorizontalRule: () => ({ chain }) => {
                return chain()
                    .insertContent({ type: this.name })
                    // set cursor after horizontal rule
                    .command(({ tr, dispatch }) => {
                    var _a;
                    if (dispatch) {
                        const { $to } = tr.selection;
                        const posAfter = $to.end();
                        if ($to.nodeAfter) {
                            tr.setSelection(TextSelection.create(tr.doc, $to.pos));
                        }
                        else {
                            // add node after horizontal rule if it’s the end of the document
                            const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();
                            if (node) {
                                tr.insert(posAfter, node);
                                tr.setSelection(TextSelection.create(tr.doc, posAfter));
                            }
                        }
                        tr.scrollIntoView();
                    }
                    return true;
                })
                    .run();
            },
        };
    },
    addInputRules() {
        return [
            nodeInputRule({
                find: /^(?:---|—-|___\s|\*\*\*\s)$/,
                type: this.type,
            }),
        ];
    },
});

const starInputRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/;
const starPasteRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g;
const underscoreInputRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/;
const underscorePasteRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;
const Italic = Mark.create({
    name: 'italic',
    addOptions() {
        return {
            HTMLAttributes: {},
        };
    },
    parseHTML() {
        return [
            {
                tag: 'em',
            },
            {
                tag: 'i',
                getAttrs: node => node.style.fontStyle !== 'normal' && null,
            },
            {
                style: 'font-style=italic',
            },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['em', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
        return {
            setItalic: () => ({ commands }) => {
                return commands.setMark(this.name);
            },
            toggleItalic: () => ({ commands }) => {
                return commands.toggleMark(this.name);
            },
            unsetItalic: () => ({ commands }) => {
                return commands.unsetMark(this.name);
            },
        };
    },
    addKeyboardShortcuts() {
        return {
            'Mod-i': () => this.editor.commands.toggleItalic(),
            'Mod-I': () => this.editor.commands.toggleItalic(),
        };
    },
    addInputRules() {
        return [
            markInputRule({
                find: starInputRegex,
                type: this.type,
            }),
            markInputRule({
                find: underscoreInputRegex,
                type: this.type,
            }),
        ];
    },
    addPasteRules() {
        return [
            markPasteRule({
                find: starPasteRegex,
                type: this.type,
            }),
            markPasteRule({
                find: underscorePasteRegex,
                type: this.type,
            }),
        ];
    },
});

const ListItem = Node.create({
    name: 'listItem',
    addOptions() {
        return {
            HTMLAttributes: {},
        };
    },
    content: 'paragraph block*',
    defining: true,
    parseHTML() {
        return [
            {
                tag: 'li',
            },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['li', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addKeyboardShortcuts() {
        return {
            Enter: () => this.editor.commands.splitListItem(this.name),
            Tab: () => this.editor.commands.sinkListItem(this.name),
            'Shift-Tab': () => this.editor.commands.liftListItem(this.name),
        };
    },
});

const inputRegex$1 = /^(\d+)\.\s$/;
const OrderedList = Node.create({
    name: 'orderedList',
    addOptions() {
        return {
            itemTypeName: 'listItem',
            HTMLAttributes: {},
        };
    },
    group: 'block list',
    content() {
        return `${this.options.itemTypeName}+`;
    },
    addAttributes() {
        return {
            start: {
                default: 1,
                parseHTML: element => {
                    return element.hasAttribute('start')
                        ? parseInt(element.getAttribute('start') || '', 10)
                        : 1;
                },
            },
        };
    },
    parseHTML() {
        return [
            {
                tag: 'ol',
            },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        const { start, ...attributesWithoutStart } = HTMLAttributes;
        return start === 1
            ? ['ol', mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0]
            : ['ol', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
        return {
            toggleOrderedList: () => ({ commands }) => {
                return commands.toggleList(this.name, this.options.itemTypeName);
            },
        };
    },
    addKeyboardShortcuts() {
        return {
            'Mod-Shift-7': () => this.editor.commands.toggleOrderedList(),
        };
    },
    addInputRules() {
        return [
            wrappingInputRule({
                find: inputRegex$1,
                type: this.type,
                getAttributes: match => ({ start: +match[1] }),
                joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],
            }),
        ];
    },
});

const Paragraph = Node.create({
    name: 'paragraph',
    priority: 1000,
    addOptions() {
        return {
            HTMLAttributes: {},
        };
    },
    group: 'block',
    content: 'inline*',
    parseHTML() {
        return [
            { tag: 'p' },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['p', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
        return {
            setParagraph: () => ({ commands }) => {
                return commands.setNode(this.name);
            },
        };
    },
    addKeyboardShortcuts() {
        return {
            'Mod-Alt-0': () => this.editor.commands.setParagraph(),
        };
    },
});

const inputRegex = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/;
const pasteRegex = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g;
const Strike = Mark.create({
    name: 'strike',
    addOptions() {
        return {
            HTMLAttributes: {},
        };
    },
    parseHTML() {
        return [
            {
                tag: 's',
            },
            {
                tag: 'del',
            },
            {
                tag: 'strike',
            },
            {
                style: 'text-decoration',
                consuming: false,
                getAttrs: style => (style.includes('line-through') ? {} : false),
            },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['s', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
        return {
            setStrike: () => ({ commands }) => {
                return commands.setMark(this.name);
            },
            toggleStrike: () => ({ commands }) => {
                return commands.toggleMark(this.name);
            },
            unsetStrike: () => ({ commands }) => {
                return commands.unsetMark(this.name);
            },
        };
    },
    addKeyboardShortcuts() {
        return {
            'Mod-Shift-x': () => this.editor.commands.toggleStrike(),
        };
    },
    addInputRules() {
        return [
            markInputRule({
                find: inputRegex,
                type: this.type,
            }),
        ];
    },
    addPasteRules() {
        return [
            markPasteRule({
                find: pasteRegex,
                type: this.type,
            }),
        ];
    },
});

const Text = Node.create({
    name: 'text',
    group: 'inline',
});

const StarterKit = Extension.create({
    name: 'starterKit',
    addExtensions() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        const extensions = [];
        if (this.options.blockquote !== false) {
            extensions.push(Blockquote.configure((_a = this.options) === null || _a === void 0 ? void 0 : _a.blockquote));
        }
        if (this.options.bold !== false) {
            extensions.push(Bold.configure((_b = this.options) === null || _b === void 0 ? void 0 : _b.bold));
        }
        if (this.options.bulletList !== false) {
            extensions.push(BulletList.configure((_c = this.options) === null || _c === void 0 ? void 0 : _c.bulletList));
        }
        if (this.options.code !== false) {
            extensions.push(Code.configure((_d = this.options) === null || _d === void 0 ? void 0 : _d.code));
        }
        if (this.options.codeBlock !== false) {
            extensions.push(CodeBlock.configure((_e = this.options) === null || _e === void 0 ? void 0 : _e.codeBlock));
        }
        if (this.options.document !== false) {
            extensions.push(Document.configure((_f = this.options) === null || _f === void 0 ? void 0 : _f.document));
        }
        if (this.options.dropcursor !== false) {
            extensions.push(Dropcursor.configure((_g = this.options) === null || _g === void 0 ? void 0 : _g.dropcursor));
        }
        if (this.options.gapcursor !== false) {
            extensions.push(Gapcursor.configure((_h = this.options) === null || _h === void 0 ? void 0 : _h.gapcursor));
        }
        if (this.options.hardBreak !== false) {
            extensions.push(HardBreak.configure((_j = this.options) === null || _j === void 0 ? void 0 : _j.hardBreak));
        }
        if (this.options.heading !== false) {
            extensions.push(Heading.configure((_k = this.options) === null || _k === void 0 ? void 0 : _k.heading));
        }
        if (this.options.history !== false) {
            extensions.push(History.configure((_l = this.options) === null || _l === void 0 ? void 0 : _l.history));
        }
        if (this.options.horizontalRule !== false) {
            extensions.push(HorizontalRule.configure((_m = this.options) === null || _m === void 0 ? void 0 : _m.horizontalRule));
        }
        if (this.options.italic !== false) {
            extensions.push(Italic.configure((_o = this.options) === null || _o === void 0 ? void 0 : _o.italic));
        }
        if (this.options.listItem !== false) {
            extensions.push(ListItem.configure((_p = this.options) === null || _p === void 0 ? void 0 : _p.listItem));
        }
        if (this.options.orderedList !== false) {
            extensions.push(OrderedList.configure((_q = this.options) === null || _q === void 0 ? void 0 : _q.orderedList));
        }
        if (this.options.paragraph !== false) {
            extensions.push(Paragraph.configure((_r = this.options) === null || _r === void 0 ? void 0 : _r.paragraph));
        }
        if (this.options.strike !== false) {
            extensions.push(Strike.configure((_s = this.options) === null || _s === void 0 ? void 0 : _s.strike));
        }
        if (this.options.text !== false) {
            extensions.push(Text.configure((_t = this.options) === null || _t === void 0 ? void 0 : _t.text));
        }
        return extensions;
    },
});

var GlobalStyles$1 = function () { return (jsx(Global, { styles: css$1(templateObject_1$D || (templateObject_1$D = __makeTemplateObject(["\n      .ProseMirror {\n        * {\n          font-family: 'Montserrat', sans-serif;\n          color: #292929;\n          ::selection {\n            background: #e9e9e9;\n          }\n        }\n        a {\n          color: #f1576c;\n          cursor: pointer;\n        }\n        h1 {\n          font-size: 2.5rem;\n        }\n        h2 {\n          font-size: 2rem;\n        }\n        h3 {\n          font-size: 1.5rem;\n        }\n        h4 {\n          font-size: 1.25rem;\n        }\n        h5 {\n          font-size: 1rem;\n        }\n        h6 {\n          font-size: 0.875rem;\n        }\n        p {\n          font-size: 14px;\n        }\n        img {\n          width: 100%;\n        }\n        ol {\n          list-style-type: decimal;\n          padding-left: 1rem;\n        }\n        ul {\n          list-style-type: disc;\n          padding-left: 1rem;\n        }\n        .tableWrapper {\n          height: max-content;\n        }\n        table {\n          height: max-content;\n          margin: 20px 0px;\n          border-collapse: collapse;\n          border-spacing: 0;\n          width: 100%;\n          border: 1px solid #ddd;\n        }\n        th,\n        td {\n          border: 1px solid #ddd;\n          text-align: left;\n          padding: 8px;\n          font-size: 1rem;\n          font-family: 'Montserrat', sans-serif;\n        }\n        td {\n          font-weight: 500;\n        }\n        tr:nth-child(even) {\n          color: #2e2e2e;\n          background-color: #f3f3f3;\n        }\n\n        .ProseMirror-selectednode {\n          background: #f2f2f2;\n        }\n      }\n    "], ["\n      .ProseMirror {\n        * {\n          font-family: 'Montserrat', sans-serif;\n          color: #292929;\n          ::selection {\n            background: #e9e9e9;\n          }\n        }\n        a {\n          color: #f1576c;\n          cursor: pointer;\n        }\n        h1 {\n          font-size: 2.5rem;\n        }\n        h2 {\n          font-size: 2rem;\n        }\n        h3 {\n          font-size: 1.5rem;\n        }\n        h4 {\n          font-size: 1.25rem;\n        }\n        h5 {\n          font-size: 1rem;\n        }\n        h6 {\n          font-size: 0.875rem;\n        }\n        p {\n          font-size: 14px;\n        }\n        img {\n          width: 100%;\n        }\n        ol {\n          list-style-type: decimal;\n          padding-left: 1rem;\n        }\n        ul {\n          list-style-type: disc;\n          padding-left: 1rem;\n        }\n        .tableWrapper {\n          height: max-content;\n        }\n        table {\n          height: max-content;\n          margin: 20px 0px;\n          border-collapse: collapse;\n          border-spacing: 0;\n          width: 100%;\n          border: 1px solid #ddd;\n        }\n        th,\n        td {\n          border: 1px solid #ddd;\n          text-align: left;\n          padding: 8px;\n          font-size: 1rem;\n          font-family: 'Montserrat', sans-serif;\n        }\n        td {\n          font-weight: 500;\n        }\n        tr:nth-child(even) {\n          color: #2e2e2e;\n          background-color: #f3f3f3;\n        }\n\n        .ProseMirror-selectednode {\n          background: #f2f2f2;\n        }\n      }\n    "]))) })); };
var InputErrorStyled = styled$1.span(templateObject_2$t || (templateObject_2$t = __makeTemplateObject(["\n  font-family: ", ";\n  font-size: ", ";\n  font-weight: ", ";\n  color: ", ";\n  height: ", ";\n  margin: ", ";\n  padding: ", ";\n"], ["\n  font-family: ", ";\n  font-size: ", ";\n  font-weight: ", ";\n  color: ", ";\n  height: ", ";\n  margin: ", ";\n  padding: ", ";\n"])), function (_a) {
    var errorFontFamily = _a.errorFontFamily;
    return errorFontFamily || "'Montserrat', sans-serif";
}, function (_a) {
    var errorFontSize = _a.errorFontSize;
    return errorFontSize || "10px";
}, function (_a) {
    var errorFontWeight = _a.errorFontWeight;
    return errorFontWeight || "700";
}, function (_a) {
    var errorColor = _a.errorColor;
    return errorColor || "#ff295f";
}, function (_a) {
    var errorHeight = _a.errorHeight;
    return errorHeight || "20px";
}, function (_a) {
    var errorMargin = _a.errorMargin;
    return errorMargin || "0px 0px 0px 0px";
}, function (_a) {
    var errorPadding = _a.errorPadding;
    return errorPadding || "5px 0px 0px 0px";
});
var InputColorStyled$1 = styled$1.input(templateObject_3$n || (templateObject_3$n = __makeTemplateObject(["\n  border: 1px solid #d5d5d5;\n  border-radius: 50%;\n\n  width: 25px;\n  height: 25px;\n  border-radius: 300px;\n  overflow: hidden;\n  ::-webkit-color-swatch {\n    border: none;\n    border-radius: 50%;\n  }\n  ::-webkit-color-swatch-wrapper {\n    padding: 0;\n  }\n"], ["\n  border: 1px solid #d5d5d5;\n  border-radius: 50%;\n\n  width: 25px;\n  height: 25px;\n  border-radius: 300px;\n  overflow: hidden;\n  ::-webkit-color-swatch {\n    border: none;\n    border-radius: 50%;\n  }\n  ::-webkit-color-swatch-wrapper {\n    padding: 0;\n  }\n"])));
var SeparateVerticalStyled = styled$1.hr(templateObject_4$h || (templateObject_4$h = __makeTemplateObject(["\n  height: 10px;\n  width: 2px;\n  background-color: #d5d5d5;\n"], ["\n  height: 10px;\n  width: 2px;\n  background-color: #d5d5d5;\n"])));
var ButtonStyled$1 = styled$1.button(templateObject_6$a || (templateObject_6$a = __makeTemplateObject(["\n  width: 30px;\n  height: 30px;\n  background-color: white;\n  border: 1px solid #d5d5d5;\n  border-radius: 4px;\n  cursor: pointer;\n  font-family: 'Montserrat', sans-serif;\n  font-size: 12px;\n  color: #373737;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-weight: 800;\n  span {\n    cursor: pointer;\n  }\n  ", "\n\n  ", "\n"], ["\n  width: 30px;\n  height: 30px;\n  background-color: white;\n  border: 1px solid #d5d5d5;\n  border-radius: 4px;\n  cursor: pointer;\n  font-family: 'Montserrat', sans-serif;\n  font-size: 12px;\n  color: #373737;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-weight: 800;\n  span {\n    cursor: pointer;\n  }\n  ", "\n\n  ", "\n"])), function (_a) {
    var isActive = _a.isActive;
    return isActive && css$1(templateObject_5$e || (templateObject_5$e = __makeTemplateObject(["\n      background-color: #f1576c;\n      color: white !important;\n      span {\n        color: white !important;\n      }\n      svg {\n        path {\n          fill: white !important;\n        }\n      }\n    "], ["\n      background-color: #f1576c;\n      color: white !important;\n      span {\n        color: white !important;\n      }\n      svg {\n        path {\n          fill: white !important;\n        }\n      }\n    "])));
}, function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
styled$1.textarea(templateObject_7$8 || (templateObject_7$8 = __makeTemplateObject(["\n  padding: 15px 20px;\n  border: none;\n  width: 100%;\n  height: 100%;\n  font-family: 'Montserrat', sans-serif;\n  font-size: 14px;\n  font-weight: 400;\n"], ["\n  padding: 15px 20px;\n  border: none;\n  width: 100%;\n  height: 100%;\n  font-family: 'Montserrat', sans-serif;\n  font-size: 14px;\n  font-weight: 400;\n"])));
var templateObject_1$D, templateObject_2$t, templateObject_3$n, templateObject_4$h, templateObject_5$e, templateObject_6$a, templateObject_7$8;

var InputTextError = function (props) {
    var formik = props.formik, id = props.id;
    return ((formik === null || formik === void 0 ? void 0 : formik.values["".concat(id)]) !== "" || (formik === null || formik === void 0 ? void 0 : formik.touched["".concat(id)])) &&
        (formik === null || formik === void 0 ? void 0 : formik.errors["".concat(id)]) ? (jsx(InputErrorStyled, __assign({}, props, { children: formik === null || formik === void 0 ? void 0 : formik.errors["".concat(id)] }))) : (jsx(InputErrorStyled, __assign({}, __assign(__assign({}, props), { children: null }))));
};

var Iframe$1 = Node.create({
    name: 'iframe',
    group: 'block',
    atom: true,
    addOptions: function () {
        return {
            allowFullscreen: true,
            HTMLAttributes: {
                class: 'iframe-wrapper',
            },
        };
    },
    addAttributes: function () {
        var _this = this;
        return {
            src: {
                default: null,
            },
            frameborder: {
                default: 0,
            },
            allowfullscreen: {
                default: this.options.allowFullscreen,
                parseHTML: function () { return _this.options.allowFullscreen; },
            },
        };
    },
    parseHTML: function () {
        return [
            {
                tag: 'iframe',
            },
            {
                tag: 'br',
            },
        ];
    },
    renderHTML: function (_a) {
        var HTMLAttributes = _a.HTMLAttributes;
        return ['div', this.options.HTMLAttributes, ['iframe', HTMLAttributes]];
    },
    addCommands: function () {
        var _this = this;
        return {
            setIframe: function (options) {
                return function (_a) {
                    var tr = _a.tr, dispatch = _a.dispatch;
                    var selection = tr.selection;
                    var node = _this.type.create(options);
                    if (dispatch) {
                        tr.replaceRangeWith(selection.from, selection.to, node);
                    }
                    return true;
                };
            },
        };
    },
});

var VideoCustom$1 = Node.create({
    name: 'video',
    group: 'block',
    atom: true,
    addOptions: function () {
        return {
            controls: true,
            allowFullscreen: true,
            HTMLAttributes: {
                class: 'video-wrapper',
            },
        };
    },
    addAttributes: function () {
        var _this = this;
        return {
            src: {
                default: null,
            },
            frameborder: {
                default: 0,
            },
            controls: {
                default: true,
            },
            allowfullscreen: {
                default: this.options.allowFullscreen,
                parseHTML: function () { return _this.options.allowFullscreen; },
            },
        };
    },
    parseHTML: function () {
        return [
            {
                tag: 'video',
            },
            {
                tag: 'br',
            },
        ];
    },
    renderHTML: function (_a) {
        var HTMLAttributes = _a.HTMLAttributes;
        return ['div', this.options.HTMLAttributes, ['video', HTMLAttributes]];
    },
    addCommands: function () {
        var _this = this;
        return {
            setVideo: function (options) {
                return function (_a) {
                    var tr = _a.tr, dispatch = _a.dispatch;
                    var selection = tr.selection;
                    var node = _this.type.create(options);
                    if (dispatch) {
                        tr.replaceRangeWith(selection.from, selection.to, node);
                    }
                    return true;
                };
            },
        };
    },
});

HardBreak.configure({
    keepMarks: false,
});
var MenuBar$1 = function (props) {
    var _a, _b, _c;
    var editor = props.editor;
    var _d = __read(useState(false), 2), isOpen = _d[0], setIsOpen = _d[1];
    var _e = __read(useState(false), 2), loadingFile = _e[0], setLoadingFile = _e[1];
    var _f = __read(useState({}), 2), image = _f[0], setImage = _f[1];
    var _g = __read(useState({}), 2), video = _g[0], setVideo = _g[1];
    var _h = __read(useState(false), 2), isOpenUrl = _h[0], setIsOpenUrl = _h[1];
    var _j = __read(useState(false), 2), isOpenVideo = _j[0], setIsOpenVideo = _j[1];
    var _k = __read(useState(''), 2), url = _k[0], setUrl = _k[1];
    var ref = useRef(null);
    var ref2 = useRef(null);
    var ref3 = useRef(null);
    useEffect(function () {
        var handleClickOutside = function (event) {
            if (ref.current && !ref.current.contains(event.target)) {
                setIsOpenUrl(false);
            }
            if (ref2.current && !ref2.current.contains(event.target)) {
                setIsOpen(false);
            }
            if (ref3.current && !ref3.current.contains(event.target)) {
                setIsOpenVideo(false);
            }
        };
        document.addEventListener("mousedown", handleClickOutside, true);
        return function () {
            document.removeEventListener("mousedown", handleClickOutside, true);
        };
    }, [ref, ref2, ref3]);
    var options = __assign({ selectFont: true, typeTags: true, textAligns: true }, ((_a = props === null || props === void 0 ? void 0 : props.options) !== null && _a !== void 0 ? _a : {}));
    return (jsx(Fragment$1, { children: jsxs(Wrapper$2, __assign({ className: "menu-editor", flexDirection: "row", width: "100%", justifyContent: "flex-start", alignItems: "center", flexWrap: "wrap", padding: "0px 0px 20px 0px", customCSS: css$1(templateObject_2$s || (templateObject_2$s = __makeTemplateObject(["\n          gap: 10px;\n          flex-wrap: wrap;\n          ButtonStyled {\n            flex-basis: 40px;\n            flex-grow: 1;\n            width: 40px;\n            height: 40px;\n            font-size: 15px;\n            overflow: hidden;\n            background-color: #fafafa;\n            border: none;\n            color: #373737;\n            font-weight: bold;\n            box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.1);\n          }\n          ", "\n        "], ["\n          gap: 10px;\n          flex-wrap: wrap;\n          ButtonStyled {\n            flex-basis: 40px;\n            flex-grow: 1;\n            width: 40px;\n            height: 40px;\n            font-size: 15px;\n            overflow: hidden;\n            background-color: #fafafa;\n            border: none;\n            color: #373737;\n            font-weight: bold;\n            box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.1);\n          }\n          ", "\n        "])), (_b = props === null || props === void 0 ? void 0 : props.customCSSH) !== null && _b !== void 0 ? _b : css$1(templateObject_1$C || (templateObject_1$C = __makeTemplateObject([""], [""])))) }, { children: [jsx(InputColorStyled$1, { type: "color", onInput: function (event) {
                        return editor === null || editor === void 0 ? void 0 : editor.chain().focus().setColor("".concat(event.currentTarget.value)).run();
                    }, value: (_c = editor === null || editor === void 0 ? void 0 : editor.getAttributes('textStyle').color) !== null && _c !== void 0 ? _c : '#ffffff' }), jsx(ButtonStyled$1, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleBold().run(); }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive('bold') }, { children: jsx(Icon$1, { height: "12px", width: "12px", color: (editor === null || editor === void 0 ? void 0 : editor.isActive('bold')) ? '#fafafa' : '#373737', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/bold-solid.svg" }) })), jsx(ButtonStyled$1, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleItalic().run(); }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive('italic') }, { children: jsx(Icon$1, { height: "12px", width: "12px", color: (editor === null || editor === void 0 ? void 0 : editor.isActive('italic')) ? '#fafafa' : '#373737', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/italic-solid.svg" }) })), jsx(ButtonStyled$1, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleStrike().run(); }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive('strike') }, { children: jsx(Icon$1, { height: "12px", width: "12px", color: (editor === null || editor === void 0 ? void 0 : editor.isActive('strike')) ? '#fafafa' : '#373737', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/strikethrough-solid.svg" }) })), jsx(ButtonStyled$1, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleUnderline().run(); }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive('underline') }, { children: jsx(Icon$1, { height: "12px", width: "12px", color: (editor === null || editor === void 0 ? void 0 : editor.isActive('underline')) ? '#fafafa' : '#373737', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/underline-solid.svg" }) })), (options === null || options === void 0 ? void 0 : options.selectFont) ? (jsxs(Fragment$1, { children: [jsx(SeparateVerticalStyled, {}), jsx(Input, { type: "select", border: "1px solid #d5d5d5", height: "30px", labelWidth: "184px", options: [
                                { id: '0', value: 'Montserrat', label: 'Montserrat' },
                                { id: '1', value: 'Inter', label: 'Inter' },
                                {
                                    id: '2',
                                    value: 'Comic Sans MS, Comic Sans',
                                    label: 'Comic Sans MS, Comic Sans',
                                },
                                { id: '3', value: 'Arial', label: 'Arial' },
                                { id: '4', value: 'serif', label: 'serif' },
                                { id: '5', value: 'monospace', label: 'monospace' },
                                { id: '6', value: 'cursive', label: 'cursive' },
                            ], customCSS: css$1(templateObject_3$m || (templateObject_3$m = __makeTemplateObject(["\n                select {\n                  font-size: 10px;\n                  option {\n                    font-size: 10px;\n                  }\n                }\n                span {\n                  display: none;\n                }\n              "], ["\n                select {\n                  font-size: 10px;\n                  option {\n                    font-size: 10px;\n                  }\n                }\n                span {\n                  display: none;\n                }\n              "]))), onChange: function (e) {
                                return editor === null || editor === void 0 ? void 0 : editor.chain().focus().setFontFamily("".concat(e.target.value)).run();
                            } })] })) : null, options.textAligns ? (jsxs(Fragment$1, { children: [jsx(SeparateVerticalStyled, {}), jsx(ButtonStyled$1, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().setTextAlign('left').run(); }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: 'left' }) }, { children: jsx(Icon$1, { height: "12px", width: "12px", color: (editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: 'left' }))
                                    ? '#fafafa'
                                    : '#373737', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/align-left-solid.svg" }) })), jsx(ButtonStyled$1, __assign({ onClick: function () {
                                return editor === null || editor === void 0 ? void 0 : editor.chain().focus().setTextAlign('center').run();
                            }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: 'center' }) }, { children: jsx(Icon$1, { height: "12px", width: "12px", color: (editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: 'center' }))
                                    ? '#fafafa'
                                    : '#373737', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/align-center-solid.svg" }) })), jsx(ButtonStyled$1, __assign({ onClick: function () {
                                return editor === null || editor === void 0 ? void 0 : editor.chain().focus().setTextAlign('right').run();
                            }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: 'right' }) }, { children: jsx(Icon$1, { height: "12px", width: "12px", color: (editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: 'right' }))
                                    ? '#fafafa'
                                    : '#373737', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/align-right-solid.svg" }) })), jsx(ButtonStyled$1, __assign({ onClick: function () {
                                return editor === null || editor === void 0 ? void 0 : editor.chain().focus().setTextAlign('justify').run();
                            }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: 'justify' }) }, { children: jsx(Icon$1, { height: "12px", width: "12px", color: (editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: 'justify' }))
                                    ? '#fafafa'
                                    : '#373737', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/align-justify-solid.svg" }) }))] })) : null, (options === null || options === void 0 ? void 0 : options.typeTags) ? (jsxs(Fragment$1, { children: [jsx(SeparateVerticalStyled, {}), jsx(ButtonStyled$1, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().setParagraph().run(); }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive('paragraph') }, { children: "P" })), jsx(ButtonStyled$1, __assign({ onClick: function () {
                                return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleHeading({ level: 1 }).run();
                            }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive('heading', { level: 1 }) }, { children: "H1" })), jsx(ButtonStyled$1, __assign({ onClick: function () {
                                return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleHeading({ level: 2 }).run();
                            }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive('heading', { level: 2 }) }, { children: "H2" })), jsx(ButtonStyled$1, __assign({ onClick: function () {
                                return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleHeading({ level: 3 }).run();
                            }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive('heading', { level: 3 }) }, { children: "H3" })), jsx(ButtonStyled$1, __assign({ onClick: function () {
                                return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleHeading({ level: 4 }).run();
                            }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive('heading', { level: 4 }) }, { children: "H4" })), jsx(ButtonStyled$1, __assign({ onClick: function () {
                                return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleHeading({ level: 5 }).run();
                            }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive('heading', { level: 5 }) }, { children: "H5" })), jsx(ButtonStyled$1, __assign({ onClick: function () {
                                return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleHeading({ level: 6 }).run();
                            }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive('heading', { level: 6 }) }, { children: "H6" }))] })) : null, jsx(SeparateVerticalStyled, {}), jsxs(ButtonStyled$1, __assign({ customCSS: css$1(templateObject_4$g || (templateObject_4$g = __makeTemplateObject(["\n            position: relative;\n          "], ["\n            position: relative;\n          "]))), onClick: function () {
                        setIsOpen(true);
                    } }, { children: [jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/picture-image-svgrepo-com.svg" }), isOpen && (jsx(Wrapper$2, __assign({ refObject: ref2, customCSS: css$1(templateObject_5$d || (templateObject_5$d = __makeTemplateObject(["\n                position: absolute;\n                background-color: #ffffff;\n                padding: 30px 30px;\n                border-radius: 5px;\n                height: max-content;\n                width: 400px;\n                max-width: 400px;\n                top: 170%;\n                left: 50%;\n                transform: translateX(-50%);\n                flex-direction: column;\n                justify-content: space-between;\n                align-items: center;\n                box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.227);\n                :before {\n                  content: '';\n                  z-index: 100;\n                  position: absolute;\n                  top: -10px;\n                  left: 50%;\n                  transform: translateX(-50%);\n                  width: 0;\n                  height: 0;\n                  border-left: 10px solid transparent;\n                  border-right: 10px solid transparent;\n                  border-bottom: 10px solid #ffffff;\n                }\n              "], ["\n                position: absolute;\n                background-color: #ffffff;\n                padding: 30px 30px;\n                border-radius: 5px;\n                height: max-content;\n                width: 400px;\n                max-width: 400px;\n                top: 170%;\n                left: 50%;\n                transform: translateX(-50%);\n                flex-direction: column;\n                justify-content: space-between;\n                align-items: center;\n                box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.227);\n                :before {\n                  content: '';\n                  z-index: 100;\n                  position: absolute;\n                  top: -10px;\n                  left: 50%;\n                  transform: translateX(-50%);\n                  width: 0;\n                  height: 0;\n                  border-left: 10px solid transparent;\n                  border-right: 10px solid transparent;\n                  border-bottom: 10px solid #ffffff;\n                }\n              "]))) }, { children: loadingFile ? (jsx(Loader, { isLoading: true, colorLoading: "#f1576c", height: "200px", type: "small" })) : (jsxs(Fragment$1, { children: [jsx(Input, { height: "150px", labelWidth: "100%", width: "100%", type: "dragdrop", onChangeDrop: function (e) {
                                            setImage(e);
                                        } }), jsxs(Wrapper$2, __assign({ margin: "10px", customCSS: css$1(templateObject_7$7 || (templateObject_7$7 = __makeTemplateObject(["\n                      ", "\n                    "], ["\n                      ", "\n                    "])), typeof image === 'object' &&
                                            image.name && css$1(templateObject_6$9 || (templateObject_6$9 = __makeTemplateObject(["\n                        span {\n                          color: #a0a0a0;\n                        }\n                        input {\n                          background-color: #fcfcfc;\n                        }\n                      "], ["\n                        span {\n                          color: #a0a0a0;\n                        }\n                        input {\n                          background-color: #fcfcfc;\n                        }\n                      "])))) }, { children: [jsx(Text$2, __assign({ fontSize: "12px", fontWeight: 600, margin: "0px 15px 0px 0px" }, { children: "Url:" })), jsx(Input, { customCSS: css$1(templateObject_8$4 || (templateObject_8$4 = __makeTemplateObject(["\n                        span {\n                          display: none;\n                        }\n                      "], ["\n                        span {\n                          display: none;\n                        }\n                      "]))), labelWidth: "100%", width: "100%", type: "text", onChange: function (e) {
                                                    setImage(e.target.value);
                                                } })] })), jsx(Wrapper$2, __assign({ flexDirection: "row", justifyContent: "flex-end" }, { children: jsx(AtomButton, __assign({ customCSS: css$1(templateObject_9$2 || (templateObject_9$2 = __makeTemplateObject(["\n                        padding: 5px;\n                        background-color: #f1576c;\n                      "], ["\n                        padding: 5px;\n                        background-color: #f1576c;\n                      "]))), onClick: function () { return __awaiter(void 0, void 0, void 0, function () {
                                                return __generator(this, function (_a) {
                                                    switch (_a.label) {
                                                        case 0:
                                                            if (!(typeof image === 'string')) return [3 /*break*/, 1];
                                                            editor === null || editor === void 0 ? void 0 : editor.chain().focus().setImage({ src: image }).run();
                                                            setImage({});
                                                            setLoadingFile(true);
                                                            setTimeout(function () {
                                                                setLoadingFile(false);
                                                                setIsOpen(false);
                                                            }, 500);
                                                            return [3 /*break*/, 3];
                                                        case 1:
                                                            if (!image.name) return [3 /*break*/, 3];
                                                            setLoadingFile(true);
                                                            return [4 /*yield*/, uploadImage(image, {
                                                                    name: 'textbox',
                                                                    orgcode: 'IXU-0001',
                                                                })
                                                                    .then(function (res) {
                                                                    setLoadingFile(false);
                                                                    setIsOpen(false);
                                                                    editor === null || editor === void 0 ? void 0 : editor.chain().focus().setImage({ src: res }).run();
                                                                    setImage({});
                                                                })
                                                                    .catch(function (err) {
                                                                    setLoadingFile(false);
                                                                    console.warn(err);
                                                                })];
                                                        case 2:
                                                            _a.sent();
                                                            _a.label = 3;
                                                        case 3:
                                                            setIsOpen(false);
                                                            return [2 /*return*/];
                                                    }
                                                });
                                            }); } }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "white", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/commons/check-4787.svg" }) })) }))] })) })))] })), jsxs(ButtonStyled$1, __assign({ customCSS: css$1(templateObject_10$2 || (templateObject_10$2 = __makeTemplateObject(["\n            position: relative;\n          "], ["\n            position: relative;\n          "]))), onClick: function () {
                        setIsOpenUrl(true);
                    } }, { children: [jsx(Icon$1, { height: "15px", width: "15px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/link-solid.svg" }), isOpenUrl && (jsxs(Wrapper$2, __assign({ refObject: ref, customCSS: css$1(templateObject_11$2 || (templateObject_11$2 = __makeTemplateObject(["\n                position: absolute;\n                background-color: #ffffff;\n                padding: 10px 30px;\n                border-radius: 5px;\n                height: max-content;\n                width: 400px;\n                max-width: 400px;\n                top: 170%;\n                left: 50%;\n                transform: translateX(-50%);\n                flex-direction: row;\n                justify-content: space-between;\n                align-items: center;\n                box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.227);\n                :after {\n                  content: '';\n                  position: absolute;\n                  top: -10px;\n                  left: 50%;\n                  transform: translateX(-50%);\n                  width: 0;\n                  height: 0;\n                  border-left: 10px solid transparent;\n                  border-right: 10px solid transparent;\n                  border-bottom: 10px solid #ffffff;\n                }\n              "], ["\n                position: absolute;\n                background-color: #ffffff;\n                padding: 10px 30px;\n                border-radius: 5px;\n                height: max-content;\n                width: 400px;\n                max-width: 400px;\n                top: 170%;\n                left: 50%;\n                transform: translateX(-50%);\n                flex-direction: row;\n                justify-content: space-between;\n                align-items: center;\n                box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.227);\n                :after {\n                  content: '';\n                  position: absolute;\n                  top: -10px;\n                  left: 50%;\n                  transform: translateX(-50%);\n                  width: 0;\n                  height: 0;\n                  border-left: 10px solid transparent;\n                  border-right: 10px solid transparent;\n                  border-bottom: 10px solid #ffffff;\n                }\n              "]))) }, { children: [jsx(Text$2, __assign({ fontSize: "12px", fontWeight: 600, margin: "0px 15px 0px 0px" }, { children: "Url:" })), jsx(Input, { customCSS: css$1(templateObject_12$2 || (templateObject_12$2 = __makeTemplateObject(["\n                  span {\n                    display: none;\n                  }\n                "], ["\n                  span {\n                    display: none;\n                  }\n                "]))), labelWidth: "100%", width: "90%", type: "text", value: url, onChange: function (e) {
                                        setUrl(e.target.value);
                                    } }), jsxs(Wrapper$2, __assign({ flexDirection: "row", justifyContent: "space-between", alignItems: "center", width: "30%" }, { children: [jsx(AtomButton, __assign({ onClick: function () {
                                                editor === null || editor === void 0 ? void 0 : editor.chain().focus().extendMarkRange('link').unsetLink().run();
                                                setUrl('');
                                                setTimeout(function () {
                                                    setIsOpenUrl(false);
                                                }, 500);
                                            }, customCSS: css$1(templateObject_13$1 || (templateObject_13$1 = __makeTemplateObject(["\n                    padding: 5px;\n                    border: 1px solid #f1576c;\n                    color: #f1576c;\n                    background-color: transparent;\n                  "], ["\n                    padding: 5px;\n                    border: 1px solid #f1576c;\n                    color: #f1576c;\n                    background-color: transparent;\n                  "]))) }, { children: jsx(Icon$1, { height: "15px", width: "15px", color: "#f1576c", customCSS: css$1(templateObject_14$1 || (templateObject_14$1 = __makeTemplateObject(["\n                      svg {\n                        fill: none;\n                      }\n                    "], ["\n                      svg {\n                        fill: none;\n                      }\n                    "]))), icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/commons/trash.svg" }) })), jsx(AtomButton, __assign({ customCSS: css$1(templateObject_15$1 || (templateObject_15$1 = __makeTemplateObject(["\n                    padding: 5px;\n                    background-color: #f1576c;\n                  "], ["\n                    padding: 5px;\n                    background-color: #f1576c;\n                  "]))), onClick: function () {
                                                setTimeout(function () {
                                                    setIsOpenUrl(false);
                                                }, 500);
                                                if (url) {
                                                    editor === null || editor === void 0 ? void 0 : editor.chain().focus().extendMarkRange('link').setLink({ href: url }).run();
                                                }
                                            } }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "white", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/commons/check-4787.svg" }) }))] }))] })))] })), jsxs(ButtonStyled$1, __assign({ customCSS: css$1(templateObject_16$1 || (templateObject_16$1 = __makeTemplateObject(["\n            position: relative;\n          "], ["\n            position: relative;\n          "]))), onClick: function () {
                        setIsOpenVideo(true);
                    } }, { children: [jsx(Icon$1, { height: "15px", width: "15px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/commons/video-svgrepo-com.svg" }), isOpenVideo && (jsx(Wrapper$2, __assign({ refObject: ref3, customCSS: css$1(templateObject_17$1 || (templateObject_17$1 = __makeTemplateObject(["\n                position: absolute;\n                background-color: #ffffff;\n                padding: 30px 30px;\n                border-radius: 5px;\n                height: max-content;\n                width: 400px;\n                max-width: 400px;\n                top: 170%;\n                left: 50%;\n                transform: translateX(-50%);\n                flex-direction: column;\n                justify-content: space-between;\n                align-items: center;\n                box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.227);\n                :after {\n                  content: '';\n                  position: absolute;\n                  top: -10px;\n                  left: 50%;\n                  transform: translateX(-50%);\n                  width: 0;\n                  height: 0;\n                  border-left: 10px solid transparent;\n                  border-right: 10px solid transparent;\n                  border-bottom: 10px solid #ffffff;\n                }\n              "], ["\n                position: absolute;\n                background-color: #ffffff;\n                padding: 30px 30px;\n                border-radius: 5px;\n                height: max-content;\n                width: 400px;\n                max-width: 400px;\n                top: 170%;\n                left: 50%;\n                transform: translateX(-50%);\n                flex-direction: column;\n                justify-content: space-between;\n                align-items: center;\n                box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.227);\n                :after {\n                  content: '';\n                  position: absolute;\n                  top: -10px;\n                  left: 50%;\n                  transform: translateX(-50%);\n                  width: 0;\n                  height: 0;\n                  border-left: 10px solid transparent;\n                  border-right: 10px solid transparent;\n                  border-bottom: 10px solid #ffffff;\n                }\n              "]))) }, { children: loadingFile ? (jsx(Loader, { isLoading: true, colorLoading: "#f1576c", height: "200px", type: "small" })) : (jsxs(Fragment$1, { children: [jsx(Input, { height: "200px", labelWidth: "100%", width: "100%", type: "dragdrop", video: true, onChangeDrop: function (e) {
                                            setVideo(e);
                                        } }), jsxs(Wrapper$2, __assign({ margin: "10px", customCSS: css$1(templateObject_19 || (templateObject_19 = __makeTemplateObject(["\n                      ", "\n                    "], ["\n                      ", "\n                    "])), typeof image === 'object' &&
                                            image.name && css$1(templateObject_18 || (templateObject_18 = __makeTemplateObject(["\n                        span {\n                          color: #a0a0a0;\n                        }\n                        input {\n                          background-color: #fcfcfc;\n                        }\n                      "], ["\n                        span {\n                          color: #a0a0a0;\n                        }\n                        input {\n                          background-color: #fcfcfc;\n                        }\n                      "])))) }, { children: [jsx(Text$2, __assign({ fontSize: "12px", fontWeight: 600, margin: "0px 15px 0px 0px" }, { children: "Url:" })), jsx(Input, { customCSS: css$1(templateObject_20 || (templateObject_20 = __makeTemplateObject(["\n                        span {\n                          display: none;\n                        }\n                      "], ["\n                        span {\n                          display: none;\n                        }\n                      "]))), labelWidth: "100%", width: "100%", type: "text", onChange: function (e) {
                                                    setVideo(e.target.value);
                                                } })] })), jsx(Wrapper$2, __assign({ flexDirection: "row", justifyContent: "flex-end" }, { children: jsx(AtomButton, __assign({ customCSS: css$1(templateObject_21 || (templateObject_21 = __makeTemplateObject(["\n                        padding: 5px;\n                        background-color: #f1576c;\n                      "], ["\n                        padding: 5px;\n                        background-color: #f1576c;\n                      "]))), onClick: function () { return __awaiter(void 0, void 0, void 0, function () {
                                                var urlVideo;
                                                return __generator(this, function (_a) {
                                                    switch (_a.label) {
                                                        case 0:
                                                            if (!(typeof video === 'string')) return [3 /*break*/, 1];
                                                            urlVideo = "".concat(video)
                                                                .replace('https://www.youtube.com/watch?v=', 'https://www.youtube.com/embed/')
                                                                .replace('https://youtu.be/', 'https://www.youtube.com/embed/')
                                                                .replace('https://vimeo.com/', 'https://player.vimeo.com/video/');
                                                            setLoadingFile(true);
                                                            setTimeout(function () {
                                                                setLoadingFile(false);
                                                                setIsOpenVideo(false);
                                                            }, 500);
                                                            editor === null || editor === void 0 ? void 0 : editor.chain().focus().setIframe({ src: urlVideo }).run();
                                                            setVideo({});
                                                            return [3 /*break*/, 4];
                                                        case 1:
                                                            if (!video.name) return [3 /*break*/, 3];
                                                            setLoadingFile(true);
                                                            return [4 /*yield*/, uploadImage(video, {
                                                                    name: 'textbox',
                                                                    orgcode: 'IXU-0001',
                                                                })
                                                                    .then(function (res) {
                                                                    setLoadingFile(false);
                                                                    setIsOpenVideo(false);
                                                                    editor === null || editor === void 0 ? void 0 : editor.chain().focus().setVideo({ src: res }).run();
                                                                    setVideo({});
                                                                })
                                                                    .catch(function (err) {
                                                                    setLoadingFile(false);
                                                                    console.warn(err);
                                                                })];
                                                        case 2:
                                                            _a.sent();
                                                            return [3 /*break*/, 4];
                                                        case 3:
                                                            setIsOpenVideo(false);
                                                            _a.label = 4;
                                                        case 4: return [2 /*return*/];
                                                    }
                                                });
                                            }); } }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "white", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/commons/check-4787.svg" }) })) }))] })) })))] })), jsx(SeparateVerticalStyled, {}), jsx(ButtonStyled$1, __assign({ onClick: function () {
                        return editor === null || editor === void 0 ? void 0 : editor.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: true }).run();
                    } }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/table-solid.svg" }) })), jsx(ButtonStyled$1, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().deleteTable().run(); }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().deleteTable()) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#a0a0a0", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/table-solid.svg" }) })), jsx(ButtonStyled$1, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().addColumnBefore().run(); }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().addColumnBefore()) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/border-left-new.svg" }) })), jsx(ButtonStyled$1, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().deleteColumn().run(); }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().deleteColumn()) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#a0a0a0", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/border-center-v.svg" }) })), jsx(ButtonStyled$1, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().addColumnAfter().run(); }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().addColumnAfter()) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/border-right.svg" }) })), jsx(ButtonStyled$1, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().addRowBefore().run(); }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().addRowBefore()) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/border-top.svg" }) })), jsx(ButtonStyled$1, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().deleteRow().run(); }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().deleteRow()) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#a0a0a0", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/border-center-h.svg" }) })), jsx(ButtonStyled$1, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().addRowAfter().run(); }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().addRowAfter()) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/border-bottom.svg" }) })), jsx(ButtonStyled$1, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleBulletList().run(); }, className: (editor === null || editor === void 0 ? void 0 : editor.isActive('bulletList')) ? 'is-active' : '' }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/list-ul-solid.svg" }) })), jsx(ButtonStyled$1, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleOrderedList().run(); }, className: (editor === null || editor === void 0 ? void 0 : editor.isActive('orderedList')) ? 'is-active' : '' }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/list-ol-solid.svg" }) })), jsx(ButtonStyled$1, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().liftListItem('listItem').run(); }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().liftListItem('listItem')) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/outdent-solid.svg" }) })), jsx(ButtonStyled$1, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().sinkListItem('listItem').run(); }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().sinkListItem('listItem')) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/indent-solid.svg" }) }))] })) }));
};
var AtomTextEditor$1 = function (props) {
    var _a, _b, _c, _d, _e, _f;
    var content = props.content, id = props.id, maxWidth = props.maxWidth, onBlur = props.onBlur;
    // const [code, setCode] = useState(true);
    var editor = useEditor({
        extensions: [
            TextAlign.configure({
                types: ['heading', 'paragraph'],
            }),
            StarterKit,
            TextStyle$1,
            FontFamily,
            Color,
            Underline,
            Image$1,
            Iframe$1,
            VideoCustom$1,
            Table.configure({
                resizable: true,
            }),
            TableRow,
            TableHeader,
            TableCell,
            Link.configure({
                openOnClick: false,
            }),
        ],
        content: content !== null && content !== void 0 ? content : '',
    }, [content]);
    var HTML = editor === null || editor === void 0 ? void 0 : editor.getHTML();
    useEffect(function () {
        if (props.onChangeEditor && editor) {
            props.onChangeEditor(editor);
        }
    }, [HTML]);
    // useEffect(() => {
    //   if (loadContent !== content && content) {
    //     editor?.commands?.setContent(content);
    //     setLoadContent(content);
    //   }
    // }, [content]);
    return (jsxs(Wrapper$2, __assign({ margin: "0px 0px", width: "100%", maxWidth: maxWidth !== null && maxWidth !== void 0 ? maxWidth : '615px', customCSS: (_a = props === null || props === void 0 ? void 0 : props.customCSSM) !== null && _a !== void 0 ? _a : css$1(templateObject_22 || (templateObject_22 = __makeTemplateObject([""], [""]))) }, { children: [jsx(GlobalStyles$1, {}), jsx(MenuBar$1, { editor: editor, options: props === null || props === void 0 ? void 0 : props.options, customCSSH: (_b = props === null || props === void 0 ? void 0 : props.customCSSH) !== null && _b !== void 0 ? _b : css$1(templateObject_23 || (templateObject_23 = __makeTemplateObject([""], [""]))) }), jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_25 || (templateObject_25 = __makeTemplateObject(["\n          border: 1px solid #e6e6e6;\n          border-radius: 0px 0px 8px 8px;\n          z-index: -1;\n          min-height: ", ";\n          align-items: center;\n          justify-content: flex-start;\n          > div {\n            min-height: ", ";\n            padding: 0px;\n            width: 100%;\n            height: 100%;\n            overflow-y: auto;\n          }\n\n          .ProseMirror {\n            min-height: ", ";\n            padding: 20px 20px;\n            outline: none;\n            .video-wrapper {\n              margin: 0px 0px 20px 0px;\n              video {\n                width: 100%;\n              }\n            }\n            .iframe-wrapper {\n              margin: 0px 0px 20px 0px;\n              position: relative;\n              padding-bottom: math.div(100, 16) * 9%;\n              height: 0;\n              overflow: hidden;\n              width: 100%;\n              height: 300px;\n\n              &.ProseMirror-selectednode {\n                outline: 3px solid #68cef8;\n              }\n\n              iframe {\n                position: absolute;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n              }\n            }\n          }\n          ", "\n        "], ["\n          border: 1px solid #e6e6e6;\n          border-radius: 0px 0px 8px 8px;\n          z-index: -1;\n          min-height: ", ";\n          align-items: center;\n          justify-content: flex-start;\n          > div {\n            min-height: ", ";\n            padding: 0px;\n            width: 100%;\n            height: 100%;\n            overflow-y: auto;\n          }\n\n          .ProseMirror {\n            min-height: ", ";\n            padding: 20px 20px;\n            outline: none;\n            .video-wrapper {\n              margin: 0px 0px 20px 0px;\n              video {\n                width: 100%;\n              }\n            }\n            .iframe-wrapper {\n              margin: 0px 0px 20px 0px;\n              position: relative;\n              padding-bottom: math.div(100, 16) * 9%;\n              height: 0;\n              overflow: hidden;\n              width: 100%;\n              height: 300px;\n\n              &.ProseMirror-selectednode {\n                outline: 3px solid #68cef8;\n              }\n\n              iframe {\n                position: absolute;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n              }\n            }\n          }\n          ", "\n        "])), (_c = props === null || props === void 0 ? void 0 : props.minHeight) !== null && _c !== void 0 ? _c : '500px', (_d = props === null || props === void 0 ? void 0 : props.minHeight) !== null && _d !== void 0 ? _d : '500px', (_e = props === null || props === void 0 ? void 0 : props.minHeight) !== null && _e !== void 0 ? _e : '500px', (_f = props === null || props === void 0 ? void 0 : props.customCSS) !== null && _f !== void 0 ? _f : css$1(templateObject_24 || (templateObject_24 = __makeTemplateObject([""], [""])))) }, { children: jsx(EditorContent, { id: id, onBlur: onBlur, editor: editor }) })), jsx(InputTextError, __assign({}, props))] })));
};
var templateObject_1$C, templateObject_2$s, templateObject_3$m, templateObject_4$g, templateObject_5$d, templateObject_6$9, templateObject_7$7, templateObject_8$4, templateObject_9$2, templateObject_10$2, templateObject_11$2, templateObject_12$2, templateObject_13$1, templateObject_14$1, templateObject_15$1, templateObject_16$1, templateObject_17$1, templateObject_18, templateObject_19, templateObject_20, templateObject_21, templateObject_22, templateObject_23, templateObject_24, templateObject_25;

var Iframe = Node.create({
    name: 'iframe',
    group: 'block',
    atom: true,
    addOptions: function () {
        return {
            allowFullscreen: true,
            HTMLAttributes: {
                class: 'iframe-wrapper',
            },
        };
    },
    addAttributes: function () {
        var _this = this;
        return {
            src: {
                default: null,
            },
            frameborder: {
                default: 0,
            },
            allowfullscreen: {
                default: this.options.allowFullscreen,
                parseHTML: function () { return _this.options.allowFullscreen; },
            },
        };
    },
    parseHTML: function () {
        return [
            {
                tag: 'iframe',
            },
            {
                tag: 'br',
            },
        ];
    },
    renderHTML: function (_a) {
        var HTMLAttributes = _a.HTMLAttributes;
        return ['div', this.options.HTMLAttributes, ['iframe', HTMLAttributes]];
    },
    addCommands: function () {
        var _this = this;
        return {
            setIframe: function (options) {
                return function (_a) {
                    var tr = _a.tr, dispatch = _a.dispatch;
                    var selection = tr.selection;
                    var node = _this.type.create(options);
                    if (dispatch) {
                        tr.replaceRangeWith(selection.from, selection.to, node);
                    }
                    return true;
                };
            },
        };
    },
});

var GlobalStyles = function () { return (jsx(Global, { styles: css$1(templateObject_1$B || (templateObject_1$B = __makeTemplateObject(["\n      .ProseMirror {\n        * {\n          font-family: 'Montserrat', sans-serif;\n          color: #292929;\n          ::selection {\n            background: #e9e9e9;\n          }\n        }\n        a {\n          color: #f1576c;\n          cursor: pointer;\n        }\n        h1 {\n          font-size: 2.5rem;\n        }\n        h2 {\n          font-size: 2rem;\n        }\n        h3 {\n          font-size: 1.5rem;\n        }\n        h4 {\n          font-size: 1.25rem;\n        }\n        h5 {\n          font-size: 1rem;\n        }\n        h6 {\n          font-size: 0.875rem;\n        }\n        p {\n          font-size: 14px;\n        }\n        img {\n          width: 100%;\n        }\n        ol {\n          list-style-type: decimal;\n          padding-left: 1rem;\n        }\n        ul {\n          list-style-type: disc;\n          padding-left: 1rem;\n        }\n        .tableWrapper {\n          height: max-content;\n        }\n        table {\n          height: max-content;\n          margin: 20px 0px;\n          border-collapse: collapse;\n          border-spacing: 0;\n          width: 100%;\n          border: 1px solid #ddd;\n        }\n        th,\n        td {\n          border: 1px solid #ddd;\n          text-align: left;\n          padding: 8px;\n          font-size: 1rem;\n          font-family: 'Montserrat', sans-serif;\n        }\n        td {\n          font-weight: 500;\n        }\n        tr:nth-child(even) {\n          color: #2e2e2e;\n          background-color: #f3f3f3;\n        }\n\n        .ProseMirror-selectednode {\n          background: #f2f2f2;\n        }\n      }\n    "], ["\n      .ProseMirror {\n        * {\n          font-family: 'Montserrat', sans-serif;\n          color: #292929;\n          ::selection {\n            background: #e9e9e9;\n          }\n        }\n        a {\n          color: #f1576c;\n          cursor: pointer;\n        }\n        h1 {\n          font-size: 2.5rem;\n        }\n        h2 {\n          font-size: 2rem;\n        }\n        h3 {\n          font-size: 1.5rem;\n        }\n        h4 {\n          font-size: 1.25rem;\n        }\n        h5 {\n          font-size: 1rem;\n        }\n        h6 {\n          font-size: 0.875rem;\n        }\n        p {\n          font-size: 14px;\n        }\n        img {\n          width: 100%;\n        }\n        ol {\n          list-style-type: decimal;\n          padding-left: 1rem;\n        }\n        ul {\n          list-style-type: disc;\n          padding-left: 1rem;\n        }\n        .tableWrapper {\n          height: max-content;\n        }\n        table {\n          height: max-content;\n          margin: 20px 0px;\n          border-collapse: collapse;\n          border-spacing: 0;\n          width: 100%;\n          border: 1px solid #ddd;\n        }\n        th,\n        td {\n          border: 1px solid #ddd;\n          text-align: left;\n          padding: 8px;\n          font-size: 1rem;\n          font-family: 'Montserrat', sans-serif;\n        }\n        td {\n          font-weight: 500;\n        }\n        tr:nth-child(even) {\n          color: #2e2e2e;\n          background-color: #f3f3f3;\n        }\n\n        .ProseMirror-selectednode {\n          background: #f2f2f2;\n        }\n      }\n    "]))) })); };
var InputColorStyled = styled$1.input(templateObject_2$r || (templateObject_2$r = __makeTemplateObject(["\n  border: 1px solid #d5d5d5;\n  border-radius: 50%;\n\n  width: 25px;\n  height: 25px;\n  border-radius: 300px;\n  overflow: hidden;\n  ::-webkit-color-swatch {\n    border: none;\n    border-radius: 50%;\n  }\n  ::-webkit-color-swatch-wrapper {\n    padding: 0;\n  }\n"], ["\n  border: 1px solid #d5d5d5;\n  border-radius: 50%;\n\n  width: 25px;\n  height: 25px;\n  border-radius: 300px;\n  overflow: hidden;\n  ::-webkit-color-swatch {\n    border: none;\n    border-radius: 50%;\n  }\n  ::-webkit-color-swatch-wrapper {\n    padding: 0;\n  }\n"])));
styled$1.hr(templateObject_3$l || (templateObject_3$l = __makeTemplateObject(["\n  height: 10px;\n  width: 2px;\n  background-color: #d5d5d5;\n"], ["\n  height: 10px;\n  width: 2px;\n  background-color: #d5d5d5;\n"])));
var ButtonStyled = styled$1.button(templateObject_5$c || (templateObject_5$c = __makeTemplateObject(["\n  width: 30px;\n  height: 30px;\n  background-color: white;\n  border: none;\n  cursor: pointer;\n  font-family: 'Montserrat', sans-serif;\n  font-size: 12px;\n  border-radius: 4px;\n  color: #373737;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-weight: 800;\n  span {\n    cursor: pointer;\n  }\n  ", "\n\n  ", "\n"], ["\n  width: 30px;\n  height: 30px;\n  background-color: white;\n  border: none;\n  cursor: pointer;\n  font-family: 'Montserrat', sans-serif;\n  font-size: 12px;\n  border-radius: 4px;\n  color: #373737;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-weight: 800;\n  span {\n    cursor: pointer;\n  }\n  ", "\n\n  ", "\n"])), function (_a) {
    var isActive = _a.isActive;
    return isActive && css$1(templateObject_4$f || (templateObject_4$f = __makeTemplateObject(["\n      background-color: #000000;\n      color: white !important;\n      span {\n        color: white !important;\n      }\n      svg {\n        path {\n          fill: white !important;\n        }\n      }\n    "], ["\n      background-color: #000000;\n      color: white !important;\n      span {\n        color: white !important;\n      }\n      svg {\n        path {\n          fill: white !important;\n        }\n      }\n    "])));
}, function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
styled$1.textarea(templateObject_6$8 || (templateObject_6$8 = __makeTemplateObject(["\n  padding: 15px 20px;\n  border: none;\n  width: 100%;\n  height: 100%;\n  font-family: 'Montserrat', sans-serif;\n  font-size: 14px;\n  font-weight: 400;\n"], ["\n  padding: 15px 20px;\n  border: none;\n  width: 100%;\n  height: 100%;\n  font-family: 'Montserrat', sans-serif;\n  font-size: 14px;\n  font-weight: 400;\n"])));
var templateObject_1$B, templateObject_2$r, templateObject_3$l, templateObject_4$f, templateObject_5$c, templateObject_6$8;

var VideoCustom = Node.create({
    name: 'video',
    group: 'block',
    atom: true,
    addOptions: function () {
        return {
            controls: true,
            allowFullscreen: true,
            HTMLAttributes: {
                class: 'video-wrapper',
            },
        };
    },
    addAttributes: function () {
        var _this = this;
        return {
            src: {
                default: null,
            },
            frameborder: {
                default: 0,
            },
            controls: {
                default: true,
            },
            allowfullscreen: {
                default: this.options.allowFullscreen,
                parseHTML: function () { return _this.options.allowFullscreen; },
            },
        };
    },
    parseHTML: function () {
        return [
            {
                tag: 'video',
            },
            {
                tag: 'br',
            },
        ];
    },
    renderHTML: function (_a) {
        var HTMLAttributes = _a.HTMLAttributes;
        return ['div', this.options.HTMLAttributes, ['video', HTMLAttributes]];
    },
    addCommands: function () {
        var _this = this;
        return {
            setVideo: function (options) {
                return function (_a) {
                    var tr = _a.tr, dispatch = _a.dispatch;
                    var selection = tr.selection;
                    var node = _this.type.create(options);
                    if (dispatch) {
                        tr.replaceRangeWith(selection.from, selection.to, node);
                    }
                    return true;
                };
            },
        };
    },
});

HardBreak.configure({
    keepMarks: false,
});
var MenuBar = function (props) {
    var _a, _b, _c, _d;
    var editor = props.editor;
    var _e = __read(useState(false), 2), isOpen = _e[0], setIsOpen = _e[1];
    var _f = __read(useState(false), 2), loadingFile = _f[0], setLoadingFile = _f[1];
    var _g = __read(useState({}), 2), image = _g[0], setImage = _g[1];
    var _h = __read(useState(false), 2), isOpenUrl = _h[0], setIsOpenUrl = _h[1];
    var _j = __read(useState(''), 2), url = _j[0], setUrl = _j[1];
    var ref = useRef(null);
    var ref2 = useRef(null);
    var ref3 = useRef(null);
    useEffect(function () {
        var handleClickOutside = function (event) {
            if (ref.current && !ref.current.contains(event.target)) {
                setIsOpenUrl(false);
            }
            if (ref2.current && !ref2.current.contains(event.target)) {
                setIsOpen(false);
            }
        };
        document.addEventListener("mousedown", handleClickOutside, true);
        return function () {
            document.removeEventListener("mousedown", handleClickOutside, true);
        };
    }, [ref, ref2, ref3]);
    var _k = (_a = props === null || props === void 0 ? void 0 : props.options) !== null && _a !== void 0 ? _a : {}, notIncludeSelectFonts = _k.notIncludeSelectFonts, notincludeTableOptions = _k.notincludeTableOptions;
    return (jsx(Fragment$1, { children: jsxs(Wrapper$2, __assign({ className: "menu-editor", flexDirection: "row", width: "100%", justifyContent: "flex-start", alignItems: "center", flexWrap: "wrap", padding: "0px 0px 0px 0px", customCSS: css$1(templateObject_1$A || (templateObject_1$A = __makeTemplateObject(["\n          gap: 5px;\n          flex-wrap: wrap;\n          padding: 8px 30px;\n          ButtonStyled {\n            flex-basis: 40px;\n            flex-grow: 1;\n            width: 40px;\n            height: 40px;\n            font-size: 15px;\n            overflow: hidden;\n            background-color: #fafafa;\n            border: none;\n            color: #373737;\n            font-weight: bold;\n            box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.1);\n          }\n          ", "\n        "], ["\n          gap: 5px;\n          flex-wrap: wrap;\n          padding: 8px 30px;\n          ButtonStyled {\n            flex-basis: 40px;\n            flex-grow: 1;\n            width: 40px;\n            height: 40px;\n            font-size: 15px;\n            overflow: hidden;\n            background-color: #fafafa;\n            border: none;\n            color: #373737;\n            font-weight: bold;\n            box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.1);\n          }\n          ", "\n        "])), (_b = props === null || props === void 0 ? void 0 : props.onCustomCSSMenuBar) === null || _b === void 0 ? void 0 : _b.call(props)) }, { children: [jsxs(ButtonStyled, __assign({ customCSS: css$1(templateObject_2$q || (templateObject_2$q = __makeTemplateObject(["\n            position: relative;\n          "], ["\n            position: relative;\n          "]))), onClick: function () {
                        setIsOpen(true);
                    } }, { children: [jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/picture-image-svgrepo-com.svg" }), isOpen && (jsx(Wrapper$2, __assign({ refObject: ref2, customCSS: css$1(templateObject_3$k || (templateObject_3$k = __makeTemplateObject(["\n                position: absolute;\n                background-color: #ffffff;\n                padding: 30px 30px;\n                border-radius: 5px;\n                height: max-content;\n                width: 400px;\n                max-width: 400px;\n                top: 170%;\n                left: -50%;\n                flex-direction: column;\n                justify-content: space-between;\n                align-items: center;\n                box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.227);\n                :before {\n                  content: '';\n                  z-index: 100;\n                  position: absolute;\n                  top: -10px;\n                  left: 5%;\n                  width: 0;\n                  height: 0;\n                  border-left: 10px solid transparent;\n                  border-right: 10px solid transparent;\n                  border-bottom: 10px solid #ffffff;\n                }\n              "], ["\n                position: absolute;\n                background-color: #ffffff;\n                padding: 30px 30px;\n                border-radius: 5px;\n                height: max-content;\n                width: 400px;\n                max-width: 400px;\n                top: 170%;\n                left: -50%;\n                flex-direction: column;\n                justify-content: space-between;\n                align-items: center;\n                box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.227);\n                :before {\n                  content: '';\n                  z-index: 100;\n                  position: absolute;\n                  top: -10px;\n                  left: 5%;\n                  width: 0;\n                  height: 0;\n                  border-left: 10px solid transparent;\n                  border-right: 10px solid transparent;\n                  border-bottom: 10px solid #ffffff;\n                }\n              "]))) }, { children: loadingFile ? (jsx(Loader, { isLoading: true, colorLoading: "#000000", height: "200px", type: "small" })) : (jsxs(Fragment$1, { children: [jsx(Input, { height: "150px", labelWidth: "100%", width: "100%", type: "dragdrop", onChangeDrop: function (e) {
                                            setImage(e);
                                        } }), jsxs(Wrapper$2, __assign({ margin: "10px", customCSS: css$1(templateObject_5$b || (templateObject_5$b = __makeTemplateObject(["\n                      ", "\n                    "], ["\n                      ", "\n                    "])), typeof image === 'object' &&
                                            image.name && css$1(templateObject_4$e || (templateObject_4$e = __makeTemplateObject(["\n                        span {\n                          color: #a0a0a0;\n                        }\n                        input {\n                          background-color: #fcfcfc;\n                        }\n                      "], ["\n                        span {\n                          color: #a0a0a0;\n                        }\n                        input {\n                          background-color: #fcfcfc;\n                        }\n                      "])))) }, { children: [jsx(Text$2, __assign({ fontSize: "12px", fontWeight: 600, margin: "0px 15px 0px 0px" }, { children: "Url:" })), jsx(Input, { customCSS: css$1(templateObject_6$7 || (templateObject_6$7 = __makeTemplateObject(["\n                        span {\n                          display: none;\n                        }\n                      "], ["\n                        span {\n                          display: none;\n                        }\n                      "]))), labelWidth: "100%", width: "100%", type: "text", onChange: function (e) {
                                                    setImage(e.target.value);
                                                } })] })), jsx(Wrapper$2, __assign({ flexDirection: "row", justifyContent: "flex-end" }, { children: jsx(AtomButton, __assign({ customCSS: css$1(templateObject_7$6 || (templateObject_7$6 = __makeTemplateObject(["\n                        padding: 5px;\n                        background-color: #000000;\n                      "], ["\n                        padding: 5px;\n                        background-color: #000000;\n                      "]))), onClick: function () { return __awaiter(void 0, void 0, void 0, function () {
                                                return __generator(this, function (_a) {
                                                    switch (_a.label) {
                                                        case 0:
                                                            if (!(typeof image === 'string')) return [3 /*break*/, 1];
                                                            editor === null || editor === void 0 ? void 0 : editor.chain().focus().setImage({ src: image }).run();
                                                            setImage({});
                                                            setLoadingFile(true);
                                                            setTimeout(function () {
                                                                setLoadingFile(false);
                                                                setIsOpen(false);
                                                            }, 500);
                                                            return [3 /*break*/, 3];
                                                        case 1:
                                                            if (!image.name) return [3 /*break*/, 3];
                                                            setLoadingFile(true);
                                                            return [4 /*yield*/, uploadImage(image, {
                                                                    name: 'textbox',
                                                                    orgcode: 'IXU-0001',
                                                                })
                                                                    .then(function (res) {
                                                                    setLoadingFile(false);
                                                                    setIsOpen(false);
                                                                    editor === null || editor === void 0 ? void 0 : editor.chain().focus().setImage({ src: res }).run();
                                                                    setImage({});
                                                                })
                                                                    .catch(function (err) {
                                                                    setLoadingFile(false);
                                                                    console.warn(err);
                                                                })];
                                                        case 2:
                                                            _a.sent();
                                                            _a.label = 3;
                                                        case 3:
                                                            setIsOpen(false);
                                                            return [2 /*return*/];
                                                    }
                                                });
                                            }); } }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "white", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/commons/check-4787.svg" }) })) }))] })) })))] })), jsxs(ButtonStyled, __assign({ customCSS: css$1(templateObject_8$3 || (templateObject_8$3 = __makeTemplateObject(["\n            position: relative;\n          "], ["\n            position: relative;\n          "]))), onClick: function () {
                        setIsOpenUrl(true);
                    } }, { children: [jsx(Icon$1, { height: "15px", width: "15px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/link-solid.svg" }), isOpenUrl && (jsxs(Wrapper$2, __assign({ refObject: ref, customCSS: css$1(templateObject_9$1 || (templateObject_9$1 = __makeTemplateObject(["\n                position: absolute;\n                background-color: #ffffff;\n                padding: 10px 30px;\n                border-radius: 5px;\n                height: max-content;\n                width: 400px;\n                max-width: 400px;\n                top: 170%;\n                left: 50%;\n                transform: translateX(-50%);\n                flex-direction: row;\n                justify-content: space-between;\n                align-items: center;\n                box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.227);\n                :after {\n                  content: '';\n                  position: absolute;\n                  top: -10px;\n                  left: 50%;\n                  transform: translateX(-50%);\n                  width: 0;\n                  height: 0;\n                  border-left: 10px solid transparent;\n                  border-right: 10px solid transparent;\n                  border-bottom: 10px solid #ffffff;\n                }\n              "], ["\n                position: absolute;\n                background-color: #ffffff;\n                padding: 10px 30px;\n                border-radius: 5px;\n                height: max-content;\n                width: 400px;\n                max-width: 400px;\n                top: 170%;\n                left: 50%;\n                transform: translateX(-50%);\n                flex-direction: row;\n                justify-content: space-between;\n                align-items: center;\n                box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.227);\n                :after {\n                  content: '';\n                  position: absolute;\n                  top: -10px;\n                  left: 50%;\n                  transform: translateX(-50%);\n                  width: 0;\n                  height: 0;\n                  border-left: 10px solid transparent;\n                  border-right: 10px solid transparent;\n                  border-bottom: 10px solid #ffffff;\n                }\n              "]))) }, { children: [jsx(Text$2, __assign({ fontSize: "12px", fontWeight: 600, margin: "0px 15px 0px 0px" }, { children: "Url:" })), jsx(Input, { customCSS: css$1(templateObject_10$1 || (templateObject_10$1 = __makeTemplateObject(["\n                  span {\n                    display: none;\n                  }\n                "], ["\n                  span {\n                    display: none;\n                  }\n                "]))), labelWidth: "100%", width: "90%", type: "text", value: url, onChange: function (e) {
                                        setUrl(e.target.value);
                                    } }), jsxs(Wrapper$2, __assign({ flexDirection: "row", justifyContent: "space-between", alignItems: "center", width: "30%" }, { children: [jsx(AtomButton, __assign({ onClick: function () {
                                                editor === null || editor === void 0 ? void 0 : editor.chain().focus().extendMarkRange('link').unsetLink().run();
                                                setUrl('');
                                                setTimeout(function () {
                                                    setIsOpenUrl(false);
                                                }, 500);
                                            }, customCSS: css$1(templateObject_11$1 || (templateObject_11$1 = __makeTemplateObject(["\n                    padding: 5px;\n                    border: 1px solid #000000;\n                    color: #000000;\n                    background-color: transparent;\n                  "], ["\n                    padding: 5px;\n                    border: 1px solid #000000;\n                    color: #000000;\n                    background-color: transparent;\n                  "]))) }, { children: jsx(Icon$1, { height: "15px", width: "15px", color: "#000000", customCSS: css$1(templateObject_12$1 || (templateObject_12$1 = __makeTemplateObject(["\n                      svg {\n                        fill: none;\n                      }\n                    "], ["\n                      svg {\n                        fill: none;\n                      }\n                    "]))), icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/commons/trash.svg" }) })), jsx(AtomButton, __assign({ customCSS: css$1(templateObject_13 || (templateObject_13 = __makeTemplateObject(["\n                    padding: 5px;\n                    background-color: #000000;\n                  "], ["\n                    padding: 5px;\n                    background-color: #000000;\n                  "]))), onClick: function () {
                                                setTimeout(function () {
                                                    setIsOpenUrl(false);
                                                }, 500);
                                                if (url) {
                                                    editor === null || editor === void 0 ? void 0 : editor.chain().focus().extendMarkRange('link').setLink({ href: url }).run();
                                                }
                                            } }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "white", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/commons/check-4787.svg" }) }))] }))] })))] })), jsx(ButtonStyled, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleBold().run(); }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive('bold') }, { children: jsx(Icon$1, { height: "12px", width: "12px", color: (editor === null || editor === void 0 ? void 0 : editor.isActive('bold')) ? '#fafafa' : '#373737', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/bold-solid.svg" }) })), jsx(ButtonStyled, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleItalic().run(); }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive('italic') }, { children: jsx(Icon$1, { height: "12px", width: "12px", color: (editor === null || editor === void 0 ? void 0 : editor.isActive('italic')) ? '#fafafa' : '#373737', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/italic-solid.svg" }) })), jsx(ButtonStyled, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleUnderline().run(); }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive('underline') }, { children: jsx(Icon$1, { height: "12px", width: "12px", color: (editor === null || editor === void 0 ? void 0 : editor.isActive('underline')) ? '#fafafa' : '#373737', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/underline-solid.svg" }) })), jsx(InputColorStyled, { type: "color", onInput: function (event) {
                        return editor === null || editor === void 0 ? void 0 : editor.chain().focus().setColor("".concat(event.currentTarget.value)).run();
                    }, value: (_c = editor === null || editor === void 0 ? void 0 : editor.getAttributes('textStyle').color) !== null && _c !== void 0 ? _c : '#ffffff' }), !notIncludeSelectFonts && (jsx(Input, { type: "select", border: "1px solid #d5d5d5", height: "30px", labelWidth: "100px", options: [
                        { id: '0', value: 'Montserrat', label: 'Montserrat' },
                        { id: '1', value: 'Inter', label: 'Inter' },
                        {
                            id: '2',
                            value: 'Comic Sans MS, Comic Sans',
                            label: 'Comic Sans MS, Comic Sans',
                        },
                        { id: '3', value: 'Arial', label: 'Arial' },
                        { id: '4', value: 'serif', label: 'serif' },
                        { id: '5', value: 'monospace', label: 'monospace' },
                        { id: '6', value: 'cursive', label: 'cursive' },
                    ], customCSS: css$1(templateObject_14 || (templateObject_14 = __makeTemplateObject(["\n              select {\n                border: none;\n                font-size: 10px;\n                option {\n                  font-size: 10px;\n                }\n              }\n              span {\n                display: none;\n              }\n            "], ["\n              select {\n                border: none;\n                font-size: 10px;\n                option {\n                  font-size: 10px;\n                }\n              }\n              span {\n                display: none;\n              }\n            "]))), onChange: function (e) {
                        return editor === null || editor === void 0 ? void 0 : editor.chain().focus().setFontFamily("".concat(e.target.value)).run();
                    } })), jsx(Input, { type: "select", border: "1px solid #d5d5d5", height: "30px", labelWidth: "55px", value: (_d = editor === null || editor === void 0 ? void 0 : editor.getAttributes('heading').level) !== null && _d !== void 0 ? _d : '6', options: [
                        { id: '0', value: '6', label: '14' },
                        { id: '1', value: '5', label: '16' },
                        { id: '2', value: '4', label: '18' },
                        { id: '3', value: '3', label: '20' },
                        { id: '4', value: '2', label: '22' },
                        { id: '5', value: '1', label: '24' },
                    ], customCSS: css$1(templateObject_15 || (templateObject_15 = __makeTemplateObject(["\n            select {\n              border: none;\n              font-size: 10px;\n              option {\n                font-size: 10px;\n              }\n            }\n            span {\n              display: none;\n            }\n          "], ["\n            select {\n              border: none;\n              font-size: 10px;\n              option {\n                font-size: 10px;\n              }\n            }\n            span {\n              display: none;\n            }\n          "]))), onChange: function (e) {
                        return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleHeading({ level: Number(e.target.value) }).run();
                    } }), jsx(ButtonStyled, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().setTextAlign('left').run(); }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: 'left' }) }, { children: jsx(Icon$1, { height: "12px", width: "12px", color: (editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: 'left' })) ? '#fafafa' : '#373737', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/align-left-solid.svg" }) })), jsx(ButtonStyled, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().setTextAlign('center').run(); }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: 'center' }) }, { children: jsx(Icon$1, { height: "12px", width: "12px", color: (editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: 'center' })) ? '#fafafa' : '#373737', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/align-center-solid.svg" }) })), jsx(ButtonStyled, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().setTextAlign('right').run(); }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: 'right' }) }, { children: jsx(Icon$1, { height: "12px", width: "12px", color: (editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: 'right' })) ? '#fafafa' : '#373737', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/align-right-solid.svg" }) })), jsx(ButtonStyled, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().setTextAlign('justify').run(); }, isActive: editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: 'justify' }) }, { children: jsx(Icon$1, { height: "12px", width: "12px", color: (editor === null || editor === void 0 ? void 0 : editor.isActive({ textAlign: 'justify' })) ? '#fafafa' : '#373737', icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/align-justify-solid.svg" }) })), jsx(ButtonStyled, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleBulletList().run(); }, className: (editor === null || editor === void 0 ? void 0 : editor.isActive('bulletList')) ? 'is-active' : '' }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/list-ul-solid.svg" }) })), jsx(ButtonStyled, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().toggleOrderedList().run(); }, className: (editor === null || editor === void 0 ? void 0 : editor.isActive('orderedList')) ? 'is-active' : '' }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/list-ol-solid.svg" }) })), !notincludeTableOptions && (jsxs(Fragment$1, { children: [jsx(ButtonStyled, __assign({ onClick: function () {
                                return editor === null || editor === void 0 ? void 0 : editor.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: true }).run();
                            } }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/table-solid.svg" }) })), jsx(ButtonStyled, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().deleteTable().run(); }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().deleteTable()) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#a0a0a0", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/table-solid.svg" }) })), jsx(ButtonStyled, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().addColumnBefore().run(); }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().addColumnBefore()) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/border-left-new.svg" }) })), jsx(ButtonStyled, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().deleteColumn().run(); }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().deleteColumn()) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#a0a0a0", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/border-center-v.svg" }) })), jsx(ButtonStyled, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().addColumnAfter().run(); }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().addColumnAfter()) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/border-right.svg" }) })), jsx(ButtonStyled, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().addRowBefore().run(); }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().addRowBefore()) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/border-top.svg" }) })), jsx(ButtonStyled, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().deleteRow().run(); }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().deleteRow()) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#a0a0a0", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/border-center-h.svg" }) })), jsx(ButtonStyled, __assign({ onClick: function () { return editor === null || editor === void 0 ? void 0 : editor.chain().focus().addRowAfter().run(); }, disabled: !(editor === null || editor === void 0 ? void 0 : editor.can().addRowAfter()) }, { children: jsx(Icon$1, { height: "16px", width: "16px", color: "#373737", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/TextEditor/border-bottom.svg" }) }))] }))] })) }));
};
var AtomTextEditor = function (props) {
    var _a, _b;
    var id = props.id, content = props.content, onUpdate = props.onUpdate, options = props.options;
    var editor = useEditor({
        extensions: [
            TextAlign.configure({
                types: ['heading', 'paragraph'],
            }),
            StarterKit,
            TextStyle$1,
            FontFamily,
            Color,
            Underline,
            Image$1,
            Iframe,
            VideoCustom,
            Table.configure({
                resizable: true,
            }),
            TableRow,
            TableHeader,
            TableCell,
            Link.configure({
                openOnClick: false,
            }),
        ],
        onUpdate: function (_a) {
            var EditorUpdate = _a.editor;
            return onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(EditorUpdate);
        },
        content: content !== null && content !== void 0 ? content : '',
    }, [content]);
    return (jsxs(Wrapper$2, __assign({ margin: "0px 0px", width: "100%", customCSS: css$1(templateObject_16 || (templateObject_16 = __makeTemplateObject(["\n        background-color: #ffffff;\n        border-radius: 8px;\n        box-shadow: 0px 0px 8px rgba(0, 0, 0, 0.052);\n        ", "\n      "], ["\n        background-color: #ffffff;\n        border-radius: 8px;\n        box-shadow: 0px 0px 8px rgba(0, 0, 0, 0.052);\n        ", "\n      "])), (_a = props === null || props === void 0 ? void 0 : props.onCustomCSSMain) === null || _a === void 0 ? void 0 : _a.call(props)) }, { children: [jsx(GlobalStyles, {}), jsx(MenuBar, { editor: editor, options: options, onCustomCSSMenuBar: props === null || props === void 0 ? void 0 : props.onCustomCSSMenuBar }), jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_17 || (templateObject_17 = __makeTemplateObject(["\n          min-height: 500px;\n          border-top: 1px solid #010101;\n          border-radius: 0px 0px 8px 8px;\n          z-index: -1;\n          align-items: center;\n          justify-content: flex-start;\n          > div {\n            padding: 0px;\n            width: 100%;\n            height: 100%;\n            overflow-y: auto;\n          }\n\n          .ProseMirror {\n            min-height: 500px;\n            padding: 20px 20px;\n            outline: none;\n            .video-wrapper {\n              margin: 0px 0px 20px 0px;\n              video {\n                width: 100%;\n              }\n            }\n            .iframe-wrapper {\n              margin: 0px 0px 20px 0px;\n              position: relative;\n              padding-bottom: math.div(100, 16) * 9%;\n              height: 0;\n              overflow: hidden;\n              width: 100%;\n              height: 300px;\n\n              &.ProseMirror-selectednode {\n                outline: 3px solid #68cef8;\n              }\n\n              iframe {\n                position: absolute;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n              }\n            }\n          }\n          ", "\n        "], ["\n          min-height: 500px;\n          border-top: 1px solid #010101;\n          border-radius: 0px 0px 8px 8px;\n          z-index: -1;\n          align-items: center;\n          justify-content: flex-start;\n          > div {\n            padding: 0px;\n            width: 100%;\n            height: 100%;\n            overflow-y: auto;\n          }\n\n          .ProseMirror {\n            min-height: 500px;\n            padding: 20px 20px;\n            outline: none;\n            .video-wrapper {\n              margin: 0px 0px 20px 0px;\n              video {\n                width: 100%;\n              }\n            }\n            .iframe-wrapper {\n              margin: 0px 0px 20px 0px;\n              position: relative;\n              padding-bottom: math.div(100, 16) * 9%;\n              height: 0;\n              overflow: hidden;\n              width: 100%;\n              height: 300px;\n\n              &.ProseMirror-selectednode {\n                outline: 3px solid #68cef8;\n              }\n\n              iframe {\n                position: absolute;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n              }\n            }\n          }\n          ", "\n        "])), (_b = props === null || props === void 0 ? void 0 : props.onCustomCSSContent) === null || _b === void 0 ? void 0 : _b.call(props)) }, { children: jsx(EditorContent, { id: id, editor: editor }) }))] })));
};
var templateObject_1$A, templateObject_2$q, templateObject_3$k, templateObject_4$e, templateObject_5$b, templateObject_6$7, templateObject_7$6, templateObject_8$3, templateObject_9$1, templateObject_10$1, templateObject_11$1, templateObject_12$1, templateObject_13, templateObject_14, templateObject_15, templateObject_16, templateObject_17;

var AtomUserDefault = function (props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    var _q = __read(useState(false), 2), showUserMenu = _q[0], setShowUserMenu = _q[1];
    var src = props.src, componentProps = props.componentProps, name = props.name, options = props.options, wrapperProps = props.wrapperProps, buttonProps = props.buttonProps;
    var ref = useRef(null);
    return (jsx(AtomButton, __assign({ onClick: function () { return setShowUserMenu(!showUserMenu); }, backgroundColor: "#fff", color: "#1d1d1d" }, buttonProps, { customCSS: css$1(templateObject_1$z || (templateObject_1$z = __makeTemplateObject(["\n        @media only screen and (max-width: 1200px) {\n          display: none;\n        }\n        ", ";\n      "], ["\n        @media only screen and (max-width: 1200px) {\n          display: none;\n        }\n        ", ";\n      "])), buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.customCSS) }, { children: jsxs(Wrapper$2, __assign({ flexDirection: "row", maxWidth: "max-content", height: "max-content", alignItems: "center", justifyContent: "center", onHoverEnd: function () { return setShowUserMenu(false); }, onHoverStart: function () { return setShowUserMenu(true); } }, wrapperProps, { children: [jsx(Image$2, __assign({ alt: "userPhoto", customCSS: css$1(templateObject_2$p || (templateObject_2$p = __makeTemplateObject(["\n            overflow: hidden;\n            background-color: #fff;\n            border-radius: 50%;\n            border: 2px solid #b3b0b0;\n            ", ";\n          "], ["\n            overflow: hidden;\n            background-color: #fff;\n            border-radius: 50%;\n            border: 2px solid #b3b0b0;\n            ", ";\n          "])), (_a = componentProps === null || componentProps === void 0 ? void 0 : componentProps.imageProps) === null || _a === void 0 ? void 0 : _a.customCSS), height: "35px", width: "35px", src: "".concat(src ||
                        'https://storage.googleapis.com/cdn-bucket-ixulabs-platform/MDCAO-0001/images/userDefault.avif') }, componentProps === null || componentProps === void 0 ? void 0 : componentProps.imageProps)), jsx(Wrapper$2, __assign({ width: "max-content", padding: "0px 0px", position: "relative", height: "max-content" }, { children: jsxs(Wrapper$2, __assign({ backgroundColor: "transparent", padding: "0px 0px", customCSS: css$1(templateObject_3$j || (templateObject_3$j = __makeTemplateObject(["\n              display: flex;\n              align-items: center;\n              justify-content: center;\n              flex-direction: row;\n              ", ";\n            "], ["\n              display: flex;\n              align-items: center;\n              justify-content: center;\n              flex-direction: row;\n              ", ";\n            "])), (_c = (_b = componentProps === null || componentProps === void 0 ? void 0 : componentProps.buttonProps) === null || _b === void 0 ? void 0 : _b.wrapperProps) === null || _c === void 0 ? void 0 : _c.customCSS) }, (_d = componentProps === null || componentProps === void 0 ? void 0 : componentProps.buttonProps) === null || _d === void 0 ? void 0 : _d.wrapperProps, { children: [jsx(Text$2, __assign({ color: "#1d1d1d", fontWeight: 600, cursor: "pointer", customCSS: css$1(templateObject_4$d || (templateObject_4$d = __makeTemplateObject(["\n                padding: 0px 20px;\n                overflow: hidden;\n                max-height: 100%;\n                ", ";\n              "], ["\n                padding: 0px 20px;\n                overflow: hidden;\n                max-height: 100%;\n                ", ";\n              "])), (_f = (_e = componentProps === null || componentProps === void 0 ? void 0 : componentProps.buttonProps) === null || _e === void 0 ? void 0 : _e.textProps) === null || _f === void 0 ? void 0 : _f.customCSS) }, (_g = componentProps === null || componentProps === void 0 ? void 0 : componentProps.buttonProps) === null || _g === void 0 ? void 0 : _g.textProps, { children: name || "" })), jsx(Icon$1, __assign({ height: "14px", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-commons/frontend-library/icons/arrow-down-3101.svg", color: "#1F1F1F" }, (_h = componentProps === null || componentProps === void 0 ? void 0 : componentProps.buttonProps) === null || _h === void 0 ? void 0 : _h.iconProps)), showUserMenu && (jsxs(Wrapper$2, __assign({ refObject: ref, position: "absolute", shadow: true, alignItems: "center", backgroundColor: "white", borderRadius: "5px", width: "80%", padding: "6px", customCSS: css$1(templateObject_5$a || (templateObject_5$a = __makeTemplateObject(["\n                  bottom: -5px;\n                  transform: translate(5%, 100%);\n                  ", ";\n                "], ["\n                  bottom: -5px;\n                  transform: translate(5%, 100%);\n                  ", ";\n                "])), (_k = (_j = componentProps === null || componentProps === void 0 ? void 0 : componentProps.menuProps) === null || _j === void 0 ? void 0 : _j.wrapperProps) === null || _k === void 0 ? void 0 : _k.customCSS) }, (_l = componentProps === null || componentProps === void 0 ? void 0 : componentProps.menuProps) === null || _l === void 0 ? void 0 : _l.wrapperProps, { children: [options === null || options === void 0 ? void 0 : options.map(function (option) {
                                        var _a, _b, _c;
                                        return (jsx(Link$1, __assign({ width: "100%", padding: "8px 10px", color: "#1d1d1d", fontSize: "10px", align: "center", customCSS: css$1(templateObject_6$6 || (templateObject_6$6 = __makeTemplateObject(["\n                      :hover {\n                        background-color: #dadada;\n                      }\n                      transition: background-color 0.3s ease;\n                      ", ";\n                    "], ["\n                      :hover {\n                        background-color: #dadada;\n                      }\n                      transition: background-color 0.3s ease;\n                      ", ";\n                    "])), (_b = (_a = componentProps === null || componentProps === void 0 ? void 0 : componentProps.menuProps) === null || _a === void 0 ? void 0 : _a.textProps) === null || _b === void 0 ? void 0 : _b.customCSS) }, option, (_c = componentProps === null || componentProps === void 0 ? void 0 : componentProps.menuProps) === null || _c === void 0 ? void 0 : _c.textProps, { children: option.label }), option.id));
                                    }), jsx(AtomButton, __assign({ width: "100%", padding: "8px 12px", color: "#1d1d1d", borderRadius: "0px", backgroundColor: "transparent", fontSize: "12px", customCSS: css$1(templateObject_7$5 || (templateObject_7$5 = __makeTemplateObject(["\n                    :hover {\n                      background-color: #dadada;\n                    }\n                    transition: background-color 0.3s ease;\n                    ", ";\n                  "], ["\n                    :hover {\n                      background-color: #dadada;\n                    }\n                    transition: background-color 0.3s ease;\n                    ", ";\n                  "])), (_o = (_m = componentProps === null || componentProps === void 0 ? void 0 : componentProps.menuProps) === null || _m === void 0 ? void 0 : _m.buttonProps) === null || _o === void 0 ? void 0 : _o.customCSS) }, (_p = componentProps === null || componentProps === void 0 ? void 0 : componentProps.menuProps) === null || _p === void 0 ? void 0 : _p.buttonProps, { children: "Cerrar sesi\u00F3n" }))] })))] })) }))] })) })));
};
var templateObject_1$z, templateObject_2$p, templateObject_3$j, templateObject_4$d, templateObject_5$a, templateObject_6$6, templateObject_7$5;

var AtomWrapperScroll = function (_a) {
    var refObject = _a.refObject, children = _a.children, minRestoffsetTop = _a.minRestoffsetTop, customCSSW = _a.customCSSW;
    var _b = __read(useState(false), 2), scroll = _b[0], setScroll = _b[1];
    useEffect(function () {
        var getScroll = function () {
            var _a;
            var rest = minRestoffsetTop !== null && minRestoffsetTop !== void 0 ? minRestoffsetTop : 40;
            setScroll(window.scrollY > (((_a = refObject === null || refObject === void 0 ? void 0 : refObject.current) === null || _a === void 0 ? void 0 : _a.offsetTop) || 0) - rest);
        };
        var watchScroll = function () {
            window.addEventListener('scroll', getScroll, true);
        };
        watchScroll();
        return function () {
            window.removeEventListener('scroll', getScroll, true);
        };
    });
    return scroll ? (jsx(AnimatePresence, { children: jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_2$o || (templateObject_2$o = __makeTemplateObject(["\n          display: flex;\n          flex-direction: row;\n          position: fixed;\n          z-index: 2;\n          bottom: 10vh;\n          right: 5vw;\n          width: max-content;\n          ", "\n        "], ["\n          display: flex;\n          flex-direction: row;\n          position: fixed;\n          z-index: 2;\n          bottom: 10vh;\n          right: 5vw;\n          width: max-content;\n          ", "\n        "])), customCSSW !== null && customCSSW !== void 0 ? customCSSW : css$1(templateObject_1$y || (templateObject_1$y = __makeTemplateObject([""], [""])))) }, { children: children })) })) : null;
};
var templateObject_1$y, templateObject_2$o;

var ContainerVideo = styled$1.div(templateObject_1$x || (templateObject_1$x = __makeTemplateObject(["\n  display: flex;\n  position: relative;\n  height: ", ";\n  width: ", ";\n  position: relative;\n  overflow: hidden;\n  position: relative;\n  overflow: hidden;\n  width: 100%;\n  padding-top: 56.25%;\n  iframe {\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n    width: 100%;\n    height: 100%;\n  }\n\n  ", "\n\n  background-color: #000000;\n"], ["\n  display: flex;\n  position: relative;\n  height: ", ";\n  width: ", ";\n  position: relative;\n  overflow: hidden;\n  position: relative;\n  overflow: hidden;\n  width: 100%;\n  padding-top: 56.25%;\n  iframe {\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n    width: 100%;\n    height: 100%;\n  }\n\n  ", "\n\n  background-color: #000000;\n"])), function (_a) {
    var height = _a.height;
    return height || '100%';
}, function (_a) {
    var width = _a.width;
    return width || '100%';
}, function (_a) {
    var customCSS = _a.customCSS;
    return customCSS;
});
var templateObject_1$x;

var Player = function (props) {
    var video = props.video;
    return (jsx(ContainerVideo, { children: jsx("iframe", { src: video, frameBorder: "0", allow: "autoplay; fullscreen", title: "Player" }) }));
};

var MoleculeCardComment = function (props) {
    var image = props.image, name = props.name, title = props.title, description = props.description;
    return (jsxs(Wrapper$2, __assign({ flexDirection: "row", justifyContent: "space-between", position: "relative" }, { children: [jsxs(Wrapper$2, __assign({ width: "10%" }, { children: [jsx(Image$2, { alt: name || 'user', height: "70px", width: "70px", customCSS: css$1(templateObject_1$w || (templateObject_1$w = __makeTemplateObject(["\n            img {\n              border-radius: 100%;\n            }\n          "], ["\n            img {\n              border-radius: 100%;\n            }\n          "]))), src: image ||
                            'https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/images/default-placeholder.png' }), jsx(Icon$1, { height: "100%", color: "#888888", customCSS: css$1(templateObject_2$n || (templateObject_2$n = __makeTemplateObject(["\n            margin: 10px 0px 0px 0px;\n            transform: translateX(100%);\n            z-index: -1;\n          "], ["\n            margin: 10px 0px 0px 0px;\n            transform: translateX(100%);\n            z-index: -1;\n          "]))), icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/images/Grupo%203198.svg" })] })), jsxs(Wrapper$2, __assign({ flexDirection: "column", width: "calc(100% - 90px)" }, { children: [jsx(Text$2, __assign({ color: "#888888", fontWeight: "bold", padding: "18px 0px" }, { children: title ||
                            '¿Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut molestie nunc eget?' })), jsx(Text$2, __assign({ color: "#888888", customCSS: css$1(templateObject_3$i || (templateObject_3$i = __makeTemplateObject(["\n            text-align: justify;\n          "], ["\n            text-align: justify;\n          "]))) }, { children: description ||
                            'Aliquam fermentum efficitur purus sit amet ultrices. Fusce vulputate ligula nec tortor venenatis porta. Aenean pretium interdum convallis. Vestibulum sit amet dictum lacus, in bibendum mauris. Curabitur et ornare velit. Curabitur blandit turpis at consequat sodales. Pellentesque sed eleifend arcu. Praesent ut risus bibendum, semper lectus ac, molestie arcu. Etiam placerat lacus eu molestie pulvinar. Cras sagittis orci ut ante scelerisque, in faucibus nibh scelerisque. Aliquam fermentum efficitur purus sit amet ultrices. Fusce vulputate ligula nec tortor venenatis porta. Aenean pretium interdum convallis. Vestibulum sit amet dictum lacus, in bibendum mauris. Curabitur et ornare velit. Curabitur blandit turpis at consequat sodales. Pellentesque sed eleifend arcu. Praesent ut risus bibendum, semper lectus ac, molestie arcu. Etiam placerat lacus eu molestie pulvinar. Cras sagittis orci ut ante scelerisque, in faucibus nibh scelerisque.' }))] }))] })));
};
var templateObject_1$w, templateObject_2$n, templateObject_3$i;

var MoleculeNewsLetter = function (props) {
    var componentsProps = props.componentsProps;
    return (jsxs(Wrapper$2, __assign({}, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperProps, { children: [jsx(Input, __assign({ id: "newsletter", labelWidth: "100%", height: "30px", border: "1px solid #00838f", placeholder: "Tu email" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.inputProps)), jsx(AtomButton, __assign({ backgroundColor: "#00838f", color: "white", fontSize: "12px", padding: "8px 15px", fontWeight: "700" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.butonProps, { children: "Subscribete" }))] })));
};

var MoleculeSearchBar = function (props) {
    var componentsProps = props.componentsProps;
    return (jsxs(Wrapper$2, __assign({ margin: "0px 0px 0px 25px", width: "max-content", height: "max-content", position: "relative", customCSS: css$1(templateObject_1$v || (templateObject_1$v = __makeTemplateObject(["\n        @media only screen and (max-width: 520px) {\n          display: none;\n        }\n      "], ["\n        @media only screen and (max-width: 520px) {\n          display: none;\n        }\n      "]))) }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperProps, { children: [jsx(Input, __assign({ id: "search", height: "26px", errorMargin: "0px", labelWidth: "max-content", borderRadius: "50px", customCSS: css$1(templateObject_2$m || (templateObject_2$m = __makeTemplateObject(["\n          input {\n            width: 180px;\n          }\n          span {\n            display: none;\n          }\n        "], ["\n          input {\n            width: 180px;\n          }\n          span {\n            display: none;\n          }\n        "]))) }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.inputProps)), jsx(Icon$1, __assign({ height: "14px", width: "14px", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-commons/frontend-library/icons/search-solid%20(1).svg", color: "#a01d7f", customCSS: css$1(templateObject_3$h || (templateObject_3$h = __makeTemplateObject(["\n          position: absolute;\n          right: -30px;\n        "], ["\n          position: absolute;\n          right: -30px;\n        "]))) }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.iconProps))] })));
};
var templateObject_1$v, templateObject_2$m, templateObject_3$h;

var MoleculeInsertComment = function (props) {
    var componentsProps = props.componentsProps;
    return (jsxs(Wrapper$2, __assign({ flexDirection: "column", justifyContent: "space-between" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperProps, { children: [jsx(Input, __assign({ type: "textbox", height: "150px", labelWidth: "100%", labelColor: "#888888", spanMargin: "0px 0px 10px 0px", label: "Haz una pregunta", padding: "15px 20px", color: "#272727" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.inputProps)), jsx(AtomButton, __assign({ fontSize: "12px", backgroundColor: "#01abb9" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.buttonProps, { children: "Enviar" }))] })));
};

var DefaultFooter = function (_a) {
    var _b, _c, _d, _e, _f, _g, _h;
    var imageLogo = _a.imageLogo, columns = _a.columns, links = _a.links, componentsProps = _a.componentsProps;
    return (jsx(Container, __assign({ backgroundColor: "#f2f2f2", padding: "50px 0px", as: "footer" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.containerProps, { children: jsxs(Wrapper$2, __assign({ flexDirection: "row", alignItems: "flex-start", justifyContent: "space-between", maxWidth: "1440px", padding: "0px 90px", flexWrap: "wrap", customCSS: css$1(templateObject_1$u || (templateObject_1$u = __makeTemplateObject(["\n          @media (max-width: 480px) {\n            flex-direction: column;\n            padding: 0px 20px;\n          }\n        "], ["\n          @media (max-width: 480px) {\n            flex-direction: column;\n            padding: 0px 20px;\n          }\n        "]))) }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperProps, { children: [jsxs(Wrapper$2, __assign({ maxWidth: "max-content", justifyContent: "space-between", customCSS: css$1(templateObject_2$l || (templateObject_2$l = __makeTemplateObject(["\n            @media (max-width: 1200px) {\n              width: 100%;\n              align-items: center;\n              justify-content: center;\n              max-width: 100%;\n            }\n            @media (max-width: 480px) {\n              max-width: max-content;\n            }\n          "], ["\n            @media (max-width: 1200px) {\n              width: 100%;\n              align-items: center;\n              justify-content: center;\n              max-width: 100%;\n            }\n            @media (max-width: 480px) {\n              max-width: max-content;\n            }\n          "]))) }, (_b = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.logoProps) === null || _b === void 0 ? void 0 : _b.wrapperProps, { children: [imageLogo && (jsxs(Link$1, __assign({ href: "/", customCSS: css$1(templateObject_3$g || (templateObject_3$g = __makeTemplateObject(["\n                svg {\n                  width: 180px;\n                  height: 50px;\n                }\n              "], ["\n                svg {\n                  width: 180px;\n                  height: 50px;\n                }\n              "]))) }, (_d = (_c = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.logoProps) === null || _c === void 0 ? void 0 : _c.linksProps) === null || _d === void 0 ? void 0 : _d.linkProps, { children: [jsx(Image$2, __assign({ alt: "LOGO", src: imageLogo, height: "80px", width: "150px", customCSS: css$1(templateObject_4$c || (templateObject_4$c = __makeTemplateObject(["\n                  img {\n                    display: flex;\n                    object-fit: contain;\n                  }\n                "], ["\n                  img {\n                    display: flex;\n                    object-fit: contain;\n                  }\n                "]))) }, (_f = (_e = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.logoProps) === null || _e === void 0 ? void 0 : _e.logoProps) === null || _f === void 0 ? void 0 : _f.imageProps)), jsx(Text$2, __assign({ customCSS: css$1(templateObject_5$9 || (templateObject_5$9 = __makeTemplateObject(["\n                  width: 0px;\n                  height: 0px;\n                  opacity: 0;\n                  display: none;\n                "], ["\n                  width: 0px;\n                  height: 0px;\n                  opacity: 0;\n                  display: none;\n                "]))) }, { children: "LOGO" }))] }))), links && (jsx(Wrapper$2, __assign({ flexDirection: "row", alignItems: "center", justifyContent: "flex-start", maxWidth: "200px", margin: "30px 0px", customCSS: css$1(templateObject_6$5 || (templateObject_6$5 = __makeTemplateObject(["\n                @media (max-width: 1200px) {\n                  justify-content: center;\n                }\n                @media (max-width: 480px) {\n                  justify-content: flex-start;\n                }\n              "], ["\n                @media (max-width: 1200px) {\n                  justify-content: center;\n                }\n                @media (max-width: 480px) {\n                  justify-content: flex-start;\n                }\n              "]))) }, (_h = (_g = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.logoProps) === null || _g === void 0 ? void 0 : _g.linksProps) === null || _h === void 0 ? void 0 : _h.wrapperProps, { children: links === null || links === void 0 ? void 0 : links.map(function (socialLink) {
                                var _a, _b, _c, _d, _e, _f;
                                return (jsxs(Link$1, __assign({ href: socialLink === null || socialLink === void 0 ? void 0 : socialLink.href, link: socialLink === null || socialLink === void 0 ? void 0 : socialLink.link, margin: "0px 10px", customCSS: css$1(templateObject_7$4 || (templateObject_7$4 = __makeTemplateObject(["\n                    cursor: pointer;\n                    @media (max-width: 480px) {\n                      margin: 0px 0px;\n                    }\n                  "], ["\n                    cursor: pointer;\n                    @media (max-width: 480px) {\n                      margin: 0px 0px;\n                    }\n                  "]))) }, (_b = (_a = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.logoProps) === null || _a === void 0 ? void 0 : _a.linksProps) === null || _b === void 0 ? void 0 : _b.linkProps, (_c = socialLink === null || socialLink === void 0 ? void 0 : socialLink.componentsProps) === null || _c === void 0 ? void 0 : _c.linkProps, { children: [jsx(Icon$1, __assign({ height: "25px", width: "25px", icon: socialLink.icon }, (_e = (_d = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.logoProps) === null || _d === void 0 ? void 0 : _d.linksProps) === null || _e === void 0 ? void 0 : _e.iconProps, (_f = socialLink === null || socialLink === void 0 ? void 0 : socialLink.componentsProps) === null || _f === void 0 ? void 0 : _f.iconProps)), jsx(Text$2, __assign({ customCSS: css$1(templateObject_8$2 || (templateObject_8$2 = __makeTemplateObject(["\n                      width: 0px;\n                      height: 0px;\n                      opacity: 0;\n                      display: none;\n                    "], ["\n                      width: 0px;\n                      height: 0px;\n                      opacity: 0;\n                      display: none;\n                    "]))) }, { children: socialLink.icon }))] }), socialLink.link));
                            }) })))] })), columns === null || columns === void 0 ? void 0 : columns.map(function (column) {
                    var _a, _b, _c, _d, _e, _f, _g;
                    return (jsxs(Wrapper$2, __assign({ maxWidth: "max-content", margin: "0px 0px 20px 0px" }, (_b = (_a = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.logoProps) === null || _a === void 0 ? void 0 : _a.columnProps) === null || _b === void 0 ? void 0 : _b.wrapperProps, (_c = column === null || column === void 0 ? void 0 : column.componentsProps) === null || _c === void 0 ? void 0 : _c.wrapperProps, { children: [jsx(Text$2, __assign({ fontSize: "large", margin: "0px 0px 5px 0px", color: "#6c6c6c", fontWeight: "bold" }, (_e = (_d = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.logoProps) === null || _d === void 0 ? void 0 : _d.columnProps) === null || _e === void 0 ? void 0 : _e.titleProps, (_f = column === null || column === void 0 ? void 0 : column.componentsProps) === null || _f === void 0 ? void 0 : _f.titleProps, { children: column === null || column === void 0 ? void 0 : column.title })), (_g = column === null || column === void 0 ? void 0 : column.links) === null || _g === void 0 ? void 0 : _g.map(function (link) {
                                var _a, _b, _c;
                                return (jsx(Link$1, __assign({ margin: "2px 0px", fontSize: "small", color: "#6c6c6c", fontWeight: 400, href: link.href, link: link.link }, (_b = (_a = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.logoProps) === null || _a === void 0 ? void 0 : _a.columnProps) === null || _b === void 0 ? void 0 : _b.linkProps, (_c = link === null || link === void 0 ? void 0 : link.componentsProps) === null || _c === void 0 ? void 0 : _c.linkProps, { children: link === null || link === void 0 ? void 0 : link.label }), link.label));
                            }), column === null || column === void 0 ? void 0 : column.component] }), column.title));
                })] })) })));
};
var templateObject_1$u, templateObject_2$l, templateObject_3$g, templateObject_4$c, templateObject_5$9, templateObject_6$5, templateObject_7$4, templateObject_8$2;

var Logout = function () { return ({
    type: 'LOGOUT',
}); };

var OrganismUserDefault = function (props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    var dispatch = useDispatch();
    var router = useRouter();
    var _0 = __read(useState(false), 2), logout = _0[0], setLogout = _0[1];
    var user = useSelector(function (state) { return state.user; });
    var _1 = __read(useState(false), 2), showUserMenu = _1[0], setShowUserMenu = _1[1];
    var options = props.options, componentProps = props.componentProps;
    var ref = useRef(null);
    useEffect(function () {
        var handleClickOutside = function (event) {
            if (ref.current && !ref.current.contains(event.target)) {
                setShowUserMenu(false);
            }
        };
        document.addEventListener("mousedown", handleClickOutside);
        return function () {
            document.removeEventListener("mousedow", handleClickOutside);
        };
    }, [ref]);
    return (jsxs(Fragment$1, { children: [jsx(Loader, { isLoading: logout, colorLoading: "#a01d7f", backgroundColor: "#00000010" }), (user === null || user === void 0 ? void 0 : user.id) ? (jsxs(Wrapper$2, __assign({ flexDirection: "row", maxWidth: "max-content", height: "max-content", alignItems: "center", justifyContent: "center" }, (_a = componentProps === null || componentProps === void 0 ? void 0 : componentProps.userProps) === null || _a === void 0 ? void 0 : _a.wrapperProps, { children: [jsx(Image$2, __assign({ alt: "userPhoto", customCSS: css$1(templateObject_1$t || (templateObject_1$t = __makeTemplateObject(["\n              overflow: hidden;\n              background-color: #fff;\n              border-radius: 50%;\n              border: 2px solid #a01d7f;\n            "], ["\n              overflow: hidden;\n              background-color: #fff;\n              border-radius: 50%;\n              border: 2px solid #a01d7f;\n            "]))), height: "35px", width: "35px", src: "".concat(user.profile.photo ||
                            'https://storage.googleapis.com/cdn-bucket-ixulabs-platform/MDCAO-0001/images/userDefault.avif') }, (_b = componentProps === null || componentProps === void 0 ? void 0 : componentProps.userProps) === null || _b === void 0 ? void 0 : _b.imageProps)), jsxs(Wrapper$2, __assign({ width: "max-content", padding: "0px 10px", position: "relative", height: "max-content" }, (_d = (_c = componentProps === null || componentProps === void 0 ? void 0 : componentProps.userProps) === null || _c === void 0 ? void 0 : _c.menuProps) === null || _d === void 0 ? void 0 : _d.wrapperProps, { children: [jsxs(AtomButton, __assign({ backgroundColor: "transparent", padding: "0px 15px", customCSS: css$1(templateObject_2$k || (templateObject_2$k = __makeTemplateObject(["\n                min-width: 130px;\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                flex-direction: row;\n              "], ["\n                min-width: 130px;\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                flex-direction: row;\n              "]))) }, (_g = (_f = (_e = componentProps === null || componentProps === void 0 ? void 0 : componentProps.userProps) === null || _e === void 0 ? void 0 : _e.menuProps) === null || _f === void 0 ? void 0 : _f.buttonProps) === null || _g === void 0 ? void 0 : _g.buttonProps, { onClick: function () { return setShowUserMenu(!showUserMenu); } }, { children: [jsx(Text$2, __assign({ color: "#7F7F7F", fontWeight: 600, cursor: "pointer" }, (_k = (_j = (_h = componentProps === null || componentProps === void 0 ? void 0 : componentProps.userProps) === null || _h === void 0 ? void 0 : _h.menuProps) === null || _j === void 0 ? void 0 : _j.buttonProps) === null || _k === void 0 ? void 0 : _k.textProps, { customCSS: css$1(templateObject_3$f || (templateObject_3$f = __makeTemplateObject(["\n                  max-width: 120px;\n                  overflow: hidden;\n                  max-height: 100%;\n                "], ["\n                  max-width: 120px;\n                  overflow: hidden;\n                  max-height: 100%;\n                "]))) }, { children: "".concat((_l = user.profile.firstName) !== null && _l !== void 0 ? _l : 'User', " ").concat((_m = user.profile.lastName) !== null && _m !== void 0 ? _m : 'Default') })), jsx(Icon$1, __assign({ height: "14px", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-commons/frontend-library/icons/arrow-down-3101.svg", color: "#1F1F1F" }, (_q = (_p = (_o = componentProps === null || componentProps === void 0 ? void 0 : componentProps.userProps) === null || _o === void 0 ? void 0 : _o.menuProps) === null || _p === void 0 ? void 0 : _p.buttonProps) === null || _q === void 0 ? void 0 : _q.iconProps))] })), showUserMenu && (jsxs(Wrapper$2, __assign({ refObject: ref, position: "absolute", shadow: true, alignItems: "center", backgroundColor: "white", borderRadius: "5px", width: "80%", padding: "6px", customCSS: css$1(templateObject_4$b || (templateObject_4$b = __makeTemplateObject(["\n                  bottom: -5px;\n                  transform: translate(5%, 100%);\n                "], ["\n                  bottom: -5px;\n                  transform: translate(5%, 100%);\n                "]))) }, (_t = (_s = (_r = componentProps === null || componentProps === void 0 ? void 0 : componentProps.userProps) === null || _r === void 0 ? void 0 : _r.menuProps) === null || _s === void 0 ? void 0 : _s.menuDropdownProps) === null || _t === void 0 ? void 0 : _t.wrapperProps, { children: [options === null || options === void 0 ? void 0 : options.map(function (option) {
                                        var _a, _b, _c;
                                        return (jsx(Link$1, __assign({ width: "100%", padding: "8px 10px", color: "#7F7F7F", fontSize: "10px", align: "center", customCSS: css$1(templateObject_5$8 || (templateObject_5$8 = __makeTemplateObject(["\n                      :hover {\n                        background-color: #dadada;\n                      }\n                      transition: background-color 0.3s ease;\n                    "], ["\n                      :hover {\n                        background-color: #dadada;\n                      }\n                      transition: background-color 0.3s ease;\n                    "]))) }, option, (_c = (_b = (_a = componentProps === null || componentProps === void 0 ? void 0 : componentProps.userProps) === null || _a === void 0 ? void 0 : _a.menuProps) === null || _b === void 0 ? void 0 : _b.menuDropdownProps) === null || _c === void 0 ? void 0 : _c.linkProps, { children: option.label }), option.id));
                                    }), jsx(AtomButton, __assign({ width: "100%", padding: "8px 10px", color: "#7F7F7F", borderRadius: "0px", backgroundColor: "transparent", fontSize: "10px", onClick: function () {
                                            setLogout(true);
                                            dispatch(Logout());
                                            router.reload();
                                        }, customCSS: css$1(templateObject_6$4 || (templateObject_6$4 = __makeTemplateObject(["\n                    :hover {\n                      background-color: #dadada;\n                    }\n                    transition: background-color 0.3s ease;\n                  "], ["\n                    :hover {\n                      background-color: #dadada;\n                    }\n                    transition: background-color 0.3s ease;\n                  "]))) }, (_w = (_v = (_u = componentProps === null || componentProps === void 0 ? void 0 : componentProps.userProps) === null || _u === void 0 ? void 0 : _u.menuProps) === null || _v === void 0 ? void 0 : _v.menuDropdownProps) === null || _w === void 0 ? void 0 : _w.buttonProps, { children: "Cerrar sesi\u00F3n" }))] })))] }))] }))) : (jsxs(Wrapper$2, __assign({ flexDirection: "row", maxWidth: "max-content", height: "100%", alignItems: "center", justifyContent: "center", customCSS: css$1(templateObject_7$3 || (templateObject_7$3 = __makeTemplateObject(["\n            @media only screen and (max-width: 1200px) {\n              display: none;\n            }\n          "], ["\n            @media only screen and (max-width: 1200px) {\n              display: none;\n            }\n          "]))) }, (_x = componentProps === null || componentProps === void 0 ? void 0 : componentProps.authProps) === null || _x === void 0 ? void 0 : _x.wrapperProps, { children: [jsx(Link$1, __assign({ padding: "0", link: "/login", color: "#1F1F1F", margin: "0px 20px 0px 0px", fontSize: "12px" }, (_y = componentProps === null || componentProps === void 0 ? void 0 : componentProps.authProps) === null || _y === void 0 ? void 0 : _y.loginProps, { children: "Iniciar Sesi\u00F3n" })), jsx(Link$1, __assign({ fontSize: "12px", link: "/register", fontWeight: 600, padding: "7px 15px", customCSS: css$1(templateObject_8$1 || (templateObject_8$1 = __makeTemplateObject(["\n              border-radius: 5px;\n              color: white;\n              background-color: #a01d7f;\n            "], ["\n              border-radius: 5px;\n              color: white;\n              background-color: #a01d7f;\n            "]))) }, (_z = componentProps === null || componentProps === void 0 ? void 0 : componentProps.authProps) === null || _z === void 0 ? void 0 : _z.registerProps, { children: "Registrarse" }))] })))] }));
};
var templateObject_1$t, templateObject_2$k, templateObject_3$f, templateObject_4$b, templateObject_5$8, templateObject_6$4, templateObject_7$3, templateObject_8$1;

var SidebarAnimation = {
    transition: {
        default: { duration: 0.3 },
    },
    initial: { x: 50, opacity: 0 },
    animate: { x: 0, opacity: 1 },
    exit: { x: 50, opacity: 0 },
};
var OrganismSidebar = function (props) {
    var componentsProps = props.componentsProps, links = props.links;
    var _a = __read(useState(false), 2), sidebar = _a[0], setSidebar = _a[1];
    return (jsxs(Wrapper$2, __assign({ width: "max-content", customCSS: css$1(templateObject_1$s || (templateObject_1$s = __makeTemplateObject(["\n        display: none;\n        @media only screen and (max-width: 1200px) {\n          display: flex;\n        }\n      "], ["\n        display: none;\n        @media only screen and (max-width: 1200px) {\n          display: flex;\n        }\n      "]))) }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperProps, { children: [jsxs(AtomButton, __assign({ backgroundColor: "transparent", onClick: function () { return setSidebar(!sidebar); }, customCSS: css$1(templateObject_2$j || (templateObject_2$j = __makeTemplateObject(["\n          align-items: center;\n          justify-content: center;\n          z-index: 10;\n\n          svg {\n            width: 30px;\n            height: 30px;\n          }\n        "], ["\n          align-items: center;\n          justify-content: center;\n          z-index: 10;\n\n          svg {\n            width: 30px;\n            height: 30px;\n          }\n        "]))) }, { children: [jsx(Icon$1, { color: "#2c2c2c", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-commons/frontend-library/icons/menu.svg" }), jsx(Text$2, __assign({ customCSS: css$1(templateObject_3$e || (templateObject_3$e = __makeTemplateObject(["\n            width: 0px;\n            height: 0px;\n            opacity: 0;\n            display: none;\n          "], ["\n            width: 0px;\n            height: 0px;\n            opacity: 0;\n            display: none;\n          "]))) }, { children: "MENU" }))] })), jsx(AnimatePresence, { children: sidebar && (jsxs(Wrapper$2, __assign({ position: "absolute", height: "100vh", justifyContent: "flex-start", alignItems: "center", backgroundColor: "white", width: "300px", shadow: true }, SidebarAnimation, { customCSS: css$1(templateObject_4$a || (templateObject_4$a = __makeTemplateObject(["\n              display: none;\n              @media only screen and (max-width: 1200px) {\n                display: flex;\n              }\n              top: 0;\n              right: 0;\n            "], ["\n              display: none;\n              @media only screen and (max-width: 1200px) {\n                display: flex;\n              }\n              top: 0;\n              right: 0;\n            "]))) }, { children: [jsx(Wrapper$2, { height: "80px", width: "100%", backgroundColor: "white" }), jsx(Wrapper$2, __assign({ height: "calc(100vh - 90px)", justifyContent: "flex-start", alignItems: "center", customCSS: css$1(templateObject_5$7 || (templateObject_5$7 = __makeTemplateObject(["\n                overflow-y: auto;\n              "], ["\n                overflow-y: auto;\n              "]))) }, { children: jsx(Wrapper$2, __assign({ height: "max-content", width: "100%", justifyContent: "flex-start", alignItems: "flex-start", backgroundColor: "white" }, { children: jsx(AtomDropdownSidebarDefault, __assign({}, links)) })) }))] }))) })] })));
};
var templateObject_1$s, templateObject_2$j, templateObject_3$e, templateObject_4$a, templateObject_5$7;

var DefaultHeader = function (props) {
    var _a, _b;
    var logo = props.logo, searchBar = props.searchBar, userAuth = props.userAuth, links = props.links;
    var _c = __read(useState(false), 2), sidebar = _c[0], setSidebar = _c[1];
    useEffect(function () {
        document.body.style.overflowY = sidebar ? 'hidden' : 'auto';
        document.body.style.height = sidebar ? '100vh' : 'max-content';
    }, [sidebar]);
    var handleresize = function () {
        if (window.innerWidth > 1200) {
            setSidebar(false);
        }
    };
    useEffect(function () {
        window.addEventListener('resize', handleresize, true);
        return function () {
            window.removeEventListener('resize', handleresize, true);
        };
    }, []);
    return (jsx(Fragment$1, { children: jsx(Container, __assign({ height: "90px", position: "fixed", as: "nav", shadow: true, padding: "0px 90px", customCSS: css$1(templateObject_1$r || (templateObject_1$r = __makeTemplateObject(["\n          top: 0;\n          z-index: 100;\n          @media only screen and (max-width: 980px) {\n            padding: 0px 30px;\n          }\n        "], ["\n          top: 0;\n          z-index: 100;\n          @media only screen and (max-width: 980px) {\n            padding: 0px 30px;\n          }\n        "]))) }, { children: jsxs(Wrapper$2, __assign({ height: "100%", flexDirection: "row", alignItems: "center", justifyContent: "space-between", maxWidth: "1440px", flexWrap: "wrap" }, { children: [logo && (jsxs(Link$1, __assign({ link: "/", customCSS: css$1(templateObject_2$i || (templateObject_2$i = __makeTemplateObject(["\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                width: max-content;\n                height: 100%;\n                svg {\n                  width: 150px;\n                  height: 50px;\n                }\n              "], ["\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                width: max-content;\n                height: 100%;\n                svg {\n                  width: 150px;\n                  height: 50px;\n                }\n              "]))) }, (_a = logo.componentsProps) === null || _a === void 0 ? void 0 : _a.linkProps, { children: [jsx(Image$2, __assign({ alt: "LOGO", src: "".concat(logo.src), height: "55px", width: "150px", customCSS: css$1(templateObject_3$d || (templateObject_3$d = __makeTemplateObject(["\n                  img {\n                    display: flex;\n                    object-fit: contain;\n                  }\n                "], ["\n                  img {\n                    display: flex;\n                    object-fit: contain;\n                  }\n                "]))) }, (_b = logo.componentsProps) === null || _b === void 0 ? void 0 : _b.imageProps)), jsx(Text$2, __assign({ customCSS: css$1(templateObject_4$9 || (templateObject_4$9 = __makeTemplateObject(["\n                  width: 0px;\n                  height: 0px;\n                  opacity: 0;\n                "], ["\n                  width: 0px;\n                  height: 0px;\n                  opacity: 0;\n                "]))) }, { children: "LOGO" }))] }))), links && jsx(AtomDropdownSidebarLinks, __assign({}, links, { links: links.links })), searchBar && (jsx(Fragment$1, { children: searchBar.component ? (searchBar.component) : (jsx(MoleculeSearchBar, __assign({}, searchBar.searchBarProps))) })), userAuth && (jsx(Fragment$1, { children: userAuth.component ? (userAuth.component) : (jsx(OrganismUserDefault, __assign({ componentProps: {
                                userProps: {
                                    wrapperProps: {
                                        customCSS: css$1(templateObject_5$6 || (templateObject_5$6 = __makeTemplateObject(["\n                          @media only screen and (max-width: 1200px) {\n                            display: none;\n                          }\n                        "], ["\n                          @media only screen and (max-width: 1200px) {\n                            display: none;\n                          }\n                        "]))),
                                    },
                                },
                            } }, userAuth.props))) })), jsx(OrganismSidebar, { links: links })] })) })) }));
};
var templateObject_1$r, templateObject_2$i, templateObject_3$d, templateObject_4$9, templateObject_5$6;

var AdminHeader = function (props) {
    var _a, _b;
    var logo = props.logo, componentsProps = props.componentsProps, organismUser = props.organismUser;
    var sideBar = useSelector(function (state) { return state.sideBar; });
    return (jsx(Container, __assign({ as: "nav", position: "fixed", height: "60px", backgroundColor: "#373737", customCSS: css$1(templateObject_1$q || (templateObject_1$q = __makeTemplateObject(["\n        top: 0;\n        width: ", ";\n        margin-left: ", ";\n      "], ["\n        top: 0;\n        width: ", ";\n        margin-left: ", ";\n      "])), sideBar ? 'calc(100% - 320px)' : 'calc(100% - 80px)', sideBar ? '320px' : '80px') }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.containerProps, { children: jsxs(Wrapper$2, __assign({ flexDirection: "row", maxWidth: "1440px", padding: "0px 80px", height: "100%", alignItems: "center", justifyContent: "flex-end" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperProps, { children: [logo && (jsxs(Link$1, __assign({ link: "/", customCSS: css$1(templateObject_2$h || (templateObject_2$h = __makeTemplateObject(["\n              display: flex;\n              align-items: center;\n              justify-content: center;\n              width: max-content;\n              height: 100%;\n              svg {\n                width: 150px;\n                height: 50px;\n              }\n            "], ["\n              display: flex;\n              align-items: center;\n              justify-content: center;\n              width: max-content;\n              height: 100%;\n              svg {\n                width: 150px;\n                height: 50px;\n              }\n            "]))) }, (_a = logo.componentsProps) === null || _a === void 0 ? void 0 : _a.linkProps, { children: [jsx(Image$2, __assign({ alt: "LOGO", src: logo.src, height: "55px", width: "150px", customCSS: css$1(templateObject_3$c || (templateObject_3$c = __makeTemplateObject(["\n                img {\n                  display: flex;\n                  object-fit: contain;\n                }\n              "], ["\n                img {\n                  display: flex;\n                  object-fit: contain;\n                }\n              "]))) }, (_b = logo.componentsProps) === null || _b === void 0 ? void 0 : _b.imageProps)), jsx(Text$2, __assign({ customCSS: css$1(templateObject_4$8 || (templateObject_4$8 = __makeTemplateObject(["\n                width: 0px;\n                height: 0px;\n                opacity: 0;\n              "], ["\n                width: 0px;\n                height: 0px;\n                opacity: 0;\n              "]))) }, { children: "LOGO" }))] }))), organismUser && (jsx(OrganismUserDefault, __assign({ componentProps: {
                        userProps: {
                            menuProps: {
                                buttonProps: {
                                    textProps: {
                                        color: '#fff',
                                    },
                                    iconProps: {
                                        color: '#fff',
                                    },
                                },
                                menuDropdownProps: {
                                    wrapperProps: {
                                        backgroundColor: '#373737',
                                    },
                                    buttonProps: {
                                        customCSS: css$1(templateObject_5$5 || (templateObject_5$5 = __makeTemplateObject(["\n                        background-color: #6a6a6a;\n                        color: white;\n                        :hover {\n                          background-color: #525252;\n                        }\n                        transition: background-color 0.3s ease;\n                      "], ["\n                        background-color: #6a6a6a;\n                        color: white;\n                        :hover {\n                          background-color: #525252;\n                        }\n                        transition: background-color 0.3s ease;\n                      "]))),
                                    },
                                    linkProps: {
                                        customCSS: css$1(templateObject_6$3 || (templateObject_6$3 = __makeTemplateObject(["\n                        background-color: #6a6a6a;\n                        color: white;\n                        :hover {\n                          background-color: #525252;\n                        }\n                        transition: background-color 0.3s ease;\n                      "], ["\n                        background-color: #6a6a6a;\n                        color: white;\n                        :hover {\n                          background-color: #525252;\n                        }\n                        transition: background-color 0.3s ease;\n                      "]))),
                                    },
                                },
                            },
                        },
                        authProps: {
                            loginProps: {
                                color: '#fff',
                            },
                            registerProps: {
                                customCSS: css$1(templateObject_7$2 || (templateObject_7$2 = __makeTemplateObject(["\n                    color: #fff;\n                    border-radius: 8px;\n                    border: 2px solid #fff;\n                    background-color: transparent;\n                  "], ["\n                    color: #fff;\n                    border-radius: 8px;\n                    border: 2px solid #fff;\n                    background-color: transparent;\n                  "]))),
                            },
                        },
                    } }, organismUser)))] })) })));
};
var templateObject_1$q, templateObject_2$h, templateObject_3$c, templateObject_4$8, templateObject_5$5, templateObject_6$3, templateObject_7$2;

var ToggleSidebar = function () { return ({
    type: 'TOGGLESIDEBAR',
}); };
var CloseSidebar = function () { return ({
    type: 'CLOSESIDEBAR',
}); };

var OrganismAdminSidebar = function (props) {
    var _a, _b, _c;
    var logo = props.logo, links = props.links, customIcon = props.customIcon, customLink = props.customLink, componentsProps = props.componentsProps, title = props.title, children = props.children, disableSidebar = props.disableSidebar;
    var sideBar = useSelector(function (state) { return state.sideBar; });
    var dispatch = useDispatch();
    var _d = __read(useState(true), 2), showButtonClose = _d[0], setShowButtonClose = _d[1];
    useEffect(function () {
        var updateSize = function () {
            var width = window.innerWidth;
            if (width < 920 && !disableSidebar) {
                dispatch(CloseSidebar());
                setShowButtonClose(false);
            }
            else {
                setShowButtonClose(true);
            }
        };
        window.addEventListener("resize", updateSize, true);
        updateSize();
        return function () { return window.removeEventListener("resize", updateSize, true); };
    });
    return (jsx(Wrapper$2, __assign({ width: sideBar ? "320px" : "80px", height: "100vh", position: "fixed", zIndex: "10", customCSS: css$1(templateObject_1$p || (templateObject_1$p = __makeTemplateObject(["\n        left: 0;\n        top: 0;\n      "], ["\n        left: 0;\n        top: 0;\n      "]))) }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.containerProps, { children: jsxs(Wrapper$2, __assign({ backgroundColor: "#4d4d4d", width: "100%", height: "100%", justifyContent: "flex-start", alignItems: "center", position: "relative" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperProps, { children: [logo && (jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_2$g || (templateObject_2$g = __makeTemplateObject(["\n              width: 100%;\n              height: 170px;\n              align-items: center;\n              justify-content: center;\n            "], ["\n              width: 100%;\n              height: 170px;\n              align-items: center;\n              justify-content: center;\n            "]))) }, { children: sideBar ? (jsx(Fragment$1, { children: (logo === null || logo === void 0 ? void 0 : logo.logo) && (jsx(Image$2, { width: "60%", height: "80px", customCSS: css$1(templateObject_3$b || (templateObject_3$b = __makeTemplateObject(["\n                      img {\n                        object-fit: contain;\n                      }\n                    "], ["\n                      img {\n                        object-fit: contain;\n                      }\n                    "]))), src: "".concat(logo === null || logo === void 0 ? void 0 : logo.logo), alt: "SIDEBARLOGO" })) })) : (jsx(Fragment$1, { children: (logo === null || logo === void 0 ? void 0 : logo.logoMini) && (jsx(Image$2, { width: "60%", height: "80px", customCSS: css$1(templateObject_4$7 || (templateObject_4$7 = __makeTemplateObject(["\n                      img {\n                        object-fit: contain;\n                      }\n                    "], ["\n                      img {\n                        object-fit: contain;\n                      }\n                    "]))), src: "".concat(logo === null || logo === void 0 ? void 0 : logo.logoMini), alt: "SIDEBARLOGO" })) })) }))), jsxs(Wrapper$2, __assign({ height: "calc(100vh - 170px)", alignItems: "center", justifyContent: "flex-start", customCSS: css$1(templateObject_5$4 || (templateObject_5$4 = __makeTemplateObject(["\n            overflow-x: hidden;\n            overflow-y: scroll;\n          "], ["\n            overflow-x: hidden;\n            overflow-y: scroll;\n          "]))) }, (_a = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.sidebarProps) === null || _a === void 0 ? void 0 : _a.containerProps, { children: [title && jsx(Text$2, __assign({}, title === null || title === void 0 ? void 0 : title.textProps, { children: title === null || title === void 0 ? void 0 : title.title })), jsx(Wrapper$2, __assign({ height: "max-content", alignItems: "center", justifyContent: "flex-start" }, (_b = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.sidebarProps) === null || _b === void 0 ? void 0 : _b.wrapperProps, { children: jsx(RecursiveSidebarLinks, __assign({ links: links, customIcon: customIcon, customLink: customLink }, (_c = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.sidebarProps) === null || _c === void 0 ? void 0 : _c.sidebarProps)) })), children] })), showButtonClose && !disableSidebar && (jsx(AtomButton, __assign({ onClick: function () { return dispatch(ToggleSidebar()); }, customCSS: css$1(templateObject_6$2 || (templateObject_6$2 = __makeTemplateObject(["\n              position: absolute;\n              display: flex;\n              padding: 0px;\n              justify-content: center;\n              align-items: center;\n              background-color: ", ";\n              box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.3);\n              width: 35px;\n              height: 35px;\n              border-radius: 50%;\n              right: -15px;\n              top: 130px;\n            "], ["\n              position: absolute;\n              display: flex;\n              padding: 0px;\n              justify-content: center;\n              align-items: center;\n              background-color: ", ";\n              box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.3);\n              width: 35px;\n              height: 35px;\n              border-radius: 50%;\n              right: -15px;\n              top: 130px;\n            "])), sideBar ? "white" : "#f1576c") }, { children: jsx(Icon$1, { customCSS: css$1(templateObject_7$1 || (templateObject_7$1 = __makeTemplateObject(["\n                svg {\n                  width: 14px;\n                  height: 14px;\n                  margin: ", ";\n                  transform: ", ";\n                  path {\n                    fill: ", " !important;\n                    stroke: ", "!important;\n                  }\n                }\n              "], ["\n                svg {\n                  width: 14px;\n                  height: 14px;\n                  margin: ", ";\n                  transform: ", ";\n                  path {\n                    fill: ", " !important;\n                    stroke: ", "!important;\n                  }\n                }\n              "])), sideBar ? "0px 2px 0px 0px" : "0px 0px 0px 2px", sideBar ? "rotate(180deg)" : "rotate(0deg)", sideBar ? "#4d4d4d" : "white", sideBar ? "#4d4d4d" : "white"), icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-commons/frontend-library/icons/arrowleft.svg" }) })))] })) })));
};
var RecursiveSidebarLinks = function (props) {
    var links = props.links, _a = props.level, level = _a === void 0 ? 0 : _a, customIcon = props.customIcon, customLink = props.customLink;
    var sideBar = useSelector(function (state) { return state.sideBar; });
    var _b = __read(useState(links === null || links === void 0 ? void 0 : links.map(function (item) { return ({
        id: item.id,
        isOpen: false,
    }); })), 2), showSubLinks = _b[0], setShowSubLinks = _b[1];
    return (jsx(Fragment$1, { children: links === null || links === void 0 ? void 0 : links.map(function (subField, subFieldIndex) {
            var _a, _b;
            return (jsxs(Fragment$2, { children: [subField.type === 'dropdown' ? (jsxs(AtomButton, __assign({ onClick: function () {
                            return setShowSubLinks(showSubLinks === null || showSubLinks === void 0 ? void 0 : showSubLinks.map(function (item, index) {
                                return index === subFieldIndex
                                    ? __assign(__assign({}, item), { isOpen: !item.isOpen }) : item;
                            }));
                        }, customCSS: css$1(templateObject_8 || (templateObject_8 = __makeTemplateObject(["\n                display: flex;\n                width: 100%;\n                align-items: center;\n                margin-left: ", ";\n                justify-content: ", ";\n                flex-direction: row;\n                padding: ", ";\n                margin-bottom: 10px;\n                cursor: pointer;\n                background-color: transparent;\n                :hover {\n                  background-color: #6a7179;\n                }\n              "], ["\n                display: flex;\n                width: 100%;\n                align-items: center;\n                margin-left: ", ";\n                justify-content: ", ";\n                flex-direction: row;\n                padding: ", ";\n                margin-bottom: 10px;\n                cursor: pointer;\n                background-color: transparent;\n                :hover {\n                  background-color: #6a7179;\n                }\n              "])), sideBar ? "".concat(level * 10, "px") : "".concat(level * 5, "px"), sideBar ? "flex-start" : "center", sideBar ? "10px 30px" : "10px 0px") }, { children: [subField.icon ? (jsx(Image$2, { alt: "IconTag".concat(subField.icon), height: "20px", width: "20px", margin: sideBar ? "0px 0px 2px 0px" : "0px", src: subField.icon })) : (jsx(Fragment$1, { children: customIcon ? (customIcon(subField)) : (jsx(Text$2, __assign({ color: "white", fontSize: "16px" }, { children: "".concat(subField.label).slice(0, 2).toUpperCase() }))) })), sideBar && (jsx(Text$2, __assign({ maxWidth: "max-content", margin: "0px 0px 0px 25px", color: "white", fontWeight: 700, fontSize: "14px", customCSS: css$1(templateObject_9 || (templateObject_9 = __makeTemplateObject(["\n                    display: flex;\n                    @media (max-width: 920px) {\n                      display: none;\n                    }\n                  "], ["\n                    display: flex;\n                    @media (max-width: 920px) {\n                      display: none;\n                    }\n                  "]))) }, { children: subField.label }))), jsx(Icon$1, { customCSS: css$1(templateObject_10 || (templateObject_10 = __makeTemplateObject(["\n                  margin-left: 15px;\n                  transform: ", ";\n                  svg {\n                    g {\n                      g {\n                        path {\n                          fill: white !important;\n                          stroke: white !important;\n                        }\n                      }\n                    }\n                  }\n                "], ["\n                  margin-left: 15px;\n                  transform: ", ";\n                  svg {\n                    g {\n                      g {\n                        path {\n                          fill: white !important;\n                          stroke: white !important;\n                        }\n                      }\n                    }\n                  }\n                "])), ((_a = showSubLinks === null || showSubLinks === void 0 ? void 0 : showSubLinks.find(function (_, index) { return index === subFieldIndex; })) === null || _a === void 0 ? void 0 : _a.isOpen)
                                    ? "rotate(180deg)"
                                    : "rotate(0deg)"), width: sideBar ? "14px" : "10px", height: sideBar ? "14px" : "10px", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-commons/frontend-library/icons/arrow-down-3101.svg" })] }))) : (jsx(Fragment$1, { children: customLink ? (customLink(subField)) : (jsxs(Link$1, __assign({ link: subField.link, customCSS: css$1(templateObject_11 || (templateObject_11 = __makeTemplateObject(["\n                    display: flex;\n                    width: 100%;\n                    align-items: center;\n                    margin-left: ", ";\n                    justify-content: ", ";\n                    flex-direction: row;\n                    padding: ", ";\n                    margin-bottom: 10px;\n                    cursor: pointer;\n                    :hover {\n                      background-color: #6a7179;\n                    }\n                  "], ["\n                    display: flex;\n                    width: 100%;\n                    align-items: center;\n                    margin-left: ", ";\n                    justify-content: ", ";\n                    flex-direction: row;\n                    padding: ", ";\n                    margin-bottom: 10px;\n                    cursor: pointer;\n                    :hover {\n                      background-color: #6a7179;\n                    }\n                  "])), sideBar ? "".concat(level * 10, "px") : "0px", sideBar ? "flex-start" : "center", sideBar ? "10px 30px" : "10px 0px") }, { children: [subField.icon ? (jsx(Image$2, { alt: "IconTag".concat(subField.icon), height: "20px", width: "20px", margin: sideBar ? "0px 0px 2px 0px" : "0px", src: subField.icon })) : (jsx(Fragment$1, { children: customIcon ? (customIcon(subField)) : (jsx(Text$2, __assign({ color: "white", fontSize: "16px" }, { children: "".concat(subField.label).slice(0, 2).toUpperCase() }))) })), sideBar && (jsx(Text$2, __assign({ maxWidth: "max-content", margin: "0px 0px 0px 25px", color: "white", fontWeight: 700, fontSize: "14px", customCSS: css$1(templateObject_12 || (templateObject_12 = __makeTemplateObject(["\n                        display: flex;\n                        @media (max-width: 920px) {\n                          display: none;\n                        }\n                      "], ["\n                        display: flex;\n                        @media (max-width: 920px) {\n                          display: none;\n                        }\n                      "]))) }, { children: subField.label })))] }))) })), ((_b = showSubLinks === null || showSubLinks === void 0 ? void 0 : showSubLinks.find(function (_, index) { return index === subFieldIndex; })) === null || _b === void 0 ? void 0 : _b.isOpen) && (jsx(RecursiveSidebarLinks, { links: subField.subFields, level: level + 1 }))] }, subField.id));
        }) }));
};
var templateObject_1$p, templateObject_2$g, templateObject_3$b, templateObject_4$7, templateObject_5$4, templateObject_6$2, templateObject_7$1, templateObject_8, templateObject_9, templateObject_10, templateObject_11, templateObject_12;

var settingsInit = {
    onCompleted: function () {
        return null;
    },
    onError: function () {
        return null;
    },
};
var useLazyFetch = function (url, setings, options) {
    if (setings === void 0) { setings = settingsInit; }
    var onCompleted = setings.onCompleted, onError = setings.onError;
    var _a = __read(useState(false), 2), refetchState = _a[0], setRefetchState = _a[1];
    var _b = __read(useState(false), 2), lazyRefetchState = _b[0], setLazyRefetchState = _b[1];
    var _c = __read(useState({
        data: false,
        error: { status: false, message: null },
        loading: false,
    }), 2), fetchState = _c[0], setFetchState = _c[1];
    var lazyFetch = function () { return setLazyRefetchState(true); };
    var refetch = function () { return setRefetchState(!refetchState); };
    useEffect(function () {
        if (fetchState.data && onCompleted && lazyRefetchState) {
            onCompleted();
        }
    }, [fetchState.data]);
    useEffect(function () {
        if (fetchState.error && onError && lazyRefetchState) {
            onError();
        }
    }, [fetchState.error]);
    useEffect(function () {
        var fetchData = function () { return __awaiter(void 0, void 0, void 0, function () {
            var response, data, isError, error_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        setFetchState({ error: null, data: null, loading: true });
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, fetch(url, __assign({}, options))];
                    case 2:
                        response = _b.sent();
                        return [4 /*yield*/, response.json()];
                    case 3:
                        data = _b.sent();
                        isError = !!((_a = data === null || data === void 0 ? void 0 : data.errors) === null || _a === void 0 ? void 0 : _a.find(function (error) { return error.status === 400; })) ||
                            (data === null || data === void 0 ? void 0 : data.status) === 400;
                        if (isError) {
                            setFetchState({ data: null, error: data, loading: false });
                        }
                        else {
                            setFetchState({ error: null, data: data, loading: false });
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        error_1 = _b.sent();
                        setFetchState({ data: null, error: error_1, loading: false });
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        }); };
        if (lazyRefetchState) {
            fetchData();
        }
    }, [lazyRefetchState, refetchState, url]);
    return [lazyFetch, __assign(__assign({}, fetchState), { isFetch: lazyRefetchState, refetch: refetch })];
};

var useDownloadFile = function (values) {
    var _a, _b, _c;
    var url = values.url, name = values.name;
    var a = (_a = window === null || window === void 0 ? void 0 : window.document) === null || _a === void 0 ? void 0 : _a.createElement("a");
    a.href = url || "";
    a.target = "_blank";
    a.download = name;
    (_b = document === null || document === void 0 ? void 0 : document.body) === null || _b === void 0 ? void 0 : _b.appendChild(a);
    a.click();
    (_c = document === null || document === void 0 ? void 0 : document.body) === null || _c === void 0 ? void 0 : _c.removeChild(a);
};

var SERVICES_BY_PROJECT = gql(templateObject_1$o || (templateObject_1$o = __makeTemplateObject(["\n  query ServicesByProject($servicesByProjectId: UUID!) {\n    servicesByProject(id: $servicesByProjectId) {\n      id\n      name\n      codeName\n      image\n      description\n      priority\n      updatedAt\n      createdAt\n      isActive\n      label\n      functions {\n        id\n        name\n        codeName\n        functionType\n        microservice {\n          id\n          description\n        }\n      }\n    }\n  }\n"], ["\n  query ServicesByProject($servicesByProjectId: UUID!) {\n    servicesByProject(id: $servicesByProjectId) {\n      id\n      name\n      codeName\n      image\n      description\n      priority\n      updatedAt\n      createdAt\n      isActive\n      label\n      functions {\n        id\n        name\n        codeName\n        functionType\n        microservice {\n          id\n          description\n        }\n      }\n    }\n  }\n"])));
var MEBYID = gql(templateObject_2$f || (templateObject_2$f = __makeTemplateObject(["\n  query meById($id: UUID!) {\n    meById(id: $id) {\n      id\n      email\n      createdAt\n      updatedAt\n      email\n      recoverToken\n      recoverRegister\n      isActive\n      firstTime\n      loginCount\n      taxonomies {\n        memberId\n        taxonomyId\n      }\n      groups {\n        id\n        name\n        description\n        groupTaxonomies {\n          taxonomy {\n            id\n            name\n          }\n        }\n      }\n      memberRoles {\n        id\n        role {\n          id\n          name\n          codeName\n        }\n        roleId\n      }\n      memberProjects {\n        id\n        projectId\n        project {\n          name\n          description\n          logo\n          tagLine\n          url\n        }\n        memberProjectRoleProject {\n          projectRoleId\n          projectRole {\n            name\n            codeName\n            projectId\n            id\n            createdAt\n            updatedAt\n          }\n          id\n          createdAt\n          updatedAt\n        }\n      }\n      memberCompanies {\n        companyId\n        company {\n          id\n          name\n        }\n      }\n      profile {\n        id\n        firstName\n        lastName\n        phone\n        photo\n        countryId\n        country {\n          name\n          code\n        }\n      }\n    }\n  }\n"], ["\n  query meById($id: UUID!) {\n    meById(id: $id) {\n      id\n      email\n      createdAt\n      updatedAt\n      email\n      recoverToken\n      recoverRegister\n      isActive\n      firstTime\n      loginCount\n      taxonomies {\n        memberId\n        taxonomyId\n      }\n      groups {\n        id\n        name\n        description\n        groupTaxonomies {\n          taxonomy {\n            id\n            name\n          }\n        }\n      }\n      memberRoles {\n        id\n        role {\n          id\n          name\n          codeName\n        }\n        roleId\n      }\n      memberProjects {\n        id\n        projectId\n        project {\n          name\n          description\n          logo\n          tagLine\n          url\n        }\n        memberProjectRoleProject {\n          projectRoleId\n          projectRole {\n            name\n            codeName\n            projectId\n            id\n            createdAt\n            updatedAt\n          }\n          id\n          createdAt\n          updatedAt\n        }\n      }\n      memberCompanies {\n        companyId\n        company {\n          id\n          name\n        }\n      }\n      profile {\n        id\n        firstName\n        lastName\n        phone\n        photo\n        countryId\n        country {\n          name\n          code\n        }\n      }\n    }\n  }\n"])));
var ROLSBYPROJECTS = gql(templateObject_3$a || (templateObject_3$a = __makeTemplateObject(["\n  query rolesByProject($id: UUID!) {\n    rolesByProject(id: $id) {\n      id\n      name\n      codeName\n      permission {\n        rules\n      }\n    }\n  }\n"], ["\n  query rolesByProject($id: UUID!) {\n    rolesByProject(id: $id) {\n      id\n      name\n      codeName\n      permission {\n        rules\n      }\n    }\n  }\n"])));
var DEFAULT_PERMISSION = 'DISABLED';
var AccessRol = {
    __owner__: 'WRITE',
    __project_manager__: 'WRITE',
    __project_user__: 'READER',
    default: DEFAULT_PERMISSION,
};
var usePermissions = function (props, deps) {
    if (props === void 0) { props = {}; }
    var userId = props.userId, projectId = props.projectId, service = props.service, role = props.role;
    var dataUser = useQuery(MEBYID, {
        variables: {
            id: userId,
        },
        skip: !userId,
    }).data;
    var dataServices = useQuery(SERVICES_BY_PROJECT, {
        variables: {
            servicesByProjectId: projectId,
        },
    }).data;
    var dataRoles = useQuery(ROLSBYPROJECTS, {
        variables: {
            id: projectId,
        },
    }).data;
    var permission = useMemo(function () {
        var _a, _b, _c, _d, _e, _f;
        var user = dataUser === null || dataUser === void 0 ? void 0 : dataUser.meById;
        var roles = dataRoles === null || dataRoles === void 0 ? void 0 : dataRoles.rolesByProject;
        var FindRole = (_c = role !== null && role !== void 0 ? role : (_b = (_a = user === null || user === void 0 ? void 0 : user.memberProjects) === null || _a === void 0 ? void 0 : _a.find(function (e) { return e.projectId === projectId; })) === null || _b === void 0 ? void 0 : _b.memberProjectRoleProject.projectRole.codeName) !== null && _c !== void 0 ? _c : (_e = (_d = user === null || user === void 0 ? void 0 : user.memberRoles) === null || _d === void 0 ? void 0 : _d.find(function (_, idx) { return idx === 0; })) === null || _e === void 0 ? void 0 : _e.role.codeName;
        var FindRoleProject = roles === null || roles === void 0 ? void 0 : roles.find(function (e) { return e.codeName === FindRole; });
        var Rule = (_f = FindRoleProject === null || FindRoleProject === void 0 ? void 0 : FindRoleProject.permission) === null || _f === void 0 ? void 0 : _f.rules;
        var GetRule = function (rule) {
            var _a, _b;
            var ConvertJSON = JSON.parse(rule);
            var FindRule = ConvertJSON.find(function (e) { return e.codeName === service; });
            var RuleAccess = ((_a = FindRule === null || FindRule === void 0 ? void 0 : FindRule.access) !== null && _a !== void 0 ? _a : DEFAULT_PERMISSION);
            return {
                access: RuleAccess,
                permissions: (_b = FindRule === null || FindRule === void 0 ? void 0 : FindRule.permision) !== null && _b !== void 0 ? _b : [],
            };
        };
        var GetRoleByUser = function () {
            var _a;
            return ({
                access: ((_a = AccessRol[FindRole]) !== null && _a !== void 0 ? _a : DEFAULT_PERMISSION),
                permissions: [],
            });
        };
        return Rule ? GetRule(Rule) : GetRoleByUser();
    }, __spreadArray([dataServices, dataRoles, dataUser, role], __read((deps !== null && deps !== void 0 ? deps : [])), false));
    return permission;
};
var havePermission = function (permission, funcinalityConame) {
    if (permission.access === 'DISABLED') {
        return false;
    }
    var isExist = permission.permissions.some(function (e) { return e.codeName === funcinalityConame; });
    return !!isExist;
};
var templateObject_1$o, templateObject_2$f, templateObject_3$a;

var FixRoutePrivate = function (router) {
    return router.asPath
        .replace("dashboard/services/".concat(router.query.service, "/").concat(router.query.id), '')
        .replace('//', '/');
};
var FixRoutePublic = function (route) {
    return route.asPath
        .replace("feed/".concat(route.query.service), '')
        .replace("dashboard/services/".concat(route.query.service, "/").concat(route.query.id), '')
        .replace('//', '/');
};
var GetRoutePrivate = function (router) {
    return "/dashboard/services/".concat(router.query.service, "/").concat(router.query.id);
};
var useRouterPrivate = function () {
    var router = useRouter();
    var route = GetRoutePrivate(router);
    return {
        next: router,
        asPath: router.asPath,
        asPathRelative: FixRoutePrivate(router),
        push: function (path) { return router.push("".concat(route).concat(path)); },
        FixRoutePrivate: FixRoutePrivate,
        FixRoutePublic: FixRoutePublic,
        GetRoutePrivate: GetRoutePrivate,
    };
};

var UPLOADMUTATION = gql(templateObject_1$n || (templateObject_1$n = __makeTemplateObject(["\n  mutation uploadFilePrivate($input: UploadFilePrivateInput!) {\n    uploadFilePrivate(input: $input) {\n      url\n      message\n      token\n      fileId\n      partialUrl\n    }\n  }\n"], ["\n  mutation uploadFilePrivate($input: UploadFilePrivateInput!) {\n    uploadFilePrivate(input: $input) {\n      url\n      message\n      token\n      fileId\n      partialUrl\n    }\n  }\n"])));
var uploadFile = function (url, file) {
    return fetch(url, {
        method: 'PUT',
        body: file,
        headers: {
            'Content-Type': 'application/octet-stream',
        },
        mode: 'cors',
    }).catch(function (e) { return console.error(e); });
};
var removeWhiteSpaces = function (name) { var _a, _b; return (_b = (_a = name === null || name === void 0 ? void 0 : name.replace(/\s+/g, '')) === null || _a === void 0 ? void 0 : _a.replace('(', '')) === null || _b === void 0 ? void 0 : _b.replace(')', ''); };
var useUploadFile = function (options) {
    var _a = __read(useMutation(UPLOADMUTATION), 2), EXECUTEFILE = _a[0], data = _a[1];
    return __assign({ uploadFile: function (values, optionsByFn) {
            var _a, _b, _c, _d;
            return EXECUTEFILE({
                variables: {
                    input: {
                        memberId: values.memberId,
                        projectId: values.projectId,
                        isProfile: values.isProfile,
                        name: removeWhiteSpaces((_a = values.fileInput) === null || _a === void 0 ? void 0 : _a.name),
                        fileName: removeWhiteSpaces((_b = values.fileInput) === null || _b === void 0 ? void 0 : _b.name),
                        description: (_c = values === null || values === void 0 ? void 0 : values.descriptionType) !== null && _c !== void 0 ? _c : JSON.stringify({
                            size: values.fileInput.size,
                            type: "".concat((_d = values.fileInput) === null || _d === void 0 ? void 0 : _d.type),
                        }),
                    },
                },
                onCompleted: function (response) { return __awaiter(void 0, void 0, void 0, function () {
                    var result;
                    var _a, _b, _c, _d, _e;
                    return __generator(this, function (_f) {
                        switch (_f.label) {
                            case 0:
                                result = __assign(__assign({}, response.uploadFilePrivate), { name: removeWhiteSpaces((_a = values.fileInput) === null || _a === void 0 ? void 0 : _a.name), fileName: removeWhiteSpaces((_b = values.fileInput) === null || _b === void 0 ? void 0 : _b.name), description: (_c = values === null || values === void 0 ? void 0 : values.descriptionType) !== null && _c !== void 0 ? _c : {
                                        size: "".concat(values.fileInput.size),
                                        type: "".concat((_d = values.fileInput) === null || _d === void 0 ? void 0 : _d.type),
                                    } });
                                return [4 /*yield*/, uploadFile((_e = response === null || response === void 0 ? void 0 : response.uploadFilePrivate) === null || _e === void 0 ? void 0 : _e.partialUrl, values === null || values === void 0 ? void 0 : values.fileInput)];
                            case 1:
                                _f.sent();
                                options === null || options === void 0 ? void 0 : options.onCompleted(result);
                                optionsByFn === null || optionsByFn === void 0 ? void 0 : optionsByFn.onCompleted(result);
                                return [2 /*return*/, response];
                        }
                    });
                }); },
                onError: function (error) {
                    options === null || options === void 0 ? void 0 : options.onError(error);
                    optionsByFn === null || optionsByFn === void 0 ? void 0 : optionsByFn.onError(error);
                },
            });
        } }, data);
};
var templateObject_1$n;

var _NormalizerStyled$1 = function (_a) {
    var scrollbarColor = _a.scrollbarColor, scrollbarWidth = _a.scrollbarWidth;
    return (jsx(Global, { styles: css$1(templateObject_1$m || (templateObject_1$m = __makeTemplateObject(["\n      *,\n      *::after,\n      *::before {\n        margin: 0;\n        padding: 0;\n        box-sizing: border-box;\n        /* width: 100%; */\n      }\n\n      *:focus {\n        outline: none;\n      }\n      :root {\n        font-size: 16px;\n      }\n      html {\n        width: 100%;\n        overflow-x: hidden;\n      }\n      body {\n        width: 100%;\n      }\n      #__next {\n        width: 100%;\n        overflow-x: hidden;\n      }\n      blockquote,\n      dl,\n      dd,\n      h1,\n      h2,\n      h3,\n      h4,\n      h5,\n      h6,\n      figure,\n      p,\n      pre {\n        margin: 0;\n      }\n\n      h1,\n      h2,\n      h3,\n      h4,\n      h5,\n      h6 {\n        font-size: inherit;\n        font-weight: inherit;\n      }\n\n      ol,\n      ul {\n        list-style: none;\n        margin: 0;\n        padding: 0;\n      }\n\n      textarea {\n        resize: none;\n        overflow: auto;\n      }\n\n      img {\n        border-style: none;\n      }\n\n      button,\n      input {\n        overflow: visible;\n      }\n\n      button,\n      input,\n      optgroup,\n      select,\n      textarea {\n        font-family: inherit;\n        font-size: 100%;\n        line-height: 1.15;\n        margin: 0;\n      }\n\n      [type='button'],\n      [type='reset'],\n      [type='submit'],\n      button {\n        -webkit-appearance: button;\n        -webkit-tap-highlight-color: transparent;\n      }\n      ::-webkit-scrollbar {\n        width: ", ";\n      }\n      ::-webkit-scrollbar-thumb {\n        background: ", ";\n      }\n    "], ["\n      *,\n      *::after,\n      *::before {\n        margin: 0;\n        padding: 0;\n        box-sizing: border-box;\n        /* width: 100%; */\n      }\n\n      *:focus {\n        outline: none;\n      }\n      :root {\n        font-size: 16px;\n      }\n      html {\n        width: 100%;\n        overflow-x: hidden;\n      }\n      body {\n        width: 100%;\n      }\n      #__next {\n        width: 100%;\n        overflow-x: hidden;\n      }\n      blockquote,\n      dl,\n      dd,\n      h1,\n      h2,\n      h3,\n      h4,\n      h5,\n      h6,\n      figure,\n      p,\n      pre {\n        margin: 0;\n      }\n\n      h1,\n      h2,\n      h3,\n      h4,\n      h5,\n      h6 {\n        font-size: inherit;\n        font-weight: inherit;\n      }\n\n      ol,\n      ul {\n        list-style: none;\n        margin: 0;\n        padding: 0;\n      }\n\n      textarea {\n        resize: none;\n        overflow: auto;\n      }\n\n      img {\n        border-style: none;\n      }\n\n      button,\n      input {\n        overflow: visible;\n      }\n\n      button,\n      input,\n      optgroup,\n      select,\n      textarea {\n        font-family: inherit;\n        font-size: 100%;\n        line-height: 1.15;\n        margin: 0;\n      }\n\n      [type='button'],\n      [type='reset'],\n      [type='submit'],\n      button {\n        -webkit-appearance: button;\n        -webkit-tap-highlight-color: transparent;\n      }\n      ::-webkit-scrollbar {\n        width: ", ";\n      }\n      ::-webkit-scrollbar-thumb {\n        background: ", ";\n      }\n    "])), scrollbarWidth !== null && scrollbarWidth !== void 0 ? scrollbarWidth : '7px', scrollbarColor || '#f0a58b') }));
};
var templateObject_1$m;

var _NormalizerStyled = function () { return (jsx(Global, { styles: css$1(templateObject_1$l || (templateObject_1$l = __makeTemplateObject(["\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 100;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUQjIg1_i6t8kCHKm45_QpRxC7mw9c.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 100;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUQjIg1_i6t8kCHKm45_QpRzS7mw9c.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 100;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUQjIg1_i6t8kCHKm45_QpRxi7mw9c.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 100;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUQjIg1_i6t8kCHKm45_QpRxy7mw9c.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 100;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUQjIg1_i6t8kCHKm45_QpRyS7m.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 200;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_aZA3gTD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 200;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_aZA3g3D_u50.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 200;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_aZA3gbD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 200;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_aZA3gfD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 200;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_aZA3gnD_g.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 300;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_cJD3gTD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 300;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_cJD3g3D_u50.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 300;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_cJD3gbD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 300;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_cJD3gfD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 300;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_cJD3gnD_g.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 400;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUSjIg1_i6t8kCHKm459WRhyzbi.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 400;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUSjIg1_i6t8kCHKm459W1hyzbi.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 400;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUSjIg1_i6t8kCHKm459WZhyzbi.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 400;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUSjIg1_i6t8kCHKm459Wdhyzbi.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 400;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUSjIg1_i6t8kCHKm459Wlhyw.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 500;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_ZpC3gTD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 500;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_ZpC3g3D_u50.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 500;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_ZpC3gbD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 500;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_ZpC3gfD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 500;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_ZpC3gnD_g.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 600;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_bZF3gTD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 600;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_bZF3g3D_u50.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 600;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_bZF3gbD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 600;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_bZF3gfD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 600;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_bZF3gnD_g.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 700;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_dJE3gTD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 700;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_dJE3g3D_u50.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 700;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_dJE3gbD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 700;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_dJE3gfD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 700;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_dJE3gnD_g.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 800;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_c5H3gTD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 800;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_c5H3g3D_u50.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 800;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_c5H3gbD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 800;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_c5H3gfD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 800;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_c5H3gnD_g.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 900;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_epG3gTD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 900;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_epG3g3D_u50.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 900;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_epG3gbD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 900;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_epG3gfD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 900;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_epG3gnD_g.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n\n      .PinturaRadioGroup .PinturaRadioGroupOptions {\n        display: flex;\n        flex-direction: column;\n      }\n      .PinturaRadioGroup\n        .PinturaRadioGroupOptionGroup\n        + .PinturaRadioGroupOptionGroup {\n        margin-top: 0.5em;\n      }\n      .PinturaRadioGroup[data-layout='row'] .PinturaRadioGroupOptions {\n        flex-direction: row;\n      }\n      .PinturaRadioGroup label {\n        -webkit-tap-highlight-color: transparent;\n      }\n      .PinturaDetailsPanel.PinturaSliderPanel {\n        border-radius: var(--border-radius-round);\n      }\n      .PinturaPercentageLabel {\n        font-variant-numeric: tabular-nums;\n        min-width: 3em;\n        text-align: center;\n      }\n      .PinturaSliderPanel .PinturaSlider {\n        width: 10em;\n        --knob-size: 0.75em;\n        --knob-margin-left: 0.3125em;\n        --knob-margin-right: 0.3125em;\n      }\n      .PinturaSliderPanel .PinturaSliderTrack {\n        background-color: #eee;\n      }\n      .PinturaSliderPanel .PinturaSliderKnob {\n        background-color: #111;\n        box-shadow: 0 0.125em 0.25em rgba(0, 0, 0, 0.35),\n          0 -0.125em 0.25em rgba(0, 0, 0, 0.1);\n      }\n      .pintura-editor,\n      pintura-editor {\n        --color-primary: #ffd843;\n        --color-primary-dark: #ffc343;\n        --color-primary-text: #000;\n        --color-secondary: #03a9f4;\n        --color-secondary-dark: #046bbf;\n        --color-focus: 4, 107, 191;\n        --color-focus-100: rgba(var(--color-focus), 1);\n        --color-focus-50: rgba(var(--color-focus), 0.5);\n        --color-focus-25: rgba(var(--color-focus), 0.25);\n        --color-error: 255, 87, 34;\n        --color-error-100: rgb(var(--color-error));\n        --color-error-75: rgba(var(--color-error), 0.75);\n        --color-error-50: rgba(var(--color-error), 0.5);\n        --color-error-25: rgba(var(--color-error), 0.25);\n        --color-foreground: 0, 0, 0;\n        --color-background: 255, 255, 255;\n        --color-preview-outline: var(--color-foreground);\n        --color-foreground-100: rgba(var(--color-foreground), 1);\n        --color-foreground-95: rgba(var(--color-foreground), 0.95);\n        --color-foreground-90: rgba(var(--color-foreground), 0.9);\n        --color-foreground-80: rgba(var(--color-foreground), 0.8);\n        --color-foreground-70: rgba(var(--color-foreground), 0.7);\n        --color-foreground-60: rgba(var(--color-foreground), 0.6);\n        --color-foreground-50: rgba(var(--color-foreground), 0.5);\n        --color-foreground-40: rgba(var(--color-foreground), 0.4);\n        --color-foreground-30: rgba(var(--color-foreground), 0.3);\n        --color-foreground-20: rgba(var(--color-foreground), 0.25);\n        --color-foreground-15: rgba(var(--color-foreground), 0.2);\n        --color-foreground-10: rgba(var(--color-foreground), 0.15);\n        --color-foreground-5: rgba(var(--color-foreground), 0.075);\n        --color-foreground-3: rgba(var(--color-foreground), 0.05);\n        --color-foreground-1: rgba(var(--color-foreground), 0.02);\n        --color-foreground-0: rgba(var(--color-foreground), 0);\n        --color-background-100: rgba(var(--color-background), 1);\n        --color-background-95: rgba(var(--color-background), 0.95);\n        --color-background-90: rgba(var(--color-background), 0.9);\n        --color-background-80: rgba(var(--color-background), 0.8);\n        --color-background-70: rgba(var(--color-background), 0.7);\n        --color-background-60: rgba(var(--color-background), 0.6);\n        --color-background-50: rgba(var(--color-background), 0.5);\n        --color-background-40: rgba(var(--color-background), 0.4);\n        --color-background-30: rgba(var(--color-background), 0.3);\n        --color-background-20: rgba(var(--color-background), 0.2);\n        --color-background-15: rgba(var(--color-background), 0.15);\n        --color-background-10: rgba(var(--color-background), 0.1);\n        --color-background-5: rgba(var(--color-background), 0.05);\n        --color-background-3: rgba(var(--color-background), 0.03);\n        --color-background-1: rgba(var(--color-background), 0.01);\n        --color-background-0: rgba(var(--color-background), 0);\n        --button-cursor: pointer;\n        --font-size: 16px;\n        --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n          Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji',\n          'Segoe UI Symbol';\n        --backdrop-filter-bright: brightness(110%) saturate(180%) blur(10px);\n        --backdrop-filter-dark: brightness(90%) saturate(180%) blur(10px);\n        --border-radius-round: 9999em;\n        --border-radius: 0.625em;\n        --filter-disabled: grayscale(95%) opacity(40%);\n        --editor-inset-top: 0px;\n        --editor-inset-bottom: 0px;\n        --safe-area-inset-top: 0px;\n        --safe-area-inset-bottom: 0px;\n      }\n      .pintura-editor,\n      .PinturaRootWrapper,\n      pintura-editor {\n        display: block;\n      }\n      .PinturaRootWrapper {\n        height: 100%;\n      }\n      .PinturaRoot {\n        --nav-group-margin: 0.5em;\n        --editor-calculated-inset-top: calc(\n          var(--safe-area-inset-top) + var(--editor-inset-top)\n        );\n        --editor-calculated-inset-bottom: calc(\n          var(--safe-area-inset-bottom) + var(--editor-inset-bottom)\n        );\n        box-sizing: border-box;\n        width: var(--editor-width, 100%);\n        height: var(--editor-height, 100%);\n        padding-top: var(--editor-calculated-inset-top);\n        padding-bottom: var(--editor-calculated-inset-bottom);\n        max-width: var(\n          --editor-max-width,\n          var(--editor-max-width-default, none)\n        );\n        max-height: var(\n          --editor-max-height,\n          var(--editor-max-height-default, none)\n        );\n        position: relative;\n        overflow: hidden;\n        contain: strict;\n        display: grid;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n        line-height: normal;\n        font-size: var(--font-size);\n        font-family: var(--font-family);\n        font-weight: 450;\n        touch-action: manipulation;\n        text-align: left;\n        text-transform: none;\n        text-rendering: optimizeLegibility;\n        direction: ltr;\n        color: var(--color-foreground-90);\n        background-color: var(--color-background-100);\n        outline-color: rgba(var(--color-preview-outline), 1);\n        transition: background-color 1ms, outline-color 1ms,\n          color 0.15s ease-in-out;\n      }\n      .PinturaRoot * {\n        box-sizing: content-box;\n      }\n      .PinturaRoot button,\n      .PinturaRoot fieldset,\n      .PinturaRoot input,\n      .PinturaRoot legend {\n        padding: 0;\n        margin: 0;\n        border: none;\n        background: transparent;\n        color: inherit;\n        font-size: inherit;\n        font-family: inherit;\n        line-height: inherit;\n        width: auto;\n        text-decoration: none;\n      }\n      .PinturaRoot button[disabled] {\n        pointer-events: none;\n      }\n      .PinturaRoot canvas {\n        display: block;\n      }\n      .PinturaRoot svg {\n        display: inline-block;\n        width: auto;\n        height: auto;\n      }\n      .PinturaRoot p {\n        margin: 0;\n      }\n      .PinturaRoot li,\n      .PinturaRoot ul {\n        list-style: none;\n        margin: 0;\n        padding: 0;\n      }\n      .PinturaRoot a {\n        color: inherit;\n        text-decoration: none;\n      }\n      .PinturaRoot .implicit {\n        border: 0;\n        clip: rect(0 0 0 0);\n        -webkit-clip-path: polygon(0 0, 0 0, 0 0);\n        clip-path: polygon(0 0, 0 0, 0 0);\n        height: 1px;\n        margin: -1px;\n        overflow: hidden;\n        padding: 0;\n        position: absolute;\n        width: 1px;\n        white-space: nowrap;\n      }\n      .PinturaRoot .PinturaStage {\n        display: flex;\n        align-self: stretch;\n        flex: 1;\n      }\n      .PinturaRoot .PinturaStage[tabindex='-1'] {\n        outline: none;\n      }\n      .PinturaRoot .PinturaRootPortal {\n        position: absolute;\n        left: 0;\n        top: 0;\n      }\n      .PinturaRoot > .PinturaCanvas {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        z-index: 0;\n        pointer-events: none;\n      }\n      .PinturaRoot > .PinturaCanvas:after {\n        content: '';\n        position: absolute;\n        left: 0;\n        top: 0;\n        bottom: 0;\n        right: 0;\n        pointer-events: none;\n        background-repeat: no-repeat;\n      }\n      .PinturaRoot > .PinturaStatus {\n        position: absolute;\n        z-index: 99999;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        display: flex;\n        justify-content: center;\n        align-items: flex-start;\n        background-color: var(--color-background-90);\n      }\n      .PinturaRoot > .PinturaStatus > p {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        display: inline-flex;\n        white-space: nowrap;\n        align-items: center;\n        transition: opacity 0.5s ease-out;\n      }\n      .PinturaRoot .PinturaStatusMessage {\n        position: absolute;\n        font-size: 0.875em;\n      }\n      .PinturaRoot .PinturaStatusAside {\n        position: absolute;\n        left: 0;\n      }\n      .PinturaRoot .PinturaStatusAside svg {\n        width: 1.25em;\n        height: 1.25em;\n      }\n      .PinturaRoot .PinturaStatusAside .PinturaProgressIndicator {\n        margin-left: 0.5em;\n      }\n      .PinturaRoot .PinturaStatusAside .PinturaButton {\n        outline: transparent;\n        margin-left: 0.75em;\n        font-size: 0.875em;\n        border-radius: var(--border-radius-round);\n        background-color: var(--color-foreground-5);\n        padding: 0.25em;\n        transition: background-color 0.1s ease-out, color 0.1s ease-out;\n        -webkit-backdrop-filter: var(--backdrop-filter-dark);\n        backdrop-filter: var(--backdrop-filter-dark);\n      }\n      .PinturaRoot\n        .PinturaStatusAside\n        .PinturaButton:not([disabled])[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaRoot .PinturaStatusAside .PinturaButton:not([disabled]):hover {\n        background-color: var(--color-foreground-10);\n      }\n      .PinturaRoot .PinturaStatusIcon svg {\n        font-size: 0.875em;\n        margin-top: 0.25em;\n        margin-left: 0.5em;\n      }\n      .PinturaRoot > .PinturaNav {\n        position: relative;\n        z-index: 3;\n      }\n      .PinturaRoot > .PinturaNav:empty() {\n        display: none !important;\n      }\n      .PinturaRoot > .PinturaNav .PinturaButton {\n        outline: transparent;\n        transition: background-color 0.1s ease-out, color 0.1s ease-out;\n      }\n      .PinturaRoot > .PinturaNav .PinturaButton svg {\n        width: 1em;\n        transition: opacity 0.1s ease-out;\n      }\n      .PinturaRoot > .PinturaNav .PinturaButton > span {\n        justify-content: center;\n      }\n      .PinturaRoot > .PinturaNav .PinturaButtonIconOnly .PinturaButtonInner,\n      .PinturaRoot > .PinturaNav .PinturaDropdownIconOnly .PinturaButtonInner {\n        width: 1.75em;\n      }\n      .PinturaRoot > .PinturaNav .PinturaButton .PinturaButtonInner {\n        height: 1.75em;\n      }\n      .PinturaRoot\n        > .PinturaNav\n        .PinturaButton:not(.PinturaButtonIconOnly):not(.PinturaDropdownIconOnly) {\n        padding-left: 0.75em;\n        padding-right: 0.75em;\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaRoot\n        > .PinturaNav\n        .PinturaButton:not(.PinturaButtonIconOnly):not(.PinturaDropdownIconOnly)\n        .PinturaButtonLabel {\n        font-size: 0.75em;\n        line-height: 2;\n      }\n      .PinturaRoot > .PinturaNav .PinturaButton:only-of-type {\n        border-radius: var(--border-radius-round);\n      }\n      .PinturaRoot > .PinturaNav .PinturaButton:only-of-type + * {\n        margin-left: 0.5em;\n      }\n      .PinturaRoot > .PinturaNav .PinturaButton[disabled] svg {\n        opacity: 0.25;\n      }\n      .PinturaRoot\n        > .PinturaNav\n        .PinturaButton:not(.PinturaButtonExport):not([disabled])[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaRoot\n        > .PinturaNav\n        .PinturaButton:not(.PinturaButtonExport):not([disabled]):hover {\n        background-color: var(--color-foreground-10);\n      }\n      .PinturaRoot .PinturaButtonExport {\n        color: var(--color-primary-text);\n        background-color: var(--color-primary);\n      }\n      .PinturaRoot .PinturaButtonExport:hover {\n        background-color: var(--color-primary-dark);\n      }\n      .PinturaRoot .PinturaButtonExport[data-focus-visible] {\n        color: var(--color-primary-text);\n        background-color: var(--color-primary);\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5),\n          0 0 0 3px var(--color-focus-50);\n        background-color: var(--color-primary-dark);\n      }\n      .PinturaRoot .PinturaButtonExport:not(.PinturaButtonIconOnly) {\n        flex: 1;\n        padding: 0 0.75em;\n      }\n      .PinturaRoot > .PinturaNavMain {\n        display: flex;\n        overflow: hidden;\n      }\n      .PinturaRoot > .PinturaNavMain [aria-selected='true'] button {\n        -webkit-backdrop-filter: var(--backdrop-filter-dark);\n        backdrop-filter: var(--backdrop-filter-dark);\n        background-color: var(--color-foreground-10);\n      }\n      .PinturaRoot > .PinturaNavMain button svg {\n        align-self: center;\n        width: 1.5em;\n      }\n      .PinturaRoot > .PinturaNavMain button span,\n      .PinturaRoot > .PinturaNavMain button svg {\n        pointer-events: none;\n      }\n      .PinturaRoot > .PinturaNavMain button svg + span {\n        margin-top: 0.75em;\n      }\n      .PinturaRoot > .PinturaNavMain button span {\n        font-size: 0.875em;\n      }\n      .PinturaRoot > .PinturaNavMain button {\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n        transition: background-color 0.1s ease-out, color 0.1s ease-out,\n          box-shadow 0.1s ease-out;\n      }\n      .PinturaRoot > .PinturaNavMain button:hover {\n        box-shadow: inset 0 0 0 1px var(--color-foreground-10);\n      }\n      .PinturaRoot > .PinturaNavMain button[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaRoot > .PinturaNavTools {\n        max-width: 100%;\n        box-sizing: border-box;\n        pointer-events: none;\n      }\n      .PinturaRoot > .PinturaNavTools:empty {\n        display: none;\n      }\n      .PinturaRoot > .PinturaNavTools,\n      .PinturaRoot > .PinturaNavTools .PinturaNavGroup,\n      .PinturaRoot > .PinturaNavTools .PinturaNavSet {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n      }\n      .PinturaRoot > .PinturaNavTools .PinturaButton,\n      .PinturaRoot > .PinturaNavTools .PinturaNavSet {\n        pointer-events: all;\n      }\n      .PinturaRoot > .PinturaNavTools .PinturaButton[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaRoot .PinturaNavGroup {\n        margin: 0 var(--nav-group-margin);\n      }\n      .PinturaRoot .PinturaNavGroup > * {\n        border-radius: var(--border-radius-round);\n      }\n      .PinturaRoot .PinturaNavGroup > * + * {\n        margin-left: 0.5em;\n      }\n      .PinturaRoot .PinturaNavGroup:first-of-type {\n        margin-right: auto;\n        margin-left: 0;\n      }\n      .PinturaRoot .PinturaNavGroup:last-of-type {\n        margin-left: auto;\n        margin-right: 0;\n      }\n      .PinturaRoot .PinturaNavSet {\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaRoot .PinturaNavSet > :not(:only-child) {\n        border: 1px solid var(--color-foreground-3);\n        border-top: 0;\n        border-bottom: 0;\n      }\n      .PinturaRoot .PinturaNavSet > :first-of-type:not(:only-child) {\n        border-left: 0;\n      }\n      .PinturaRoot .PinturaNavSet > :last-child:not(:only-child) {\n        border-right: 0;\n      }\n      .PinturaRoot .PinturaNavSet > * + * {\n        margin-left: -1px;\n      }\n      .PinturaRoot .PinturaNavSet > .PinturaButton:hover,\n      .PinturaRoot .PinturaNavSet > .PinturaButton[data-focus-visible] {\n        position: relative;\n        z-index: 1;\n      }\n      .PinturaRoot .PinturaNavSet > :only-child {\n        border-radius: var(--border-radius-round);\n      }\n      .PinturaRoot\n        .PinturaNavSet\n        > :first-of-type:not(:only-child)\n        .PinturaButtonInner {\n        padding: 0 0.125em 0 0.25em;\n      }\n      .PinturaRoot .PinturaNavSet > :first-of-type:not(:only-child) {\n        border-top-left-radius: var(--border-radius-round);\n        border-bottom-left-radius: var(--border-radius-round);\n      }\n      .PinturaRoot\n        .PinturaNavSet\n        > :last-child:not(:only-child)\n        .PinturaButtonInner {\n        padding: 0 0.25em 0 0.125em;\n      }\n      .PinturaRoot .PinturaNavSet > :last-child:not(:only-child) {\n        border-top-right-radius: var(--border-radius-round);\n        border-bottom-right-radius: var(--border-radius-round);\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaNavSet {\n        background-color: var(--color-background-50);\n        -webkit-backdrop-filter: var(--backdrop-filter-bright);\n        backdrop-filter: var(--backdrop-filter-bright);\n        box-shadow: inset 0 0 0 1px var(--color-background-15),\n          0 0.0625em 0.125em rgba(0, 0, 0, 0.25),\n          0 0.125em 0.35em rgba(0, 0, 0, 0.35);\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaNavSet\n        .PinturaButton:not(.PinturaButtonExport):not([disabled]):hover,\n      .PinturaRoot[data-env~='overlay'] .PinturaNavSet > * {\n        border-color: var(--color-background-15);\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaNavGroup > .PinturaButton {\n        box-shadow: 0 0.0625em 0.125em rgba(0, 0, 0, 0.25),\n          0 0.125em 0.35em rgba(0, 0, 0, 0.35);\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaNavGroup .PinturaButtonExport {\n        box-shadow: inset 0 0 0.125em rgba(0, 0, 0, 0.25),\n          0 0.0625em 0.125em rgba(0, 0, 0, 0.25),\n          0 0.125em 0.35em rgba(0, 0, 0, 0.35);\n      }\n      .PinturaRoot .PinturaNavGroupFloat {\n        position: absolute;\n        left: 0;\n        right: 0;\n        pointer-events: none;\n      }\n      .PinturaRoot .PinturaNavGroupFloat > * {\n        pointer-events: all;\n      }\n      .PinturaRoot .PinturaUtilFooter .PinturaScrollable > div {\n        padding-left: 1em;\n        padding-right: 1em;\n      }\n      .PinturaRoot > .PinturaMain {\n        max-width: 100vw;\n      }\n      .PinturaRoot:not([data-env~='has-toolbar']) .PinturaUtilHeader {\n        padding-top: 0;\n        padding-bottom: 1em;\n        margin-bottom: -1em;\n      }\n      .PinturaRoot[data-env~='landscape'] {\n        grid-template-rows: -webkit-min-content auto;\n        grid-template-rows: min-content auto;\n        grid-template-columns: auto;\n      }\n      .PinturaRoot[data-env~='landscape'] > .PinturaNavTools {\n        grid-row: 1;\n        grid-column: 1;\n        padding: 1em 1em 0;\n        z-index: 3;\n      }\n      .PinturaRoot[data-env~='landscape'] > .PinturaNavMain {\n        align-items: center;\n        justify-content: flex-end;\n        position: absolute;\n        left: 1em;\n        top: calc(1em + var(--editor-calculated-inset-top));\n        bottom: calc(1em + var(--editor-calculated-inset-bottom));\n      }\n      .PinturaRoot[data-env~='landscape'] > .PinturaNavMain .PinturaTabList {\n        flex-direction: column;\n      }\n      .PinturaRoot[data-env~='landscape'] > .PinturaNavMain .PinturaTabList li {\n        display: flex;\n      }\n      .PinturaRoot[data-env~='landscape']\n        > .PinturaNavMain\n        .PinturaTabList\n        li\n        + li {\n        margin: 0.5em 0 0;\n      }\n      .PinturaRoot[data-env~='landscape'] > .PinturaNavMain button {\n        flex: 1;\n        width: 4em;\n        height: 4em;\n        border-radius: var(--border-radius);\n        justify-content: center;\n      }\n      .PinturaRoot[data-env~='landscape'] > .PinturaNavMain button span {\n        font-size: 0.6875em;\n        margin-top: 0.5em;\n      }\n      .PinturaRoot[data-env~='landscape'] > .PinturaNavMain button svg {\n        width: 1em;\n        margin-top: 0.25em;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='has-toolbar']\n        > .PinturaNavMain {\n        top: calc(4em + var(--editor-calculated-inset-top));\n        bottom: calc(4em + var(--editor-calculated-inset-bottom));\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='has-limited-space']\n        > .PinturaNavMain {\n        align-items: flex-start;\n        bottom: calc(1em + var(--editor-calculated-inset-bottom));\n      }\n      .PinturaRoot[data-env~='landscape'] > .PinturaMain {\n        grid-row: 2;\n        grid-column: 1;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='has-navigation'] {\n        grid-template-columns: 6em auto;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='has-navigation']\n        .PinturaNavGroupFloat {\n        margin: 0 0 0 6em;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='has-navigation']\n        > .PinturaNavTools {\n        grid-column: 1 / span 2;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='has-navigation']\n        > .PinturaMain {\n        grid-column: 2;\n      }\n      .PinturaRoot[data-env~='portrait'] {\n        grid-template-rows: -webkit-min-content auto -webkit-min-content;\n        grid-template-rows: min-content auto min-content;\n        grid-template-columns: auto;\n      }\n      .PinturaRoot[data-env~='portrait'] > * {\n        grid-column: 1;\n      }\n      .PinturaRoot[data-env~='portrait'] > .PinturaNavTools {\n        grid-row: 1;\n        padding: 0.75em 0.75em 0;\n      }\n      .PinturaRoot[data-env~='portrait'] > .PinturaNavMain {\n        grid-row: 3;\n        margin-bottom: 0.75em;\n        justify-content: center;\n      }\n      .PinturaRoot[data-env~='portrait'] > .PinturaNavMain .PinturaTabList {\n        padding: 0 0.875em;\n      }\n      .PinturaRoot[data-env~='portrait'] > .PinturaNavMain li + li {\n        margin-left: 0.5em;\n      }\n      .PinturaRoot[data-env~='portrait']\n        > .PinturaNavMain[data-state~='overflows'] {\n        overflow: visible;\n      }\n      .PinturaRoot[data-env~='portrait'] > .PinturaNavMain button {\n        flex: 1;\n        width: 4em;\n        height: 4em;\n        border-radius: var(--border-radius);\n        justify-content: center;\n      }\n      .PinturaRoot[data-env~='portrait'] > .PinturaNavMain button span {\n        font-size: 0.6875em;\n        margin-top: 0.5em;\n      }\n      .PinturaRoot[data-env~='portrait'] > .PinturaNavMain button svg {\n        width: 1em;\n        margin-top: 0.25em;\n      }\n      .PinturaRoot[data-env~='portrait'] > .PinturaMain {\n        grid-row: 2;\n        grid-column: 1;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='is-compact']\n        > .PinturaNavMain\n        button {\n        flex: 1;\n        flex-direction: row;\n        width: auto;\n        height: auto;\n        border-radius: var(--border-radius);\n        justify-content: flex-start;\n        align-items: center;\n        padding: 0.625em 0;\n        width: 6em;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='is-compact']\n        > .PinturaNavMain\n        button\n        span {\n        font-size: 0.6875em;\n        margin: 0 0.625em 0 0;\n        line-height: 0;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='is-compact']\n        > .PinturaNavMain\n        button\n        svg {\n        margin: 0 0.5em 0 0.625em;\n        width: 1em;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='is-compact'][data-env~='has-navigation'] {\n        grid-template-columns: 8em auto;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='is-compact'][data-env~='has-navigation']\n        .PinturaNavGroupFloat {\n        margin: 0 0 0 8em;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='is-compact']\n        > .PinturaNavMain\n        button {\n        padding: 0;\n        font-size: 0.625em;\n        width: 4em;\n        height: 4em;\n        justify-content: center;\n        border-radius: 9999em;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='is-compact']\n        > .PinturaNavMain\n        button\n        span {\n        visibility: hidden;\n        font-size: 0;\n        margin: 0;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='is-compact']\n        > .PinturaNavMain\n        button\n        svg {\n        margin-top: 0;\n        width: 1.6em;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='is-compact']\n        > .PinturaNavMain\n        button\n        svg\n        [stroke-width] {\n        stroke-width: 0.15em;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='narrow'] {\n        --nav-group-margin: 0.25em;\n        grid-template-rows: -webkit-min-content auto -webkit-min-content;\n        grid-template-rows: min-content auto min-content;\n        grid-template-columns: auto;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='narrow'] > * {\n        grid-column: 1;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='narrow']\n        .PinturaUtilFooter\n        .PinturaControlList\n        .PinturaControlListOption\n        span,\n      .PinturaRoot[data-env~='portrait'][data-env~='narrow']\n        .PinturaUtilFooter\n        .PinturaControlList\n        [role='tab']\n        span {\n        font-size: 0.6875em;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='narrow']\n        .PinturaToolbar\n        .PinturaToolbarInner\n        > * {\n        margin: 0 0.25em;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='narrow'][data-env~='short']\n        .PinturaNavGroupFloat {\n        position: static;\n      }\n      .PinturaRoot[data-env~='overlay'] {\n        grid-template-rows: auto !important;\n        grid-template-columns: auto !important;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaNav {\n        z-index: 3;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaMain {\n        grid-row: 1;\n        grid-column: 1;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaUtilMain {\n        position: absolute;\n        left: 0;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        padding: 0;\n        z-index: -1;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaUtilFooter,\n      .PinturaRoot[data-env~='overlay'] .PinturaUtilHeader {\n        position: absolute;\n        left: 0;\n        right: 0;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaUtilHeader {\n        top: 0;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaUtilFooter {\n        bottom: 0;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaNavMain {\n        position: absolute;\n        right: 0;\n        top: 0;\n        bottom: 0;\n        background: none;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaNavTools {\n        position: absolute;\n        left: 0;\n        top: 0;\n        right: 0;\n      }\n      .PinturaRoot[data-env~='has-swipe-navigation'] .PinturaUtilMain {\n        padding-left: 2em;\n        padding-right: 2em;\n      }\n      .PinturaRoot[data-env*='is-disabled'],\n      .PinturaRoot[data-env*='is-disabled'] * {\n        pointer-events: none !important;\n      }\n      .PinturaRoot[data-env*='is-disabled'] {\n        --color-primary: #b4b4b4;\n        --color-primary-dark: #a0a0a0;\n        --color-primary-text: #000;\n        --color-secondary: #969696;\n        --color-secondary-dark: #646464;\n      }\n      .PinturaRoot[data-env*='is-disabled'] .PinturaCanvas,\n      .PinturaRoot[data-env*='is-disabled'] .PinturaColorPickerButton {\n        filter: grayscale(100%);\n      }\n      .PinturaRoot .PinturaEditorOverlay {\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        z-index: 3;\n        background: var(--color-background-50);\n        pointer-events: none;\n      }\n      .PinturaDropdownPanel {\n        overflow: hidden;\n        border-radius: inherit;\n      }\n      .PinturaDropdownPanel .PinturaDropdownOption {\n        transition: background-color 0.1s;\n        border-radius: inherit;\n      }\n      .PinturaDropdownPanel .PinturaDropdownOption label {\n        display: block;\n        margin: 0;\n        border-radius: inherit;\n        white-space: nowrap;\n      }\n      .PinturaDropdownPanel .PinturaDropdownOption svg {\n        margin-right: 0.25em;\n        margin-left: -0.5em;\n        min-width: 1.5em;\n      }\n      .PinturaDropdownPanel .PinturaDropdownOption [slot] {\n        display: flex;\n        align-items: center;\n        padding: 0.325em 0.75em;\n      }\n      .PinturaDropdownPanel .PinturaDropdownOptionLabel {\n        font-size: 0.75em;\n        line-height: 1.75;\n        padding: 0 0.325em;\n        margin-left: -0.325em;\n      }\n      .PinturaDropdownPanel .PinturaDropdownOptionGroup > span {\n        display: block;\n        padding: 0.75em 1em;\n        text-transform: uppercase;\n        font-size: 0.75em;\n        color: rgba(0, 0, 0, 0.75);\n      }\n      .PinturaDropdownPanel [data-disabled='true'] {\n        color: #999;\n      }\n      .PinturaDropdownPanel\n        [data-selected='false']:not([data-disabled='true']):hover {\n        background-color: rgba(0, 0, 0, 0.15);\n      }\n      .PinturaDropdownPanel [data-selected='true'] {\n        color: #fff;\n        background: #000;\n      }\n      .PinturaDropdownPanel\n        [data-focus-visible]\n        + label\n        .PinturaDropdownOptionLabel {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n        border-radius: 0.25em;\n      }\n      .PinturaDropdownOption label {\n        margin: 0;\n      }\n      .PinturaColorPickerPanel {\n        padding: 0.5em;\n        max-width: 14em;\n        overflow: visible;\n        touch-action: none;\n      }\n      .PinturaColorPickerPanel .PinturaColorPickerButton {\n        outline: transparent;\n      }\n      .PinturaColorPickerPanel .PinturaColorPickerButton[data-focus-visible] {\n        box-shadow: inset 0 0 0 1px var(--color-foreground-70);\n      }\n      .PinturaColorPickerPanel .PinturaColorPreview {\n        width: 1.25em;\n        height: 1.25em;\n        border-radius: 0.25em;\n      }\n      .PinturaColorPickerPanel .PinturaColorPreview span {\n        border-radius: 0.2em;\n        box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.25);\n      }\n      .PinturaColorPickerPanel .PinturaColorPresets legend {\n        color: #777;\n        margin: 0 0 0.25em 0.3125em;\n        font-size: 0.75em;\n      }\n      .PinturaColorPickerPanel\n        .PinturaColorPresetsGrid\n        .PinturaRadioGroupOptions {\n        display: flex;\n        flex-direction: row;\n        flex-wrap: wrap;\n      }\n      .PinturaColorPickerPanel .PinturaColorPresetsGrid .PinturaDropdownOption {\n        display: block;\n        padding: 0.25em;\n      }\n      .PinturaColorPickerPanel\n        .PinturaColorPresetsGrid\n        .PinturaDropdownOption\n        label,\n      .PinturaColorPickerPanel\n        .PinturaColorPresetsGrid\n        .PinturaDropdownOption\n        label\n        span {\n        display: block;\n        cursor: var(--button-cursor);\n      }\n      .PinturaColorPickerPanel\n        .PinturaColorPresetsGrid\n        input[data-focus-visible]\n        + label\n        .PinturaColorPreview:after {\n        position: absolute;\n        left: -0.3125em;\n        right: -0.3125em;\n        top: -0.3125em;\n        bottom: -0.3125em;\n        border-radius: inherit;\n        pointer-events: none;\n        content: '';\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaColorPickerPanel .PinturaSlider {\n        margin-left: -0.325em;\n        margin-right: -0.325em;\n      }\n      .PinturaColorPickerPanel .PinturaPicker {\n        width: 100%;\n        padding-bottom: 0.5em;\n      }\n      .PinturaColorPickerPanel .PinturaPicker .PinturaPickerKnob,\n      .PinturaColorPickerPanel .PinturaPicker .PinturaSliderKnob {\n        border-radius: 9999em;\n        box-shadow: inset 0 0.06125em 0.06125em rgba(0, 0, 0, 0.1),\n          0 0 0 0.125em #fff, 0 0.1875em 0.25em rgba(0, 0, 0, 0.35),\n          0 -0.125em 0.25em rgba(0, 0, 0, 0.1);\n      }\n      .PinturaColorPickerPanel .PinturaPicker .PinturaPickerKnob {\n        pointer-events: none;\n        position: absolute;\n        z-index: 1;\n        left: 0;\n        top: 0;\n        margin-left: -0.625em;\n        margin-top: -0.625em;\n        width: 1.25em;\n        height: 1.25em;\n        visibility: visible;\n        outline: none;\n      }\n      .PinturaColorPickerPanel\n        .PinturaPicker\n        .PinturaPickerKnob[data-focus-visible]:after {\n        position: absolute;\n        left: -0.3125em;\n        right: -0.3125em;\n        top: -0.3125em;\n        bottom: -0.3125em;\n        border-radius: inherit;\n        pointer-events: none;\n        content: '';\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaColorPickerPanel .PinturaPicker .PinturaPickerKnobController {\n        position: absolute;\n        left: 0;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        visibility: hidden;\n      }\n      .PinturaColorPickerPanel .PinturaPicker .PinturaSaturationPicker {\n        position: relative;\n        border-radius: var(--border-radius) var(--border-radius) 0 0;\n        margin: -0.5em -0.5em 0.5em;\n        height: 7em;\n        background-image: linear-gradient(180deg, transparent, #000),\n          linear-gradient(90deg, #fff, transparent);\n      }\n      .PinturaColorPickerPanel\n        .PinturaPicker\n        .PinturaHuePicker\n        .PinturaSliderTrack {\n        background-image: linear-gradient(\n          90deg,\n          red,\n          #ff0,\n          #0f0,\n          #0ff,\n          #00f,\n          #f0f,\n          red\n        );\n      }\n      .PinturaColorPickerPanel\n        .PinturaPicker\n        .PinturaOpacityPicker\n        .PinturaSliderTrack:before {\n        position: absolute;\n        content: '';\n        display: block;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        z-index: -1;\n        border-radius: inherit;\n        background-color: #fff;\n        background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='8' height='8' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h4v4H0zm4 4h4v4H4z' fill='%23E5E5E5'/%3E%3C/svg%3E\");\n      }\n      .PinturaColorPickerPanel .PinturaPicker .PinturaOpacityPicker {\n        margin-top: 0.5em;\n      }\n      .PinturaPanel[data-util='filter'] .PinturaScrollable {\n        width: 100%;\n        max-width: 40em;\n        min-height: 5.5em;\n      }\n      .PinturaPanel[data-util='filter']\n        [data-layout='row']\n        > .PinturaRadioGroupOptions\n        > li {\n        margin: 0 0.5em;\n      }\n      .PinturaPanel[data-util='filter']\n        [data-layout='row']\n        > .PinturaRadioGroupOptions\n        > li:first-of-type {\n        margin-left: 0;\n      }\n      .PinturaPanel[data-util='filter']\n        [data-layout='row']\n        > .PinturaRadioGroupOptions\n        > li:last-child {\n        margin-right: 0;\n      }\n      .PinturaPanel[data-util='filter'] .PinturaRadioGroupOptionGroupLabel {\n        width: 1px;\n        height: 1px;\n        position: absolute;\n        font-size: 0;\n        pointer-events: none;\n      }\n      .PinturaPanel[data-util='filter'] .PinturaFilterPreview {\n        border-radius: 0;\n        transition: border-radius 1ms;\n      }\n      .PinturaPanel[data-util='filter'] .PinturaFilterOption {\n        border-radius: 0;\n      }\n      .PinturaPanel[data-util='filter']\n        .PinturaRadioGroupOptions\n        .PinturaRadioGroupOption:first-of-type\n        .PinturaFilterPreview {\n        border-top-left-radius: var(--border-radius);\n        border-bottom-left-radius: var(--border-radius);\n      }\n      .PinturaPanel[data-util='filter']\n        .PinturaRadioGroupOptions\n        .PinturaRadioGroupOption:first-of-type\n        .PinturaFilterOption {\n        border-bottom-left-radius: var(--border-radius);\n      }\n      .PinturaPanel[data-util='filter']\n        .PinturaRadioGroupOptions\n        .PinturaRadioGroupOption:last-of-type\n        .PinturaFilterPreview {\n        border-top-right-radius: var(--border-radius);\n        border-bottom-right-radius: var(--border-radius);\n      }\n      .PinturaPanel[data-util='filter']\n        .PinturaRadioGroupOptions\n        .PinturaRadioGroupOption:last-of-type\n        .PinturaFilterOption {\n        border-bottom-right-radius: var(--border-radius);\n      }\n      .PinturaPanel[data-util='filter'] .PinturaRadioGroupOptionGroup {\n        display: flex;\n        flex-direction: column-reverse;\n      }\n      .PinturaPanel[data-util='filter'] .PinturaFilterOption {\n        cursor: var(--button-cursor);\n        margin-bottom: 1em;\n      }\n      .PinturaPanel[data-util='filter'] .PinturaFilterOption span {\n        display: block;\n        text-align: center;\n        padding: 0 0.3125em;\n        line-height: 1.75;\n        max-width: 100%;\n        font-size: 0.625em;\n        font-weight: 400;\n        margin-left: 1px;\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n      }\n      .PinturaPanel[data-util='filter'] .PinturaFilterPreview:before {\n        transition: background-color 0.1s, color 0.1s;\n      }\n      .PinturaPanel[data-util='filter']\n        [data-selected='true']\n        .PinturaFilterOption\n        .PinturaFilterPreview {\n        position: relative;\n        z-index: 1;\n      }\n      .PinturaPanel[data-util='filter']\n        [data-selected='true']\n        .PinturaFilterOption\n        .PinturaFilterPreview:before {\n        content: '';\n        position: absolute;\n        width: 100%;\n        height: 100%;\n        opacity: 0.35;\n        border-radius: inherit;\n        background-color: var(--color-primary);\n      }\n      .PinturaPanel[data-util='filter']\n        [data-focus-visible]\n        + label\n        > .PinturaFilterOption\n        span {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n        border-radius: 0.25em;\n      }\n      .PinturaPanel[data-util='filter'] .PinturaFilterOption,\n      .PinturaPanel[data-util='filter'] .PinturaFilterPreview {\n        width: 3.75em;\n        height: 4.5em;\n      }\n      .PinturaRoot[data-env~='is-compact']\n        .PinturaPanel[data-util='filter']\n        .PinturaUtilFooter\n        > div {\n        padding: 0;\n      }\n      .PinturaRoot[data-env~='is-compact']\n        .PinturaPanel[data-util='filter']\n        .PinturaFilterOption,\n      .PinturaRoot[data-env~='is-compact']\n        .PinturaPanel[data-util='filter']\n        .PinturaFilterPreview {\n        width: 2.875em;\n        height: 3.5em;\n      }\n      .PinturaRoot[data-env~='is-compact']\n        .PinturaPanel[data-util='filter']\n        .PinturaFilterOption\n        span {\n        font-size: 0.5em;\n      }\n      .PinturaRoot[data-env~='is-compact']\n        .PinturaPanel[data-util='filter']\n        .PinturaScrollable {\n        min-height: 4.5em;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaShapeStyleEditor {\n        min-height: 3.375em;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption {\n        margin: 1em 1em 0 0;\n        padding: 0.125em;\n        border: 1px dashed var(--color-foreground-15);\n        color: var(--color-foreground-70);\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption span {\n        color: var(--color-foreground-90);\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption label {\n        font-size: 0.75em;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption img,\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption svg {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        -o-object-fit: contain;\n        object-fit: contain;\n      }\n      .PinturaPanel[data-util='frame'] [data-selected='true'] {\n        border-color: var(--color-primary);\n        color: var(--color-primary);\n      }\n      .PinturaPanel[data-util='frame'] [data-selected='true'] span {\n        color: var(--color-foreground-90);\n      }\n      .PinturaPanel[data-util='frame']\n        [data-layout='row']\n        > .PinturaRadioGroupOptions\n        > li {\n        margin: 0 0.5em;\n      }\n      .PinturaPanel[data-util='frame']\n        [data-layout='row']\n        > .PinturaRadioGroupOptions\n        > li:first-of-type {\n        margin-left: 0;\n      }\n      .PinturaPanel[data-util='frame']\n        [data-layout='row']\n        > .PinturaRadioGroupOptions\n        > li:last-child {\n        margin-right: 0;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOptionGroupLabel {\n        width: 1px;\n        height: 1px;\n        position: absolute;\n        font-size: 0;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOptionGroup {\n        display: flex;\n        flex-direction: column-reverse;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption {\n        cursor: var(--button-cursor);\n        margin-bottom: 1em;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption span {\n        display: block;\n        text-align: center;\n        padding: 0 1.5em;\n        font-size: 0.625em;\n        font-weight: 400;\n      }\n      .PinturaPanel[data-util='frame']\n        [data-focus-visible]\n        + label\n        > .PinturaRadioGroupOption\n        span {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n        border-radius: 0.25em;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption {\n        position: relative;\n        width: 3em;\n        height: 4em;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption div {\n        position: absolute;\n        outline-color: currentColor;\n        border-color: currentColor;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption div[slot] {\n        overflow: hidden;\n        left: -1px;\n        top: -1px;\n        bottom: -1px;\n        right: -1px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n      }\n      .PinturaRoot[data-env~='is-compact']\n        .PinturaPanel[data-util='frame']\n        .PinturaUtilFooter\n        > div {\n        padding: 0;\n      }\n      .PinturaRoot[data-env~='is-compact']\n        .PinturaPanel[data-util='frame']\n        .PinturaRadioGroupOption {\n        width: 2.25em;\n        height: 3em;\n      }\n      .PinturaRoot[data-env~='is-compact']\n        .PinturaPanel[data-util='frame']\n        .PinturaRadioGroupOption\n        span {\n        font-size: 0.5em;\n      }\n      .PinturaPanel[data-util='crop'] .PinturaStage {\n        touch-action: none;\n      }\n      .PinturaPanel[data-util='crop'] .PinturaImageInfo {\n        position: absolute;\n        right: 1em;\n        bottom: 1em;\n      }\n      .PinturaPanel[data-util='crop'] .PinturaButtonCenter {\n        --size: 3em;\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: var(--size);\n        height: var(--size);\n        z-index: 1;\n        line-height: 0;\n        margin-top: calc(var(--size) * (-0.5));\n        margin-left: calc(var(--size) * (-0.5));\n        overflow: hidden;\n        color: #000;\n        background: hsla(0, 0%, 100%, 0.8);\n        border-radius: 50%;\n        -webkit-backdrop-filter: var(--backdrop-filter-bright);\n        backdrop-filter: var(--backdrop-filter-bright);\n        outline: none;\n      }\n      .PinturaPanel[data-util='crop'] .PinturaButtonCenter[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaRoot[data-env~='short']\n        .PinturaPanel[data-util='crop']\n        .PinturaUtilFooter {\n        padding-bottom: 0.5em;\n      }\n      .PinturaPanel[data-util='resize'] form {\n        display: flex;\n        justify-content: center;\n        padding: 0 1em;\n      }\n      .PinturaPanel[data-util='resize'] .PinturaFormInner {\n        position: relative;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n      }\n      .PinturaPanel[data-util='resize'] .PinturaFormInner > button {\n        position: absolute;\n        left: 100%;\n        margin-left: 1em;\n      }\n      .PinturaPanel[data-util='resize'] .PinturaFieldsetInner {\n        display: inline-flex;\n        align-items: center;\n        justify-content: center;\n      }\n      .PinturaPanel[data-util='resize'] .PinturaResizeLabel {\n        font-size: 0.75em;\n      }\n      .PinturaPanel[data-util='resize'] .PinturaDropdownButton {\n        margin-left: 0.5em;\n        margin-right: 0.5em;\n        -webkit-backdrop-filter: var(--backdrop-filter-dark);\n        backdrop-filter: var(--backdrop-filter-dark);\n        background-color: var(--color-foreground-5);\n        border-radius: var(--border-radius-round);\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n        transition: background-color 0.1s;\n      }\n      .PinturaPanel[data-util='resize'] .PinturaDropdownButton:hover {\n        background-color: var(--color-foreground-10);\n      }\n      .PinturaPanel[data-util='resize']\n        .PinturaDropdownButton\n        .PinturaButtonLabel {\n        display: block;\n        line-height: 2.65;\n        padding: 0 1em;\n        font-variant-numeric: tabular-nums;\n        font-size: 0.75em;\n        font-weight: 400;\n      }\n      .PinturaPanel[data-util='resize']\n        .PinturaDropdownButton\n        .PinturaButtonLabel:after {\n        content: '\u25BC';\n        font-size: 0.6875em;\n        margin-left: 0.75em;\n        position: relative;\n        top: -0.125em;\n        margin-right: -0.25em;\n        pointer-events: none;\n      }\n      .PinturaPanel[data-util='resize'] input[type='checkbox'] + label {\n        padding: 0 0.125em;\n        outline: transparent;\n        display: block;\n        cursor: pointer;\n      }\n      .PinturaPanel[data-util='resize']\n        input[type='checkbox'][data-focus-visible]\n        + label {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaInputDimension {\n        display: inline-flex;\n        align-items: center;\n        position: relative;\n      }\n      .PinturaInputDimension label {\n        position: absolute;\n        right: 0.625em;\n        font-size: 0.75em;\n        text-transform: uppercase;\n        pointer-events: none;\n        color: var(--color-foreground-20);\n        z-index: 1;\n      }\n      .PinturaInputDimension button,\n      .PinturaInputDimension input,\n      .PinturaInputDimension label {\n        font-size: 0.75em;\n        font-weight: 400;\n      }\n      .PinturaInputDimension button,\n      .PinturaInputDimension input {\n        -webkit-appearance: none;\n        appearance: none;\n        -moz-appearance: textfield;\n        box-sizing: border-box;\n        font-variant-numeric: tabular-nums;\n        padding: 0.625em 0 0.625em 0.625em;\n        width: 100%;\n        max-width: 7em;\n        outline: transparent;\n        border-radius: var(--border-radius);\n        box-shadow: none;\n        border: 1px solid var(--color-foreground-20);\n        transition: background-color 0.1s ease-in-out, color 0.1s ease-in-out,\n          border-color 0.1s ease-in-out;\n      }\n      .PinturaInputDimension button::-moz-selection,\n      .PinturaInputDimension input::-moz-selection {\n        background-color: var(--color-foreground-20);\n      }\n      .PinturaInputDimension button::selection,\n      .PinturaInputDimension input::selection {\n        background-color: var(--color-foreground-20);\n      }\n      .PinturaInputDimension button:hover,\n      .PinturaInputDimension input:hover {\n        border-color: var(--color-foreground-30);\n      }\n      .PinturaInputDimension button:focus,\n      .PinturaInputDimension input:focus {\n        border-color: var(--color-focus-100);\n      }\n      .PinturaInputDimension input {\n        -webkit-backdrop-filter: var(--backdrop-filter-dark);\n        backdrop-filter: var(--backdrop-filter-dark);\n        background-color: var(--color-foreground-5);\n      }\n      .PinturaInputDimension input:-moz-placeholder-shown {\n        border-style: dashed;\n      }\n      .PinturaInputDimension input:-ms-input-placeholder {\n        border-style: dashed;\n      }\n      .PinturaInputDimension input:placeholder-shown {\n        border-style: dashed;\n      }\n      .PinturaInputDimension input::-moz-placeholder {\n        color: var(--color-foreground-30);\n      }\n      .PinturaInputDimension input:-ms-input-placeholder {\n        color: var(--color-foreground-30);\n      }\n      .PinturaInputDimension input::placeholder {\n        color: var(--color-foreground-30);\n      }\n      .PinturaInputDimension input[data-state='invalid'] {\n        border-color: var(--color-error-75);\n        box-shadow: inset 0 0 0.25em var(--color-error-25),\n          0 0 0.25em var(--color-error-50);\n      }\n      .PinturaInputDimension button {\n        width: 10em;\n        min-height: 2.65em;\n      }\n      .PinturaInputDimension input::-webkit-inner-spin-button,\n      .PinturaInputDimension input::-webkit-outer-spin-button {\n        -webkit-appearance: none;\n      }\n      .PinturaInputDimension input::-ms-clear {\n        display: none;\n      }\n      .PinturaModal {\n        --safe-area-inset-top: env(safe-area-inset-top);\n        --safe-area-inset-bottom: env(safe-area-inset-bottom);\n        --editor-modal-border-radius: 0;\n        --editor-modal-overlay-opacity: 0.95;\n        --editor-modal-shadow: 0 1em 2em -1em rgba(0, 0, 0, 0.25),\n          0 1.5em 1.5em -2em rgba(0, 0, 0, 0.5);\n        --editor-modal-outline: inset 0 0 0 1px var(--color-foreground-3);\n        position: fixed;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100vh;\n        z-index: 2147483646;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        background-color: rgba(\n          var(--color-background),\n          var(\n            --editor-modal-overlay-opacity,\n            var(--editor-modal-overlay-opacity-default, 0.95)\n          )\n        );\n      }\n      .PinturaModal > .PinturaRoot[data-env~='is-centered'] {\n        box-shadow: var(--editor-modal-shadow);\n        border-radius: var(--editor-modal-border-radius);\n      }\n      .PinturaModal > .PinturaRoot[data-env~='is-centered']:after {\n        position: absolute;\n        left: 0;\n        top: 0;\n        bottom: 0;\n        right: 0;\n        pointer-events: none;\n        border-radius: inherit;\n        content: '';\n        box-shadow: var(--editor-modal-outline);\n        z-index: 2147483646;\n      }\n      .PinturaModal[style*='--viewport-pad-footer:1'] {\n        box-sizing: border-box;\n        padding-bottom: 44px;\n      }\n      .PinturaModal + .PinturaModal {\n        --editor-modal-overlay-opacity-default: 0.75;\n      }\n      .PinturaModal + .PinturaModal .PinturaRoot:not([data-env~='is-compact']) {\n        --editor-max-width-default: calc(100vw - 8em);\n        --editor-max-height-default: calc(100vh - 8em);\n      }\n      .PinturaCanvas canvas {\n        display: block;\n        width: 100%;\n        height: 100%;\n        position: absolute;\n      }\n      .PinturaDetailsPanel {\n        position: absolute;\n        top: 0;\n        left: 0;\n        z-index: 2147483647;\n        width: -webkit-max-content;\n        width: -moz-max-content;\n        width: max-content;\n        cursor: auto;\n        outline: transparent;\n        box-shadow: 0 0.125em 0.25em rgba(0, 0, 0, 0.25),\n          0 0.125em 0.75em rgba(0, 0, 0, 0.15),\n          0 0.125em 0.125em rgba(0, 0, 0, 0.1);\n        border-radius: var(--border-radius);\n        color: #111;\n        background: #fff;\n      }\n      .PinturaDetailsPanelTip {\n        position: absolute;\n        width: 0.5em;\n        height: 0.5em;\n        margin-left: -0.25em;\n        margin-top: -0.25em;\n        background: #fff;\n        z-index: -1;\n      }\n      .PinturaScrollable {\n        --scrollable-feather-start-opacity: 0;\n        --scrollable-feather-end-opacity: 0;\n        --scrollable-feather-size: 2em;\n        contain: paint;\n        overflow: hidden;\n      }\n      .PinturaScrollable:focus {\n        outline: transparent;\n      }\n      .PinturaScrollable > div {\n        position: relative;\n        display: inline-flex;\n        vertical-align: top;\n      }\n      .PinturaScrollable {\n        touch-action: none;\n      }\n      .PinturaScrollable[data-direction='x'] {\n        max-width: 100%;\n        --mask-angle: 90deg;\n      }\n      .PinturaScrollable[data-direction='y'] {\n        max-height: 100%;\n        --mask-angle: 180deg;\n      }\n      .PinturaScrollable[data-state~='overflows'] {\n        -webkit-mask: linear-gradient(\n          var(--mask-angle),\n          rgba(0, 0, 0, var(--scrollable-feather-start-opacity)),\n          #000 var(--scrollable-feather-size),\n          #000 calc(100% - var(--scrollable-feather-size)),\n          rgba(0, 0, 0, var(--scrollable-feather-end-opacity))\n        );\n        mask: linear-gradient(\n          var(--mask-angle),\n          rgba(0, 0, 0, var(--scrollable-feather-start-opacity)),\n          #000 var(--scrollable-feather-size),\n          #000 calc(100% - var(--scrollable-feather-size)),\n          rgba(0, 0, 0, var(--scrollable-feather-end-opacity))\n        );\n      }\n      .PinturaScrollable[data-state~='scrolling'] > div * {\n        pointer-events: none;\n      }\n      .PinturaTabPanels {\n        position: relative;\n        flex: 1;\n      }\n      .PinturaTabPanel {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n      }\n      .PinturaTabPanel:not([hidden]) {\n        z-index: 2;\n        outline: transparent;\n      }\n      .PinturaTabPanel[hidden] {\n        display: block !important;\n        z-index: 1;\n        pointer-events: none;\n      }\n      .PinturaTabPanel[data-inert='true'] {\n        visibility: hidden;\n      }\n      .PinturaTabPanel[data-inert='true'] [data-inert] {\n        visibility: hidden !important;\n      }\n      .PinturaTabList {\n        display: flex;\n        justify-content: center;\n      }\n      .PinturaTabList button {\n        display: flex;\n        align-items: center;\n        flex-direction: column;\n        outline: transparent;\n        cursor: var(--button-cursor);\n        -webkit-tap-highlight-color: transparent;\n      }\n      .PinturaTabList button > * {\n        transition: filter 0.2s ease-out;\n      }\n      .PinturaTabList button[disabled] > * {\n        filter: var(--filter-disabled);\n      }\n      .PinturaPanel {\n        position: relative;\n        z-index: 1;\n        height: 100%;\n        display: flex;\n        flex: 1;\n        flex-direction: column;\n        contain: layout size;\n      }\n      .PinturaProgressIndicator {\n        position: relative;\n        display: block;\n        width: 1.25em;\n        height: 1.25em;\n      }\n      .PinturaProgressIndicator .PinturaProgressIndicatorFill {\n        stroke-dashoffset: 0;\n      }\n      .PinturaProgressIndicator[data-status='busy'] svg {\n        -webkit-animation: image_editor_spin 1s linear infinite;\n        animation: image_editor_spin 1s linear infinite;\n      }\n      .PinturaProgressIndicator[data-status='busy']\n        .PinturaProgressIndicatorFill {\n        stroke-dashoffset: -26.5;\n        stroke-dasharray: 26.5 53;\n        transition: stroke-dashoffset 0.5s linear, stroke-dasharray 0.5s linear;\n      }\n      @-webkit-keyframes image_editor_spin {\n        0% {\n          transform: rotate(0deg);\n        }\n        to {\n          transform: rotate(1turn);\n        }\n      }\n      @keyframes image_editor_spin {\n        0% {\n          transform: rotate(0deg);\n        }\n        to {\n          transform: rotate(1turn);\n        }\n      }\n      @media only screen and (-webkit-min-device-pixel-ratio: 3) {\n        .PinturaRoot[data-env~='is-ios'] .PinturaProgressIndicator svg {\n          transform-origin: 49% 49%;\n        }\n      }\n      .PinturaButton {\n        white-space: nowrap;\n        flex-shrink: 0;\n        -webkit-tap-highlight-color: transparent;\n        cursor: var(--button-cursor);\n      }\n      .PinturaButton > span {\n        display: inline-flex;\n        align-items: center;\n        vertical-align: top;\n        min-height: 1em;\n      }\n      .PinturaButton svg + .PinturaButtonLabel {\n        margin-left: 0.5em;\n      }\n      .PinturaButton[disabled] {\n        cursor: default;\n      }\n      .PinturaButton:not(.PinturaButtonIconOnly) svg:first-of-type {\n        margin-left: -0.25em;\n      }\n      .PinturaColorPreview {\n        --color: transparent;\n        color: var(--color);\n        position: relative;\n        pointer-events: none;\n        background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='8' height='8' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h4v4H0zm4 4h4v4H4z' fill='%23E5E5E5'/%3E%3C/svg%3E\");\n      }\n      .PinturaColorPreview span {\n        position: absolute;\n        left: 0;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        background-color: var(--color);\n        border-radius: inherit;\n      }\n      .PinturaSlider {\n        position: relative;\n        --track-offset-x: 0.5em;\n        --track-offset-y: 0.5em;\n        --track-size: 1.5em;\n        --knob-size: 1em;\n        --knob-margin-top: 0em;\n        --knob-margin-right: 0em;\n        --knob-margin-bottom: 0em;\n        --knob-margin-left: 0em;\n        display: flex;\n        align-items: center;\n        touch-action: none;\n      }\n      .PinturaSlider[data-direction='y'] {\n        flex-direction: column;\n      }\n      .PinturaSlider .PinturaSliderControl {\n        position: relative;\n        flex: 1;\n      }\n      .PinturaSlider > button {\n        position: relative;\n        z-index: 1;\n        width: var(--track-size);\n        height: var(--track-size);\n        overflow: hidden;\n        cursor: pointer;\n        flex-shrink: none;\n      }\n      .PinturaSlider > button svg {\n        width: 1.25em;\n        height: 1.25em;\n        margin: 0.125em;\n        stroke-width: 0.125em;\n        stroke: #aaa;\n      }\n      .PinturaSlider > button:first-of-type {\n        order: 2;\n        padding-right: 0.125em;\n        margin-left: -0.325em;\n      }\n      .PinturaSlider > button:last-of-type {\n        order: 1;\n        padding-left: 0.125em;\n        margin-right: -0.325em;\n      }\n      .PinturaSlider > .PinturaSliderControl {\n        order: 2;\n      }\n      .PinturaSlider .PinturaSliderKnob {\n        left: 0;\n        top: 50%;\n        border-radius: 9999em;\n        visibility: visible;\n        background-color: #333;\n        width: var(--knob-size);\n        height: var(--knob-size);\n        margin-left: calc(var(--knob-size) * -0.5);\n        margin-top: calc(var(--knob-size) * -0.5);\n      }\n      .PinturaSlider .PinturaSliderKnob,\n      .PinturaSlider .PinturaSliderKnobController,\n      .PinturaSlider .PinturaSliderTrack {\n        pointer-events: none;\n        position: absolute;\n      }\n      .PinturaSlider .PinturaSliderTrack {\n        top: var(--track-offset-y);\n        bottom: var(--track-offset-y);\n        left: var(--track-offset-x);\n        right: var(--track-offset-x);\n      }\n      .PinturaSlider .PinturaSliderKnobController {\n        visibility: hidden;\n        top: calc(var(--track-offset-y) + var(--knob-margin-top));\n        bottom: calc(var(--track-offset-y) + var(--knob-margin-bottom));\n        left: calc(var(--track-offset-x) + var(--knob-margin-left));\n        right: calc(var(--track-offset-x) + var(--knob-margin-right));\n      }\n      .PinturaSlider .PinturaSliderTrack {\n        border-radius: 9999em;\n      }\n      .PinturaSlider[data-direction='x'] input[type='range'] {\n        height: var(--track-size);\n        margin-left: 0.5em;\n        width: calc(100% - 1em);\n      }\n      .PinturaSlider[data-direction='y'] input[type='range'] {\n        width: var(--track-size);\n        margin-top: 0.5em;\n        height: calc(100% - 1em);\n      }\n      .PinturaSlider input[type='range'] {\n        -webkit-appearance: none;\n        display: block;\n      }\n      .PinturaSlider input[type='range']::-webkit-slider-runnable-track {\n        background: transparent;\n      }\n      .PinturaSlider input[type='range']::-webkit-slider-thumb {\n        -webkit-appearance: none;\n        line-height: 0;\n        margin: 0;\n        padding: 0;\n        border: none;\n      }\n      .PinturaSlider input[type='range']::-moz-range-thumb {\n        line-height: 0;\n        margin: 0;\n        padding: 0;\n        border: none;\n      }\n      .PinturaSlider input[type='range']::-ms-thumb {\n        line-height: 0;\n        margin: 0;\n        padding: 0;\n        border: none;\n      }\n      .PinturaSlider input[type='range']::-ms-ticks-before,\n      .PinturaSlider input[type='range']::-ms-tooltip {\n        display: none;\n      }\n      .PinturaSlider input[type='range']::-ms-ticks-after {\n        display: none;\n      }\n      .PinturaSlider input[type='range']::-ms-track {\n        color: transparent;\n        border: none;\n        background: transparent;\n      }\n      .PinturaSlider input[type='range']::-ms-fill-lower,\n      .PinturaSlider input[type='range']::-ms-fill-upper {\n        background: transparent;\n      }\n      .PinturaSlider input[type='range']:focus {\n        outline: transparent;\n      }\n      .PinturaSlider\n        input[type='range'][data-focus-visible]\n        ~ .PinturaSliderKnobController\n        .PinturaSliderKnob:after {\n        position: absolute;\n        left: -0.3125em;\n        right: -0.3125em;\n        top: -0.3125em;\n        bottom: -0.3125em;\n        border-radius: inherit;\n        content: '';\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n        pointer-events: none;\n      }\n      .PinturaRangeInput {\n        position: relative;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        width: 24em;\n        height: 3.5em;\n        margin: auto;\n        max-width: 90%;\n        touch-action: none;\n        --range-input-feather-left: 2em;\n        --range-input-feather-right: 2em;\n        --range-input-mask-from: 0%;\n        --range-input-mask-to: 100%;\n        --range-input-mask-color: rgba(0, 0, 0, 0.25);\n        --range-input-line-color: var(--color-foreground-15);\n        outline: transparent;\n      }\n      .PinturaRangeInput[data-focus-visible]:after {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n        content: '';\n        position: absolute;\n        left: 0;\n        right: 0;\n        top: calc(50% - 1em);\n        height: 2em;\n        border-radius: 0.25em;\n      }\n      .PinturaRangeInputInner {\n        position: relative;\n        overflow: hidden;\n        height: 100%;\n        width: 100%;\n        contain: strict;\n        -webkit-mask: linear-gradient(\n          90deg,\n          transparent 0,\n          #000 var(--range-input-feather-left),\n          #000 calc(50% - 3em),\n          transparent 50%,\n          #000 calc(50% + 3em),\n          #000 calc(100% - var(--range-input-feather-right)),\n          transparent\n        );\n        mask: linear-gradient(\n          90deg,\n          transparent 0,\n          #000 var(--range-input-feather-left),\n          #000 calc(50% - 3em),\n          transparent 50%,\n          #000 calc(50% + 3em),\n          #000 calc(100% - var(--range-input-feather-right)),\n          transparent\n        );\n      }\n      .PinturaRangeInputMeter {\n        height: 100%;\n      }\n      .PinturaRangeInput .PinturaRangeInputMeter svg {\n        display: block;\n        pointer-events: none;\n        fill: currentColor;\n      }\n      .PinturaRangeInput > .PinturaRangeInputValue {\n        position: absolute;\n        z-index: 1;\n        pointer-events: none;\n        top: calc(50% - 0.6875em);\n        left: calc(50% - 1.75em);\n        width: 3.5em;\n        height: 1.5em;\n        overflow: hidden;\n        contain: strict;\n        text-align: center;\n        font-size: 0.75em;\n        font-variant-numeric: tabular-nums;\n        font-feature-settings: 'tnum';\n        font-family: Tahoma, Geneva, Verdana, sans-serif;\n      }\n      .PinturaRangeInput > .PinturaRangeInputReset {\n        position: absolute;\n        left: calc(50% - 1.0625em);\n        top: 0;\n        margin-top: 0.125em;\n        padding: 0;\n        z-index: 1;\n        width: 2em;\n        overflow: hidden;\n        color: transparent !important;\n        transition: opacity 0.25s;\n        opacity: 0.35;\n        outline: transparent;\n        cursor: var(--button-cursor);\n      }\n      .PinturaRangeInput > .PinturaRangeInputReset:hover {\n        opacity: 0.5;\n      }\n      .PinturaRangeInput > .PinturaRangeInputReset[data-focus-visible] {\n        opacity: 1;\n      }\n      .PinturaRangeInput > .PinturaRangeInputReset[data-focus-visible]:before {\n        content: '';\n        pointer-events: none;\n        position: absolute;\n        left: calc(50% - 0.5em);\n        top: calc(50% - 0.5em);\n        height: 1em;\n        width: 1em;\n        z-index: 2;\n        border-radius: 0.25em;\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaRangeInput > .PinturaRangeInputReset[disabled] {\n        opacity: 0.15;\n      }\n      .PinturaRangeInput > .PinturaRangeInputReset:after {\n        content: '';\n        position: absolute;\n        left: 50%;\n        top: 20%;\n        width: 1px;\n        height: 60%;\n        background: var(--color-foreground-100);\n      }\n      .PinturaRangeInputInner[data-value-limited] svg {\n        -webkit-mask: linear-gradient(\n          90deg,\n          var(--range-input-mask-color) var(--range-mask-from),\n          #000 var(--range-mask-from),\n          #000 var(--range-mask-to),\n          var(--range-input-mask-color) var(--range-mask-to)\n        );\n        mask: linear-gradient(\n          90deg,\n          var(--range-input-mask-color) var(--range-mask-from),\n          #000 var(--range-mask-from),\n          #000 var(--range-mask-to),\n          var(--range-input-mask-color) var(--range-mask-to)\n        );\n      }\n      .PinturaRangeInputInner[data-value-limited] svg rect {\n        x: var(--range-mask-from);\n        width: calc(var(--range-mask-to) - var(--range-mask-from));\n        fill: var(--range-input-line-color);\n      }\n      .PinturaUtilMain {\n        padding: 1em;\n        min-height: 1px;\n      }\n      .PinturaUtilMain,\n      .PinturaUtilMain > [slot] {\n        flex: 1;\n        display: flex;\n        flex-direction: column;\n      }\n      .PinturaUtilMain > [slot] {\n        align-items: center;\n      }\n      .PinturaUtilFooter {\n        padding: 0 0 1em;\n      }\n      .PinturaUtilFooter > [slot]:empty {\n        height: 1em;\n      }\n      .PinturaUtilFooter > [slot] {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: stretch;\n      }\n      .PinturaUtilFooter .PinturaRangeInput {\n        margin-top: -0.25em;\n      }\n      .PinturaUtilFooter > [slot] > .PinturaControlList,\n      .PinturaUtilFooter > [slot] > .PinturaControlListScroller {\n        order: 1;\n        margin-bottom: -0.1875em;\n      }\n      .PinturaUtilFooter\n        .PinturaControlList\n        [role='tab'][aria-selected='true']\n        button {\n        -webkit-backdrop-filter: var(--backdrop-filter-dark);\n        backdrop-filter: var(--backdrop-filter-dark);\n        background-color: var(--color-foreground-10);\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaUtilFooter .PinturaControlList .PinturaControlListOption label,\n      .PinturaUtilFooter .PinturaControlList [role='tab'] button {\n        flex-direction: row;\n        line-height: 1;\n        padding: 0 0.75em;\n        min-height: 1.75em;\n        border-radius: var(--border-radius-round);\n        transition: background-color 0.1s ease-out, color 0.1s ease-out,\n          filter 0.2s ease-out;\n        box-shadow: inset 0 0 0 1px var(--color-foreground-0);\n        cursor: var(--button-cursor);\n      }\n      .PinturaUtilFooter\n        .PinturaControlList\n        .PinturaControlListOption\n        label\n        span,\n      .PinturaUtilFooter .PinturaControlList [role='tab'] button span {\n        font-size: 0.75em;\n        font-weight: 400;\n      }\n      .PinturaUtilFooter\n        .PinturaControlList\n        .PinturaControlListOption\n        label\n        svg,\n      .PinturaUtilFooter .PinturaControlList [role='tab'] button svg {\n        width: 0.875em;\n        font-size: 0.875em;\n      }\n      .PinturaUtilFooter\n        .PinturaControlList\n        .PinturaControlListOption\n        label\n        svg:not(:only-child),\n      .PinturaUtilFooter\n        .PinturaControlList\n        [role='tab']\n        button\n        svg:not(:only-child) {\n        margin-left: -0.25em;\n        margin-right: 0.375em;\n      }\n      .PinturaUtilFooter\n        .PinturaControlList\n        .PinturaControlListOption\n        label:hover,\n      .PinturaUtilFooter .PinturaControlList [role='tab'] button:hover {\n        box-shadow: inset 0 0 0 1px var(--color-foreground-10);\n      }\n      .PinturaUtilFooter\n        .PinturaControlList\n        .PinturaControlListOption\n        label[data-focus-visible],\n      .PinturaUtilFooter\n        .PinturaControlList\n        [role='tab']\n        button[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaUtilFooter .PinturaControlListOption [slot],\n      .PinturaUtilFooter .PinturaControlListOption label {\n        display: flex;\n        flex-direction: row;\n        align-items: center;\n      }\n      .PinturaUtilFooter .PinturaControlListOption[data-selected='true'] label {\n        background-color: var(--color-foreground-10);\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaUtilFooter\n        .PinturaControlListOption\n        input[data-focus-visible]\n        + label {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaUtilFooter .PinturaControlListOption input[disabled] + label {\n        filter: var(--filter-disabled);\n      }\n      .PinturaUtilFooter\n        .PinturaControlList\n        .PinturaControlListOption\n        + .PinturaControlListOption,\n      .PinturaUtilFooter .PinturaControlList > li + li {\n        margin-left: 0.5em;\n      }\n      .PinturaUtilFooter .PinturaControlPanels {\n        position: relative;\n        width: 100%;\n        max-width: 30em;\n        min-height: 3.375em;\n        margin: 0 auto;\n        flex: auto;\n      }\n      .PinturaUtilFooter .PinturaControlPanel {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        visibility: visible;\n        opacity: 1;\n      }\n      .PinturaUtilFooter .PinturaControlPanel[hidden] {\n        display: block !important;\n        visibility: hidden;\n        transition-delay: 0s;\n        pointer-events: none;\n        opacity: 0;\n      }\n      .PinturaUtilFooter .PinturaControlList[data-layout='compact'] > * + * {\n        margin-left: -1px;\n      }\n      .PinturaUtilFooter\n        .PinturaControlList[data-layout='compact']\n        > [role='tab']\n        button {\n        padding-left: 0.625em;\n        padding-right: 0.625em;\n        border-radius: 0;\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaUtilFooter\n        .PinturaControlList[data-layout='compact']\n        > [role='tab']:only-child\n        button {\n        border-radius: var(--border-radius-round);\n      }\n      .PinturaUtilFooter\n        .PinturaControlList[data-layout='compact']\n        > [role='tab']:first-of-type:not(:only-child)\n        button {\n        padding-left: 0.75em;\n        border-top-left-radius: var(--border-radius-round);\n        border-bottom-left-radius: var(--border-radius-round);\n      }\n      .PinturaUtilFooter\n        .PinturaControlList[data-layout='compact']\n        > [role='tab']:last-child:not(:only-child)\n        button {\n        padding-right: 0.75em;\n        border-top-right-radius: var(--border-radius-round);\n        border-bottom-right-radius: var(--border-radius-round);\n      }\n      .PinturaRoot[data-env~='is-animated']\n        .PinturaUtilFooter\n        .PinturaControlPanel {\n        transition: opacity 0.3s ease-in-out, visibility 0.3s linear;\n        transition-delay: 0.1s;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaUtilFooter {\n        margin-bottom: 0.75em;\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaControlPanels {\n        min-height: 1.375em;\n        max-width: 20em;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaUtilFooter .PinturaControlList {\n        margin-top: 1em;\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaControlList\n        > li\n        + li {\n        margin-left: 0;\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaControlList\n        li[role='tab']\n        span {\n        font-size: 0.75em;\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaControlList\n        li[role='tab']\n        button {\n        border-radius: 0;\n        background-color: var(--color-background-50);\n        -webkit-backdrop-filter: var(--backdrop-filter-bright);\n        backdrop-filter: var(--backdrop-filter-bright);\n        box-shadow: inset 0 0 0 1px var(--color-background-15),\n          0 0.0625em 0.125em rgba(0, 0, 0, 0.25),\n          0 0.125em 0.35em rgba(0, 0, 0, 0.35);\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaControlList\n        li[role='tab']:first-of-type\n        button {\n        padding-left: 0.875em;\n        border-top-left-radius: var(--border-radius-round);\n        border-bottom-left-radius: var(--border-radius-round);\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaControlList\n        li[role='tab']:last-child\n        button {\n        padding-right: 0.875em;\n        border-top-right-radius: var(--border-radius-round);\n        border-bottom-right-radius: var(--border-radius-round);\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaControlList\n        li:not([aria-selected='true'])\n        span {\n        color: var(--color-foreground-40);\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaControlPanels {\n        background-color: var(--color-background-50);\n        -webkit-backdrop-filter: var(--backdrop-filter-bright);\n        backdrop-filter: var(--backdrop-filter-bright);\n        border-radius: var(--border-radius-round);\n        box-shadow: inset 0 0 0 1px var(--color-background-15),\n          0 0.0625em 0.125em rgba(0, 0, 0, 0.25),\n          0 0.125em 0.35em rgba(0, 0, 0, 0.35);\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaUtilFooter .PinturaRangeInput {\n        height: 1.5em;\n        margin-top: 0;\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaRangeInputReset {\n        opacity: 0;\n      }\n      .PinturaImageInfo {\n        pointer-events: none;\n      }\n      .PinturaImageInfo p {\n        width: 8em;\n        height: 1.25em;\n        contain: strict;\n        overflow: hidden;\n        font-variant-numeric: tabular-nums;\n        font-feature-settings: 'tnum';\n        font-family: Tahoma, Geneva, Verdana, sans-serif;\n        text-align: right;\n        line-height: 1;\n        font-size: 0.75em;\n      }\n      .PinturaShapeStyleEditor {\n        position: relative;\n        width: 100%;\n        min-height: 2.75em;\n      }\n      .PinturaShapeStyles {\n        position: absolute;\n        left: 0;\n        right: 0;\n        top: 0;\n      }\n      .PinturaShapeStyles:not([data-state~='overflows']) {\n        display: flex;\n        justify-content: center;\n      }\n      .PinturaShapeStyleList {\n        display: flex;\n      }\n      .PinturaShapeStyleList .PinturaButton,\n      .PinturaShapeStyleList .PinturaInput {\n        outline: transparent;\n      }\n      .PinturaShapeStyleList .PinturaInput {\n        padding: 0 0 0 0.625em;\n        font-size: 0.75em;\n        line-height: 2.25;\n      }\n      .PinturaShapeStyleList .PinturaShapeStyleLabel {\n        line-height: 1.75;\n        font-size: 0.625em;\n        font-weight: 300;\n        padding: 0 0.75em;\n        text-transform: lowercase;\n        pointer-events: none;\n        text-align: center;\n        color: var(--color-foreground-50);\n        white-space: nowrap;\n      }\n      .PinturaShapeStyleList > .PinturaShapeStyle {\n        border-radius: var(--border-radius-round);\n      }\n      .PinturaShapeStyleList > .PinturaShapeStyle + .PinturaShapeStyle {\n        margin-left: 1em;\n      }\n      .PinturaShapeStyle {\n        display: flex;\n        flex-direction: column;\n        align-items: stretch;\n      }\n      .PinturaShapeStyle .PinturaDetailsButton {\n        border-radius: inherit;\n      }\n      .PinturaShapeStyle > .PinturaButton:hover,\n      .PinturaShapeStyle > .PinturaButton[data-focus-visible] {\n        position: relative;\n        z-index: 1;\n      }\n      .PinturaShapeStyle > .PinturaColorPickerButton .PinturaButtonLabel {\n        display: block;\n        border-radius: inherit;\n      }\n      .PinturaShapeStyle > .PinturaColorPickerButton {\n        display: flex;\n        justify-content: center;\n      }\n      .PinturaShapeStyle .PinturaColorPreview {\n        border-radius: inherit;\n        width: 1.5em;\n        height: 1.5em;\n        background-color: #fff;\n        background-size: 4px;\n        border: 1px solid var(--color-background-100);\n        margin-top: -1px;\n      }\n      .PinturaShapeStyle .PinturaColorPreview span {\n        border-radius: inherit;\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaShapeStyle [data-focus-visible] .PinturaColorPreview span:before {\n        position: absolute;\n        left: 0;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        border-radius: inherit;\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n        content: '';\n        z-index: 1;\n      }\n      .PinturaShapeStyle\n        > .PinturaColorPickerButtonStroke\n        .PinturaColorPreview\n        span:after {\n        position: absolute;\n        left: 6px;\n        top: 6px;\n        right: 6px;\n        bottom: 6px;\n        background: var(--color-background-100);\n        border-radius: inherit;\n        box-shadow: 0 0 0 1px var(--color-foreground-5);\n        content: '';\n      }\n      .PinturaShapeStyle > .PinturaDropdownButton .PinturaButtonLabel,\n      .PinturaShapeStyle > .PinturaRadioGroup .PinturaButtonLabel,\n      .PinturaShapeStyle > .PinturaRadioGroupOption label,\n      .PinturaShapeStyle > .PinturaSliderButton .PinturaButtonLabel {\n        display: block;\n        line-height: 2.25;\n        padding: 0 1em;\n        font-size: 0.6875em;\n      }\n      .PinturaShapeStyle\n        > .PinturaButton:not(.PinturaColorPickerButton)[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaShapeStyle .PinturaInputField {\n        text-align: right;\n        padding: 0 0.75em;\n        width: 3em;\n        height: 2em;\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n        border-radius: var(--border-radius);\n      }\n      .PinturaShapeStyle > .PinturaDropdownButton {\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n        transition: background-color 0.1s;\n      }\n      .PinturaShapeStyle > .PinturaDropdownButton:hover {\n        background-color: var(--color-foreground-10);\n      }\n      .PinturaShapeStyle > .PinturaDropdownButton .PinturaButtonLabel:after {\n        content: '\u25BC';\n        font-size: 0.6875em;\n        margin-left: 0.75em;\n        position: relative;\n        top: -0.125em;\n        margin-right: -0.25em;\n        pointer-events: none;\n      }\n      .PinturaShapeStyle > .PinturaRadioGroup > .PinturaRadioGroupOptions {\n        flex-direction: row;\n      }\n      .PinturaShapeStyle\n        > .PinturaRadioGroup\n        > .PinturaRadioGroupOptions\n        label {\n        cursor: var(--button-cursor);\n        display: flex;\n        height: 1.5em;\n        align-items: center;\n        padding: 0 0.25em;\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n        transition: background-color 0.1s;\n      }\n      .PinturaShapeStyle\n        > .PinturaRadioGroup\n        > .PinturaRadioGroupOptions\n        label:hover {\n        background-color: var(--color-foreground-20);\n      }\n      .PinturaShapeStyle > .PinturaRadioGroup > .PinturaRadioGroupOptions svg {\n        width: 1.125em;\n        height: 1.125em;\n      }\n      .PinturaShapeStyle\n        > .PinturaRadioGroup\n        > .PinturaRadioGroupOptions\n        .PinturaRadioGroupOption:first-of-type\n        label {\n        padding-left: 0.5em;\n        border-top-left-radius: var(--border-radius-round);\n        border-bottom-left-radius: var(--border-radius-round);\n      }\n      .PinturaShapeStyle\n        > .PinturaRadioGroup\n        > .PinturaRadioGroupOptions\n        .PinturaRadioGroupOption:last-of-type\n        label {\n        padding-right: 0.5em;\n        border-top-right-radius: var(--border-radius-round);\n        border-bottom-right-radius: var(--border-radius-round);\n      }\n      .PinturaShapeStyle\n        > .PinturaRadioGroup\n        > .PinturaRadioGroupOptions\n        [data-selected='true']\n        label {\n        background-color: var(--color-foreground-10);\n      }\n      .PinturaToolbar {\n        display: flex;\n        justify-content: center;\n        margin-left: 1em;\n        margin-right: 1em;\n        padding-top: 1em;\n      }\n      .PinturaToolbar .PinturaToolbarInner {\n        display: inline-flex;\n      }\n      .PinturaToolbar[data-layout='compact'] .PinturaToolbarContentWide,\n      .PinturaToolbar[data-overflow='overflow'] .PinturaToolbarContentOptional {\n        display: none;\n      }\n      .PinturaToolbar .PinturaButton {\n        border-radius: var(--border-radius-round);\n        outline: transparent;\n        padding: 0.3125em 0.75em;\n        transition: background-color 0.1s ease-out, color 0.1s ease-out,\n          box-shadow 0.1s ease-out;\n        line-height: 1.1;\n      }\n      .PinturaToolbar .PinturaButton:hover {\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaToolbar .PinturaButton[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaToolbar .PinturaButton .PinturaButtonIcon {\n        width: 1em;\n      }\n      .PinturaToolbar .PinturaButtonLabel {\n        font-size: 0.75em;\n      }\n      .PinturaToolbar .PinturaDetailsPanel {\n        z-index: 3;\n      }\n      .PinturaToolbar .PinturaToolbarInner > * {\n        margin: 0 0.5em;\n      }\n      .PinturaRectManipulator {\n        --size: 1.25em;\n        position: absolute;\n        left: 0;\n        top: 0;\n        outline: none;\n        touch-action: none;\n      }\n      .PinturaRectManipulator:not([data-shape='edge']) {\n        width: var(--size);\n        height: var(--size);\n        z-index: 2;\n      }\n      .PinturaRectManipulator:not([data-shape='edge']):after {\n        position: absolute;\n        left: -0.5em;\n        right: -0.5em;\n        top: -0.5em;\n        bottom: -0.5em;\n        border-radius: inherit;\n        content: '';\n      }\n      .PinturaRectManipulator:not([data-shape='edge'])[data-focus-visible]:after {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaRectManipulator[data-shape~='circle'] {\n        margin-left: calc(var(--size) * (-0.5));\n        margin-top: calc(var(--size) * (-0.5));\n        line-height: var(--size);\n        border-radius: 50%;\n        background-color: var(--color-foreground-100);\n        box-shadow: 0 0 2px var(--color-background-50);\n      }\n      .PinturaRectManipulator[data-shape='hook'] {\n        border: 3px solid var(--color-foreground-100);\n      }\n      .PinturaRectManipulator[data-shape='hook'][data-direction*='t'] {\n        margin-top: -3px;\n        border-bottom: 0;\n      }\n      .PinturaRectManipulator[data-shape='hook'][data-direction*='r'] {\n        border-left: 0;\n        margin-left: calc(var(--size) * (-1));\n      }\n      .PinturaRectManipulator[data-shape='hook'][data-direction*='b'] {\n        margin-top: calc(var(--size) * (-1));\n        border-top: 0;\n      }\n      .PinturaRectManipulator[data-shape='hook'][data-direction*='l'] {\n        border-right: 0;\n        margin-left: -3px;\n      }\n      .PinturaRectManipulator[data-shape~='edge'] {\n        height: 1px;\n        width: 1px;\n        z-index: 1;\n      }\n      .PinturaRectManipulator[data-shape~='edge'][data-focus-visible] {\n        background-color: var(--color-focus-50);\n      }\n      .PinturaRectManipulator[data-direction='b'],\n      .PinturaRectManipulator[data-direction='t'] {\n        cursor: ns-resize;\n        height: var(--size);\n        margin-top: calc(var(--size) * (-0.5));\n        transform-origin: 0 center;\n      }\n      .PinturaRectManipulator[data-direction='l'],\n      .PinturaRectManipulator[data-direction='r'] {\n        cursor: ew-resize;\n        width: var(--size);\n        margin-left: calc(var(--size) * (-0.5));\n        transform-origin: center 0;\n      }\n      .PinturaRectManipulator[data-direction='bl'],\n      .PinturaRectManipulator[data-direction='tr'] {\n        cursor: nesw-resize;\n      }\n      .PinturaRectManipulator[data-direction='br'],\n      .PinturaRectManipulator[data-direction='tl'] {\n        cursor: nwse-resize;\n      }\n      .PinturaRoot[data-env~='pointer-coarse']\n        .PinturaRectManipulator[data-shape='edge']:active {\n        background-color: var(--color-foreground-5);\n      }\n      .PinturaRoot[data-env~='pointer-coarse']\n        .PinturaRectManipulator:not([data-shape='edge']):after {\n        left: -1em;\n        right: -1em;\n        top: -1em;\n        bottom: -1em;\n      }\n      .PinturaRoot[data-env~='pointer-coarse']\n        .PinturaRectManipulator:not([data-shape='edge']):active:after {\n        background-color: var(--color-foreground-5);\n      }\n      .PinturaShapePresetsPalette {\n        width: calc(100% - 2em);\n        text-align: center;\n      }\n      .PinturaShapePresetsPalette .PinturaShapePresetSelect {\n        vertical-align: top;\n        display: inline-block;\n      }\n      .PinturaShapePresetsPalette\n        .PinturaScrollable:not([data-state~='overflows']) {\n        display: flex;\n        justify-content: center;\n      }\n      .PinturaShapePresetsPalette .PinturaButton + .PinturaButton {\n        margin-left: 0.5em;\n      }\n      .PinturaShapePresetsPalette .PinturaButton {\n        flex-direction: row;\n        line-height: 1.1;\n        padding: 0.3125em 0.75em;\n        border-radius: var(--border-radius-round);\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n        cursor: var(--button-cursor);\n        transition: background-color 0.1s ease-out, color 0.1s ease-out,\n          box-shadow 0.1s ease-out;\n        outline: none;\n      }\n      .PinturaShapePresetsPalette .PinturaButton .PinturaButtonIcon {\n        width: 1em;\n      }\n      .PinturaShapePresetsPalette .PinturaButton .PinturaButtonLabel {\n        font-size: 0.75em;\n      }\n      .PinturaShapePresetsPalette .PinturaButton:hover {\n        box-shadow: inset 0 0 0 1px var(--color-foreground-10);\n      }\n      .PinturaShapePresetsPalette .PinturaButton[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaShapePresetsPalette .PinturaShapePresetsFlat > * + *,\n      .PinturaShapePresetsPalette .PinturaShapePresetsGroups > * + * {\n        margin-left: 0.5em;\n      }\n      .PinturaShapePresetsGroups {\n        display: flex;\n        order: 2;\n        margin-bottom: -0.1875em;\n      }\n      .PinturaShapePresetsGrouped {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n      }\n      .PinturaShapePresetsFlat {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n      }\n      .PinturaShapeList {\n        pointer-events: none;\n        opacity: 0;\n        transition: opacity 0.1s ease-in-out;\n        position: absolute;\n        top: 1em;\n        left: 1em;\n        width: -webkit-max-content;\n        width: -moz-max-content;\n        width: max-content;\n        z-index: 1;\n        border-radius: var(--border-radius);\n        color: var(--color-foreground-100);\n        background: var(--color-background-70);\n        box-shadow: 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaShapeList li + li {\n        margin-top: -0.3125em;\n      }\n      .PinturaShapeList[data-visible='true'] {\n        opacity: 1;\n      }\n      .PinturaShapeList .PinturaColorPreview {\n        width: 0.75em;\n        height: 0.75em;\n        margin-right: 0.25em;\n        border-radius: 0.25em;\n      }\n      .PinturaShapeList .PinturaShapeListItem {\n        display: flex;\n        align-items: center;\n        padding: 0.25em 0.5em;\n        outline: none;\n      }\n      .PinturaShapeList .PinturaShapeListItem > span {\n        font-size: 0.75em;\n        line-height: 1.75;\n        padding: 0 0.325em;\n        margin-left: -0.325em;\n      }\n      .PinturaShapeList .PinturaShapeListItem[data-focus-visible] > span {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaShapeList[data-visible='true'] .PinturaShapeListItem {\n        pointer-events: all;\n      }\n      .PinturaShapeEditor {\n        height: 100%;\n        width: 100%;\n        outline: none;\n        touch-action: none;\n      }\n      .PinturaShapeControls {\n        position: absolute !important;\n        left: 0;\n        top: 0;\n        z-index: 3;\n        pointer-events: none;\n        display: flex;\n        align-items: center;\n      }\n      .PinturaShapeControlsGroup {\n        pointer-events: all;\n      }\n      .PinturaShapeControlsGroup,\n      .PinturaShapeControlsGroup .PinturaSlider {\n        color: #eee;\n        background: #333;\n        box-shadow: 0 0.125em 0.25em rgba(0, 0, 0, 0.25);\n        border-radius: 0.25em;\n      }\n      .PinturaShapeControlsGroup,\n      .PinturaShapeControlsGroup .PinturaShapeControlsGroupToggle {\n        display: inline-flex;\n        min-height: 1.75em;\n      }\n      .PinturaShapeControlsGroup + .PinturaShapeControlsGroup {\n        margin-left: 0.5em;\n      }\n      .PinturaShapeControlsGroup .PinturaShapeControlsGroupToggle {\n        position: relative;\n      }\n      .PinturaShapeControlsGroup .PinturaButton {\n        outline: transparent;\n      }\n      .PinturaShapeControlsGroup .PinturaButton[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaShapeControlsGroup > .PinturaButton {\n        display: block;\n        font-weight: 700;\n        transition: background-color 0.1s;\n        outline: transparent;\n      }\n      .PinturaShapeControlsGroup > .PinturaButton:hover {\n        background-color: hsla(0, 0%, 100%, 0.15);\n      }\n      .PinturaShapeControlsGroup > .PinturaButton .PinturaButtonLabel {\n        display: block;\n        font-size: 0.6875em;\n        padding: 0 0.75em;\n        line-height: 1.7em;\n      }\n      .PinturaShapeControlsGroup .PinturaButtonIconOnly {\n        width: 1.75em;\n        transition: background-color 0.1s;\n      }\n      .PinturaShapeControlsGroup .PinturaButtonIconOnly:hover {\n        background-color: hsla(0, 0%, 100%, 0.15);\n      }\n      .PinturaShapeControlsGroup > button:first-of-type {\n        border-radius: 0.25em 0 0 0.25em;\n      }\n      .PinturaShapeControlsGroup > button:last-of-type {\n        border-radius: 0 0.25em 0.25em 0;\n      }\n      .PinturaShapeControlsGroup > button:only-of-type {\n        border-radius: 0.25em;\n      }\n      .PinturaShapeControlsGroup > * + * {\n        border-left: 1px solid rgba(0, 0, 0, 0.5);\n      }\n      .PinturaShapeControlsGroup svg {\n        pointer-events: none;\n      }\n      .PinturaInputForm {\n        opacity: 0;\n        cursor: auto;\n        z-index: 2147483647;\n      }\n      .PinturaInputForm:not([data-layout='stick']) {\n        position: absolute;\n        bottom: 6.5em;\n        width: 30em;\n        left: calc(50% - 15em);\n        box-shadow: 0 0.25em 0.5em -0.5em rgba(0, 0, 0, 0.75),\n          inset 0 0 0 1px var(--color-foreground-10);\n        border-radius: var(--border-radius);\n        background-color: var(--color-background-95);\n      }\n      @media (max-width: 34em) {\n        .PinturaInputForm:not([data-layout='stick']) {\n          left: 2em;\n          right: 2em;\n          width: auto;\n        }\n      }\n      .PinturaInputForm[data-layout='stick'] {\n        transition: opacity 0.15s ease 0.25s;\n        position: absolute;\n        left: 0;\n        right: 0;\n        outline: 1px solid var(--color-foreground-15);\n        background-color: var(--color-background-100);\n      }\n      .PinturaInputForm[data-layout='stick'] > .PinturaInputFormInner {\n        background-color: var(--color-foreground-3);\n      }\n      .PinturaInputFormInner > .PinturaButton {\n        color: var(--color-foreground-100);\n        border-radius: 9999em;\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaInputFormInner > .PinturaButton:first-of-type {\n        left: 1em;\n      }\n      .PinturaInputFormInner > .PinturaButton:last-of-type {\n        right: 1rem;\n        color: var(--color-primary-text);\n        background: var(--color-primary);\n        box-shadow: inset 0 0 0 1px var(--color-foreground-10);\n      }\n      .PinturaInputFormInner\n        > .PinturaButton:not(.PinturaButtonIconOnly)\n        .PinturaButtonInner {\n        padding: 0 0.875em 0 0.625em;\n      }\n      .PinturaInputFormInner > .PinturaButton .PinturaButtonIcon {\n        width: 0.875em;\n        height: 0.875em;\n      }\n      .PinturaInputFormInner > .PinturaButton.PinturaButtonIconOnly {\n        width: 1.875em;\n        height: 1.875em;\n      }\n      .PinturaInputFormInner > .PinturaButton .PinturaButtonLabel {\n        font-size: 0.875em;\n      }\n      .PinturaInputFormInner > .PinturaButton .PinturaButtonInner {\n        line-height: 2;\n        display: flex;\n        justify-content: center;\n      }\n      .PinturaInputFormInner {\n        padding-top: 1em;\n        padding-bottom: 3.5em;\n      }\n      .PinturaInputFormInner > .PinturaButton {\n        position: absolute;\n        bottom: 1em;\n      }\n      .PinturaInputFormFields textarea:only-child {\n        width: 100%;\n        padding: 0 1em 0.5em;\n        height: 5em;\n        display: block;\n        background: transparent;\n        -webkit-mask: linear-gradient(0deg, transparent, #000 1em);\n        mask: linear-gradient(0deg, transparent, #000 1em);\n      }\n      .PinturaInputFormFields textarea:only-child::-webkit-scrollbar {\n        width: 1em;\n        cursor: pointer;\n      }\n      .PinturaInputFormFields textarea:only-child::-webkit-scrollbar-track {\n        background: none;\n      }\n      .PinturaInputFormFields textarea:only-child::-webkit-scrollbar-thumb {\n        cursor: pointer;\n        background-clip: padding-box;\n        background-color: var(--color-foreground-70);\n        border-radius: 9999em;\n        border: 0.25em solid transparent;\n      }\n      .PinturaInputForm input,\n      .PinturaInputForm textarea {\n        box-sizing: border-box;\n        resize: none;\n        border: none;\n        font-size: 1rem;\n        outline: transparent;\n        color: var(--color-foreground-100);\n      }\n      .PinturaInputForm input {\n        background-color: var(--color-background-100);\n      }\n      .PinturaShapePresetsList {\n        display: flex;\n        align-items: center;\n      }\n      .PinturaShapePresetsList text {\n        font-family: monospace;\n      }\n      .PinturaShapePresetsList .PinturaShapePreset {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n      }\n      .PinturaShapePresetsList .PinturaShapePreset img,\n      .PinturaShapePresetsList .PinturaShapePreset svg {\n        display: block;\n        width: 1.75em;\n        height: 1.75em;\n        -o-object-fit: cover;\n        object-fit: cover;\n        border-radius: 0.3125em;\n      }\n      .PinturaShapePresetsList .PinturaShapePreset .PinturaDragButton {\n        padding: 0.3125em;\n        border-radius: var(--border-radius);\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaShapePresetsList .PinturaShapePreset .PinturaDragButton:hover {\n        background-color: var(--color-foreground-10);\n      }\n      .PinturaShapePresetsList .PinturaShapePreset + .PinturaShapePreset {\n        margin-left: 0.5em;\n      }\n      .PinturaShapeManipulator {\n        position: absolute;\n        left: 0;\n        top: 0;\n        outline: none;\n        touch-action: none;\n        --size: 0.75em;\n      }\n      .PinturaShapeManipulator:not([data-control='edge']) {\n        margin-left: calc(var(--size) * (-0.5));\n        margin-top: calc(var(--size) * (-0.5));\n        line-height: var(--size);\n        width: var(--size);\n        height: var(--size);\n        border-radius: 9999em;\n      }\n      .PinturaShapeManipulator:not([data-control='edge']):after {\n        position: absolute;\n        left: -0.5em;\n        right: -0.5em;\n        top: -0.5em;\n        bottom: -0.5em;\n        content: '';\n      }\n      .PinturaShapeManipulator:not([data-control='edge'])[data-focus-visible]:after {\n        border-radius: inherit;\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaShapeManipulator[data-control='point'] {\n        background: linear-gradient(\n          90deg,\n          var(--color-secondary-dark),\n          var(--color-secondary)\n        );\n        box-shadow: 0 0 0 2px #fff, 0 0 4px #000;\n        z-index: 3;\n      }\n      .PinturaShapeManipulator[data-control='edge'] {\n        margin-top: calc(var(--size) * (-0.5));\n        height: var(--size);\n        width: 1px;\n        z-index: 1;\n        transform-origin: 0 calc(var(--size) * 0.5);\n      }\n      .PinturaShapeManipulator[data-control='edge'][data-focus-visible] {\n        background-color: var(--color-focus-50);\n      }\n      .PinturaShapeManipulator[data-control='rotate'] {\n        border-radius: 9999em;\n        background: linear-gradient(90deg, #fff, #ddd);\n        box-shadow: 0 0 0 2px var(--color-secondary-dark), 0 0 4px #000;\n        z-index: 2;\n        cursor: move;\n      }\n      .PinturaDragButton {\n        cursor: var(--button-cursor);\n        outline: transparent;\n      }\n      .PinturaDragButton > * {\n        pointer-events: none;\n      }\n      .PinturaDragButton {\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n        -webkit-touch-callout: none;\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n        transition: filter 0.2s ease-out;\n      }\n      .PinturaDragButton[disabled] {\n        filter: var(--filter-disabled);\n      }\n    "], ["\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 100;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUQjIg1_i6t8kCHKm45_QpRxC7mw9c.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 100;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUQjIg1_i6t8kCHKm45_QpRzS7mw9c.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 100;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUQjIg1_i6t8kCHKm45_QpRxi7mw9c.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 100;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUQjIg1_i6t8kCHKm45_QpRxy7mw9c.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 100;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUQjIg1_i6t8kCHKm45_QpRyS7m.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 200;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_aZA3gTD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 200;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_aZA3g3D_u50.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 200;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_aZA3gbD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 200;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_aZA3gfD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 200;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_aZA3gnD_g.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 300;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_cJD3gTD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 300;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_cJD3g3D_u50.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 300;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_cJD3gbD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 300;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_cJD3gfD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 300;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_cJD3gnD_g.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 400;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUSjIg1_i6t8kCHKm459WRhyzbi.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 400;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUSjIg1_i6t8kCHKm459W1hyzbi.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 400;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUSjIg1_i6t8kCHKm459WZhyzbi.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 400;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUSjIg1_i6t8kCHKm459Wdhyzbi.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 400;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTUSjIg1_i6t8kCHKm459Wlhyw.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 500;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_ZpC3gTD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 500;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_ZpC3g3D_u50.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 500;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_ZpC3gbD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 500;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_ZpC3gfD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 500;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_ZpC3gnD_g.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 600;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_bZF3gTD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 600;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_bZF3g3D_u50.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 600;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_bZF3gbD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 600;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_bZF3gfD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 600;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_bZF3gnD_g.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 700;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_dJE3gTD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 700;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_dJE3g3D_u50.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 700;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_dJE3gbD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 700;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_dJE3gfD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 700;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_dJE3gnD_g.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 800;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_c5H3gTD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 800;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_c5H3g3D_u50.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 800;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_c5H3gbD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 800;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_c5H3gfD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 800;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_c5H3gnD_g.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n      /* cyrillic-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 900;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_epG3gTD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF,\n          U+A640-A69F, U+FE2E-FE2F;\n      }\n      /* cyrillic */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 900;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_epG3g3D_u50.woff2)\n          format('woff2');\n        unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;\n      }\n      /* vietnamese */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 900;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_epG3gbD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169,\n          U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;\n      }\n      /* latin-ext */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 900;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_epG3gfD_u50.woff2)\n          format('woff2');\n        unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB,\n          U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n      }\n      /* latin */\n      @font-face {\n        font-family: 'Montserrat';\n        font-style: normal;\n        font-weight: 900;\n        font-display: swap;\n        src: url(https://fonts.gstatic.com/s/montserrat/v18/JTURjIg1_i6t8kCHKm45_epG3gnD_g.woff2)\n          format('woff2');\n        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6,\n          U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193,\n          U+2212, U+2215, U+FEFF, U+FFFD;\n      }\n\n      .PinturaRadioGroup .PinturaRadioGroupOptions {\n        display: flex;\n        flex-direction: column;\n      }\n      .PinturaRadioGroup\n        .PinturaRadioGroupOptionGroup\n        + .PinturaRadioGroupOptionGroup {\n        margin-top: 0.5em;\n      }\n      .PinturaRadioGroup[data-layout='row'] .PinturaRadioGroupOptions {\n        flex-direction: row;\n      }\n      .PinturaRadioGroup label {\n        -webkit-tap-highlight-color: transparent;\n      }\n      .PinturaDetailsPanel.PinturaSliderPanel {\n        border-radius: var(--border-radius-round);\n      }\n      .PinturaPercentageLabel {\n        font-variant-numeric: tabular-nums;\n        min-width: 3em;\n        text-align: center;\n      }\n      .PinturaSliderPanel .PinturaSlider {\n        width: 10em;\n        --knob-size: 0.75em;\n        --knob-margin-left: 0.3125em;\n        --knob-margin-right: 0.3125em;\n      }\n      .PinturaSliderPanel .PinturaSliderTrack {\n        background-color: #eee;\n      }\n      .PinturaSliderPanel .PinturaSliderKnob {\n        background-color: #111;\n        box-shadow: 0 0.125em 0.25em rgba(0, 0, 0, 0.35),\n          0 -0.125em 0.25em rgba(0, 0, 0, 0.1);\n      }\n      .pintura-editor,\n      pintura-editor {\n        --color-primary: #ffd843;\n        --color-primary-dark: #ffc343;\n        --color-primary-text: #000;\n        --color-secondary: #03a9f4;\n        --color-secondary-dark: #046bbf;\n        --color-focus: 4, 107, 191;\n        --color-focus-100: rgba(var(--color-focus), 1);\n        --color-focus-50: rgba(var(--color-focus), 0.5);\n        --color-focus-25: rgba(var(--color-focus), 0.25);\n        --color-error: 255, 87, 34;\n        --color-error-100: rgb(var(--color-error));\n        --color-error-75: rgba(var(--color-error), 0.75);\n        --color-error-50: rgba(var(--color-error), 0.5);\n        --color-error-25: rgba(var(--color-error), 0.25);\n        --color-foreground: 0, 0, 0;\n        --color-background: 255, 255, 255;\n        --color-preview-outline: var(--color-foreground);\n        --color-foreground-100: rgba(var(--color-foreground), 1);\n        --color-foreground-95: rgba(var(--color-foreground), 0.95);\n        --color-foreground-90: rgba(var(--color-foreground), 0.9);\n        --color-foreground-80: rgba(var(--color-foreground), 0.8);\n        --color-foreground-70: rgba(var(--color-foreground), 0.7);\n        --color-foreground-60: rgba(var(--color-foreground), 0.6);\n        --color-foreground-50: rgba(var(--color-foreground), 0.5);\n        --color-foreground-40: rgba(var(--color-foreground), 0.4);\n        --color-foreground-30: rgba(var(--color-foreground), 0.3);\n        --color-foreground-20: rgba(var(--color-foreground), 0.25);\n        --color-foreground-15: rgba(var(--color-foreground), 0.2);\n        --color-foreground-10: rgba(var(--color-foreground), 0.15);\n        --color-foreground-5: rgba(var(--color-foreground), 0.075);\n        --color-foreground-3: rgba(var(--color-foreground), 0.05);\n        --color-foreground-1: rgba(var(--color-foreground), 0.02);\n        --color-foreground-0: rgba(var(--color-foreground), 0);\n        --color-background-100: rgba(var(--color-background), 1);\n        --color-background-95: rgba(var(--color-background), 0.95);\n        --color-background-90: rgba(var(--color-background), 0.9);\n        --color-background-80: rgba(var(--color-background), 0.8);\n        --color-background-70: rgba(var(--color-background), 0.7);\n        --color-background-60: rgba(var(--color-background), 0.6);\n        --color-background-50: rgba(var(--color-background), 0.5);\n        --color-background-40: rgba(var(--color-background), 0.4);\n        --color-background-30: rgba(var(--color-background), 0.3);\n        --color-background-20: rgba(var(--color-background), 0.2);\n        --color-background-15: rgba(var(--color-background), 0.15);\n        --color-background-10: rgba(var(--color-background), 0.1);\n        --color-background-5: rgba(var(--color-background), 0.05);\n        --color-background-3: rgba(var(--color-background), 0.03);\n        --color-background-1: rgba(var(--color-background), 0.01);\n        --color-background-0: rgba(var(--color-background), 0);\n        --button-cursor: pointer;\n        --font-size: 16px;\n        --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n          Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji',\n          'Segoe UI Symbol';\n        --backdrop-filter-bright: brightness(110%) saturate(180%) blur(10px);\n        --backdrop-filter-dark: brightness(90%) saturate(180%) blur(10px);\n        --border-radius-round: 9999em;\n        --border-radius: 0.625em;\n        --filter-disabled: grayscale(95%) opacity(40%);\n        --editor-inset-top: 0px;\n        --editor-inset-bottom: 0px;\n        --safe-area-inset-top: 0px;\n        --safe-area-inset-bottom: 0px;\n      }\n      .pintura-editor,\n      .PinturaRootWrapper,\n      pintura-editor {\n        display: block;\n      }\n      .PinturaRootWrapper {\n        height: 100%;\n      }\n      .PinturaRoot {\n        --nav-group-margin: 0.5em;\n        --editor-calculated-inset-top: calc(\n          var(--safe-area-inset-top) + var(--editor-inset-top)\n        );\n        --editor-calculated-inset-bottom: calc(\n          var(--safe-area-inset-bottom) + var(--editor-inset-bottom)\n        );\n        box-sizing: border-box;\n        width: var(--editor-width, 100%);\n        height: var(--editor-height, 100%);\n        padding-top: var(--editor-calculated-inset-top);\n        padding-bottom: var(--editor-calculated-inset-bottom);\n        max-width: var(\n          --editor-max-width,\n          var(--editor-max-width-default, none)\n        );\n        max-height: var(\n          --editor-max-height,\n          var(--editor-max-height-default, none)\n        );\n        position: relative;\n        overflow: hidden;\n        contain: strict;\n        display: grid;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n        line-height: normal;\n        font-size: var(--font-size);\n        font-family: var(--font-family);\n        font-weight: 450;\n        touch-action: manipulation;\n        text-align: left;\n        text-transform: none;\n        text-rendering: optimizeLegibility;\n        direction: ltr;\n        color: var(--color-foreground-90);\n        background-color: var(--color-background-100);\n        outline-color: rgba(var(--color-preview-outline), 1);\n        transition: background-color 1ms, outline-color 1ms,\n          color 0.15s ease-in-out;\n      }\n      .PinturaRoot * {\n        box-sizing: content-box;\n      }\n      .PinturaRoot button,\n      .PinturaRoot fieldset,\n      .PinturaRoot input,\n      .PinturaRoot legend {\n        padding: 0;\n        margin: 0;\n        border: none;\n        background: transparent;\n        color: inherit;\n        font-size: inherit;\n        font-family: inherit;\n        line-height: inherit;\n        width: auto;\n        text-decoration: none;\n      }\n      .PinturaRoot button[disabled] {\n        pointer-events: none;\n      }\n      .PinturaRoot canvas {\n        display: block;\n      }\n      .PinturaRoot svg {\n        display: inline-block;\n        width: auto;\n        height: auto;\n      }\n      .PinturaRoot p {\n        margin: 0;\n      }\n      .PinturaRoot li,\n      .PinturaRoot ul {\n        list-style: none;\n        margin: 0;\n        padding: 0;\n      }\n      .PinturaRoot a {\n        color: inherit;\n        text-decoration: none;\n      }\n      .PinturaRoot .implicit {\n        border: 0;\n        clip: rect(0 0 0 0);\n        -webkit-clip-path: polygon(0 0, 0 0, 0 0);\n        clip-path: polygon(0 0, 0 0, 0 0);\n        height: 1px;\n        margin: -1px;\n        overflow: hidden;\n        padding: 0;\n        position: absolute;\n        width: 1px;\n        white-space: nowrap;\n      }\n      .PinturaRoot .PinturaStage {\n        display: flex;\n        align-self: stretch;\n        flex: 1;\n      }\n      .PinturaRoot .PinturaStage[tabindex='-1'] {\n        outline: none;\n      }\n      .PinturaRoot .PinturaRootPortal {\n        position: absolute;\n        left: 0;\n        top: 0;\n      }\n      .PinturaRoot > .PinturaCanvas {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        z-index: 0;\n        pointer-events: none;\n      }\n      .PinturaRoot > .PinturaCanvas:after {\n        content: '';\n        position: absolute;\n        left: 0;\n        top: 0;\n        bottom: 0;\n        right: 0;\n        pointer-events: none;\n        background-repeat: no-repeat;\n      }\n      .PinturaRoot > .PinturaStatus {\n        position: absolute;\n        z-index: 99999;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        display: flex;\n        justify-content: center;\n        align-items: flex-start;\n        background-color: var(--color-background-90);\n      }\n      .PinturaRoot > .PinturaStatus > p {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        display: inline-flex;\n        white-space: nowrap;\n        align-items: center;\n        transition: opacity 0.5s ease-out;\n      }\n      .PinturaRoot .PinturaStatusMessage {\n        position: absolute;\n        font-size: 0.875em;\n      }\n      .PinturaRoot .PinturaStatusAside {\n        position: absolute;\n        left: 0;\n      }\n      .PinturaRoot .PinturaStatusAside svg {\n        width: 1.25em;\n        height: 1.25em;\n      }\n      .PinturaRoot .PinturaStatusAside .PinturaProgressIndicator {\n        margin-left: 0.5em;\n      }\n      .PinturaRoot .PinturaStatusAside .PinturaButton {\n        outline: transparent;\n        margin-left: 0.75em;\n        font-size: 0.875em;\n        border-radius: var(--border-radius-round);\n        background-color: var(--color-foreground-5);\n        padding: 0.25em;\n        transition: background-color 0.1s ease-out, color 0.1s ease-out;\n        -webkit-backdrop-filter: var(--backdrop-filter-dark);\n        backdrop-filter: var(--backdrop-filter-dark);\n      }\n      .PinturaRoot\n        .PinturaStatusAside\n        .PinturaButton:not([disabled])[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaRoot .PinturaStatusAside .PinturaButton:not([disabled]):hover {\n        background-color: var(--color-foreground-10);\n      }\n      .PinturaRoot .PinturaStatusIcon svg {\n        font-size: 0.875em;\n        margin-top: 0.25em;\n        margin-left: 0.5em;\n      }\n      .PinturaRoot > .PinturaNav {\n        position: relative;\n        z-index: 3;\n      }\n      .PinturaRoot > .PinturaNav:empty() {\n        display: none !important;\n      }\n      .PinturaRoot > .PinturaNav .PinturaButton {\n        outline: transparent;\n        transition: background-color 0.1s ease-out, color 0.1s ease-out;\n      }\n      .PinturaRoot > .PinturaNav .PinturaButton svg {\n        width: 1em;\n        transition: opacity 0.1s ease-out;\n      }\n      .PinturaRoot > .PinturaNav .PinturaButton > span {\n        justify-content: center;\n      }\n      .PinturaRoot > .PinturaNav .PinturaButtonIconOnly .PinturaButtonInner,\n      .PinturaRoot > .PinturaNav .PinturaDropdownIconOnly .PinturaButtonInner {\n        width: 1.75em;\n      }\n      .PinturaRoot > .PinturaNav .PinturaButton .PinturaButtonInner {\n        height: 1.75em;\n      }\n      .PinturaRoot\n        > .PinturaNav\n        .PinturaButton:not(.PinturaButtonIconOnly):not(.PinturaDropdownIconOnly) {\n        padding-left: 0.75em;\n        padding-right: 0.75em;\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaRoot\n        > .PinturaNav\n        .PinturaButton:not(.PinturaButtonIconOnly):not(.PinturaDropdownIconOnly)\n        .PinturaButtonLabel {\n        font-size: 0.75em;\n        line-height: 2;\n      }\n      .PinturaRoot > .PinturaNav .PinturaButton:only-of-type {\n        border-radius: var(--border-radius-round);\n      }\n      .PinturaRoot > .PinturaNav .PinturaButton:only-of-type + * {\n        margin-left: 0.5em;\n      }\n      .PinturaRoot > .PinturaNav .PinturaButton[disabled] svg {\n        opacity: 0.25;\n      }\n      .PinturaRoot\n        > .PinturaNav\n        .PinturaButton:not(.PinturaButtonExport):not([disabled])[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaRoot\n        > .PinturaNav\n        .PinturaButton:not(.PinturaButtonExport):not([disabled]):hover {\n        background-color: var(--color-foreground-10);\n      }\n      .PinturaRoot .PinturaButtonExport {\n        color: var(--color-primary-text);\n        background-color: var(--color-primary);\n      }\n      .PinturaRoot .PinturaButtonExport:hover {\n        background-color: var(--color-primary-dark);\n      }\n      .PinturaRoot .PinturaButtonExport[data-focus-visible] {\n        color: var(--color-primary-text);\n        background-color: var(--color-primary);\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5),\n          0 0 0 3px var(--color-focus-50);\n        background-color: var(--color-primary-dark);\n      }\n      .PinturaRoot .PinturaButtonExport:not(.PinturaButtonIconOnly) {\n        flex: 1;\n        padding: 0 0.75em;\n      }\n      .PinturaRoot > .PinturaNavMain {\n        display: flex;\n        overflow: hidden;\n      }\n      .PinturaRoot > .PinturaNavMain [aria-selected='true'] button {\n        -webkit-backdrop-filter: var(--backdrop-filter-dark);\n        backdrop-filter: var(--backdrop-filter-dark);\n        background-color: var(--color-foreground-10);\n      }\n      .PinturaRoot > .PinturaNavMain button svg {\n        align-self: center;\n        width: 1.5em;\n      }\n      .PinturaRoot > .PinturaNavMain button span,\n      .PinturaRoot > .PinturaNavMain button svg {\n        pointer-events: none;\n      }\n      .PinturaRoot > .PinturaNavMain button svg + span {\n        margin-top: 0.75em;\n      }\n      .PinturaRoot > .PinturaNavMain button span {\n        font-size: 0.875em;\n      }\n      .PinturaRoot > .PinturaNavMain button {\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n        transition: background-color 0.1s ease-out, color 0.1s ease-out,\n          box-shadow 0.1s ease-out;\n      }\n      .PinturaRoot > .PinturaNavMain button:hover {\n        box-shadow: inset 0 0 0 1px var(--color-foreground-10);\n      }\n      .PinturaRoot > .PinturaNavMain button[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaRoot > .PinturaNavTools {\n        max-width: 100%;\n        box-sizing: border-box;\n        pointer-events: none;\n      }\n      .PinturaRoot > .PinturaNavTools:empty {\n        display: none;\n      }\n      .PinturaRoot > .PinturaNavTools,\n      .PinturaRoot > .PinturaNavTools .PinturaNavGroup,\n      .PinturaRoot > .PinturaNavTools .PinturaNavSet {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n      }\n      .PinturaRoot > .PinturaNavTools .PinturaButton,\n      .PinturaRoot > .PinturaNavTools .PinturaNavSet {\n        pointer-events: all;\n      }\n      .PinturaRoot > .PinturaNavTools .PinturaButton[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaRoot .PinturaNavGroup {\n        margin: 0 var(--nav-group-margin);\n      }\n      .PinturaRoot .PinturaNavGroup > * {\n        border-radius: var(--border-radius-round);\n      }\n      .PinturaRoot .PinturaNavGroup > * + * {\n        margin-left: 0.5em;\n      }\n      .PinturaRoot .PinturaNavGroup:first-of-type {\n        margin-right: auto;\n        margin-left: 0;\n      }\n      .PinturaRoot .PinturaNavGroup:last-of-type {\n        margin-left: auto;\n        margin-right: 0;\n      }\n      .PinturaRoot .PinturaNavSet {\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaRoot .PinturaNavSet > :not(:only-child) {\n        border: 1px solid var(--color-foreground-3);\n        border-top: 0;\n        border-bottom: 0;\n      }\n      .PinturaRoot .PinturaNavSet > :first-of-type:not(:only-child) {\n        border-left: 0;\n      }\n      .PinturaRoot .PinturaNavSet > :last-child:not(:only-child) {\n        border-right: 0;\n      }\n      .PinturaRoot .PinturaNavSet > * + * {\n        margin-left: -1px;\n      }\n      .PinturaRoot .PinturaNavSet > .PinturaButton:hover,\n      .PinturaRoot .PinturaNavSet > .PinturaButton[data-focus-visible] {\n        position: relative;\n        z-index: 1;\n      }\n      .PinturaRoot .PinturaNavSet > :only-child {\n        border-radius: var(--border-radius-round);\n      }\n      .PinturaRoot\n        .PinturaNavSet\n        > :first-of-type:not(:only-child)\n        .PinturaButtonInner {\n        padding: 0 0.125em 0 0.25em;\n      }\n      .PinturaRoot .PinturaNavSet > :first-of-type:not(:only-child) {\n        border-top-left-radius: var(--border-radius-round);\n        border-bottom-left-radius: var(--border-radius-round);\n      }\n      .PinturaRoot\n        .PinturaNavSet\n        > :last-child:not(:only-child)\n        .PinturaButtonInner {\n        padding: 0 0.25em 0 0.125em;\n      }\n      .PinturaRoot .PinturaNavSet > :last-child:not(:only-child) {\n        border-top-right-radius: var(--border-radius-round);\n        border-bottom-right-radius: var(--border-radius-round);\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaNavSet {\n        background-color: var(--color-background-50);\n        -webkit-backdrop-filter: var(--backdrop-filter-bright);\n        backdrop-filter: var(--backdrop-filter-bright);\n        box-shadow: inset 0 0 0 1px var(--color-background-15),\n          0 0.0625em 0.125em rgba(0, 0, 0, 0.25),\n          0 0.125em 0.35em rgba(0, 0, 0, 0.35);\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaNavSet\n        .PinturaButton:not(.PinturaButtonExport):not([disabled]):hover,\n      .PinturaRoot[data-env~='overlay'] .PinturaNavSet > * {\n        border-color: var(--color-background-15);\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaNavGroup > .PinturaButton {\n        box-shadow: 0 0.0625em 0.125em rgba(0, 0, 0, 0.25),\n          0 0.125em 0.35em rgba(0, 0, 0, 0.35);\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaNavGroup .PinturaButtonExport {\n        box-shadow: inset 0 0 0.125em rgba(0, 0, 0, 0.25),\n          0 0.0625em 0.125em rgba(0, 0, 0, 0.25),\n          0 0.125em 0.35em rgba(0, 0, 0, 0.35);\n      }\n      .PinturaRoot .PinturaNavGroupFloat {\n        position: absolute;\n        left: 0;\n        right: 0;\n        pointer-events: none;\n      }\n      .PinturaRoot .PinturaNavGroupFloat > * {\n        pointer-events: all;\n      }\n      .PinturaRoot .PinturaUtilFooter .PinturaScrollable > div {\n        padding-left: 1em;\n        padding-right: 1em;\n      }\n      .PinturaRoot > .PinturaMain {\n        max-width: 100vw;\n      }\n      .PinturaRoot:not([data-env~='has-toolbar']) .PinturaUtilHeader {\n        padding-top: 0;\n        padding-bottom: 1em;\n        margin-bottom: -1em;\n      }\n      .PinturaRoot[data-env~='landscape'] {\n        grid-template-rows: -webkit-min-content auto;\n        grid-template-rows: min-content auto;\n        grid-template-columns: auto;\n      }\n      .PinturaRoot[data-env~='landscape'] > .PinturaNavTools {\n        grid-row: 1;\n        grid-column: 1;\n        padding: 1em 1em 0;\n        z-index: 3;\n      }\n      .PinturaRoot[data-env~='landscape'] > .PinturaNavMain {\n        align-items: center;\n        justify-content: flex-end;\n        position: absolute;\n        left: 1em;\n        top: calc(1em + var(--editor-calculated-inset-top));\n        bottom: calc(1em + var(--editor-calculated-inset-bottom));\n      }\n      .PinturaRoot[data-env~='landscape'] > .PinturaNavMain .PinturaTabList {\n        flex-direction: column;\n      }\n      .PinturaRoot[data-env~='landscape'] > .PinturaNavMain .PinturaTabList li {\n        display: flex;\n      }\n      .PinturaRoot[data-env~='landscape']\n        > .PinturaNavMain\n        .PinturaTabList\n        li\n        + li {\n        margin: 0.5em 0 0;\n      }\n      .PinturaRoot[data-env~='landscape'] > .PinturaNavMain button {\n        flex: 1;\n        width: 4em;\n        height: 4em;\n        border-radius: var(--border-radius);\n        justify-content: center;\n      }\n      .PinturaRoot[data-env~='landscape'] > .PinturaNavMain button span {\n        font-size: 0.6875em;\n        margin-top: 0.5em;\n      }\n      .PinturaRoot[data-env~='landscape'] > .PinturaNavMain button svg {\n        width: 1em;\n        margin-top: 0.25em;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='has-toolbar']\n        > .PinturaNavMain {\n        top: calc(4em + var(--editor-calculated-inset-top));\n        bottom: calc(4em + var(--editor-calculated-inset-bottom));\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='has-limited-space']\n        > .PinturaNavMain {\n        align-items: flex-start;\n        bottom: calc(1em + var(--editor-calculated-inset-bottom));\n      }\n      .PinturaRoot[data-env~='landscape'] > .PinturaMain {\n        grid-row: 2;\n        grid-column: 1;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='has-navigation'] {\n        grid-template-columns: 6em auto;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='has-navigation']\n        .PinturaNavGroupFloat {\n        margin: 0 0 0 6em;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='has-navigation']\n        > .PinturaNavTools {\n        grid-column: 1 / span 2;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='has-navigation']\n        > .PinturaMain {\n        grid-column: 2;\n      }\n      .PinturaRoot[data-env~='portrait'] {\n        grid-template-rows: -webkit-min-content auto -webkit-min-content;\n        grid-template-rows: min-content auto min-content;\n        grid-template-columns: auto;\n      }\n      .PinturaRoot[data-env~='portrait'] > * {\n        grid-column: 1;\n      }\n      .PinturaRoot[data-env~='portrait'] > .PinturaNavTools {\n        grid-row: 1;\n        padding: 0.75em 0.75em 0;\n      }\n      .PinturaRoot[data-env~='portrait'] > .PinturaNavMain {\n        grid-row: 3;\n        margin-bottom: 0.75em;\n        justify-content: center;\n      }\n      .PinturaRoot[data-env~='portrait'] > .PinturaNavMain .PinturaTabList {\n        padding: 0 0.875em;\n      }\n      .PinturaRoot[data-env~='portrait'] > .PinturaNavMain li + li {\n        margin-left: 0.5em;\n      }\n      .PinturaRoot[data-env~='portrait']\n        > .PinturaNavMain[data-state~='overflows'] {\n        overflow: visible;\n      }\n      .PinturaRoot[data-env~='portrait'] > .PinturaNavMain button {\n        flex: 1;\n        width: 4em;\n        height: 4em;\n        border-radius: var(--border-radius);\n        justify-content: center;\n      }\n      .PinturaRoot[data-env~='portrait'] > .PinturaNavMain button span {\n        font-size: 0.6875em;\n        margin-top: 0.5em;\n      }\n      .PinturaRoot[data-env~='portrait'] > .PinturaNavMain button svg {\n        width: 1em;\n        margin-top: 0.25em;\n      }\n      .PinturaRoot[data-env~='portrait'] > .PinturaMain {\n        grid-row: 2;\n        grid-column: 1;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='is-compact']\n        > .PinturaNavMain\n        button {\n        flex: 1;\n        flex-direction: row;\n        width: auto;\n        height: auto;\n        border-radius: var(--border-radius);\n        justify-content: flex-start;\n        align-items: center;\n        padding: 0.625em 0;\n        width: 6em;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='is-compact']\n        > .PinturaNavMain\n        button\n        span {\n        font-size: 0.6875em;\n        margin: 0 0.625em 0 0;\n        line-height: 0;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='is-compact']\n        > .PinturaNavMain\n        button\n        svg {\n        margin: 0 0.5em 0 0.625em;\n        width: 1em;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='is-compact'][data-env~='has-navigation'] {\n        grid-template-columns: 8em auto;\n      }\n      .PinturaRoot[data-env~='landscape'][data-env~='is-compact'][data-env~='has-navigation']\n        .PinturaNavGroupFloat {\n        margin: 0 0 0 8em;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='is-compact']\n        > .PinturaNavMain\n        button {\n        padding: 0;\n        font-size: 0.625em;\n        width: 4em;\n        height: 4em;\n        justify-content: center;\n        border-radius: 9999em;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='is-compact']\n        > .PinturaNavMain\n        button\n        span {\n        visibility: hidden;\n        font-size: 0;\n        margin: 0;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='is-compact']\n        > .PinturaNavMain\n        button\n        svg {\n        margin-top: 0;\n        width: 1.6em;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='is-compact']\n        > .PinturaNavMain\n        button\n        svg\n        [stroke-width] {\n        stroke-width: 0.15em;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='narrow'] {\n        --nav-group-margin: 0.25em;\n        grid-template-rows: -webkit-min-content auto -webkit-min-content;\n        grid-template-rows: min-content auto min-content;\n        grid-template-columns: auto;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='narrow'] > * {\n        grid-column: 1;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='narrow']\n        .PinturaUtilFooter\n        .PinturaControlList\n        .PinturaControlListOption\n        span,\n      .PinturaRoot[data-env~='portrait'][data-env~='narrow']\n        .PinturaUtilFooter\n        .PinturaControlList\n        [role='tab']\n        span {\n        font-size: 0.6875em;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='narrow']\n        .PinturaToolbar\n        .PinturaToolbarInner\n        > * {\n        margin: 0 0.25em;\n      }\n      .PinturaRoot[data-env~='portrait'][data-env~='narrow'][data-env~='short']\n        .PinturaNavGroupFloat {\n        position: static;\n      }\n      .PinturaRoot[data-env~='overlay'] {\n        grid-template-rows: auto !important;\n        grid-template-columns: auto !important;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaNav {\n        z-index: 3;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaMain {\n        grid-row: 1;\n        grid-column: 1;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaUtilMain {\n        position: absolute;\n        left: 0;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        padding: 0;\n        z-index: -1;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaUtilFooter,\n      .PinturaRoot[data-env~='overlay'] .PinturaUtilHeader {\n        position: absolute;\n        left: 0;\n        right: 0;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaUtilHeader {\n        top: 0;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaUtilFooter {\n        bottom: 0;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaNavMain {\n        position: absolute;\n        right: 0;\n        top: 0;\n        bottom: 0;\n        background: none;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaNavTools {\n        position: absolute;\n        left: 0;\n        top: 0;\n        right: 0;\n      }\n      .PinturaRoot[data-env~='has-swipe-navigation'] .PinturaUtilMain {\n        padding-left: 2em;\n        padding-right: 2em;\n      }\n      .PinturaRoot[data-env*='is-disabled'],\n      .PinturaRoot[data-env*='is-disabled'] * {\n        pointer-events: none !important;\n      }\n      .PinturaRoot[data-env*='is-disabled'] {\n        --color-primary: #b4b4b4;\n        --color-primary-dark: #a0a0a0;\n        --color-primary-text: #000;\n        --color-secondary: #969696;\n        --color-secondary-dark: #646464;\n      }\n      .PinturaRoot[data-env*='is-disabled'] .PinturaCanvas,\n      .PinturaRoot[data-env*='is-disabled'] .PinturaColorPickerButton {\n        filter: grayscale(100%);\n      }\n      .PinturaRoot .PinturaEditorOverlay {\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        z-index: 3;\n        background: var(--color-background-50);\n        pointer-events: none;\n      }\n      .PinturaDropdownPanel {\n        overflow: hidden;\n        border-radius: inherit;\n      }\n      .PinturaDropdownPanel .PinturaDropdownOption {\n        transition: background-color 0.1s;\n        border-radius: inherit;\n      }\n      .PinturaDropdownPanel .PinturaDropdownOption label {\n        display: block;\n        margin: 0;\n        border-radius: inherit;\n        white-space: nowrap;\n      }\n      .PinturaDropdownPanel .PinturaDropdownOption svg {\n        margin-right: 0.25em;\n        margin-left: -0.5em;\n        min-width: 1.5em;\n      }\n      .PinturaDropdownPanel .PinturaDropdownOption [slot] {\n        display: flex;\n        align-items: center;\n        padding: 0.325em 0.75em;\n      }\n      .PinturaDropdownPanel .PinturaDropdownOptionLabel {\n        font-size: 0.75em;\n        line-height: 1.75;\n        padding: 0 0.325em;\n        margin-left: -0.325em;\n      }\n      .PinturaDropdownPanel .PinturaDropdownOptionGroup > span {\n        display: block;\n        padding: 0.75em 1em;\n        text-transform: uppercase;\n        font-size: 0.75em;\n        color: rgba(0, 0, 0, 0.75);\n      }\n      .PinturaDropdownPanel [data-disabled='true'] {\n        color: #999;\n      }\n      .PinturaDropdownPanel\n        [data-selected='false']:not([data-disabled='true']):hover {\n        background-color: rgba(0, 0, 0, 0.15);\n      }\n      .PinturaDropdownPanel [data-selected='true'] {\n        color: #fff;\n        background: #000;\n      }\n      .PinturaDropdownPanel\n        [data-focus-visible]\n        + label\n        .PinturaDropdownOptionLabel {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n        border-radius: 0.25em;\n      }\n      .PinturaDropdownOption label {\n        margin: 0;\n      }\n      .PinturaColorPickerPanel {\n        padding: 0.5em;\n        max-width: 14em;\n        overflow: visible;\n        touch-action: none;\n      }\n      .PinturaColorPickerPanel .PinturaColorPickerButton {\n        outline: transparent;\n      }\n      .PinturaColorPickerPanel .PinturaColorPickerButton[data-focus-visible] {\n        box-shadow: inset 0 0 0 1px var(--color-foreground-70);\n      }\n      .PinturaColorPickerPanel .PinturaColorPreview {\n        width: 1.25em;\n        height: 1.25em;\n        border-radius: 0.25em;\n      }\n      .PinturaColorPickerPanel .PinturaColorPreview span {\n        border-radius: 0.2em;\n        box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.25);\n      }\n      .PinturaColorPickerPanel .PinturaColorPresets legend {\n        color: #777;\n        margin: 0 0 0.25em 0.3125em;\n        font-size: 0.75em;\n      }\n      .PinturaColorPickerPanel\n        .PinturaColorPresetsGrid\n        .PinturaRadioGroupOptions {\n        display: flex;\n        flex-direction: row;\n        flex-wrap: wrap;\n      }\n      .PinturaColorPickerPanel .PinturaColorPresetsGrid .PinturaDropdownOption {\n        display: block;\n        padding: 0.25em;\n      }\n      .PinturaColorPickerPanel\n        .PinturaColorPresetsGrid\n        .PinturaDropdownOption\n        label,\n      .PinturaColorPickerPanel\n        .PinturaColorPresetsGrid\n        .PinturaDropdownOption\n        label\n        span {\n        display: block;\n        cursor: var(--button-cursor);\n      }\n      .PinturaColorPickerPanel\n        .PinturaColorPresetsGrid\n        input[data-focus-visible]\n        + label\n        .PinturaColorPreview:after {\n        position: absolute;\n        left: -0.3125em;\n        right: -0.3125em;\n        top: -0.3125em;\n        bottom: -0.3125em;\n        border-radius: inherit;\n        pointer-events: none;\n        content: '';\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaColorPickerPanel .PinturaSlider {\n        margin-left: -0.325em;\n        margin-right: -0.325em;\n      }\n      .PinturaColorPickerPanel .PinturaPicker {\n        width: 100%;\n        padding-bottom: 0.5em;\n      }\n      .PinturaColorPickerPanel .PinturaPicker .PinturaPickerKnob,\n      .PinturaColorPickerPanel .PinturaPicker .PinturaSliderKnob {\n        border-radius: 9999em;\n        box-shadow: inset 0 0.06125em 0.06125em rgba(0, 0, 0, 0.1),\n          0 0 0 0.125em #fff, 0 0.1875em 0.25em rgba(0, 0, 0, 0.35),\n          0 -0.125em 0.25em rgba(0, 0, 0, 0.1);\n      }\n      .PinturaColorPickerPanel .PinturaPicker .PinturaPickerKnob {\n        pointer-events: none;\n        position: absolute;\n        z-index: 1;\n        left: 0;\n        top: 0;\n        margin-left: -0.625em;\n        margin-top: -0.625em;\n        width: 1.25em;\n        height: 1.25em;\n        visibility: visible;\n        outline: none;\n      }\n      .PinturaColorPickerPanel\n        .PinturaPicker\n        .PinturaPickerKnob[data-focus-visible]:after {\n        position: absolute;\n        left: -0.3125em;\n        right: -0.3125em;\n        top: -0.3125em;\n        bottom: -0.3125em;\n        border-radius: inherit;\n        pointer-events: none;\n        content: '';\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaColorPickerPanel .PinturaPicker .PinturaPickerKnobController {\n        position: absolute;\n        left: 0;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        visibility: hidden;\n      }\n      .PinturaColorPickerPanel .PinturaPicker .PinturaSaturationPicker {\n        position: relative;\n        border-radius: var(--border-radius) var(--border-radius) 0 0;\n        margin: -0.5em -0.5em 0.5em;\n        height: 7em;\n        background-image: linear-gradient(180deg, transparent, #000),\n          linear-gradient(90deg, #fff, transparent);\n      }\n      .PinturaColorPickerPanel\n        .PinturaPicker\n        .PinturaHuePicker\n        .PinturaSliderTrack {\n        background-image: linear-gradient(\n          90deg,\n          red,\n          #ff0,\n          #0f0,\n          #0ff,\n          #00f,\n          #f0f,\n          red\n        );\n      }\n      .PinturaColorPickerPanel\n        .PinturaPicker\n        .PinturaOpacityPicker\n        .PinturaSliderTrack:before {\n        position: absolute;\n        content: '';\n        display: block;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        z-index: -1;\n        border-radius: inherit;\n        background-color: #fff;\n        background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='8' height='8' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h4v4H0zm4 4h4v4H4z' fill='%23E5E5E5'/%3E%3C/svg%3E\");\n      }\n      .PinturaColorPickerPanel .PinturaPicker .PinturaOpacityPicker {\n        margin-top: 0.5em;\n      }\n      .PinturaPanel[data-util='filter'] .PinturaScrollable {\n        width: 100%;\n        max-width: 40em;\n        min-height: 5.5em;\n      }\n      .PinturaPanel[data-util='filter']\n        [data-layout='row']\n        > .PinturaRadioGroupOptions\n        > li {\n        margin: 0 0.5em;\n      }\n      .PinturaPanel[data-util='filter']\n        [data-layout='row']\n        > .PinturaRadioGroupOptions\n        > li:first-of-type {\n        margin-left: 0;\n      }\n      .PinturaPanel[data-util='filter']\n        [data-layout='row']\n        > .PinturaRadioGroupOptions\n        > li:last-child {\n        margin-right: 0;\n      }\n      .PinturaPanel[data-util='filter'] .PinturaRadioGroupOptionGroupLabel {\n        width: 1px;\n        height: 1px;\n        position: absolute;\n        font-size: 0;\n        pointer-events: none;\n      }\n      .PinturaPanel[data-util='filter'] .PinturaFilterPreview {\n        border-radius: 0;\n        transition: border-radius 1ms;\n      }\n      .PinturaPanel[data-util='filter'] .PinturaFilterOption {\n        border-radius: 0;\n      }\n      .PinturaPanel[data-util='filter']\n        .PinturaRadioGroupOptions\n        .PinturaRadioGroupOption:first-of-type\n        .PinturaFilterPreview {\n        border-top-left-radius: var(--border-radius);\n        border-bottom-left-radius: var(--border-radius);\n      }\n      .PinturaPanel[data-util='filter']\n        .PinturaRadioGroupOptions\n        .PinturaRadioGroupOption:first-of-type\n        .PinturaFilterOption {\n        border-bottom-left-radius: var(--border-radius);\n      }\n      .PinturaPanel[data-util='filter']\n        .PinturaRadioGroupOptions\n        .PinturaRadioGroupOption:last-of-type\n        .PinturaFilterPreview {\n        border-top-right-radius: var(--border-radius);\n        border-bottom-right-radius: var(--border-radius);\n      }\n      .PinturaPanel[data-util='filter']\n        .PinturaRadioGroupOptions\n        .PinturaRadioGroupOption:last-of-type\n        .PinturaFilterOption {\n        border-bottom-right-radius: var(--border-radius);\n      }\n      .PinturaPanel[data-util='filter'] .PinturaRadioGroupOptionGroup {\n        display: flex;\n        flex-direction: column-reverse;\n      }\n      .PinturaPanel[data-util='filter'] .PinturaFilterOption {\n        cursor: var(--button-cursor);\n        margin-bottom: 1em;\n      }\n      .PinturaPanel[data-util='filter'] .PinturaFilterOption span {\n        display: block;\n        text-align: center;\n        padding: 0 0.3125em;\n        line-height: 1.75;\n        max-width: 100%;\n        font-size: 0.625em;\n        font-weight: 400;\n        margin-left: 1px;\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n      }\n      .PinturaPanel[data-util='filter'] .PinturaFilterPreview:before {\n        transition: background-color 0.1s, color 0.1s;\n      }\n      .PinturaPanel[data-util='filter']\n        [data-selected='true']\n        .PinturaFilterOption\n        .PinturaFilterPreview {\n        position: relative;\n        z-index: 1;\n      }\n      .PinturaPanel[data-util='filter']\n        [data-selected='true']\n        .PinturaFilterOption\n        .PinturaFilterPreview:before {\n        content: '';\n        position: absolute;\n        width: 100%;\n        height: 100%;\n        opacity: 0.35;\n        border-radius: inherit;\n        background-color: var(--color-primary);\n      }\n      .PinturaPanel[data-util='filter']\n        [data-focus-visible]\n        + label\n        > .PinturaFilterOption\n        span {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n        border-radius: 0.25em;\n      }\n      .PinturaPanel[data-util='filter'] .PinturaFilterOption,\n      .PinturaPanel[data-util='filter'] .PinturaFilterPreview {\n        width: 3.75em;\n        height: 4.5em;\n      }\n      .PinturaRoot[data-env~='is-compact']\n        .PinturaPanel[data-util='filter']\n        .PinturaUtilFooter\n        > div {\n        padding: 0;\n      }\n      .PinturaRoot[data-env~='is-compact']\n        .PinturaPanel[data-util='filter']\n        .PinturaFilterOption,\n      .PinturaRoot[data-env~='is-compact']\n        .PinturaPanel[data-util='filter']\n        .PinturaFilterPreview {\n        width: 2.875em;\n        height: 3.5em;\n      }\n      .PinturaRoot[data-env~='is-compact']\n        .PinturaPanel[data-util='filter']\n        .PinturaFilterOption\n        span {\n        font-size: 0.5em;\n      }\n      .PinturaRoot[data-env~='is-compact']\n        .PinturaPanel[data-util='filter']\n        .PinturaScrollable {\n        min-height: 4.5em;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaShapeStyleEditor {\n        min-height: 3.375em;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption {\n        margin: 1em 1em 0 0;\n        padding: 0.125em;\n        border: 1px dashed var(--color-foreground-15);\n        color: var(--color-foreground-70);\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption span {\n        color: var(--color-foreground-90);\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption label {\n        font-size: 0.75em;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption img,\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption svg {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        -o-object-fit: contain;\n        object-fit: contain;\n      }\n      .PinturaPanel[data-util='frame'] [data-selected='true'] {\n        border-color: var(--color-primary);\n        color: var(--color-primary);\n      }\n      .PinturaPanel[data-util='frame'] [data-selected='true'] span {\n        color: var(--color-foreground-90);\n      }\n      .PinturaPanel[data-util='frame']\n        [data-layout='row']\n        > .PinturaRadioGroupOptions\n        > li {\n        margin: 0 0.5em;\n      }\n      .PinturaPanel[data-util='frame']\n        [data-layout='row']\n        > .PinturaRadioGroupOptions\n        > li:first-of-type {\n        margin-left: 0;\n      }\n      .PinturaPanel[data-util='frame']\n        [data-layout='row']\n        > .PinturaRadioGroupOptions\n        > li:last-child {\n        margin-right: 0;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOptionGroupLabel {\n        width: 1px;\n        height: 1px;\n        position: absolute;\n        font-size: 0;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOptionGroup {\n        display: flex;\n        flex-direction: column-reverse;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption {\n        cursor: var(--button-cursor);\n        margin-bottom: 1em;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption span {\n        display: block;\n        text-align: center;\n        padding: 0 1.5em;\n        font-size: 0.625em;\n        font-weight: 400;\n      }\n      .PinturaPanel[data-util='frame']\n        [data-focus-visible]\n        + label\n        > .PinturaRadioGroupOption\n        span {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n        border-radius: 0.25em;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption {\n        position: relative;\n        width: 3em;\n        height: 4em;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption div {\n        position: absolute;\n        outline-color: currentColor;\n        border-color: currentColor;\n      }\n      .PinturaPanel[data-util='frame'] .PinturaRadioGroupOption div[slot] {\n        overflow: hidden;\n        left: -1px;\n        top: -1px;\n        bottom: -1px;\n        right: -1px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n      }\n      .PinturaRoot[data-env~='is-compact']\n        .PinturaPanel[data-util='frame']\n        .PinturaUtilFooter\n        > div {\n        padding: 0;\n      }\n      .PinturaRoot[data-env~='is-compact']\n        .PinturaPanel[data-util='frame']\n        .PinturaRadioGroupOption {\n        width: 2.25em;\n        height: 3em;\n      }\n      .PinturaRoot[data-env~='is-compact']\n        .PinturaPanel[data-util='frame']\n        .PinturaRadioGroupOption\n        span {\n        font-size: 0.5em;\n      }\n      .PinturaPanel[data-util='crop'] .PinturaStage {\n        touch-action: none;\n      }\n      .PinturaPanel[data-util='crop'] .PinturaImageInfo {\n        position: absolute;\n        right: 1em;\n        bottom: 1em;\n      }\n      .PinturaPanel[data-util='crop'] .PinturaButtonCenter {\n        --size: 3em;\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: var(--size);\n        height: var(--size);\n        z-index: 1;\n        line-height: 0;\n        margin-top: calc(var(--size) * (-0.5));\n        margin-left: calc(var(--size) * (-0.5));\n        overflow: hidden;\n        color: #000;\n        background: hsla(0, 0%, 100%, 0.8);\n        border-radius: 50%;\n        -webkit-backdrop-filter: var(--backdrop-filter-bright);\n        backdrop-filter: var(--backdrop-filter-bright);\n        outline: none;\n      }\n      .PinturaPanel[data-util='crop'] .PinturaButtonCenter[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaRoot[data-env~='short']\n        .PinturaPanel[data-util='crop']\n        .PinturaUtilFooter {\n        padding-bottom: 0.5em;\n      }\n      .PinturaPanel[data-util='resize'] form {\n        display: flex;\n        justify-content: center;\n        padding: 0 1em;\n      }\n      .PinturaPanel[data-util='resize'] .PinturaFormInner {\n        position: relative;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n      }\n      .PinturaPanel[data-util='resize'] .PinturaFormInner > button {\n        position: absolute;\n        left: 100%;\n        margin-left: 1em;\n      }\n      .PinturaPanel[data-util='resize'] .PinturaFieldsetInner {\n        display: inline-flex;\n        align-items: center;\n        justify-content: center;\n      }\n      .PinturaPanel[data-util='resize'] .PinturaResizeLabel {\n        font-size: 0.75em;\n      }\n      .PinturaPanel[data-util='resize'] .PinturaDropdownButton {\n        margin-left: 0.5em;\n        margin-right: 0.5em;\n        -webkit-backdrop-filter: var(--backdrop-filter-dark);\n        backdrop-filter: var(--backdrop-filter-dark);\n        background-color: var(--color-foreground-5);\n        border-radius: var(--border-radius-round);\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n        transition: background-color 0.1s;\n      }\n      .PinturaPanel[data-util='resize'] .PinturaDropdownButton:hover {\n        background-color: var(--color-foreground-10);\n      }\n      .PinturaPanel[data-util='resize']\n        .PinturaDropdownButton\n        .PinturaButtonLabel {\n        display: block;\n        line-height: 2.65;\n        padding: 0 1em;\n        font-variant-numeric: tabular-nums;\n        font-size: 0.75em;\n        font-weight: 400;\n      }\n      .PinturaPanel[data-util='resize']\n        .PinturaDropdownButton\n        .PinturaButtonLabel:after {\n        content: '\u25BC';\n        font-size: 0.6875em;\n        margin-left: 0.75em;\n        position: relative;\n        top: -0.125em;\n        margin-right: -0.25em;\n        pointer-events: none;\n      }\n      .PinturaPanel[data-util='resize'] input[type='checkbox'] + label {\n        padding: 0 0.125em;\n        outline: transparent;\n        display: block;\n        cursor: pointer;\n      }\n      .PinturaPanel[data-util='resize']\n        input[type='checkbox'][data-focus-visible]\n        + label {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaInputDimension {\n        display: inline-flex;\n        align-items: center;\n        position: relative;\n      }\n      .PinturaInputDimension label {\n        position: absolute;\n        right: 0.625em;\n        font-size: 0.75em;\n        text-transform: uppercase;\n        pointer-events: none;\n        color: var(--color-foreground-20);\n        z-index: 1;\n      }\n      .PinturaInputDimension button,\n      .PinturaInputDimension input,\n      .PinturaInputDimension label {\n        font-size: 0.75em;\n        font-weight: 400;\n      }\n      .PinturaInputDimension button,\n      .PinturaInputDimension input {\n        -webkit-appearance: none;\n        appearance: none;\n        -moz-appearance: textfield;\n        box-sizing: border-box;\n        font-variant-numeric: tabular-nums;\n        padding: 0.625em 0 0.625em 0.625em;\n        width: 100%;\n        max-width: 7em;\n        outline: transparent;\n        border-radius: var(--border-radius);\n        box-shadow: none;\n        border: 1px solid var(--color-foreground-20);\n        transition: background-color 0.1s ease-in-out, color 0.1s ease-in-out,\n          border-color 0.1s ease-in-out;\n      }\n      .PinturaInputDimension button::-moz-selection,\n      .PinturaInputDimension input::-moz-selection {\n        background-color: var(--color-foreground-20);\n      }\n      .PinturaInputDimension button::selection,\n      .PinturaInputDimension input::selection {\n        background-color: var(--color-foreground-20);\n      }\n      .PinturaInputDimension button:hover,\n      .PinturaInputDimension input:hover {\n        border-color: var(--color-foreground-30);\n      }\n      .PinturaInputDimension button:focus,\n      .PinturaInputDimension input:focus {\n        border-color: var(--color-focus-100);\n      }\n      .PinturaInputDimension input {\n        -webkit-backdrop-filter: var(--backdrop-filter-dark);\n        backdrop-filter: var(--backdrop-filter-dark);\n        background-color: var(--color-foreground-5);\n      }\n      .PinturaInputDimension input:-moz-placeholder-shown {\n        border-style: dashed;\n      }\n      .PinturaInputDimension input:-ms-input-placeholder {\n        border-style: dashed;\n      }\n      .PinturaInputDimension input:placeholder-shown {\n        border-style: dashed;\n      }\n      .PinturaInputDimension input::-moz-placeholder {\n        color: var(--color-foreground-30);\n      }\n      .PinturaInputDimension input:-ms-input-placeholder {\n        color: var(--color-foreground-30);\n      }\n      .PinturaInputDimension input::placeholder {\n        color: var(--color-foreground-30);\n      }\n      .PinturaInputDimension input[data-state='invalid'] {\n        border-color: var(--color-error-75);\n        box-shadow: inset 0 0 0.25em var(--color-error-25),\n          0 0 0.25em var(--color-error-50);\n      }\n      .PinturaInputDimension button {\n        width: 10em;\n        min-height: 2.65em;\n      }\n      .PinturaInputDimension input::-webkit-inner-spin-button,\n      .PinturaInputDimension input::-webkit-outer-spin-button {\n        -webkit-appearance: none;\n      }\n      .PinturaInputDimension input::-ms-clear {\n        display: none;\n      }\n      .PinturaModal {\n        --safe-area-inset-top: env(safe-area-inset-top);\n        --safe-area-inset-bottom: env(safe-area-inset-bottom);\n        --editor-modal-border-radius: 0;\n        --editor-modal-overlay-opacity: 0.95;\n        --editor-modal-shadow: 0 1em 2em -1em rgba(0, 0, 0, 0.25),\n          0 1.5em 1.5em -2em rgba(0, 0, 0, 0.5);\n        --editor-modal-outline: inset 0 0 0 1px var(--color-foreground-3);\n        position: fixed;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100vh;\n        z-index: 2147483646;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        background-color: rgba(\n          var(--color-background),\n          var(\n            --editor-modal-overlay-opacity,\n            var(--editor-modal-overlay-opacity-default, 0.95)\n          )\n        );\n      }\n      .PinturaModal > .PinturaRoot[data-env~='is-centered'] {\n        box-shadow: var(--editor-modal-shadow);\n        border-radius: var(--editor-modal-border-radius);\n      }\n      .PinturaModal > .PinturaRoot[data-env~='is-centered']:after {\n        position: absolute;\n        left: 0;\n        top: 0;\n        bottom: 0;\n        right: 0;\n        pointer-events: none;\n        border-radius: inherit;\n        content: '';\n        box-shadow: var(--editor-modal-outline);\n        z-index: 2147483646;\n      }\n      .PinturaModal[style*='--viewport-pad-footer:1'] {\n        box-sizing: border-box;\n        padding-bottom: 44px;\n      }\n      .PinturaModal + .PinturaModal {\n        --editor-modal-overlay-opacity-default: 0.75;\n      }\n      .PinturaModal + .PinturaModal .PinturaRoot:not([data-env~='is-compact']) {\n        --editor-max-width-default: calc(100vw - 8em);\n        --editor-max-height-default: calc(100vh - 8em);\n      }\n      .PinturaCanvas canvas {\n        display: block;\n        width: 100%;\n        height: 100%;\n        position: absolute;\n      }\n      .PinturaDetailsPanel {\n        position: absolute;\n        top: 0;\n        left: 0;\n        z-index: 2147483647;\n        width: -webkit-max-content;\n        width: -moz-max-content;\n        width: max-content;\n        cursor: auto;\n        outline: transparent;\n        box-shadow: 0 0.125em 0.25em rgba(0, 0, 0, 0.25),\n          0 0.125em 0.75em rgba(0, 0, 0, 0.15),\n          0 0.125em 0.125em rgba(0, 0, 0, 0.1);\n        border-radius: var(--border-radius);\n        color: #111;\n        background: #fff;\n      }\n      .PinturaDetailsPanelTip {\n        position: absolute;\n        width: 0.5em;\n        height: 0.5em;\n        margin-left: -0.25em;\n        margin-top: -0.25em;\n        background: #fff;\n        z-index: -1;\n      }\n      .PinturaScrollable {\n        --scrollable-feather-start-opacity: 0;\n        --scrollable-feather-end-opacity: 0;\n        --scrollable-feather-size: 2em;\n        contain: paint;\n        overflow: hidden;\n      }\n      .PinturaScrollable:focus {\n        outline: transparent;\n      }\n      .PinturaScrollable > div {\n        position: relative;\n        display: inline-flex;\n        vertical-align: top;\n      }\n      .PinturaScrollable {\n        touch-action: none;\n      }\n      .PinturaScrollable[data-direction='x'] {\n        max-width: 100%;\n        --mask-angle: 90deg;\n      }\n      .PinturaScrollable[data-direction='y'] {\n        max-height: 100%;\n        --mask-angle: 180deg;\n      }\n      .PinturaScrollable[data-state~='overflows'] {\n        -webkit-mask: linear-gradient(\n          var(--mask-angle),\n          rgba(0, 0, 0, var(--scrollable-feather-start-opacity)),\n          #000 var(--scrollable-feather-size),\n          #000 calc(100% - var(--scrollable-feather-size)),\n          rgba(0, 0, 0, var(--scrollable-feather-end-opacity))\n        );\n        mask: linear-gradient(\n          var(--mask-angle),\n          rgba(0, 0, 0, var(--scrollable-feather-start-opacity)),\n          #000 var(--scrollable-feather-size),\n          #000 calc(100% - var(--scrollable-feather-size)),\n          rgba(0, 0, 0, var(--scrollable-feather-end-opacity))\n        );\n      }\n      .PinturaScrollable[data-state~='scrolling'] > div * {\n        pointer-events: none;\n      }\n      .PinturaTabPanels {\n        position: relative;\n        flex: 1;\n      }\n      .PinturaTabPanel {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n      }\n      .PinturaTabPanel:not([hidden]) {\n        z-index: 2;\n        outline: transparent;\n      }\n      .PinturaTabPanel[hidden] {\n        display: block !important;\n        z-index: 1;\n        pointer-events: none;\n      }\n      .PinturaTabPanel[data-inert='true'] {\n        visibility: hidden;\n      }\n      .PinturaTabPanel[data-inert='true'] [data-inert] {\n        visibility: hidden !important;\n      }\n      .PinturaTabList {\n        display: flex;\n        justify-content: center;\n      }\n      .PinturaTabList button {\n        display: flex;\n        align-items: center;\n        flex-direction: column;\n        outline: transparent;\n        cursor: var(--button-cursor);\n        -webkit-tap-highlight-color: transparent;\n      }\n      .PinturaTabList button > * {\n        transition: filter 0.2s ease-out;\n      }\n      .PinturaTabList button[disabled] > * {\n        filter: var(--filter-disabled);\n      }\n      .PinturaPanel {\n        position: relative;\n        z-index: 1;\n        height: 100%;\n        display: flex;\n        flex: 1;\n        flex-direction: column;\n        contain: layout size;\n      }\n      .PinturaProgressIndicator {\n        position: relative;\n        display: block;\n        width: 1.25em;\n        height: 1.25em;\n      }\n      .PinturaProgressIndicator .PinturaProgressIndicatorFill {\n        stroke-dashoffset: 0;\n      }\n      .PinturaProgressIndicator[data-status='busy'] svg {\n        -webkit-animation: image_editor_spin 1s linear infinite;\n        animation: image_editor_spin 1s linear infinite;\n      }\n      .PinturaProgressIndicator[data-status='busy']\n        .PinturaProgressIndicatorFill {\n        stroke-dashoffset: -26.5;\n        stroke-dasharray: 26.5 53;\n        transition: stroke-dashoffset 0.5s linear, stroke-dasharray 0.5s linear;\n      }\n      @-webkit-keyframes image_editor_spin {\n        0% {\n          transform: rotate(0deg);\n        }\n        to {\n          transform: rotate(1turn);\n        }\n      }\n      @keyframes image_editor_spin {\n        0% {\n          transform: rotate(0deg);\n        }\n        to {\n          transform: rotate(1turn);\n        }\n      }\n      @media only screen and (-webkit-min-device-pixel-ratio: 3) {\n        .PinturaRoot[data-env~='is-ios'] .PinturaProgressIndicator svg {\n          transform-origin: 49% 49%;\n        }\n      }\n      .PinturaButton {\n        white-space: nowrap;\n        flex-shrink: 0;\n        -webkit-tap-highlight-color: transparent;\n        cursor: var(--button-cursor);\n      }\n      .PinturaButton > span {\n        display: inline-flex;\n        align-items: center;\n        vertical-align: top;\n        min-height: 1em;\n      }\n      .PinturaButton svg + .PinturaButtonLabel {\n        margin-left: 0.5em;\n      }\n      .PinturaButton[disabled] {\n        cursor: default;\n      }\n      .PinturaButton:not(.PinturaButtonIconOnly) svg:first-of-type {\n        margin-left: -0.25em;\n      }\n      .PinturaColorPreview {\n        --color: transparent;\n        color: var(--color);\n        position: relative;\n        pointer-events: none;\n        background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='8' height='8' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h4v4H0zm4 4h4v4H4z' fill='%23E5E5E5'/%3E%3C/svg%3E\");\n      }\n      .PinturaColorPreview span {\n        position: absolute;\n        left: 0;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        background-color: var(--color);\n        border-radius: inherit;\n      }\n      .PinturaSlider {\n        position: relative;\n        --track-offset-x: 0.5em;\n        --track-offset-y: 0.5em;\n        --track-size: 1.5em;\n        --knob-size: 1em;\n        --knob-margin-top: 0em;\n        --knob-margin-right: 0em;\n        --knob-margin-bottom: 0em;\n        --knob-margin-left: 0em;\n        display: flex;\n        align-items: center;\n        touch-action: none;\n      }\n      .PinturaSlider[data-direction='y'] {\n        flex-direction: column;\n      }\n      .PinturaSlider .PinturaSliderControl {\n        position: relative;\n        flex: 1;\n      }\n      .PinturaSlider > button {\n        position: relative;\n        z-index: 1;\n        width: var(--track-size);\n        height: var(--track-size);\n        overflow: hidden;\n        cursor: pointer;\n        flex-shrink: none;\n      }\n      .PinturaSlider > button svg {\n        width: 1.25em;\n        height: 1.25em;\n        margin: 0.125em;\n        stroke-width: 0.125em;\n        stroke: #aaa;\n      }\n      .PinturaSlider > button:first-of-type {\n        order: 2;\n        padding-right: 0.125em;\n        margin-left: -0.325em;\n      }\n      .PinturaSlider > button:last-of-type {\n        order: 1;\n        padding-left: 0.125em;\n        margin-right: -0.325em;\n      }\n      .PinturaSlider > .PinturaSliderControl {\n        order: 2;\n      }\n      .PinturaSlider .PinturaSliderKnob {\n        left: 0;\n        top: 50%;\n        border-radius: 9999em;\n        visibility: visible;\n        background-color: #333;\n        width: var(--knob-size);\n        height: var(--knob-size);\n        margin-left: calc(var(--knob-size) * -0.5);\n        margin-top: calc(var(--knob-size) * -0.5);\n      }\n      .PinturaSlider .PinturaSliderKnob,\n      .PinturaSlider .PinturaSliderKnobController,\n      .PinturaSlider .PinturaSliderTrack {\n        pointer-events: none;\n        position: absolute;\n      }\n      .PinturaSlider .PinturaSliderTrack {\n        top: var(--track-offset-y);\n        bottom: var(--track-offset-y);\n        left: var(--track-offset-x);\n        right: var(--track-offset-x);\n      }\n      .PinturaSlider .PinturaSliderKnobController {\n        visibility: hidden;\n        top: calc(var(--track-offset-y) + var(--knob-margin-top));\n        bottom: calc(var(--track-offset-y) + var(--knob-margin-bottom));\n        left: calc(var(--track-offset-x) + var(--knob-margin-left));\n        right: calc(var(--track-offset-x) + var(--knob-margin-right));\n      }\n      .PinturaSlider .PinturaSliderTrack {\n        border-radius: 9999em;\n      }\n      .PinturaSlider[data-direction='x'] input[type='range'] {\n        height: var(--track-size);\n        margin-left: 0.5em;\n        width: calc(100% - 1em);\n      }\n      .PinturaSlider[data-direction='y'] input[type='range'] {\n        width: var(--track-size);\n        margin-top: 0.5em;\n        height: calc(100% - 1em);\n      }\n      .PinturaSlider input[type='range'] {\n        -webkit-appearance: none;\n        display: block;\n      }\n      .PinturaSlider input[type='range']::-webkit-slider-runnable-track {\n        background: transparent;\n      }\n      .PinturaSlider input[type='range']::-webkit-slider-thumb {\n        -webkit-appearance: none;\n        line-height: 0;\n        margin: 0;\n        padding: 0;\n        border: none;\n      }\n      .PinturaSlider input[type='range']::-moz-range-thumb {\n        line-height: 0;\n        margin: 0;\n        padding: 0;\n        border: none;\n      }\n      .PinturaSlider input[type='range']::-ms-thumb {\n        line-height: 0;\n        margin: 0;\n        padding: 0;\n        border: none;\n      }\n      .PinturaSlider input[type='range']::-ms-ticks-before,\n      .PinturaSlider input[type='range']::-ms-tooltip {\n        display: none;\n      }\n      .PinturaSlider input[type='range']::-ms-ticks-after {\n        display: none;\n      }\n      .PinturaSlider input[type='range']::-ms-track {\n        color: transparent;\n        border: none;\n        background: transparent;\n      }\n      .PinturaSlider input[type='range']::-ms-fill-lower,\n      .PinturaSlider input[type='range']::-ms-fill-upper {\n        background: transparent;\n      }\n      .PinturaSlider input[type='range']:focus {\n        outline: transparent;\n      }\n      .PinturaSlider\n        input[type='range'][data-focus-visible]\n        ~ .PinturaSliderKnobController\n        .PinturaSliderKnob:after {\n        position: absolute;\n        left: -0.3125em;\n        right: -0.3125em;\n        top: -0.3125em;\n        bottom: -0.3125em;\n        border-radius: inherit;\n        content: '';\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n        pointer-events: none;\n      }\n      .PinturaRangeInput {\n        position: relative;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        width: 24em;\n        height: 3.5em;\n        margin: auto;\n        max-width: 90%;\n        touch-action: none;\n        --range-input-feather-left: 2em;\n        --range-input-feather-right: 2em;\n        --range-input-mask-from: 0%;\n        --range-input-mask-to: 100%;\n        --range-input-mask-color: rgba(0, 0, 0, 0.25);\n        --range-input-line-color: var(--color-foreground-15);\n        outline: transparent;\n      }\n      .PinturaRangeInput[data-focus-visible]:after {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n        content: '';\n        position: absolute;\n        left: 0;\n        right: 0;\n        top: calc(50% - 1em);\n        height: 2em;\n        border-radius: 0.25em;\n      }\n      .PinturaRangeInputInner {\n        position: relative;\n        overflow: hidden;\n        height: 100%;\n        width: 100%;\n        contain: strict;\n        -webkit-mask: linear-gradient(\n          90deg,\n          transparent 0,\n          #000 var(--range-input-feather-left),\n          #000 calc(50% - 3em),\n          transparent 50%,\n          #000 calc(50% + 3em),\n          #000 calc(100% - var(--range-input-feather-right)),\n          transparent\n        );\n        mask: linear-gradient(\n          90deg,\n          transparent 0,\n          #000 var(--range-input-feather-left),\n          #000 calc(50% - 3em),\n          transparent 50%,\n          #000 calc(50% + 3em),\n          #000 calc(100% - var(--range-input-feather-right)),\n          transparent\n        );\n      }\n      .PinturaRangeInputMeter {\n        height: 100%;\n      }\n      .PinturaRangeInput .PinturaRangeInputMeter svg {\n        display: block;\n        pointer-events: none;\n        fill: currentColor;\n      }\n      .PinturaRangeInput > .PinturaRangeInputValue {\n        position: absolute;\n        z-index: 1;\n        pointer-events: none;\n        top: calc(50% - 0.6875em);\n        left: calc(50% - 1.75em);\n        width: 3.5em;\n        height: 1.5em;\n        overflow: hidden;\n        contain: strict;\n        text-align: center;\n        font-size: 0.75em;\n        font-variant-numeric: tabular-nums;\n        font-feature-settings: 'tnum';\n        font-family: Tahoma, Geneva, Verdana, sans-serif;\n      }\n      .PinturaRangeInput > .PinturaRangeInputReset {\n        position: absolute;\n        left: calc(50% - 1.0625em);\n        top: 0;\n        margin-top: 0.125em;\n        padding: 0;\n        z-index: 1;\n        width: 2em;\n        overflow: hidden;\n        color: transparent !important;\n        transition: opacity 0.25s;\n        opacity: 0.35;\n        outline: transparent;\n        cursor: var(--button-cursor);\n      }\n      .PinturaRangeInput > .PinturaRangeInputReset:hover {\n        opacity: 0.5;\n      }\n      .PinturaRangeInput > .PinturaRangeInputReset[data-focus-visible] {\n        opacity: 1;\n      }\n      .PinturaRangeInput > .PinturaRangeInputReset[data-focus-visible]:before {\n        content: '';\n        pointer-events: none;\n        position: absolute;\n        left: calc(50% - 0.5em);\n        top: calc(50% - 0.5em);\n        height: 1em;\n        width: 1em;\n        z-index: 2;\n        border-radius: 0.25em;\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaRangeInput > .PinturaRangeInputReset[disabled] {\n        opacity: 0.15;\n      }\n      .PinturaRangeInput > .PinturaRangeInputReset:after {\n        content: '';\n        position: absolute;\n        left: 50%;\n        top: 20%;\n        width: 1px;\n        height: 60%;\n        background: var(--color-foreground-100);\n      }\n      .PinturaRangeInputInner[data-value-limited] svg {\n        -webkit-mask: linear-gradient(\n          90deg,\n          var(--range-input-mask-color) var(--range-mask-from),\n          #000 var(--range-mask-from),\n          #000 var(--range-mask-to),\n          var(--range-input-mask-color) var(--range-mask-to)\n        );\n        mask: linear-gradient(\n          90deg,\n          var(--range-input-mask-color) var(--range-mask-from),\n          #000 var(--range-mask-from),\n          #000 var(--range-mask-to),\n          var(--range-input-mask-color) var(--range-mask-to)\n        );\n      }\n      .PinturaRangeInputInner[data-value-limited] svg rect {\n        x: var(--range-mask-from);\n        width: calc(var(--range-mask-to) - var(--range-mask-from));\n        fill: var(--range-input-line-color);\n      }\n      .PinturaUtilMain {\n        padding: 1em;\n        min-height: 1px;\n      }\n      .PinturaUtilMain,\n      .PinturaUtilMain > [slot] {\n        flex: 1;\n        display: flex;\n        flex-direction: column;\n      }\n      .PinturaUtilMain > [slot] {\n        align-items: center;\n      }\n      .PinturaUtilFooter {\n        padding: 0 0 1em;\n      }\n      .PinturaUtilFooter > [slot]:empty {\n        height: 1em;\n      }\n      .PinturaUtilFooter > [slot] {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: stretch;\n      }\n      .PinturaUtilFooter .PinturaRangeInput {\n        margin-top: -0.25em;\n      }\n      .PinturaUtilFooter > [slot] > .PinturaControlList,\n      .PinturaUtilFooter > [slot] > .PinturaControlListScroller {\n        order: 1;\n        margin-bottom: -0.1875em;\n      }\n      .PinturaUtilFooter\n        .PinturaControlList\n        [role='tab'][aria-selected='true']\n        button {\n        -webkit-backdrop-filter: var(--backdrop-filter-dark);\n        backdrop-filter: var(--backdrop-filter-dark);\n        background-color: var(--color-foreground-10);\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaUtilFooter .PinturaControlList .PinturaControlListOption label,\n      .PinturaUtilFooter .PinturaControlList [role='tab'] button {\n        flex-direction: row;\n        line-height: 1;\n        padding: 0 0.75em;\n        min-height: 1.75em;\n        border-radius: var(--border-radius-round);\n        transition: background-color 0.1s ease-out, color 0.1s ease-out,\n          filter 0.2s ease-out;\n        box-shadow: inset 0 0 0 1px var(--color-foreground-0);\n        cursor: var(--button-cursor);\n      }\n      .PinturaUtilFooter\n        .PinturaControlList\n        .PinturaControlListOption\n        label\n        span,\n      .PinturaUtilFooter .PinturaControlList [role='tab'] button span {\n        font-size: 0.75em;\n        font-weight: 400;\n      }\n      .PinturaUtilFooter\n        .PinturaControlList\n        .PinturaControlListOption\n        label\n        svg,\n      .PinturaUtilFooter .PinturaControlList [role='tab'] button svg {\n        width: 0.875em;\n        font-size: 0.875em;\n      }\n      .PinturaUtilFooter\n        .PinturaControlList\n        .PinturaControlListOption\n        label\n        svg:not(:only-child),\n      .PinturaUtilFooter\n        .PinturaControlList\n        [role='tab']\n        button\n        svg:not(:only-child) {\n        margin-left: -0.25em;\n        margin-right: 0.375em;\n      }\n      .PinturaUtilFooter\n        .PinturaControlList\n        .PinturaControlListOption\n        label:hover,\n      .PinturaUtilFooter .PinturaControlList [role='tab'] button:hover {\n        box-shadow: inset 0 0 0 1px var(--color-foreground-10);\n      }\n      .PinturaUtilFooter\n        .PinturaControlList\n        .PinturaControlListOption\n        label[data-focus-visible],\n      .PinturaUtilFooter\n        .PinturaControlList\n        [role='tab']\n        button[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaUtilFooter .PinturaControlListOption [slot],\n      .PinturaUtilFooter .PinturaControlListOption label {\n        display: flex;\n        flex-direction: row;\n        align-items: center;\n      }\n      .PinturaUtilFooter .PinturaControlListOption[data-selected='true'] label {\n        background-color: var(--color-foreground-10);\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaUtilFooter\n        .PinturaControlListOption\n        input[data-focus-visible]\n        + label {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaUtilFooter .PinturaControlListOption input[disabled] + label {\n        filter: var(--filter-disabled);\n      }\n      .PinturaUtilFooter\n        .PinturaControlList\n        .PinturaControlListOption\n        + .PinturaControlListOption,\n      .PinturaUtilFooter .PinturaControlList > li + li {\n        margin-left: 0.5em;\n      }\n      .PinturaUtilFooter .PinturaControlPanels {\n        position: relative;\n        width: 100%;\n        max-width: 30em;\n        min-height: 3.375em;\n        margin: 0 auto;\n        flex: auto;\n      }\n      .PinturaUtilFooter .PinturaControlPanel {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        visibility: visible;\n        opacity: 1;\n      }\n      .PinturaUtilFooter .PinturaControlPanel[hidden] {\n        display: block !important;\n        visibility: hidden;\n        transition-delay: 0s;\n        pointer-events: none;\n        opacity: 0;\n      }\n      .PinturaUtilFooter .PinturaControlList[data-layout='compact'] > * + * {\n        margin-left: -1px;\n      }\n      .PinturaUtilFooter\n        .PinturaControlList[data-layout='compact']\n        > [role='tab']\n        button {\n        padding-left: 0.625em;\n        padding-right: 0.625em;\n        border-radius: 0;\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaUtilFooter\n        .PinturaControlList[data-layout='compact']\n        > [role='tab']:only-child\n        button {\n        border-radius: var(--border-radius-round);\n      }\n      .PinturaUtilFooter\n        .PinturaControlList[data-layout='compact']\n        > [role='tab']:first-of-type:not(:only-child)\n        button {\n        padding-left: 0.75em;\n        border-top-left-radius: var(--border-radius-round);\n        border-bottom-left-radius: var(--border-radius-round);\n      }\n      .PinturaUtilFooter\n        .PinturaControlList[data-layout='compact']\n        > [role='tab']:last-child:not(:only-child)\n        button {\n        padding-right: 0.75em;\n        border-top-right-radius: var(--border-radius-round);\n        border-bottom-right-radius: var(--border-radius-round);\n      }\n      .PinturaRoot[data-env~='is-animated']\n        .PinturaUtilFooter\n        .PinturaControlPanel {\n        transition: opacity 0.3s ease-in-out, visibility 0.3s linear;\n        transition-delay: 0.1s;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaUtilFooter {\n        margin-bottom: 0.75em;\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaControlPanels {\n        min-height: 1.375em;\n        max-width: 20em;\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaUtilFooter .PinturaControlList {\n        margin-top: 1em;\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaControlList\n        > li\n        + li {\n        margin-left: 0;\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaControlList\n        li[role='tab']\n        span {\n        font-size: 0.75em;\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaControlList\n        li[role='tab']\n        button {\n        border-radius: 0;\n        background-color: var(--color-background-50);\n        -webkit-backdrop-filter: var(--backdrop-filter-bright);\n        backdrop-filter: var(--backdrop-filter-bright);\n        box-shadow: inset 0 0 0 1px var(--color-background-15),\n          0 0.0625em 0.125em rgba(0, 0, 0, 0.25),\n          0 0.125em 0.35em rgba(0, 0, 0, 0.35);\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaControlList\n        li[role='tab']:first-of-type\n        button {\n        padding-left: 0.875em;\n        border-top-left-radius: var(--border-radius-round);\n        border-bottom-left-radius: var(--border-radius-round);\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaControlList\n        li[role='tab']:last-child\n        button {\n        padding-right: 0.875em;\n        border-top-right-radius: var(--border-radius-round);\n        border-bottom-right-radius: var(--border-radius-round);\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaControlList\n        li:not([aria-selected='true'])\n        span {\n        color: var(--color-foreground-40);\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaControlPanels {\n        background-color: var(--color-background-50);\n        -webkit-backdrop-filter: var(--backdrop-filter-bright);\n        backdrop-filter: var(--backdrop-filter-bright);\n        border-radius: var(--border-radius-round);\n        box-shadow: inset 0 0 0 1px var(--color-background-15),\n          0 0.0625em 0.125em rgba(0, 0, 0, 0.25),\n          0 0.125em 0.35em rgba(0, 0, 0, 0.35);\n      }\n      .PinturaRoot[data-env~='overlay'] .PinturaUtilFooter .PinturaRangeInput {\n        height: 1.5em;\n        margin-top: 0;\n      }\n      .PinturaRoot[data-env~='overlay']\n        .PinturaUtilFooter\n        .PinturaRangeInputReset {\n        opacity: 0;\n      }\n      .PinturaImageInfo {\n        pointer-events: none;\n      }\n      .PinturaImageInfo p {\n        width: 8em;\n        height: 1.25em;\n        contain: strict;\n        overflow: hidden;\n        font-variant-numeric: tabular-nums;\n        font-feature-settings: 'tnum';\n        font-family: Tahoma, Geneva, Verdana, sans-serif;\n        text-align: right;\n        line-height: 1;\n        font-size: 0.75em;\n      }\n      .PinturaShapeStyleEditor {\n        position: relative;\n        width: 100%;\n        min-height: 2.75em;\n      }\n      .PinturaShapeStyles {\n        position: absolute;\n        left: 0;\n        right: 0;\n        top: 0;\n      }\n      .PinturaShapeStyles:not([data-state~='overflows']) {\n        display: flex;\n        justify-content: center;\n      }\n      .PinturaShapeStyleList {\n        display: flex;\n      }\n      .PinturaShapeStyleList .PinturaButton,\n      .PinturaShapeStyleList .PinturaInput {\n        outline: transparent;\n      }\n      .PinturaShapeStyleList .PinturaInput {\n        padding: 0 0 0 0.625em;\n        font-size: 0.75em;\n        line-height: 2.25;\n      }\n      .PinturaShapeStyleList .PinturaShapeStyleLabel {\n        line-height: 1.75;\n        font-size: 0.625em;\n        font-weight: 300;\n        padding: 0 0.75em;\n        text-transform: lowercase;\n        pointer-events: none;\n        text-align: center;\n        color: var(--color-foreground-50);\n        white-space: nowrap;\n      }\n      .PinturaShapeStyleList > .PinturaShapeStyle {\n        border-radius: var(--border-radius-round);\n      }\n      .PinturaShapeStyleList > .PinturaShapeStyle + .PinturaShapeStyle {\n        margin-left: 1em;\n      }\n      .PinturaShapeStyle {\n        display: flex;\n        flex-direction: column;\n        align-items: stretch;\n      }\n      .PinturaShapeStyle .PinturaDetailsButton {\n        border-radius: inherit;\n      }\n      .PinturaShapeStyle > .PinturaButton:hover,\n      .PinturaShapeStyle > .PinturaButton[data-focus-visible] {\n        position: relative;\n        z-index: 1;\n      }\n      .PinturaShapeStyle > .PinturaColorPickerButton .PinturaButtonLabel {\n        display: block;\n        border-radius: inherit;\n      }\n      .PinturaShapeStyle > .PinturaColorPickerButton {\n        display: flex;\n        justify-content: center;\n      }\n      .PinturaShapeStyle .PinturaColorPreview {\n        border-radius: inherit;\n        width: 1.5em;\n        height: 1.5em;\n        background-color: #fff;\n        background-size: 4px;\n        border: 1px solid var(--color-background-100);\n        margin-top: -1px;\n      }\n      .PinturaShapeStyle .PinturaColorPreview span {\n        border-radius: inherit;\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaShapeStyle [data-focus-visible] .PinturaColorPreview span:before {\n        position: absolute;\n        left: 0;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        border-radius: inherit;\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n        content: '';\n        z-index: 1;\n      }\n      .PinturaShapeStyle\n        > .PinturaColorPickerButtonStroke\n        .PinturaColorPreview\n        span:after {\n        position: absolute;\n        left: 6px;\n        top: 6px;\n        right: 6px;\n        bottom: 6px;\n        background: var(--color-background-100);\n        border-radius: inherit;\n        box-shadow: 0 0 0 1px var(--color-foreground-5);\n        content: '';\n      }\n      .PinturaShapeStyle > .PinturaDropdownButton .PinturaButtonLabel,\n      .PinturaShapeStyle > .PinturaRadioGroup .PinturaButtonLabel,\n      .PinturaShapeStyle > .PinturaRadioGroupOption label,\n      .PinturaShapeStyle > .PinturaSliderButton .PinturaButtonLabel {\n        display: block;\n        line-height: 2.25;\n        padding: 0 1em;\n        font-size: 0.6875em;\n      }\n      .PinturaShapeStyle\n        > .PinturaButton:not(.PinturaColorPickerButton)[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaShapeStyle .PinturaInputField {\n        text-align: right;\n        padding: 0 0.75em;\n        width: 3em;\n        height: 2em;\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n        border-radius: var(--border-radius);\n      }\n      .PinturaShapeStyle > .PinturaDropdownButton {\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n        transition: background-color 0.1s;\n      }\n      .PinturaShapeStyle > .PinturaDropdownButton:hover {\n        background-color: var(--color-foreground-10);\n      }\n      .PinturaShapeStyle > .PinturaDropdownButton .PinturaButtonLabel:after {\n        content: '\u25BC';\n        font-size: 0.6875em;\n        margin-left: 0.75em;\n        position: relative;\n        top: -0.125em;\n        margin-right: -0.25em;\n        pointer-events: none;\n      }\n      .PinturaShapeStyle > .PinturaRadioGroup > .PinturaRadioGroupOptions {\n        flex-direction: row;\n      }\n      .PinturaShapeStyle\n        > .PinturaRadioGroup\n        > .PinturaRadioGroupOptions\n        label {\n        cursor: var(--button-cursor);\n        display: flex;\n        height: 1.5em;\n        align-items: center;\n        padding: 0 0.25em;\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n        transition: background-color 0.1s;\n      }\n      .PinturaShapeStyle\n        > .PinturaRadioGroup\n        > .PinturaRadioGroupOptions\n        label:hover {\n        background-color: var(--color-foreground-20);\n      }\n      .PinturaShapeStyle > .PinturaRadioGroup > .PinturaRadioGroupOptions svg {\n        width: 1.125em;\n        height: 1.125em;\n      }\n      .PinturaShapeStyle\n        > .PinturaRadioGroup\n        > .PinturaRadioGroupOptions\n        .PinturaRadioGroupOption:first-of-type\n        label {\n        padding-left: 0.5em;\n        border-top-left-radius: var(--border-radius-round);\n        border-bottom-left-radius: var(--border-radius-round);\n      }\n      .PinturaShapeStyle\n        > .PinturaRadioGroup\n        > .PinturaRadioGroupOptions\n        .PinturaRadioGroupOption:last-of-type\n        label {\n        padding-right: 0.5em;\n        border-top-right-radius: var(--border-radius-round);\n        border-bottom-right-radius: var(--border-radius-round);\n      }\n      .PinturaShapeStyle\n        > .PinturaRadioGroup\n        > .PinturaRadioGroupOptions\n        [data-selected='true']\n        label {\n        background-color: var(--color-foreground-10);\n      }\n      .PinturaToolbar {\n        display: flex;\n        justify-content: center;\n        margin-left: 1em;\n        margin-right: 1em;\n        padding-top: 1em;\n      }\n      .PinturaToolbar .PinturaToolbarInner {\n        display: inline-flex;\n      }\n      .PinturaToolbar[data-layout='compact'] .PinturaToolbarContentWide,\n      .PinturaToolbar[data-overflow='overflow'] .PinturaToolbarContentOptional {\n        display: none;\n      }\n      .PinturaToolbar .PinturaButton {\n        border-radius: var(--border-radius-round);\n        outline: transparent;\n        padding: 0.3125em 0.75em;\n        transition: background-color 0.1s ease-out, color 0.1s ease-out,\n          box-shadow 0.1s ease-out;\n        line-height: 1.1;\n      }\n      .PinturaToolbar .PinturaButton:hover {\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaToolbar .PinturaButton[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaToolbar .PinturaButton .PinturaButtonIcon {\n        width: 1em;\n      }\n      .PinturaToolbar .PinturaButtonLabel {\n        font-size: 0.75em;\n      }\n      .PinturaToolbar .PinturaDetailsPanel {\n        z-index: 3;\n      }\n      .PinturaToolbar .PinturaToolbarInner > * {\n        margin: 0 0.5em;\n      }\n      .PinturaRectManipulator {\n        --size: 1.25em;\n        position: absolute;\n        left: 0;\n        top: 0;\n        outline: none;\n        touch-action: none;\n      }\n      .PinturaRectManipulator:not([data-shape='edge']) {\n        width: var(--size);\n        height: var(--size);\n        z-index: 2;\n      }\n      .PinturaRectManipulator:not([data-shape='edge']):after {\n        position: absolute;\n        left: -0.5em;\n        right: -0.5em;\n        top: -0.5em;\n        bottom: -0.5em;\n        border-radius: inherit;\n        content: '';\n      }\n      .PinturaRectManipulator:not([data-shape='edge'])[data-focus-visible]:after {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaRectManipulator[data-shape~='circle'] {\n        margin-left: calc(var(--size) * (-0.5));\n        margin-top: calc(var(--size) * (-0.5));\n        line-height: var(--size);\n        border-radius: 50%;\n        background-color: var(--color-foreground-100);\n        box-shadow: 0 0 2px var(--color-background-50);\n      }\n      .PinturaRectManipulator[data-shape='hook'] {\n        border: 3px solid var(--color-foreground-100);\n      }\n      .PinturaRectManipulator[data-shape='hook'][data-direction*='t'] {\n        margin-top: -3px;\n        border-bottom: 0;\n      }\n      .PinturaRectManipulator[data-shape='hook'][data-direction*='r'] {\n        border-left: 0;\n        margin-left: calc(var(--size) * (-1));\n      }\n      .PinturaRectManipulator[data-shape='hook'][data-direction*='b'] {\n        margin-top: calc(var(--size) * (-1));\n        border-top: 0;\n      }\n      .PinturaRectManipulator[data-shape='hook'][data-direction*='l'] {\n        border-right: 0;\n        margin-left: -3px;\n      }\n      .PinturaRectManipulator[data-shape~='edge'] {\n        height: 1px;\n        width: 1px;\n        z-index: 1;\n      }\n      .PinturaRectManipulator[data-shape~='edge'][data-focus-visible] {\n        background-color: var(--color-focus-50);\n      }\n      .PinturaRectManipulator[data-direction='b'],\n      .PinturaRectManipulator[data-direction='t'] {\n        cursor: ns-resize;\n        height: var(--size);\n        margin-top: calc(var(--size) * (-0.5));\n        transform-origin: 0 center;\n      }\n      .PinturaRectManipulator[data-direction='l'],\n      .PinturaRectManipulator[data-direction='r'] {\n        cursor: ew-resize;\n        width: var(--size);\n        margin-left: calc(var(--size) * (-0.5));\n        transform-origin: center 0;\n      }\n      .PinturaRectManipulator[data-direction='bl'],\n      .PinturaRectManipulator[data-direction='tr'] {\n        cursor: nesw-resize;\n      }\n      .PinturaRectManipulator[data-direction='br'],\n      .PinturaRectManipulator[data-direction='tl'] {\n        cursor: nwse-resize;\n      }\n      .PinturaRoot[data-env~='pointer-coarse']\n        .PinturaRectManipulator[data-shape='edge']:active {\n        background-color: var(--color-foreground-5);\n      }\n      .PinturaRoot[data-env~='pointer-coarse']\n        .PinturaRectManipulator:not([data-shape='edge']):after {\n        left: -1em;\n        right: -1em;\n        top: -1em;\n        bottom: -1em;\n      }\n      .PinturaRoot[data-env~='pointer-coarse']\n        .PinturaRectManipulator:not([data-shape='edge']):active:after {\n        background-color: var(--color-foreground-5);\n      }\n      .PinturaShapePresetsPalette {\n        width: calc(100% - 2em);\n        text-align: center;\n      }\n      .PinturaShapePresetsPalette .PinturaShapePresetSelect {\n        vertical-align: top;\n        display: inline-block;\n      }\n      .PinturaShapePresetsPalette\n        .PinturaScrollable:not([data-state~='overflows']) {\n        display: flex;\n        justify-content: center;\n      }\n      .PinturaShapePresetsPalette .PinturaButton + .PinturaButton {\n        margin-left: 0.5em;\n      }\n      .PinturaShapePresetsPalette .PinturaButton {\n        flex-direction: row;\n        line-height: 1.1;\n        padding: 0.3125em 0.75em;\n        border-radius: var(--border-radius-round);\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n        cursor: var(--button-cursor);\n        transition: background-color 0.1s ease-out, color 0.1s ease-out,\n          box-shadow 0.1s ease-out;\n        outline: none;\n      }\n      .PinturaShapePresetsPalette .PinturaButton .PinturaButtonIcon {\n        width: 1em;\n      }\n      .PinturaShapePresetsPalette .PinturaButton .PinturaButtonLabel {\n        font-size: 0.75em;\n      }\n      .PinturaShapePresetsPalette .PinturaButton:hover {\n        box-shadow: inset 0 0 0 1px var(--color-foreground-10);\n      }\n      .PinturaShapePresetsPalette .PinturaButton[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaShapePresetsPalette .PinturaShapePresetsFlat > * + *,\n      .PinturaShapePresetsPalette .PinturaShapePresetsGroups > * + * {\n        margin-left: 0.5em;\n      }\n      .PinturaShapePresetsGroups {\n        display: flex;\n        order: 2;\n        margin-bottom: -0.1875em;\n      }\n      .PinturaShapePresetsGrouped {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n      }\n      .PinturaShapePresetsFlat {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n      }\n      .PinturaShapeList {\n        pointer-events: none;\n        opacity: 0;\n        transition: opacity 0.1s ease-in-out;\n        position: absolute;\n        top: 1em;\n        left: 1em;\n        width: -webkit-max-content;\n        width: -moz-max-content;\n        width: max-content;\n        z-index: 1;\n        border-radius: var(--border-radius);\n        color: var(--color-foreground-100);\n        background: var(--color-background-70);\n        box-shadow: 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaShapeList li + li {\n        margin-top: -0.3125em;\n      }\n      .PinturaShapeList[data-visible='true'] {\n        opacity: 1;\n      }\n      .PinturaShapeList .PinturaColorPreview {\n        width: 0.75em;\n        height: 0.75em;\n        margin-right: 0.25em;\n        border-radius: 0.25em;\n      }\n      .PinturaShapeList .PinturaShapeListItem {\n        display: flex;\n        align-items: center;\n        padding: 0.25em 0.5em;\n        outline: none;\n      }\n      .PinturaShapeList .PinturaShapeListItem > span {\n        font-size: 0.75em;\n        line-height: 1.75;\n        padding: 0 0.325em;\n        margin-left: -0.325em;\n      }\n      .PinturaShapeList .PinturaShapeListItem[data-focus-visible] > span {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaShapeList[data-visible='true'] .PinturaShapeListItem {\n        pointer-events: all;\n      }\n      .PinturaShapeEditor {\n        height: 100%;\n        width: 100%;\n        outline: none;\n        touch-action: none;\n      }\n      .PinturaShapeControls {\n        position: absolute !important;\n        left: 0;\n        top: 0;\n        z-index: 3;\n        pointer-events: none;\n        display: flex;\n        align-items: center;\n      }\n      .PinturaShapeControlsGroup {\n        pointer-events: all;\n      }\n      .PinturaShapeControlsGroup,\n      .PinturaShapeControlsGroup .PinturaSlider {\n        color: #eee;\n        background: #333;\n        box-shadow: 0 0.125em 0.25em rgba(0, 0, 0, 0.25);\n        border-radius: 0.25em;\n      }\n      .PinturaShapeControlsGroup,\n      .PinturaShapeControlsGroup .PinturaShapeControlsGroupToggle {\n        display: inline-flex;\n        min-height: 1.75em;\n      }\n      .PinturaShapeControlsGroup + .PinturaShapeControlsGroup {\n        margin-left: 0.5em;\n      }\n      .PinturaShapeControlsGroup .PinturaShapeControlsGroupToggle {\n        position: relative;\n      }\n      .PinturaShapeControlsGroup .PinturaButton {\n        outline: transparent;\n      }\n      .PinturaShapeControlsGroup .PinturaButton[data-focus-visible] {\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaShapeControlsGroup > .PinturaButton {\n        display: block;\n        font-weight: 700;\n        transition: background-color 0.1s;\n        outline: transparent;\n      }\n      .PinturaShapeControlsGroup > .PinturaButton:hover {\n        background-color: hsla(0, 0%, 100%, 0.15);\n      }\n      .PinturaShapeControlsGroup > .PinturaButton .PinturaButtonLabel {\n        display: block;\n        font-size: 0.6875em;\n        padding: 0 0.75em;\n        line-height: 1.7em;\n      }\n      .PinturaShapeControlsGroup .PinturaButtonIconOnly {\n        width: 1.75em;\n        transition: background-color 0.1s;\n      }\n      .PinturaShapeControlsGroup .PinturaButtonIconOnly:hover {\n        background-color: hsla(0, 0%, 100%, 0.15);\n      }\n      .PinturaShapeControlsGroup > button:first-of-type {\n        border-radius: 0.25em 0 0 0.25em;\n      }\n      .PinturaShapeControlsGroup > button:last-of-type {\n        border-radius: 0 0.25em 0.25em 0;\n      }\n      .PinturaShapeControlsGroup > button:only-of-type {\n        border-radius: 0.25em;\n      }\n      .PinturaShapeControlsGroup > * + * {\n        border-left: 1px solid rgba(0, 0, 0, 0.5);\n      }\n      .PinturaShapeControlsGroup svg {\n        pointer-events: none;\n      }\n      .PinturaInputForm {\n        opacity: 0;\n        cursor: auto;\n        z-index: 2147483647;\n      }\n      .PinturaInputForm:not([data-layout='stick']) {\n        position: absolute;\n        bottom: 6.5em;\n        width: 30em;\n        left: calc(50% - 15em);\n        box-shadow: 0 0.25em 0.5em -0.5em rgba(0, 0, 0, 0.75),\n          inset 0 0 0 1px var(--color-foreground-10);\n        border-radius: var(--border-radius);\n        background-color: var(--color-background-95);\n      }\n      @media (max-width: 34em) {\n        .PinturaInputForm:not([data-layout='stick']) {\n          left: 2em;\n          right: 2em;\n          width: auto;\n        }\n      }\n      .PinturaInputForm[data-layout='stick'] {\n        transition: opacity 0.15s ease 0.25s;\n        position: absolute;\n        left: 0;\n        right: 0;\n        outline: 1px solid var(--color-foreground-15);\n        background-color: var(--color-background-100);\n      }\n      .PinturaInputForm[data-layout='stick'] > .PinturaInputFormInner {\n        background-color: var(--color-foreground-3);\n      }\n      .PinturaInputFormInner > .PinturaButton {\n        color: var(--color-foreground-100);\n        border-radius: 9999em;\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaInputFormInner > .PinturaButton:first-of-type {\n        left: 1em;\n      }\n      .PinturaInputFormInner > .PinturaButton:last-of-type {\n        right: 1rem;\n        color: var(--color-primary-text);\n        background: var(--color-primary);\n        box-shadow: inset 0 0 0 1px var(--color-foreground-10);\n      }\n      .PinturaInputFormInner\n        > .PinturaButton:not(.PinturaButtonIconOnly)\n        .PinturaButtonInner {\n        padding: 0 0.875em 0 0.625em;\n      }\n      .PinturaInputFormInner > .PinturaButton .PinturaButtonIcon {\n        width: 0.875em;\n        height: 0.875em;\n      }\n      .PinturaInputFormInner > .PinturaButton.PinturaButtonIconOnly {\n        width: 1.875em;\n        height: 1.875em;\n      }\n      .PinturaInputFormInner > .PinturaButton .PinturaButtonLabel {\n        font-size: 0.875em;\n      }\n      .PinturaInputFormInner > .PinturaButton .PinturaButtonInner {\n        line-height: 2;\n        display: flex;\n        justify-content: center;\n      }\n      .PinturaInputFormInner {\n        padding-top: 1em;\n        padding-bottom: 3.5em;\n      }\n      .PinturaInputFormInner > .PinturaButton {\n        position: absolute;\n        bottom: 1em;\n      }\n      .PinturaInputFormFields textarea:only-child {\n        width: 100%;\n        padding: 0 1em 0.5em;\n        height: 5em;\n        display: block;\n        background: transparent;\n        -webkit-mask: linear-gradient(0deg, transparent, #000 1em);\n        mask: linear-gradient(0deg, transparent, #000 1em);\n      }\n      .PinturaInputFormFields textarea:only-child::-webkit-scrollbar {\n        width: 1em;\n        cursor: pointer;\n      }\n      .PinturaInputFormFields textarea:only-child::-webkit-scrollbar-track {\n        background: none;\n      }\n      .PinturaInputFormFields textarea:only-child::-webkit-scrollbar-thumb {\n        cursor: pointer;\n        background-clip: padding-box;\n        background-color: var(--color-foreground-70);\n        border-radius: 9999em;\n        border: 0.25em solid transparent;\n      }\n      .PinturaInputForm input,\n      .PinturaInputForm textarea {\n        box-sizing: border-box;\n        resize: none;\n        border: none;\n        font-size: 1rem;\n        outline: transparent;\n        color: var(--color-foreground-100);\n      }\n      .PinturaInputForm input {\n        background-color: var(--color-background-100);\n      }\n      .PinturaShapePresetsList {\n        display: flex;\n        align-items: center;\n      }\n      .PinturaShapePresetsList text {\n        font-family: monospace;\n      }\n      .PinturaShapePresetsList .PinturaShapePreset {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n      }\n      .PinturaShapePresetsList .PinturaShapePreset img,\n      .PinturaShapePresetsList .PinturaShapePreset svg {\n        display: block;\n        width: 1.75em;\n        height: 1.75em;\n        -o-object-fit: cover;\n        object-fit: cover;\n        border-radius: 0.3125em;\n      }\n      .PinturaShapePresetsList .PinturaShapePreset .PinturaDragButton {\n        padding: 0.3125em;\n        border-radius: var(--border-radius);\n        box-shadow: inset 0 0 0 1px var(--color-foreground-5);\n      }\n      .PinturaShapePresetsList .PinturaShapePreset .PinturaDragButton:hover {\n        background-color: var(--color-foreground-10);\n      }\n      .PinturaShapePresetsList .PinturaShapePreset + .PinturaShapePreset {\n        margin-left: 0.5em;\n      }\n      .PinturaShapeManipulator {\n        position: absolute;\n        left: 0;\n        top: 0;\n        outline: none;\n        touch-action: none;\n        --size: 0.75em;\n      }\n      .PinturaShapeManipulator:not([data-control='edge']) {\n        margin-left: calc(var(--size) * (-0.5));\n        margin-top: calc(var(--size) * (-0.5));\n        line-height: var(--size);\n        width: var(--size);\n        height: var(--size);\n        border-radius: 9999em;\n      }\n      .PinturaShapeManipulator:not([data-control='edge']):after {\n        position: absolute;\n        left: -0.5em;\n        right: -0.5em;\n        top: -0.5em;\n        bottom: -0.5em;\n        content: '';\n      }\n      .PinturaShapeManipulator:not([data-control='edge'])[data-focus-visible]:after {\n        border-radius: inherit;\n        background-color: var(--color-focus-50);\n        box-shadow: inset 0 0 0 1px var(--color-focus-100);\n      }\n      .PinturaShapeManipulator[data-control='point'] {\n        background: linear-gradient(\n          90deg,\n          var(--color-secondary-dark),\n          var(--color-secondary)\n        );\n        box-shadow: 0 0 0 2px #fff, 0 0 4px #000;\n        z-index: 3;\n      }\n      .PinturaShapeManipulator[data-control='edge'] {\n        margin-top: calc(var(--size) * (-0.5));\n        height: var(--size);\n        width: 1px;\n        z-index: 1;\n        transform-origin: 0 calc(var(--size) * 0.5);\n      }\n      .PinturaShapeManipulator[data-control='edge'][data-focus-visible] {\n        background-color: var(--color-focus-50);\n      }\n      .PinturaShapeManipulator[data-control='rotate'] {\n        border-radius: 9999em;\n        background: linear-gradient(90deg, #fff, #ddd);\n        box-shadow: 0 0 0 2px var(--color-secondary-dark), 0 0 4px #000;\n        z-index: 2;\n        cursor: move;\n      }\n      .PinturaDragButton {\n        cursor: var(--button-cursor);\n        outline: transparent;\n      }\n      .PinturaDragButton > * {\n        pointer-events: none;\n      }\n      .PinturaDragButton {\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n        -webkit-touch-callout: none;\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n        transition: filter 0.2s ease-out;\n      }\n      .PinturaDragButton[disabled] {\n        filter: var(--filter-disabled);\n      }\n    "]))) })); };
var templateObject_1$l;

var StylesGlobal = function (_a) {
    var children = _a.children, scrollbarColor = _a.scrollbarColor, scrollbarWidth = _a.scrollbarWidth;
    return (jsxs(Fragment$1, { children: [jsx(_NormalizerStyled$1, { scrollbarColor: scrollbarColor, scrollbarWidth: scrollbarWidth }), jsx(_NormalizerStyled, {}), children] }));
};

var spring = {
    x: { type: "spring", damping: 20, stiffness: 180, when: "afterChildren" },
    default: { duration: 0.45 },
};
var animation = {
    transition: spring,
    initial: { opacity: 0 },
    animate: { opacity: 1 },
    exit: { opacity: 0 },
};
var LayoutAnimation = function (props) {
    var children = props.children, pathname = props.pathname;
    return (jsx(AnimatePresence, __assign({ exitBeforeEnter: true }, { children: createElement(Container, __assign({ as: "main", minHeight: "100vh" }, props, animation, { key: pathname !== null && pathname !== void 0 ? pathname : '1' }), children) })));
};

var typeAlert = {
    error: {
        color: '#d3343c',
        icon: 'https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/commons/cross.svg',
    },
    success: {
        color: '#00b881',
        icon: 'https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/commons/check.svg',
    },
    warning: {
        color: '#f75b13',
        icon: 'https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/commons/cross.svg',
    },
    info: {
        color: '#4b56f0',
        icon: 'https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/commons/cross.svg',
    },
};

var ContextAlert = createContext({});
var useAlert = function () {
    var _a = useContext(ContextAlert), alert = _a.alert, setAlert = _a.setAlert;
    var insertAlert = function (newAlert) {
        var newAlertID = __assign(__assign({}, newAlert), { id: v4() });
        setAlert(__spreadArray(__spreadArray([], __read(alert), false), [newAlertID], false));
    };
    return { insertAlert: insertAlert };
};

var Alert = function (_a) {
    var children = _a.children, time = _a.time, customCSS = _a.customCSS;
    var _b = __read(useState([]), 2), alert = _b[0], setAlert = _b[1];
    return (jsxs(ContextAlert.Provider, __assign({ value: { alert: alert, setAlert: setAlert } }, { children: [jsx(AnimatePresence, __assign({ exitBeforeEnter: true }, { children: alert.length > 0 && (jsx(Wrapper$2, __assign({ maxWidth: "100vw", position: "fixed", zIndex: "9999", padding: "10px", alignItems: "center", justifyContent: "center", customCSS: css$1(templateObject_1$k || (templateObject_1$k = __makeTemplateObject(["\n              top: 0;\n              left: 50%;\n              transform: translateX(-50%);\n              animation: all 0.5s ease-in-out;\n              ", "\n            "], ["\n              top: 0;\n              left: 50%;\n              transform: translateX(-50%);\n              animation: all 0.5s ease-in-out;\n              ", "\n            "])), customCSS) }, { children: jsx(AnimatePresence, { children: alert.map(function (item) { return (jsx(UniqueAlert, __assign({}, item, { setAlert: setAlert, time: time }), item.id)); }) }) }), alert.length > 0 ? 'ok' : 'no')) })), children] })));
};
var DefaultAnimation = {
    transition: {
        default: { duration: 0.5 },
    },
    initial: { opacity: 0 },
    animate: { opacity: 1 },
    exit: { opacity: 0 },
};
var UniqueAlert = function (props) {
    var id = props.id, message = props.message, setAlert = props.setAlert, type = props.type, _a = props.time, time = _a === void 0 ? 3000 : _a;
    var ref = useRef(null);
    useEffect(function () {
        var timer = setTimeout(function () {
            if (time > 0) {
                setAlert(function (a) { return a.filter(function (item) { return item.id !== id; }); });
            }
        }, time);
        return function () { return clearTimeout(timer); };
    }, [alert, time]);
    return (jsxs(Wrapper$2, __assign({ maxWidth: "max-content", margin: "0px 0px 20px 0px", flexDirection: "row", alignItems: "center", justifyContent: "center", padding: "15px 25px", borderRadius: "2px", backgroundColor: typeAlert[type].color, refObject: ref }, DefaultAnimation, { children: [jsx(Icon$1, { icon: typeAlert[type].icon, width: "15px", height: "12px", color: "white" }), jsx(Text$2, __assign({ padding: "3px 0px 0px 0px", color: "white", fontWeight: 600, margin: "0px 0px 0px 15px" }, { children: message })), jsx(AtomButton, __assign({ backgroundColor: "white", padding: "8px", borderRadius: "4px", margin: "0px 0px 0px 20px", onClick: function () { return setAlert(function (a) { return a.filter(function (item) { return item.id !== id; }); }); } }, { children: jsx(Icon$1, { icon: typeAlert[type].icon, width: "8px", height: "8px", color: typeAlert[type].color }) }))] })));
};
var templateObject_1$k;

var DOWNLOAD_FILES = gql(templateObject_1$j || (templateObject_1$j = __makeTemplateObject(["\n  query downloadFile($token: String!) {\n    downloadFile(token: $token) {\n      url\n    }\n  }\n"], ["\n  query downloadFile($token: String!) {\n    downloadFile(token: $token) {\n      url\n    }\n  }\n"])));
var DownloadFile = function (props) {
    var _a = __read(useLazyQuery(DOWNLOAD_FILES), 1), getUrlFile = _a[0];
    var downloadFile = function (name, token) {
        getUrlFile({
            variables: { token: token },
        }).then(function (response) {
            var _a, _b, _c, _d, _e;
            var url = (_b = (_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.downloadFile) === null || _b === void 0 ? void 0 : _b.url;
            var a = (_c = window === null || window === void 0 ? void 0 : window.document) === null || _c === void 0 ? void 0 : _c.createElement("a");
            a.href = url || "";
            a.target = "_blank";
            a.download = name;
            (_d = document === null || document === void 0 ? void 0 : document.body) === null || _d === void 0 ? void 0 : _d.appendChild(a);
            a.click();
            (_e = document === null || document === void 0 ? void 0 : document.body) === null || _e === void 0 ? void 0 : _e.removeChild(a);
        });
    };
    return (jsx(AtomButton, __assign({ customCSS: props === null || props === void 0 ? void 0 : props.customCSS, onClick: function () {
            downloadFile(props === null || props === void 0 ? void 0 : props.nameFileDownload, props === null || props === void 0 ? void 0 : props.token);
        } }, { children: props === null || props === void 0 ? void 0 : props.buttonText })));
};
var templateObject_1$j;

var MoleculeCard = function (props) {
    var children = props.children, customCSS = props.customCSS;
    return (jsx(Wrapper$2, __assign({}, props, { whileHover: {
            zIndex: 10,
            scale: 1.05,
            boxShadow: "0px 0px 20px rgba(0, 0, 0, 0.1)",
            transition: { duration: 0.3 },
        }, customCSS: css$1(templateObject_1$i || (templateObject_1$i = __makeTemplateObject(["\n        width: 32%;\n        min-width: 220px;\n        height: max-content;\n        display: flex;\n        flex-direction: column;\n        background-color: transparent;\n        padding: 0;\n        margin: 0px 0px 20px 0px;\n        position: relative;\n        justify-content: flex-end;\n        border-radius: 10px;\n        @media only screen and (max-width: 820px) {\n          width: 48%;\n        }\n        @media only screen and (max-width: 560px) {\n          width: 100%;\n        }\n\n        ", "\n      "], ["\n        width: 32%;\n        min-width: 220px;\n        height: max-content;\n        display: flex;\n        flex-direction: column;\n        background-color: transparent;\n        padding: 0;\n        margin: 0px 0px 20px 0px;\n        position: relative;\n        justify-content: flex-end;\n        border-radius: 10px;\n        @media only screen and (max-width: 820px) {\n          width: 48%;\n        }\n        @media only screen and (max-width: 560px) {\n          width: 100%;\n        }\n\n        ", "\n      "])), customCSS) }, { children: children })));
};
var templateObject_1$i;

var MoleculeButtonCardShop = function (props) {
    var iconColor = props.iconColor;
    return (jsx(AtomButton, __assign({ padding: "10px", backgroundColor: "white" }, props, { children: jsx(Icon$1, { color: iconColor || 'red', height: "19px", width: "19px", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/images/add-to-cart.svg" }) })));
};

var MoleculeCardImage = function (props) {
    var customCSS = props.customCSS, src = props.src, background = props.background;
    return (jsx(Image$2, __assign({}, props, { alt: "image", width: "100%", height: "300px", src: src ||
            "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/images/default-placeholder.png", zIndex: "-1", customCSS: css$1(templateObject_1$h || (templateObject_1$h = __makeTemplateObject(["\n        background-color: ", ";\n        top: 0;\n        left: 0;\n        border-radius: 10px 10px 0 0;\n        ", "\n      "], ["\n        background-color: ", ";\n        top: 0;\n        left: 0;\n        border-radius: 10px 10px 0 0;\n        ", "\n      "])), background, customCSS) })));
};
var templateObject_1$h;

var CartShop = function (props) {
    var _a;
    var wrapperProps = props.wrapperProps, buttonProps = props.buttonProps, iconProps = props.iconProps, componentsProps = props.componentsProps, children = props.children;
    var _b = __read(useState(false), 2), show = _b[0], setShow = _b[1];
    var ref = useRef(null);
    useEffect(function () {
        var handleClickOutside = function (event) {
            if (ref.current && !ref.current.contains(event.target)) {
                setShow(false);
            }
        };
        document.addEventListener("mousedown", handleClickOutside);
        return function () {
            document.removeEventListener("mousedown", handleClickOutside);
        };
    }, [ref]);
    return (jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_1$g || (templateObject_1$g = __makeTemplateObject(["\n        position: relative;\n        max-width: max-content;\n        margin-left: 0;\n        margin-right: 20px;\n        ", ";\n      "], ["\n        position: relative;\n        max-width: max-content;\n        margin-left: 0;\n        margin-right: 20px;\n        ", ";\n      "])), wrapperProps === null || wrapperProps === void 0 ? void 0 : wrapperProps.customCSS) }, wrapperProps, { children: [show && (jsx(Wrapper$2, __assign({ refObject: ref, customCSS: css$1(templateObject_2$e || (templateObject_2$e = __makeTemplateObject(["\n            top: 150%;\n            right: 50%;\n            transform: translateX(50%);\n            position: absolute;\n            max-width: initial;\n            align-items: center;\n            justify-content: center;\n            width: 350px;\n            height: max-content;\n            background-color: #ffffff;\n            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);\n            margin-right: 55px;\n          "], ["\n            top: 150%;\n            right: 50%;\n            transform: translateX(50%);\n            position: absolute;\n            max-width: initial;\n            align-items: center;\n            justify-content: center;\n            width: 350px;\n            height: max-content;\n            background-color: #ffffff;\n            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);\n            margin-right: 55px;\n          "]))) }, { children: jsx(Wrapper$2, __assign({ maxHeight: "250px", borderRadius: "5px", justifyContent: "flex-start", customCSS: css$1(templateObject_3$9 || (templateObject_3$9 = __makeTemplateObject(["\n              overflow-y: auto;\n              ", ";\n            "], ["\n              overflow-y: auto;\n              ", ";\n            "])), (_a = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperContainerProps) === null || _a === void 0 ? void 0 : _a.customCSS) }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperContainerProps, { children: jsx(Wrapper$2, __assign({ borderRadius: "5px" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperBodyProps, { children: children })) })) }))), jsx(AtomButton, __assign({ backgroundColor: "transparent", padding: "0", onClick: function () { return setShow(!show); }, customCSS: css$1(templateObject_4$6 || (templateObject_4$6 = __makeTemplateObject(["\n          position: relative;\n          ", ";\n        "], ["\n          position: relative;\n          ", ";\n        "])), buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.customCSS) }, buttonProps, { children: jsx(Icon$1, __assign({ height: "24px", width: "24px", color: "#317c57", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/MDC-0001/svg/shopping-cart-svgrepo-com.svg" }, iconProps)) }))] })));
};
var templateObject_1$g, templateObject_2$e, templateObject_3$9, templateObject_4$6;

var ButtonsCartShop = function (props) {
    var _a, _b, _c;
    var wrapperProps = props.wrapperProps, componentsProps = props.componentsProps;
    return (jsxs(Wrapper$2, __assign({ width: "max-content", height: "100%", alignItems: "center", flexDirection: "row", customCSS: css$1(templateObject_1$f || (templateObject_1$f = __makeTemplateObject(["\n        align-self: center;\n        ", ";\n      "], ["\n        align-self: center;\n        ", ";\n      "])), wrapperProps === null || wrapperProps === void 0 ? void 0 : wrapperProps.customCSS) }, wrapperProps, { children: [jsx(AtomButton, __assign({ customCSS: css$1(templateObject_2$d || (templateObject_2$d = __makeTemplateObject(["\n          padding: 0;\n          height: 20px;\n          width: 20px;\n          box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);\n          ", ";\n        "], ["\n          padding: 0;\n          height: 20px;\n          width: 20px;\n          box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);\n          ", ";\n        "])), (_a = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.buttonAddProps) === null || _a === void 0 ? void 0 : _a.customCSS) }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.buttonSubProps, { children: jsx(Text$2, __assign({ color: "white", fontSize: "12px", fontWeight: "bold", cursor: "pointer" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.textProps, { children: "-" })) })), jsx(Wrapper$2, __assign({ customCSS: css$1(templateObject_3$8 || (templateObject_3$8 = __makeTemplateObject(["\n          align-items: center;\n          height: 20px;\n          width: 20px;\n          margin: 0px 12px;\n          box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);\n        "], ["\n          align-items: center;\n          height: 20px;\n          width: 20px;\n          margin: 0px 12px;\n          box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);\n        "]))) }, { children: jsx(Input, __assign({ type: "number", 
                    // value={`${item.quantity}`}
                    width: "35px", height: "20px", padding: "0px 0px 0px 0px", spanMargin: "0px 0px 0px 0px", errorPadding: "0px 0px 0px 0px", errorHeight: "0px 0px 0px 0px", customCSS: css$1(templateObject_4$5 || (templateObject_4$5 = __makeTemplateObject(["\n            input {\n              font-size: 12px;\n              font-weight: bold;\n              text-align: center;\n            }\n            input::-webkit-outer-spin-button,\n            input::-webkit-inner-spin-button {\n              -webkit-appearance: none;\n              margin: 0;\n            }\n            input[type='number'] {\n              -moz-appearance: textfield;\n            }\n            ", ";\n          "], ["\n            input {\n              font-size: 12px;\n              font-weight: bold;\n              text-align: center;\n            }\n            input::-webkit-outer-spin-button,\n            input::-webkit-inner-spin-button {\n              -webkit-appearance: none;\n              margin: 0;\n            }\n            input[type='number'] {\n              -moz-appearance: textfield;\n            }\n            ", ";\n          "])), (_b = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.inputProps) === null || _b === void 0 ? void 0 : _b.customCSS) }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.inputProps)) })), jsx(AtomButton, __assign({ customCSS: css$1(templateObject_5$3 || (templateObject_5$3 = __makeTemplateObject(["\n          background-color: #317c57;\n          padding: 0;\n          height: 20px;\n          width: 20px;\n          box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);\n          ", ";\n        "], ["\n          background-color: #317c57;\n          padding: 0;\n          height: 20px;\n          width: 20px;\n          box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);\n          ", ";\n        "])), (_c = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.buttonAddProps) === null || _c === void 0 ? void 0 : _c.customCSS) }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.buttonAddProps, { children: jsx(Text$2, __assign({ color: "white", fontSize: "12px", fontWeight: "bold", cursor: "pointer" }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.textProps, { children: "+" })) }))] })));
};
var templateObject_1$f, templateObject_2$d, templateObject_3$8, templateObject_4$5, templateObject_5$3;

var ItemCartShop = function (props) {
    var _a;
    var buttonProps = props.buttonProps, iconProps = props.iconProps, children = props.children, buttonSection = props.buttonSection, src = props.src, componentsProps = props.componentsProps, wrapperProps = props.wrapperProps;
    return (jsxs(Wrapper$2
    //   key={item.id}
    , __assign({ 
        //   key={item.id}
        customCSS: css$1(templateObject_1$e || (templateObject_1$e = __makeTemplateObject(["\n        width: 100%;\n        justify-content: space-between;\n        flex-direction: row;\n        padding: 20px;\n        border-bottom: 1px solid #e6e6e6;\n        ", ";\n      "], ["\n        width: 100%;\n        justify-content: space-between;\n        flex-direction: row;\n        padding: 20px;\n        border-bottom: 1px solid #e6e6e6;\n        ", ";\n      "])), wrapperProps === null || wrapperProps === void 0 ? void 0 : wrapperProps.customCSS) }, wrapperProps, { children: [jsxs(Wrapper$2, __assign({ flexDirection: "row", maxWidth: "max-content", width: "100%", justifyContent: "space-between" }, { children: [jsx(Image$2, __assign({ height: "50px", width: "50px", 
                        //   alt={item.name}
                        alt: "product", src: src !== null && src !== void 0 ? src : 'https://storage.googleapis.com/cdn-bucket-ixulabs-platform/MDC-0001/images/default.jpg', customCSS: css$1(templateObject_2$c || (templateObject_2$c = __makeTemplateObject(["\n            overflow: hidden;\n            border-radius: 50%;\n            ", ";\n          "], ["\n            overflow: hidden;\n            border-radius: 50%;\n            ", ";\n          "])), (_a = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.imageProps) === null || _a === void 0 ? void 0 : _a.customCSS) }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.imageProps)), jsx(Wrapper$2, __assign({ maxWidth: "max-content", margin: "0px 0px 0px 10px", height: "100%", justifyContent: "space-between" }, { children: children }))] })), buttonSection, jsx(AtomButton, __assign({ customCSS: css$1(templateObject_3$7 || (templateObject_3$7 = __makeTemplateObject(["\n          align-self: center;\n          background-color: transparent;\n          padding: 0;\n          height: max-content;\n          width: max-content;\n          ", "\n        "], ["\n          align-self: center;\n          background-color: transparent;\n          padding: 0;\n          height: max-content;\n          width: max-content;\n          ", "\n        "])), buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.customCSS) }, buttonProps, { children: jsx(Icon$1, __assign({ height: "20px", width: "20px", color: "#317c57", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/MDC-0001/svg/trash-svgrepo-com.svg" }, iconProps)) }))] })));
};
var templateObject_1$e, templateObject_2$c, templateObject_3$7;

var DivStyle = function (props) { return css$1(templateObject_1$d || (templateObject_1$d = __makeTemplateObject(["\n  ", ";\n  width: ", ";\n  height: ", ";\n  background: ", ";\n"], ["\n  ", ";\n  width: ", ";\n  height: ", ";\n  background: ", ";\n"])), props === null || props === void 0 ? void 0 : props.customCSS, (props === null || props === void 0 ? void 0 : props.width) || "100%", (props === null || props === void 0 ? void 0 : props.height) || "auto", (props === null || props === void 0 ? void 0 : props.height) || "auto"); };
var TextStyle = function (props) { return css$1(templateObject_2$b || (templateObject_2$b = __makeTemplateObject(["\n  color: ", ";\n  padding: ", ";\n  font-size: ", ";\n  margin: ", ";\n  align-self: ", ";\n\n  ", ";\n"], ["\n  color: ", ";\n  padding: ", ";\n  font-size: ", ";\n  margin: ", ";\n  align-self: ", ";\n\n  ", ";\n"])), (props === null || props === void 0 ? void 0 : props.color) || "white", (props === null || props === void 0 ? void 0 : props.padding) || "5px 0px 0px 0px", (props === null || props === void 0 ? void 0 : props.fontSize) || "12px", (props === null || props === void 0 ? void 0 : props.margin) || "0px 50px 0px 10px", (props === null || props === void 0 ? void 0 : props.alignSelf) || "flex-end", props === null || props === void 0 ? void 0 : props.customCSS); };
var MessageContainer = styled$1(motion.section)(templateObject_3$6 || (templateObject_3$6 = __makeTemplateObject(["\n  margin-bottom: 20px;\n  display: flex;\n  font-family: 'Roboto', sans-serif;\n  flex-direction: column;\n  align-self: ", ";\n  ", "\n\n  div {\n    display: flex;\n\n    img {\n      width: 40px;\n      height: 40px;\n      border-radius: 50%;\n    }\n  }\n"], ["\n  margin-bottom: 20px;\n  display: flex;\n  font-family: 'Roboto', sans-serif;\n  flex-direction: column;\n  align-self: ", ";\n  ", "\n\n  div {\n    display: flex;\n\n    img {\n      width: 40px;\n      height: 40px;\n      border-radius: 50%;\n    }\n  }\n"])), function (props) { return (props.align === true ? "flex-end" : ""); }, function (props) { return DivStyle(props); });
var Message = styled$1(motion.div)(templateObject_4$4 || (templateObject_4$4 = __makeTemplateObject(["\n  padding: ", ";\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n  border-radius: ", ";\n  background-color: ", ";\n  ", "\n\n  section {\n    display: flex;\n    justify-content: space-between;\n    span {\n      font-size: 10px;\n      margin-bottom: 5px;\n      text-align: ", ";\n    }\n  }\n  div {\n    display: flex;\n    flex-direction: column;\n    line-height: 2;\n  }\n  img {\n    width: 100% !important;\n    height: auto !important;\n    border-radius: 10px !important;\n  }\n  p {\n    color: ", ";\n    overflow: hidden;\n  }\n"], ["\n  padding: ", ";\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n  border-radius: ", ";\n  background-color: ", ";\n  ", "\n\n  section {\n    display: flex;\n    justify-content: space-between;\n    span {\n      font-size: 10px;\n      margin-bottom: 5px;\n      text-align: ", ";\n    }\n  }\n  div {\n    display: flex;\n    flex-direction: column;\n    line-height: 2;\n  }\n  img {\n    width: 100% !important;\n    height: auto !important;\n    border-radius: 10px !important;\n  }\n  p {\n    color: ", ";\n    overflow: hidden;\n  }\n"])), function (_a) {
    var padding = _a.padding;
    return padding || "10px 20px 20px 20px";
}, function (_a) {
    var borderRadius = _a.borderRadius;
    return borderRadius;
}, function (_a) {
    var background = _a.background;
    return background;
}, function (props) { return DivStyle(props); }, function (props) { return (props.align === true ? "right" : "left"); }, function (_a) {
    var color = _a.color;
    return color;
});
var Triangle = styled$1(motion.div)(templateObject_5$2 || (templateObject_5$2 = __makeTemplateObject(["\n  width: 0;\n  height: 0;\n  border-left: 10px solid transparent;\n  border-right: 0 solid transparent;\n  border-bottom: 10px solid ", ";\n  transform: rotate(-90deg);\n  margin: 0 0 0 auto;\n"], ["\n  width: 0;\n  height: 0;\n  border-left: 10px solid transparent;\n  border-right: 0 solid transparent;\n  border-bottom: 10px solid ", ";\n  transform: rotate(-90deg);\n  margin: 0 0 0 auto;\n"])), function (_a) {
    var background = _a.background;
    return background;
});
var MyMessageTriangle = styled$1(motion.div)(templateObject_6$1 || (templateObject_6$1 = __makeTemplateObject(["\n  width: 0;\n  height: 0;\n  border-left: 10px solid transparent;\n  border-right: 0 solid transparent;\n  border-bottom: 10px solid ", ";\n  transform: rotate(180deg);\n  margin: 0 0 0 auto;\n"], ["\n  width: 0;\n  height: 0;\n  border-left: 10px solid transparent;\n  border-right: 0 solid transparent;\n  border-bottom: 10px solid ", ";\n  transform: rotate(180deg);\n  margin: 0 0 0 auto;\n"])), function (_a) {
    var background = _a.background;
    return background;
});
var DateofMessage = styled$1(motion.p)(templateObject_7 || (templateObject_7 = __makeTemplateObject(["\n  ", "\n"], ["\n  ", "\n"])), function (props) { return TextStyle(props); });
var templateObject_1$d, templateObject_2$b, templateObject_3$6, templateObject_4$4, templateObject_5$2, templateObject_6$1, templateObject_7;

var ChatMyMessage = function (props) {
    var imagen = props.imagen, content = props.content, dateMessage = props.dateMessage, background = props.background, borderRadius = props.borderRadius, componentsProps = props.componentsProps, messageOptions = props.messageOptions;
    return (jsxs(MessageContainer, __assign({}, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperProps, { children: [jsxs("div", { children: [jsxs(Message, __assign({ borderRadius: borderRadius, background: background }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.messageProps, { children: [jsxs("section", { children: [jsx("div", { children: messageOptions }), jsx("span", { children: "T\u00FA" })] }), jsx("div", { dangerouslySetInnerHTML: {
                                    __html: content,
                                } })] })), jsx(MyMessageTriangle, __assign({ background: background }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.triangleProps)), jsx("img", { src: imagen, alt: "img profile" })] }), jsx(DateofMessage, __assign({ color: background }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.textProps, { children: dateMessage }))] })));
};

var ChatOtherMessage = function (props) {
    var imagen = props.imagen, name = props.name, background = props.background, dateMessage = props.dateMessage, content = props.content, borderRadius = props.borderRadius, componentsProps = props.componentsProps, messageOptions = props.messageOptions;
    return (jsxs(MessageContainer, __assign({}, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.wrapperProps, { children: [jsxs("div", { children: [jsx("img", { src: imagen, alt: "img profile" }), jsx(Triangle, { background: background }), jsxs(Message, __assign({ borderRadius: borderRadius, background: background }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.messageProps, { children: [jsxs("section", { children: [jsx("span", { children: name }), jsx("div", { children: messageOptions })] }), jsx("div", { dangerouslySetInnerHTML: {
                                    __html: content,
                                } })] }))] }), jsx(DateofMessage, __assign({ color: background }, { children: dateMessage }))] })));
};

var FooterColumnsComponent = function (props) {
    var children = props.children, columns = props.columns, wrapper = props.wrapper;
    return (jsx(Wrapper$2, __assign({ maxWidth: "1440px", customCSS: css$1(templateObject_1$c || (templateObject_1$c = __makeTemplateObject(["\n        width: 100%;\n        display: flex;\n        flex-direction: row;\n        flex-grow: 1;\n        padding: 0px 180px;\n        margin: 50px 0px;\n        gap: 30px;\n\n        @media (max-width: 980px) {\n          flex-direction: column;\n          padding: 0px 40px;\n        }\n        ", "\n      "], ["\n        width: 100%;\n        display: flex;\n        flex-direction: row;\n        flex-grow: 1;\n        padding: 0px 180px;\n        margin: 50px 0px;\n        gap: 30px;\n\n        @media (max-width: 980px) {\n          flex-direction: column;\n          padding: 0px 40px;\n        }\n        ", "\n      "])), wrapper) }, { children: children === null || children === void 0 ? void 0 : children.map(function (column, idx) { return (jsx(Wrapper$2, __assign({ justifyContent: "center", alignItems: "center", customCSS: css$1(templateObject_2$a || (templateObject_2$a = __makeTemplateObject(["\n            justify-content: flex-start;\n            align-items: center;\n            flex-basis: calc((100vw / ", "px));\n            ", "\n          "], ["\n            justify-content: flex-start;\n            align-items: center;\n            flex-basis: calc((100vw / ", "px));\n            ", "\n          "])), children === null || children === void 0 ? void 0 : children.length, columns) }, { children: column }), "".concat(idx + 1, "Column"))); }) })));
};
var templateObject_1$c, templateObject_2$a;

var Footer = function (props) {
    var children = props.children;
    return (jsx(Container, __assign({ backgroundColor: "#ff4f66", as: "footer" }, props, { children: children })));
};

var FooterLogoComponent = function (props) {
    var logo = props.logo, styles = props.styles;
    return (jsx(Wrapper$2, __assign({}, styles === null || styles === void 0 ? void 0 : styles.stylesWrapper, { children: jsx(Icon$1, __assign({ icon: logo, width: "117px", height: "122px", color: "white" }, styles === null || styles === void 0 ? void 0 : styles.styleIcons)) })));
};

var FooterSolicialLinks = function (props) {
    var _a;
    var socialLinks = props.socialLinks;
    return (jsx(Wrapper$2, __assign({ flexDirection: "row", alignItems: "center", justifyContent: "flex-start", maxWidth: "200px", margin: "30px 0px", customCSS: css$1(templateObject_1$b || (templateObject_1$b = __makeTemplateObject(["\n        @media (max-width: 1200px) {\n          justify-content: center;\n        }\n        @media (max-width: 480px) {\n          justify-content: flex-start;\n        }\n      "], ["\n        @media (max-width: 1200px) {\n          justify-content: center;\n        }\n        @media (max-width: 480px) {\n          justify-content: flex-start;\n        }\n      "]))) }, socialLinks === null || socialLinks === void 0 ? void 0 : socialLinks.stylesWrapper, { children: (_a = socialLinks === null || socialLinks === void 0 ? void 0 : socialLinks.links) === null || _a === void 0 ? void 0 : _a.map(function (socialLink) { return (jsxs(Link$1, __assign({ href: socialLink === null || socialLink === void 0 ? void 0 : socialLink.href, link: socialLink === null || socialLink === void 0 ? void 0 : socialLink.link, margin: "0px 10px", customCSS: css$1(templateObject_2$9 || (templateObject_2$9 = __makeTemplateObject(["\n            cursor: pointer;\n            @media (max-width: 480px) {\n              margin: 0px 0px;\n            }\n          "], ["\n            cursor: pointer;\n            @media (max-width: 480px) {\n              margin: 0px 0px;\n            }\n          "]))) }, socialLinks === null || socialLinks === void 0 ? void 0 : socialLinks.styleLinks, socialLink === null || socialLink === void 0 ? void 0 : socialLink.styleLink, { children: [jsx(Icon$1, __assign({ height: "25px", width: "25px", icon: socialLink.icon }, socialLinks === null || socialLinks === void 0 ? void 0 : socialLinks.styleIcons, socialLink === null || socialLink === void 0 ? void 0 : socialLink.styleIcon)), jsx(Text$2, __assign({ customCSS: css$1(templateObject_3$5 || (templateObject_3$5 = __makeTemplateObject(["\n              width: 0px;\n              height: 0px;\n              opacity: 0;\n              display: none;\n            "], ["\n              width: 0px;\n              height: 0px;\n              opacity: 0;\n              display: none;\n            "]))) }, { children: socialLink.icon }))] }), v4())); }) })));
};
var templateObject_1$b, templateObject_2$9, templateObject_3$5;

var Header = function (props) {
    var children = props.children, customCSS = props.customCSS;
    return (jsx(Container, __assign({ height: "80px", position: "fixed", as: "nav", justifyContent: "space-between", flexDirection: "row", padding: "0px 90px" }, props, { customCSS: css$1(templateObject_1$a || (templateObject_1$a = __makeTemplateObject(["\n        top: 0;\n        z-index: 100;\n        @media only screen and (max-width: 980px) {\n          padding: 0px 30px;\n        }\n        box-shadow: 0px 3px 6px rgb(0 0 0 / 10%);\n        ", "\n      "], ["\n        top: 0;\n        z-index: 100;\n        @media only screen and (max-width: 980px) {\n          padding: 0px 30px;\n        }\n        box-shadow: 0px 3px 6px rgb(0 0 0 / 10%);\n        ", "\n      "])), customCSS) }, { children: children })));
};
var templateObject_1$a;

var BurgerBUtton = function (props) {
    var iconProps = props.iconProps, buttonProps = props.buttonProps;
    return (jsx(AtomButton, __assign({ backgroundColor: "transparent", customCSS: css$1(templateObject_1$9 || (templateObject_1$9 = __makeTemplateObject(["\n        display: none;\n        align-items: center;\n        justify-content: center;\n        z-index: 10;\n        @media only screen and (max-width: 1200px) {\n          display: flex;\n        }\n        svg {\n          width: 30px;\n          height: 30px;\n        }\n        ", "\n      "], ["\n        display: none;\n        align-items: center;\n        justify-content: center;\n        z-index: 10;\n        @media only screen and (max-width: 1200px) {\n          display: flex;\n        }\n        svg {\n          width: 30px;\n          height: 30px;\n        }\n        ", "\n      "])), buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.customCSS) }, buttonProps, { children: jsx(Icon$1, __assign({ color: "#1d1d1d", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/BMB-001/Icons/menu.svg" }, iconProps)) })));
};
var templateObject_1$9;

var ContainerPublicLinks = function (props) {
    var SidebarAnimation = {
        transition: {
            default: { duration: 0.3 },
        },
        initial: { x: 50, opacity: 0 },
        animate: { x: 0, opacity: 1 },
        exit: { x: 50, opacity: 0 },
    };
    var background = props.background, containerProps = props.containerProps, children = props.children;
    return (jsxs(Wrapper$2, __assign({ position: "absolute", height: "100vh", justifyContent: "flex-start", alignItems: "center", backgroundColor: background || 'white', width: "300px", shadow: true }, SidebarAnimation, { customCSS: css$1(templateObject_1$8 || (templateObject_1$8 = __makeTemplateObject(["\n        /* display: none; */\n        @media only screen and (max-width: 1200px) {\n          display: flex;\n        }\n        top: 0;\n        right: 0;\n        z-index: 101;\n        ", "\n      "], ["\n        /* display: none; */\n        @media only screen and (max-width: 1200px) {\n          display: flex;\n        }\n        top: 0;\n        right: 0;\n        z-index: 101;\n        ", "\n      "])), containerProps === null || containerProps === void 0 ? void 0 : containerProps.customCSS) }, containerProps, { children: [jsx(Wrapper$2, { height: "80px", width: "100%", backgroundColor: background || 'white' }), jsx(Wrapper$2, __assign({ height: "calc(100vh - 90px)", justifyContent: "flex-start", alignItems: "center", customCSS: css$1(templateObject_2$8 || (templateObject_2$8 = __makeTemplateObject(["\n          overflow-y: auto;\n          overflow-x: hidden;\n        "], ["\n          overflow-y: auto;\n          overflow-x: hidden;\n        "]))) }, { children: jsx(Wrapper$2, __assign({ height: "max-content", width: "100%", justifyContent: "flex-start", alignItems: "flex-start", backgroundColor: background || 'white' }, { children: children })) }))] })));
};
var templateObject_1$8, templateObject_2$8;

var ContainerLinkStyled = styled$1(motion.ul)(templateObject_2$7 || (templateObject_2$7 = __makeTemplateObject(["\n  display: flex;\n  align-items: center;\n  justify-content: flex-start;\n  flex-direction: row;\n  ", "\n"], ["\n  display: flex;\n  align-items: center;\n  justify-content: flex-start;\n  flex-direction: row;\n  ", "\n"])), css$1(templateObject_1$7 || (templateObject_1$7 = __makeTemplateObject(["\n    @media only screen and (max-width: 1200px) {\n      display: none;\n    }\n  "], ["\n    @media only screen and (max-width: 1200px) {\n      display: none;\n    }\n  "]))));
var LinkStyled = styled$1(motion.li)(templateObject_3$4 || (templateObject_3$4 = __makeTemplateObject(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: max-content;\n  flex-direction: row;\n  background: transparent;\n  border: none;\n  margin: ", ";\n  cursor: pointer;\n  position: relative;\n\n  ", ";\n"], ["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: max-content;\n  flex-direction: row;\n  background: transparent;\n  border: none;\n  margin: ", ";\n  cursor: pointer;\n  position: relative;\n\n  ", ";\n"])), function (props) { return props.margin || '0px 25px 0px 0px'; }, function (_a) {
    var customcss = _a.customcss;
    return customcss;
});
var LinkPublic = styled$1(motion.li)(templateObject_4$3 || (templateObject_4$3 = __makeTemplateObject(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: row;\n  cursor: pointer;\n  position: relative;\n  width: 100%;\n  justify-content: space-between;\n  :hover {\n    width: 100%;\n    background-color: #f1576c;\n    a {\n      color: #1d1d1d;\n    }\n  }\n\n  ", ";\n"], ["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: row;\n  cursor: pointer;\n  position: relative;\n  width: 100%;\n  justify-content: space-between;\n  :hover {\n    width: 100%;\n    background-color: #f1576c;\n    a {\n      color: #1d1d1d;\n    }\n  }\n\n  ", ";\n"])), function (_a) {
    var customcss = _a.customcss;
    return customcss;
});
var templateObject_1$7, templateObject_2$7, templateObject_3$4, templateObject_4$3;

var HeaderLink = function (props) {
    var linkProps = props.linkProps, textProps = props.textProps, links = props.links, iconProps = props.iconProps, buttonProps = props.buttonProps, wrapperProps = props.wrapperProps, linksLength = props.linksLength;
    var _a = __read(useState(false), 2), treeSubFileds = _a[0], setTreeSubFileds = _a[1];
    var _b = __read(useState(false), 2), showMoreLinks = _b[0], setShowMoreLikns = _b[1];
    var _c = __read(useState(0), 2), showTreeSubField = _c[0], setShowTreeSubField = _c[1];
    return (jsx(ContainerLinkStyled, { children: links.length > (linksLength || 3) ? (jsxs(Fragment$1, { children: [links
                    .filter(function (_, index) { return index < (linksLength || 3); })
                    .map(function (link, index) {
                    return (link === null || link === void 0 ? void 0 : link.type) === 'dropdown' ? (jsxs(LinkStyled, __assign({ onHoverStart: function () {
                            setTreeSubFileds(true);
                            setShowTreeSubField(index);
                        }, onHoverEnd: function () { return setTreeSubFileds(false); } }, { children: [jsxs(Link$1, __assign({ fontSize: "12px" }, link, { color: "#1d1d1d", fontWeight: 600, cursor: "pointer", customCSS: css$1(templateObject_1$6 || (templateObject_1$6 = __makeTemplateObject(["\n                      display: flex;\n                      align-items: center;\n                      justify-content: center;\n                      ", ";\n                    "], ["\n                      display: flex;\n                      align-items: center;\n                      justify-content: center;\n                      ", ";\n                    "])), textProps === null || textProps === void 0 ? void 0 : textProps.customCSS) }, textProps, { children: [link.label, jsx(Icon$1, __assign({ height: "10px", width: "10px", color: "#6c6c6c", customCSS: css$1(templateObject_2$6 || (templateObject_2$6 = __makeTemplateObject(["\n                        margin: 0px 0px 0px 10px;\n                        ", ";\n                      "], ["\n                        margin: 0px 0px 0px 10px;\n                        ", ";\n                      "])), iconProps === null || iconProps === void 0 ? void 0 : iconProps.customCSS) }, iconProps, { icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-commons/frontend-library/icons/arrow-down-3101.svg" }))] })), treeSubFileds && showTreeSubField === index && (jsx(RecursiveDropdownHook, { data: link === null || link === void 0 ? void 0 : link.subFields }))] }), link.id)) : (jsx(LinkStyled, { children: jsx(Link$1, __assign({ fontSize: "12px", as: "a" }, link, { color: "#1d1d1d", fontWeight: 600 }, linkProps, { children: link.label })) }, link.id));
                }), links.length >= (linksLength || 3) && (jsxs(Wrapper$2, __assign({ as: "li", position: "relative", flexDirection: "row", width: "max-content", height: "max-content", onHoverEnd: function () { return setShowMoreLikns(false); }, onHoverStart: function () { return setShowMoreLikns(true); } }, wrapperProps, { children: [jsxs(AtomButton, __assign({ borderRadius: "100%", width: "18px", height: "18px", padding: "0", customCSS: css$1(templateObject_3$3 || (templateObject_3$3 = __makeTemplateObject(["\n                  display: flex;\n                  background-color: transparent;\n                  align-items: center;\n                  justify-content: center;\n                  fill: #fff;\n                  stroke: #fff;\n                  :hover {\n                    background-color: #dadada;\n                  }\n\n                  transition: background-color 0.3s ease;\n                  ", ";\n                "], ["\n                  display: flex;\n                  background-color: transparent;\n                  align-items: center;\n                  justify-content: center;\n                  fill: #fff;\n                  stroke: #fff;\n                  :hover {\n                    background-color: #dadada;\n                  }\n\n                  transition: background-color 0.3s ease;\n                  ", ";\n                "])), buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.customCSS) }, buttonProps, { children: [jsx(Icon$1, __assign({ width: "11px", height: "11px", color: "#1d1d1b", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/assets/svgs/PFS-0001/outline/three-dots-svgrepo-com.svg" }, iconProps)), jsx(Text$2, __assign({}, textProps, { customCSS: css$1(templateObject_4$2 || (templateObject_4$2 = __makeTemplateObject(["\n                    width: 0px;\n                    height: 0px;\n                    opacity: 0;\n                    ", ";\n                  "], ["\n                    width: 0px;\n                    height: 0px;\n                    opacity: 0;\n                    ", ";\n                  "])), textProps === null || textProps === void 0 ? void 0 : textProps.customCSS) }, { children: "MENU" }))] })), showMoreLinks && (jsx(RecursiveDropdownHook, { data: links.filter(function (_, index) { return index >= (linksLength || 3); }) }))] })))] })) : (jsx(Fragment$1, { children: links.map(function (link, index) {
                return (link === null || link === void 0 ? void 0 : link.type) === 'dropdown' ? (jsxs(LinkStyled, __assign({ onHoverStart: function () {
                        setTreeSubFileds(true);
                        setShowTreeSubField(index);
                    }, onHoverEnd: function () { return setTreeSubFileds(false); } }, { children: [jsxs(Link$1, __assign({ fontSize: "12px" }, link, { color: "#1d1d1d", fontWeight: 600, cursor: "pointer", customCSS: css$1(templateObject_5$1 || (templateObject_5$1 = __makeTemplateObject(["\n                    display: flex;\n                    align-items: center;\n                    justify-content: center;\n                    ", ";\n                  "], ["\n                    display: flex;\n                    align-items: center;\n                    justify-content: center;\n                    ", ";\n                  "])), textProps === null || textProps === void 0 ? void 0 : textProps.customCSS) }, textProps, { children: [link.label, jsx(Icon$1, __assign({ height: "10px", width: "10px", color: "#6c6c6c", customCSS: css$1(templateObject_6 || (templateObject_6 = __makeTemplateObject(["\n                      margin: 0px 0px 0px 10px;\n                      ", ";\n                    "], ["\n                      margin: 0px 0px 0px 10px;\n                      ", ";\n                    "])), iconProps === null || iconProps === void 0 ? void 0 : iconProps.customCSS) }, iconProps, { icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-commons/frontend-library/icons/arrow-down-3101.svg" }))] })), treeSubFileds && showTreeSubField === index && (jsx(RecursiveDropdownHook, { data: link === null || link === void 0 ? void 0 : link.subFields }))] }), link.id)) : (jsx(LinkStyled, { children: jsx(Link$1, __assign({ fontSize: "12px", as: "a" }, link, { color: "#1d1d1d", fontWeight: 600 }, linkProps, { children: link.label })) }, link.id));
            }) })) }));
};
var templateObject_1$6, templateObject_2$6, templateObject_3$3, templateObject_4$2, templateObject_5$1, templateObject_6;

var HeaderLinkPublic = function (props) {
    var data = props.data, _a = props.level, level = _a === void 0 ? 0 : _a, componentsProps = props.componentsProps, iconProps = props.iconProps, linkedProps = props.linkedProps;
    var _b = __read(useState(false), 2), showSubLinks = _b[0], setShowSubLinks = _b[1];
    var _c = __read(useState(0), 2), show = _c[0], setShow = _c[1];
    return (jsx(Fragment$1, { children: data === null || data === void 0 ? void 0 : data.map(function (subField, index) { return (jsxs(Fragment$2, { children: [jsxs(LinkPublic, __assign({ onClick: function () {
                        var _a, _b;
                        if (subField.type === 'dropdown' && index === show) {
                            setShowSubLinks(!showSubLinks);
                        }
                        else if (!showSubLinks) {
                            setShowSubLinks(!showSubLinks);
                        }
                        setShow(index);
                        (_b = (_a = componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.linksProps) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a);
                    } }, linkedProps, { children: [jsx(Link$1, __assign({ width: "100%", as: "a" }, subField, { color: "#303030", fontWeight: 600, padding: "15px ".concat(level * 10 + 40, "px") }, componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.linksProps, { children: subField.label })), subField.type === 'dropdown' && (jsx(Icon$1, __assign({}, iconProps, { height: "14px", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-commons/frontend-library/icons/arrow-down-3101.svg", color: "#1F1F1F" })))] })), showSubLinks && show === index && (jsx(HeaderLinkPublic, { componentsProps: componentsProps, iconProps: iconProps, linkedProps: linkedProps, data: subField.subFields, level: level + 1 }))] }, subField.id)); }) }));
};

var HeaderLogo = function (props) {
    var text = props.text, linkProps = props.linkProps, textProps = props.textProps, iconProps = props.iconProps, imageProps = props.imageProps, src = props.src, icon = props.icon;
    return (jsxs(Link$1, __assign({ customCSS: css$1(templateObject_1$5 || (templateObject_1$5 = __makeTemplateObject(["\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: max-content;\n        height: 100%;\n        svg {\n          width: 150px;\n          height: 50px;\n        }\n        ", ";\n      "], ["\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: max-content;\n        height: 100%;\n        svg {\n          width: 150px;\n          height: 50px;\n        }\n        ", ";\n      "])), linkProps === null || linkProps === void 0 ? void 0 : linkProps.customCSS) }, linkProps, { children: [src && (jsx(Image$2, __assign({ src: src, alt: "imageHeader", height: "70%" }, imageProps))), icon && (jsx(Icon$1, __assign({ height: "70%", color: "#ffffff" }, iconProps, { icon: src }))), jsx(Text$2, __assign({ customCSS: css$1(templateObject_2$5 || (templateObject_2$5 = __makeTemplateObject(["\n          width: 0px;\n          height: 0px;\n          opacity: 0;\n          ", ";\n        "], ["\n          width: 0px;\n          height: 0px;\n          opacity: 0;\n          ", ";\n        "])), textProps === null || textProps === void 0 ? void 0 : textProps.customCSS) }, textProps, { children: text }))] })));
};
var templateObject_1$5, templateObject_2$5;

var Sidebar$1 = function (props) {
    var Links = props.Links, buttonProps = props.buttonProps, children = props.children, customCSS = props.customCSS, iconProps = props.iconProps, ContainerStylesPublicLinks = props.ContainerPublicLinks;
    var _a = __read(useState(false), 2), isShow = _a[0], setIsShow = _a[1];
    return (jsxs(Wrapper$2, __assign({ customCSS: css$1(templateObject_1$4 || (templateObject_1$4 = __makeTemplateObject(["\n        width: max-content;\n        display: none;\n        @media screen and (max-width: 1200px) {\n          display: block;\n        }\n      "], ["\n        width: max-content;\n        display: none;\n        @media screen and (max-width: 1200px) {\n          display: block;\n        }\n      "]))) }, { children: [jsx(BurgerBUtton, { buttonProps: {
                    onClick: function () { return setIsShow(!isShow); },
                    customCSS: css$1(templateObject_2$4 || (templateObject_2$4 = __makeTemplateObject(["\n            z-index: 102;\n            ", "\n          "], ["\n            z-index: 102;\n            ", "\n          "])), buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.customCSS),
                }, iconProps: iconProps }), isShow && (jsx(Wrapper$2, __assign({ width: "max-content" }, { children: jsx(AnimatePresence, { children: jsxs(ContainerPublicLinks, __assign({}, ContainerStylesPublicLinks, { children: [jsx(HeaderLinkPublic, { data: Links, componentsProps: {
                                    linksProps: {
                                        onClick: function () {
                                            setIsShow(false);
                                        },
                                        customCSS: css$1(templateObject_3$2 || (templateObject_3$2 = __makeTemplateObject(["\n                      :hover {\n                        background: #e8e8e8;\n                      }\n                    "], ["\n                      :hover {\n                        background: #e8e8e8;\n                      }\n                    "]))),
                                    },
                                }, linkedProps: {
                                    customcss: css$1(templateObject_4$1 || (templateObject_4$1 = __makeTemplateObject(["\n                    :hover {\n                      background: #f1cece;\n                    }\n                    ", "\n                  "], ["\n                    :hover {\n                      background: #f1cece;\n                    }\n                    ", "\n                  "])), customCSS),
                                } }), children] })) }) })))] })));
};
var templateObject_1$4, templateObject_2$4, templateObject_3$2, templateObject_4$1;

var Sidebar = function (props) {
    var children = props.children, customCSS = props.customCSS;
    var dispatch = useDispatch();
    var sideBar = useSelector(function (state) { return state.sideBar; });
    var _a = __read(useState(true), 2), showButtonClose = _a[0], setShowButtonClose = _a[1];
    useEffect(function () {
        var updateSize = function () {
            var width = window.innerWidth;
            if (width < 920) {
                dispatch(CloseSidebar());
                setShowButtonClose(false);
            }
            else {
                setShowButtonClose(true);
            }
        };
        window.addEventListener("resize", updateSize, true);
        updateSize();
        return function () { return window.removeEventListener("resize", updateSize, true); };
    });
    return (jsxs(Container, __assign({}, props, { customCSS: css$1(templateObject_1$3 || (templateObject_1$3 = __makeTemplateObject(["\n        top: 0;\n        left: 0;\n        position: fixed;\n        margin-top: 80px;\n        height: calc(100vh - 80px);\n        justify-content: flex-start;\n        width: ", ";\n        z-index: 50;\n        box-shadow: rgb(0 0 0 / 10%) 0px 3px 6px;\n        ", "\n      "], ["\n        top: 0;\n        left: 0;\n        position: fixed;\n        margin-top: 80px;\n        height: calc(100vh - 80px);\n        justify-content: flex-start;\n        width: ", ";\n        z-index: 50;\n        box-shadow: rgb(0 0 0 / 10%) 0px 3px 6px;\n        ", "\n      "])), sideBar ? "300px" : "80px", customCSS) }, { children: [children, showButtonClose && (jsx(AtomButton, __assign({ onClick: function () { return dispatch(ToggleSidebar()); }, customCSS: css$1(templateObject_2$3 || (templateObject_2$3 = __makeTemplateObject(["\n            position: absolute;\n            display: flex;\n            padding: 0px;\n            justify-content: center;\n            align-items: center;\n            background-color: ", ";\n            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.3);\n            width: 35px;\n            height: 35px;\n            border-radius: 50%;\n            right: -15px;\n            top: 130px;\n            svg {\n              width: 14px;\n              height: 14px;\n              margin: ", ";\n              transform: ", ";\n              path {\n                fill: ", ";\n                stroke: ", ";\n              }\n            }\n          "], ["\n            position: absolute;\n            display: flex;\n            padding: 0px;\n            justify-content: center;\n            align-items: center;\n            background-color: ", ";\n            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.3);\n            width: 35px;\n            height: 35px;\n            border-radius: 50%;\n            right: -15px;\n            top: 130px;\n            svg {\n              width: 14px;\n              height: 14px;\n              margin: ", ";\n              transform: ", ";\n              path {\n                fill: ", ";\n                stroke: ", ";\n              }\n            }\n          "])), sideBar ? "white" : "#f1576c", sideBar ? "0px 2px 0px 0px" : "0px 0px 0px 2px", sideBar ? "rotate(0deg)" : "rotate(180deg)", sideBar ? "#4d4d4d" : "white", sideBar ? "#4d4d4d" : "white") }, { children: jsx(Icon$1, { height: "15px", width: "15px", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/icons/sideBar/arrow-left.svg", customCSS: css$1(templateObject_3$1 || (templateObject_3$1 = __makeTemplateObject(["\n              margin: ", ";\n              svg {\n                g {\n                  path {\n                    fill: ", " !important;\n                    stroke: ", " !important;\n                  }\n                }\n              }\n            "], ["\n              margin: ", ";\n              svg {\n                g {\n                  path {\n                    fill: ", " !important;\n                    stroke: ", " !important;\n                  }\n                }\n              }\n            "])), sideBar ? "0px 0px 0px 0px" : "0px 0px 0px 0px", sideBar ? "#4d4d4d" : "white", sideBar ? "#4d4d4d" : "white") }) })))] })));
};
var templateObject_1$3, templateObject_2$3, templateObject_3$1;

var getIcon = function (name) {
    return "https://storage.googleapis.com/cdn-bucket-ixulabs-platform/IXU-0001/icons/sideBar/".concat(name, ".svg");
};
var SidebarCall = function () {
    var sideBar = useSelector(function (state) { return state.sideBar; });
    return (jsxs(Link$1, __assign({ link: "/", customCSS: css$1(templateObject_1$2 || (templateObject_1$2 = __makeTemplateObject(["\n        display: flex;\n        width: 100%;\n        align-items: center;\n        justify-content: ", ";\n        flex-direction: row;\n        padding: ", ";\n        padding-left: ", ";\n        border-radius: 0px;\n        background-color: transparent;\n        span {\n          cursor: pointer;\n          color: #656a69;\n        }\n        svg {\n          g {\n            path {\n              fill: #f1576c !important;\n              stroke: #f1576c !important;\n            }\n          }\n        }\n        :hover {\n          background-color: #f1576c;\n          span {\n            cursor: pointer;\n            color: white;\n          }\n          svg {\n            g {\n              path {\n                fill: white !important;\n                stroke: white !important;\n              }\n            }\n          }\n        }\n        transition: all 0.2s ease-in-out;\n      "], ["\n        display: flex;\n        width: 100%;\n        align-items: center;\n        justify-content: ", ";\n        flex-direction: row;\n        padding: ", ";\n        padding-left: ", ";\n        border-radius: 0px;\n        background-color: transparent;\n        span {\n          cursor: pointer;\n          color: #656a69;\n        }\n        svg {\n          g {\n            path {\n              fill: #f1576c !important;\n              stroke: #f1576c !important;\n            }\n          }\n        }\n        :hover {\n          background-color: #f1576c;\n          span {\n            cursor: pointer;\n            color: white;\n          }\n          svg {\n            g {\n              path {\n                fill: white !important;\n                stroke: white !important;\n              }\n            }\n          }\n        }\n        transition: all 0.2s ease-in-out;\n      "])), sideBar ? "flex-start" : "center", sideBar ? "15px 30px" : "15px 0px", sideBar ? "30px" : "0px") }, { children: [jsx(Icon$1, { height: "18px", width: "18px", icon: getIcon('phone') }), sideBar && (jsx(Text$2, __assign({ maxWidth: "max-content", margin: "0px 0px 0px 25px", color: "#656a69", fontWeight: 700, fontSize: "14px", customCSS: css$1(templateObject_2$2 || (templateObject_2$2 = __makeTemplateObject(["\n            display: flex;\n            @media (max-width: 920px) {\n              display: none;\n            }\n          "], ["\n            display: flex;\n            @media (max-width: 920px) {\n              display: none;\n            }\n          "]))) }, { children: "Realizar llamada" })))] })));
};
var templateObject_1$2, templateObject_2$2;

var SidebarRecursive = function (_a) {
    var data = _a.data, _b = _a.level, level = _b === void 0 ? 0 : _b, _c = _a.isOpen, isOpen = _c === void 0 ? false : _c;
    var sideBar = useSelector(function (state) { return state.sideBar; });
    var _d = __read(useState(data === null || data === void 0 ? void 0 : data.map(function (item) { return ({
        id: item.id,
        isOpen: false,
    }); })), 2), showSubLinks = _d[0], setShowSubLinks = _d[1];
    useEffect(function () {
        setShowSubLinks(data === null || data === void 0 ? void 0 : data.map(function (item) { return ({
            id: item.id,
            isOpen: false,
        }); }));
    }, [data]);
    return (jsx(Fragment$1, { children: data === null || data === void 0 ? void 0 : data.map(function (subField, subFieldIndex) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
            return (jsxs(Fragment$2, { children: [subField.type === 'dropdown' ? (jsxs(AtomButton, __assign({ onClick: function () {
                            return setShowSubLinks(showSubLinks === null || showSubLinks === void 0 ? void 0 : showSubLinks.map(function (item, index) {
                                return index === subFieldIndex
                                    ? __assign(__assign({}, item), { isOpen: !item.isOpen }) : __assign(__assign({}, item), { isOpen: false });
                            }));
                        }, customCSS: css$1(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject(["\n                display: flex;\n                width: 100%;\n                align-items: center;\n                justify-content: ", ";\n                flex-direction: row;\n                padding: ", ";\n                padding-left: ", ";\n                cursor: pointer;\n                border-radius: 0px;\n                background-color: ", ";\n                span {\n                  cursor: pointer;\n                  color: ", ";\n                }\n                :hover {\n                  cursor: pointer;\n                  background-color: ", ";\n                  span {\n                    color: white;\n                  }\n                  svg {\n                    path {\n                      fill: white !important;\n                      stroke: white !important;\n                    }\n                  }\n                }\n                transition: all 0.2s ease-in-out;\n              "], ["\n                display: flex;\n                width: 100%;\n                align-items: center;\n                justify-content: ", ";\n                flex-direction: row;\n                padding: ", ";\n                padding-left: ", ";\n                cursor: pointer;\n                border-radius: 0px;\n                background-color: ", ";\n                span {\n                  cursor: pointer;\n                  color: ", ";\n                }\n                :hover {\n                  cursor: pointer;\n                  background-color: ", ";\n                  span {\n                    color: white;\n                  }\n                  svg {\n                    path {\n                      fill: white !important;\n                      stroke: white !important;\n                    }\n                  }\n                }\n                transition: all 0.2s ease-in-out;\n              "])), sideBar ? "flex-start" : "center", sideBar ? "15px 30px" : "15px 0px", sideBar
                            ? "".concat((sideBar ? 30 : 0) + level * 10, "px")
                            : "0px", isOpen ||
                            ((_a = showSubLinks === null || showSubLinks === void 0 ? void 0 : showSubLinks.find(function (_, index) { return index === subFieldIndex; })) === null || _a === void 0 ? void 0 : _a.isOpen)
                            ? '#f1576c'
                            : 'transparent', isOpen ||
                            ((_b = showSubLinks === null || showSubLinks === void 0 ? void 0 : showSubLinks.find(function (_, index) { return index === subFieldIndex; })) === null || _b === void 0 ? void 0 : _b.isOpen)
                            ? 'white'
                            : '#656a69', isOpen ||
                            ((_c = showSubLinks === null || showSubLinks === void 0 ? void 0 : showSubLinks.find(function (_, index) { return index === subFieldIndex; })) === null || _c === void 0 ? void 0 : _c.isOpen)
                            ? '#da4a5d'
                            : '#f1576c') }, { children: [(subField === null || subField === void 0 ? void 0 : subField.icon) ? (jsx(Icon$1, { height: "20px", width: "20px", icon: subField.icon })) : (jsx(Text$2, __assign({ fontSize: "14px", color: "#656a69", fontWeight: "bold", cursor: "pointer" }, { children: subField.label.slice(0, 2).toUpperCase() }))), sideBar && (jsx(Text$2, __assign({ maxWidth: "max-content", margin: "0px 0px 0px 25px", color: "#656a69", fontWeight: 700, fontSize: "14px", customCSS: css$1(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject(["\n                    display: flex;\n                    @media (max-width: 920px) {\n                      display: none;\n                    }\n                  "], ["\n                    display: flex;\n                    @media (max-width: 920px) {\n                      display: none;\n                    }\n                  "]))) }, { children: subField.label }))), jsx(Icon$1, { customCSS: css$1(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n                  margin-left: 15px;\n                  transform: ", ";\n                  svg {\n                    g {\n                      g {\n                        path {\n                          fill: ", " !important;\n                          stroke: ", " !important;\n                        }\n                      }\n                    }\n                  }\n                "], ["\n                  margin-left: 15px;\n                  transform: ", ";\n                  svg {\n                    g {\n                      g {\n                        path {\n                          fill: ", " !important;\n                          stroke: ", " !important;\n                        }\n                      }\n                    }\n                  }\n                "])), ((_d = showSubLinks === null || showSubLinks === void 0 ? void 0 : showSubLinks.find(function (_, index) { return index === subFieldIndex; })) === null || _d === void 0 ? void 0 : _d.isOpen)
                                    ? "rotate(180deg)"
                                    : "rotate(0deg)", isOpen ||
                                    ((_e = showSubLinks === null || showSubLinks === void 0 ? void 0 : showSubLinks.find(function (_, index) { return index === subFieldIndex; })) === null || _e === void 0 ? void 0 : _e.isOpen)
                                    ? 'white'
                                    : '#656a69', isOpen ||
                                    ((_f = showSubLinks === null || showSubLinks === void 0 ? void 0 : showSubLinks.find(function (_, index) { return index === subFieldIndex; })) === null || _f === void 0 ? void 0 : _f.isOpen)
                                    ? 'white'
                                    : '#656a69'), width: sideBar ? "14px" : "10px", height: sideBar ? "14px" : "10px", icon: "https://storage.googleapis.com/cdn-bucket-ixulabs-commons/frontend-library/icons/arrow-down-3101.svg" })] }))) : (jsxs(Link$1, __assign({ link: subField.link, customCSS: css$1(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n                display: flex;\n                width: 100%;\n                align-items: center;\n                justify-content: ", ";\n                flex-direction: row;\n                padding: ", ";\n                padding-left: ", ";\n                border-radius: 0px;\n                background-color: ", ";\n                span {\n                  cursor: pointer;\n                  color: ", ";\n                }\n                svg {\n                  g {\n                    path {\n                      fill: #f1576c !important;\n                      stroke: #f1576c !important;\n                    }\n                  }\n                }\n                :hover {\n                  background-color: ", ";\n                  span {\n                    cursor: pointer;\n                    color: white;\n                  }\n                  svg {\n                    g {\n                      path {\n                        fill: white !important;\n                        stroke: white !important;\n                      }\n                    }\n                  }\n                }\n                transition: all 0.2s ease-in-out;\n              "], ["\n                display: flex;\n                width: 100%;\n                align-items: center;\n                justify-content: ", ";\n                flex-direction: row;\n                padding: ", ";\n                padding-left: ", ";\n                border-radius: 0px;\n                background-color: ", ";\n                span {\n                  cursor: pointer;\n                  color: ", ";\n                }\n                svg {\n                  g {\n                    path {\n                      fill: #f1576c !important;\n                      stroke: #f1576c !important;\n                    }\n                  }\n                }\n                :hover {\n                  background-color: ", ";\n                  span {\n                    cursor: pointer;\n                    color: white;\n                  }\n                  svg {\n                    g {\n                      path {\n                        fill: white !important;\n                        stroke: white !important;\n                      }\n                    }\n                  }\n                }\n                transition: all 0.2s ease-in-out;\n              "])), sideBar ? "flex-start" : "center", sideBar ? "15px 30px" : "15px 0px", sideBar
                            ? "".concat((sideBar ? 30 : 0) + level * 10, "px")
                            : "0px", isOpen ||
                            ((_g = showSubLinks === null || showSubLinks === void 0 ? void 0 : showSubLinks.find(function (_, index) { return index === subFieldIndex; })) === null || _g === void 0 ? void 0 : _g.isOpen)
                            ? '#f1576c'
                            : 'transparent', isOpen ||
                            ((_h = showSubLinks === null || showSubLinks === void 0 ? void 0 : showSubLinks.find(function (_, index) { return index === subFieldIndex; })) === null || _h === void 0 ? void 0 : _h.isOpen)
                            ? 'white'
                            : '#656a69', isOpen ||
                            ((_j = showSubLinks === null || showSubLinks === void 0 ? void 0 : showSubLinks.find(function (_, index) { return index === subFieldIndex; })) === null || _j === void 0 ? void 0 : _j.isOpen)
                            ? '#da4a5d'
                            : '#f1576c') }, { children: [(subField === null || subField === void 0 ? void 0 : subField.icon) ? (jsx(Icon$1, { height: "20px", width: "20px", icon: subField.icon })) : (jsx(Text$2, __assign({ fontSize: "14px", color: "#656a69", fontWeight: "bold", cursor: "pointer" }, { children: subField.label.slice(0, 2).toUpperCase() }))), sideBar && (jsx(Text$2, __assign({ maxWidth: "max-content", margin: "0px 0px 0px 25px", color: "#656a69", fontWeight: 700, fontSize: "14px", customCSS: css$1(templateObject_5 || (templateObject_5 = __makeTemplateObject(["\n                    display: flex;\n                    @media (max-width: 920px) {\n                      display: none;\n                    }\n                  "], ["\n                    display: flex;\n                    @media (max-width: 920px) {\n                      display: none;\n                    }\n                  "]))) }, { children: subField.label })))] }))), ((_k = showSubLinks === null || showSubLinks === void 0 ? void 0 : showSubLinks.find(function (_, index) { return index === subFieldIndex; })) === null || _k === void 0 ? void 0 : _k.isOpen) && (jsx(SidebarRecursive, { isOpen: (_l = showSubLinks === null || showSubLinks === void 0 ? void 0 : showSubLinks.find(function (_, index) { return index === subFieldIndex; })) === null || _l === void 0 ? void 0 : _l.isOpen, data: subField.subFields, level: level + 1 }))] }, subField.id));
        }) }));
};
var templateObject_1$1, templateObject_2$1, templateObject_3, templateObject_4, templateObject_5;

var SidebarLinks = function (props) {
    var links = props.links, children = props.children, customCSS = props.customCSS;
    return (jsxs(Wrapper$2, __assign({ height: "100%", alignItems: "flex-start", justifyContent: "space-between", padding: "40px 0px", customCSS: css$1(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n        ", "\n      "], ["\n        ", "\n      "])), customCSS) }, { children: [jsx(Wrapper$2, __assign({ height: "100%", alignItems: "center", justifyContent: "flex-start", customCSS: css$1(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n          overflow-x: hidden;\n          overflow-y: scroll;\n        "], ["\n          overflow-x: hidden;\n          overflow-y: scroll;\n        "]))) }, { children: jsx(Wrapper$2, __assign({ height: "max-content", alignItems: "flex-start", justifyContent: "flex-start" }, { children: jsx(SidebarRecursive, { data: links }) })) })), children] })));
};
var templateObject_1, templateObject_2;

var IPeriodInvoice;
(function (IPeriodInvoice) {
    IPeriodInvoice["DAILY"] = "DAILY";
    IPeriodInvoice["WEEKLY"] = "WEEKLY";
    IPeriodInvoice["TWO_WEEKS"] = "TWO_WEEKS";
    IPeriodInvoice["MONTHLY"] = "MONTHLY";
})(IPeriodInvoice || (IPeriodInvoice = {}));
var IBillingForm;
(function (IBillingForm) {
    IBillingForm["CERTIFICATE"] = "CERTIFICATE";
    IBillingForm["GLOBAL"] = "GLOBAL";
})(IBillingForm || (IBillingForm = {}));
var IPaymentTerm;
(function (IPaymentTerm) {
    IPaymentTerm["CASH_PAYMENT"] = "CASH_PAYMENT";
    IPaymentTerm["PREPAID"] = "PREPAID";
    IPaymentTerm["PAYMENT_POSTPONED"] = "PAYMENT_POSTPONED";
    IPaymentTerm["CREDIT"] = "CREDIT";
})(IPaymentTerm || (IPaymentTerm = {}));
var ITypeInsurance;
(function (ITypeInsurance) {
    ITypeInsurance["MEDICAL_EXPENSES"] = "MEDICAL_EXPENSES";
    ITypeInsurance["LIFE"] = "LIFE";
    ITypeInsurance["HOME"] = "HOME";
    ITypeInsurance["CARS"] = "CARS";
    ITypeInsurance["OLDER"] = "OLDER";
    ITypeInsurance["YOUNGER"] = "YOUNGER";
    ITypeInsurance["DENTAL"] = "DENTAL";
})(ITypeInsurance || (ITypeInsurance = {}));
var IPerson;
(function (IPerson) {
    IPerson["NATURAL"] = "NATURAL";
    IPerson["LEGAL"] = "LEGAL";
})(IPerson || (IPerson = {}));
var IUseCDFI;
(function (IUseCDFI) {
    IUseCDFI["PROOF_OF_INCOME"] = "PROOF_OF_INCOME";
    IUseCDFI["DISBURSEMENT_VOUCHER"] = "DISBURSEMENT_VOUCHER";
    IUseCDFI["PROOF_OF_TRANSFER"] = "PROOF_OF_TRANSFER";
    IUseCDFI["PAYROLL_RECEIPT"] = "PAYROLL_RECEIPT";
    IUseCDFI["PROOF_OF_RECEIPT_OF_PAYMENTS"] = "PROOF_OF_RECEIPT_OF_PAYMENTS";
    IUseCDFI["PROOF_OF_WITHHOLDINGS_AND_PAYMENT_INFORMATION"] = "PROOF_OF_WITHHOLDINGS_AND_PAYMENT_INFORMATION";
})(IUseCDFI || (IUseCDFI = {}));
var Iauth_PaymentMethod;
(function (Iauth_PaymentMethod) {
    Iauth_PaymentMethod["CASH"] = "CASH";
    Iauth_PaymentMethod["NOMINAL_CHECK"] = "NOMINAL_CHECK";
    Iauth_PaymentMethod["TRANSFER"] = "TRANSFER";
    Iauth_PaymentMethod["ELECTRONIC_FUNDS"] = "ELECTRONIC_FUNDS";
    Iauth_PaymentMethod["TO_DEFINE"] = "TO_DEFINE";
})(Iauth_PaymentMethod || (Iauth_PaymentMethod = {}));
var IEnumMemberRelationStatus;
(function (IEnumMemberRelationStatus) {
    IEnumMemberRelationStatus["ACTIVE"] = "ACTIVE";
    IEnumMemberRelationStatus["POTENTIAL"] = "POTENTIAL";
    IEnumMemberRelationStatus["INTERESTED"] = "INTERESTED";
    IEnumMemberRelationStatus["CLOSED"] = "CLOSED";
})(IEnumMemberRelationStatus || (IEnumMemberRelationStatus = {}));
var ISellStatus;
(function (ISellStatus) {
    ISellStatus["IN_PROCESS"] = "IN_PROCESS";
    ISellStatus["DONE"] = "DONE";
    ISellStatus["CANCELLED"] = "CANCELLED";
})(ISellStatus || (ISellStatus = {}));
var IGender;
(function (IGender) {
    IGender["MALE"] = "MALE";
    IGender["FEMALE"] = "FEMALE";
    IGender["UNKNOWN"] = "UNKNOWN";
})(IGender || (IGender = {}));
var IMaritalStatus;
(function (IMaritalStatus) {
    IMaritalStatus["DIVORCED"] = "DIVORCED";
    IMaritalStatus["MARRIED"] = "MARRIED";
    IMaritalStatus["SINGLE"] = "SINGLE";
    IMaritalStatus["SEPARATED"] = "SEPARATED";
    IMaritalStatus["WIDOWED"] = "WIDOWED";
    IMaritalStatus["UNKNOWN"] = "UNKNOWN";
})(IMaritalStatus || (IMaritalStatus = {}));
var ISocialNetworkType;
(function (ISocialNetworkType) {
    ISocialNetworkType["FACEBOOK"] = "FACEBOOK";
    ISocialNetworkType["TWITTER"] = "TWITTER";
    ISocialNetworkType["INSTAGRAM"] = "INSTAGRAM";
})(ISocialNetworkType || (ISocialNetworkType = {}));
var ISortEnumType;
(function (ISortEnumType) {
    ISortEnumType["ASC"] = "ASC";
    ISortEnumType["DESC"] = "DESC";
})(ISortEnumType || (ISortEnumType = {}));
var IEnumTransactionStatus;
(function (IEnumTransactionStatus) {
    IEnumTransactionStatus["PENDING"] = "PENDING";
    IEnumTransactionStatus["IN_POCESS"] = "IN_POCESS";
    IEnumTransactionStatus["PAID"] = "PAID";
    IEnumTransactionStatus["CANCELED"] = "CANCELED";
})(IEnumTransactionStatus || (IEnumTransactionStatus = {}));
var IEnumTransactionService;
(function (IEnumTransactionService) {
    IEnumTransactionService["STRIPE"] = "STRIPE";
    IEnumTransactionService["PAYPAL"] = "PAYPAL";
})(IEnumTransactionService || (IEnumTransactionService = {}));
var IEnumTransactionType;
(function (IEnumTransactionType) {
    IEnumTransactionType["RETIREMENT"] = "RETIREMENT";
    IEnumTransactionType["DEPOSIT"] = "DEPOSIT";
    IEnumTransactionType["PAYMENT"] = "PAYMENT";
})(IEnumTransactionType || (IEnumTransactionType = {}));
var IInvoiceStatus;
(function (IInvoiceStatus) {
    IInvoiceStatus["PENDING"] = "PENDING";
    IInvoiceStatus["PAID"] = "PAID";
    IInvoiceStatus["CANCELLED"] = "CANCELLED";
})(IInvoiceStatus || (IInvoiceStatus = {}));
var IProductStatus;
(function (IProductStatus) {
    IProductStatus["DRAFT"] = "DRAFT";
    IProductStatus["PUBLISHED"] = "PUBLISHED";
    IProductStatus["INACTIVE"] = "INACTIVE";
    IProductStatus["PROGRAMMED"] = "PROGRAMMED";
})(IProductStatus || (IProductStatus = {}));
var IArticleStatus;
(function (IArticleStatus) {
    IArticleStatus["DRAFT"] = "DRAFT";
    IArticleStatus["PUBLISHED"] = "PUBLISHED";
    IArticleStatus["PROGRAMMED"] = "PROGRAMMED";
})(IArticleStatus || (IArticleStatus = {}));
var ITypeContent;
(function (ITypeContent) {
    ITypeContent["ARTICLE"] = "ARTICLE";
    ITypeContent["PODCAST"] = "PODCAST";
    ITypeContent["VIDEO"] = "VIDEO";
    ITypeContent["BENEFITS"] = "BENEFITS";
    ITypeContent["PROMOTIONS"] = "PROMOTIONS";
    ITypeContent["COMUNICATIONS"] = "COMUNICATIONS";
})(ITypeContent || (ITypeContent = {}));
var IArticleLanguage;
(function (IArticleLanguage) {
    IArticleLanguage["ES"] = "ES";
    IArticleLanguage["EN"] = "EN";
    IArticleLanguage["PT"] = "PT";
    IArticleLanguage["ZH"] = "ZH";
    IArticleLanguage["DE"] = "DE";
    IArticleLanguage["FR"] = "FR";
    IArticleLanguage["RU"] = "RU";
})(IArticleLanguage || (IArticleLanguage = {}));
var IQuestionType;
(function (IQuestionType) {
    IQuestionType["SINGLE"] = "SINGLE";
    IQuestionType["OPEN"] = "OPEN";
    IQuestionType["MULTIPLE"] = "MULTIPLE";
})(IQuestionType || (IQuestionType = {}));
var IShopType;
(function (IShopType) {
    IShopType["IXULABS"] = "IXULABS";
    IShopType["MERCADOLIBRE"] = "MERCADOLIBRE";
    IShopType["BODEGA"] = "BODEGA";
})(IShopType || (IShopType = {}));
var IStoreType;
(function (IStoreType) {
    IStoreType["MOVIL"] = "MOVIL";
    IStoreType["FIJO"] = "FIJO";
})(IStoreType || (IStoreType = {}));
var IProductType;
(function (IProductType) {
    IProductType["CASH"] = "CASH";
    IProductType["SUBSCRIPTION"] = "SUBSCRIPTION";
})(IProductType || (IProductType = {}));
var ICostingType;
(function (ICostingType) {
    ICostingType["AVERAGE"] = "AVERAGE";
    ICostingType["STANDARD"] = "STANDARD";
    ICostingType["EUPS"] = "EUPS";
    ICostingType["PEPS"] = "PEPS";
    ICostingType["EQUAL"] = "EQUAL";
    ICostingType["PACKAGE"] = "PACKAGE";
})(ICostingType || (ICostingType = {}));
var IProductModality;
(function (IProductModality) {
    IProductModality["PURCHASE"] = "PURCHASE";
    IProductModality["SELL"] = "SELL";
    IProductModality["PRODUCTION"] = "PRODUCTION";
    IProductModality["CONSUMPTION"] = "CONSUMPTION";
    IProductModality["FIXED_ACTIVE"] = "FIXED_ACTIVE";
    IProductModality["BILLS"] = "BILLS";
})(IProductModality || (IProductModality = {}));
var IProviderType;
(function (IProviderType) {
    IProviderType["NATIONAL"] = "NATIONAL";
    IProviderType["FOREIGN"] = "FOREIGN";
})(IProviderType || (IProviderType = {}));
var IEnumDiscount;
(function (IEnumDiscount) {
    IEnumDiscount["FIXED"] = "FIXED";
    IEnumDiscount["DISCOUNT"] = "DISCOUNT";
})(IEnumDiscount || (IEnumDiscount = {}));
var IEnumResourceQuoteStatus;
(function (IEnumResourceQuoteStatus) {
    IEnumResourceQuoteStatus["DRAFT"] = "DRAFT";
    IEnumResourceQuoteStatus["RELEASED"] = "RELEASED";
    IEnumResourceQuoteStatus["PENDING"] = "PENDING";
    IEnumResourceQuoteStatus["APPROVED"] = "APPROVED";
    IEnumResourceQuoteStatus["REJECTED"] = "REJECTED";
})(IEnumResourceQuoteStatus || (IEnumResourceQuoteStatus = {}));
var IEnumQuizStatus;
(function (IEnumQuizStatus) {
    IEnumQuizStatus["STARTED"] = "STARTED";
    IEnumQuizStatus["SAVED"] = "SAVED";
    IEnumQuizStatus["FINISHED"] = "FINISHED";
})(IEnumQuizStatus || (IEnumQuizStatus = {}));
var IQuiz_QuestionType;
(function (IQuiz_QuestionType) {
    IQuiz_QuestionType["MULTIPLE_OPTION"] = "MULTIPLE_OPTION";
    IQuiz_QuestionType["MULTIPLE_SELECTION"] = "MULTIPLE_SELECTION";
    IQuiz_QuestionType["OPEN"] = "OPEN";
})(IQuiz_QuestionType || (IQuiz_QuestionType = {}));
var IEnumTagPosition;
(function (IEnumTagPosition) {
    IEnumTagPosition["TOP"] = "TOP";
    IEnumTagPosition["BOTTOM"] = "BOTTOM";
    IEnumTagPosition["LEFT"] = "LEFT";
    IEnumTagPosition["RIGHT"] = "RIGHT";
    IEnumTagPosition["HIDDEN"] = "HIDDEN";
    IEnumTagPosition["QUIZ"] = "QUIZ";
})(IEnumTagPosition || (IEnumTagPosition = {}));
var IEnumOnlineQuizStatus;
(function (IEnumOnlineQuizStatus) {
    IEnumOnlineQuizStatus["DRAFT"] = "DRAFT";
    IEnumOnlineQuizStatus["PUBLISHED"] = "PUBLISHED";
})(IEnumOnlineQuizStatus || (IEnumOnlineQuizStatus = {}));
var IEnumCivilState;
(function (IEnumCivilState) {
    IEnumCivilState["SINGLE"] = "SINGLE";
    IEnumCivilState["MARRIED"] = "MARRIED";
    IEnumCivilState["FREE_UNION"] = "FREE_UNION";
    IEnumCivilState["SEPARATE"] = "SEPARATE";
    IEnumCivilState["DIVORCED"] = "DIVORCED";
    IEnumCivilState["WIDOWER"] = "WIDOWER";
})(IEnumCivilState || (IEnumCivilState = {}));
var IEnumBenefits;
(function (IEnumBenefits) {
    IEnumBenefits["ANOTHER"] = "ANOTHER";
    IEnumBenefits["LAW_BENEFITS"] = "LAW_BENEFITS";
})(IEnumBenefits || (IEnumBenefits = {}));
var IEnumHiringType;
(function (IEnumHiringType) {
    IEnumHiringType["DETERMINATED"] = "DETERMINATED";
    IEnumHiringType["UNDETERMINATED"] = "UNDETERMINATED";
    IEnumHiringType["TRIAL"] = "TRIAL";
    IEnumHiringType["TRAINING"] = "TRAINING";
    IEnumHiringType["SEASON"] = "SEASON";
})(IEnumHiringType || (IEnumHiringType = {}));
var IFrequencyPayment;
(function (IFrequencyPayment) {
    IFrequencyPayment["BIWEEKLY"] = "BIWEEKLY";
    IFrequencyPayment["MONTHLY"] = "MONTHLY";
    IFrequencyPayment["QUARTERLY"] = "QUARTERLY";
    IFrequencyPayment["SEMI_ANNUALLY"] = "SEMI_ANNUALLY";
    IFrequencyPayment["ANNUALLY"] = "ANNUALLY";
})(IFrequencyPayment || (IFrequencyPayment = {}));
var IServicePayment;
(function (IServicePayment) {
    IServicePayment["MEXPAGO"] = "MEXPAGO";
    IServicePayment["PAYPAL"] = "PAYPAL";
    IServicePayment["STRIPE"] = "STRIPE";
    IServicePayment["CONEKTA"] = "CONEKTA";
    IServicePayment["FLAP"] = "FLAP";
})(IServicePayment || (IServicePayment = {}));
var IBackgroundTypesOptions;
(function (IBackgroundTypesOptions) {
    IBackgroundTypesOptions["INPUTTEXT"] = "INPUTTEXT";
    IBackgroundTypesOptions["CHECKBOX"] = "CHECKBOX";
    IBackgroundTypesOptions["RADIOINPUT"] = "RADIOINPUT";
    IBackgroundTypesOptions["TEXTEDITOR"] = "TEXTEDITOR";
})(IBackgroundTypesOptions || (IBackgroundTypesOptions = {}));
var IEnumInsideType;
(function (IEnumInsideType) {
    IEnumInsideType["PROGRESS"] = "PROGRESS";
    IEnumInsideType["DEADLINE"] = "DEADLINE";
    IEnumInsideType["TEXT"] = "TEXT";
    IEnumInsideType["MEMBER"] = "MEMBER";
    IEnumInsideType["TASK"] = "TASK";
    IEnumInsideType["STATUS"] = "STATUS";
    IEnumInsideType["FILE"] = "FILE";
    IEnumInsideType["DATE"] = "DATE";
})(IEnumInsideType || (IEnumInsideType = {}));
var IProgress;
(function (IProgress) {
    IProgress["NONE"] = "NONE";
    IProgress["NOT_INITIALIZED"] = "NOT_INITIALIZED";
    IProgress["IN_PROGRESS"] = "IN_PROGRESS";
    IProgress["STAGNANT"] = "STAGNANT";
    IProgress["FINALIZED"] = "FINALIZED";
})(IProgress || (IProgress = {}));
var IPriority;
(function (IPriority) {
    IPriority["NONE"] = "NONE";
    IPriority["LOW"] = "LOW";
    IPriority["MEDIUM"] = "MEDIUM";
    IPriority["HIGH"] = "HIGH";
})(IPriority || (IPriority = {}));
var IEnumSpaceAccess;
(function (IEnumSpaceAccess) {
    IEnumSpaceAccess["READER"] = "READER";
    IEnumSpaceAccess["EDITOR"] = "EDITOR";
})(IEnumSpaceAccess || (IEnumSpaceAccess = {}));
var IEnumVisibility;
(function (IEnumVisibility) {
    IEnumVisibility["NONE"] = "NONE";
    IEnumVisibility["PUBLIC"] = "PUBLIC";
    IEnumVisibility["PRIVATE"] = "PRIVATE";
})(IEnumVisibility || (IEnumVisibility = {}));
var IFunctionType;
(function (IFunctionType) {
    IFunctionType["WRITE"] = "WRITE";
    IFunctionType["READER"] = "READER";
    IFunctionType["CUSTOM"] = "CUSTOM";
    IFunctionType["DISABLE"] = "DISABLE";
})(IFunctionType || (IFunctionType = {}));
var IServiceEmail;
(function (IServiceEmail) {
    IServiceEmail["SENDGRID"] = "SENDGRID";
})(IServiceEmail || (IServiceEmail = {}));
var ITemplateService;
(function (ITemplateService) {
    ITemplateService["REGISTER"] = "REGISTER";
})(ITemplateService || (ITemplateService = {}));
var ITypeForm;
(function (ITypeForm) {
    ITypeForm["LIFE"] = "LIFE";
    ITypeForm["WITHDRAWAL"] = "WITHDRAWAL";
    ITypeForm["EDUCATIONAL"] = "EDUCATIONAL";
    ITypeForm["INVESTMENT"] = "INVESTMENT";
    ITypeForm["MEDICAL_EXPENSES"] = "MEDICAL_EXPENSES";
})(ITypeForm || (ITypeForm = {}));
var ICourseLevel;
(function (ICourseLevel) {
    ICourseLevel["BEGGINER"] = "BEGGINER";
    ICourseLevel["ADVANCED"] = "ADVANCED";
})(ICourseLevel || (ICourseLevel = {}));
var ICourseModality;
(function (ICourseModality) {
    ICourseModality["PRESENCIAL"] = "PRESENCIAL";
    ICourseModality["VIRTUAL"] = "VIRTUAL";
})(ICourseModality || (ICourseModality = {}));
var ICourseType;
(function (ICourseType) {
    ICourseType["SIMPLE"] = "SIMPLE";
    ICourseType["CERTIFICATE"] = "CERTIFICATE";
})(ICourseType || (ICourseType = {}));
var IBeginType;
(function (IBeginType) {
    IBeginType["UNIQUE"] = "UNIQUE";
    IBeginType["MULTIPLE"] = "MULTIPLE";
})(IBeginType || (IBeginType = {}));
var IPurchaseQuoteStatus;
(function (IPurchaseQuoteStatus) {
    IPurchaseQuoteStatus["PENDING"] = "PENDING";
    IPurchaseQuoteStatus["ACCEPTED"] = "ACCEPTED";
    IPurchaseQuoteStatus["DENIED"] = "DENIED";
})(IPurchaseQuoteStatus || (IPurchaseQuoteStatus = {}));
var IEventMode;
(function (IEventMode) {
    IEventMode["ONLINE"] = "ONLINE";
    IEventMode["FACE_TO_FACE"] = "FACE_TO_FACE";
})(IEventMode || (IEventMode = {}));
var IEventVisibility;
(function (IEventVisibility) {
    IEventVisibility["PUBLIC"] = "PUBLIC";
    IEventVisibility["PRIVATE"] = "PRIVATE";
})(IEventVisibility || (IEventVisibility = {}));
var IEventStatus;
(function (IEventStatus) {
    IEventStatus["CLOSED"] = "CLOSED";
    IEventStatus["OPEN"] = "OPEN";
})(IEventStatus || (IEventStatus = {}));
var ITemplateType;
(function (ITemplateType) {
    ITemplateType["WHATSAPP"] = "WHATSAPP";
    ITemplateType["PUSH_NOTIFICATION"] = "PUSH_NOTIFICATION";
    ITemplateType["EMAIL"] = "EMAIL";
    ITemplateType["SMS"] = "SMS";
    ITemplateType["CAMPAIGN"] = "CAMPAIGN";
    ITemplateType["WHATSAPP_MESSAGES"] = "WHATSAPP_MESSAGES";
})(ITemplateType || (ITemplateType = {}));
var IRoleType;
(function (IRoleType) {
    IRoleType["NOMINATOR"] = "NOMINATOR";
    IRoleType["SELLER"] = "SELLER";
    IRoleType["PROSPECT"] = "PROSPECT";
})(IRoleType || (IRoleType = {}));
var ICouponRuleType;
(function (ICouponRuleType) {
    ICouponRuleType["FIXED_AMOUNT"] = "FIXED_AMOUNT";
    ICouponRuleType["DISCOUNT"] = "DISCOUNT";
})(ICouponRuleType || (ICouponRuleType = {}));
var IRuleAppliesOn;
(function (IRuleAppliesOn) {
    IRuleAppliesOn["MEMBERSHIP"] = "MEMBERSHIP";
    IRuleAppliesOn["PRODUCT"] = "PRODUCT";
    IRuleAppliesOn["CATEGORIES"] = "CATEGORIES";
})(IRuleAppliesOn || (IRuleAppliesOn = {}));
var ITypeVideo;
(function (ITypeVideo) {
    ITypeVideo["STREAM"] = "STREAM";
    ITypeVideo["MEET"] = "MEET";
})(ITypeVideo || (ITypeVideo = {}));
var IEnumRecordStatus;
(function (IEnumRecordStatus) {
    IEnumRecordStatus["IN_PROGRESS"] = "IN_PROGRESS";
    IEnumRecordStatus["FINISHED"] = "FINISHED";
})(IEnumRecordStatus || (IEnumRecordStatus = {}));
var IEnumNameCatalog;
(function (IEnumNameCatalog) {
    IEnumNameCatalog["BRAND"] = "BRAND";
    IEnumNameCatalog["SUB_BRAND"] = "SUB_BRAND";
    IEnumNameCatalog["MODEL"] = "MODEL";
    IEnumNameCatalog["DESCRIPTION_MODEL"] = "DESCRIPTION_MODEL";
    IEnumNameCatalog["SEPOMEX"] = "SEPOMEX";
    IEnumNameCatalog["OCCUPATION"] = "OCCUPATION";
    IEnumNameCatalog["BANK"] = "BANK";
    IEnumNameCatalog["INSURER_SUBBRAND"] = "INSURER_SUBBRAND";
    IEnumNameCatalog["FISCAL_REGIME_INSURER_SUBBRANCH"] = "FISCAL_REGIME_INSURER_SUBBRANCH";
})(IEnumNameCatalog || (IEnumNameCatalog = {}));
var IEnumFormsPayment;
(function (IEnumFormsPayment) {
    IEnumFormsPayment["CASH_PAYMENT"] = "CASH_PAYMENT";
    IEnumFormsPayment["BIANNUAL"] = "BIANNUAL";
    IEnumFormsPayment["QUARTERLY"] = "QUARTERLY";
    IEnumFormsPayment["MONTHLY"] = "MONTHLY";
})(IEnumFormsPayment || (IEnumFormsPayment = {}));
var ITransactionType;
(function (ITransactionType) {
    ITransactionType["DIRECT"] = "DIRECT";
    ITransactionType["TO_ACCOUNT"] = "TO_ACCOUNT";
    ITransactionType["SUBSCRIPTION"] = "SUBSCRIPTION";
})(ITransactionType || (ITransactionType = {}));
var ITransactionStatus;
(function (ITransactionStatus) {
    ITransactionStatus["PAID"] = "PAID";
    ITransactionStatus["PENDING"] = "PENDING";
    ITransactionStatus["ERROR"] = "ERROR";
    ITransactionStatus["CANCEL"] = "CANCEL";
})(ITransactionStatus || (ITransactionStatus = {}));
var IQuoteGender;
(function (IQuoteGender) {
    IQuoteGender["MALE"] = "MALE";
    IQuoteGender["FEMALE"] = "FEMALE";
    IQuoteGender["UNKNOWN"] = "UNKNOWN";
})(IQuoteGender || (IQuoteGender = {}));
var IQuoteStatus;
(function (IQuoteStatus) {
    IQuoteStatus["HIRE"] = "HIRE";
    IQuoteStatus["PENDING"] = "PENDING";
    IQuoteStatus["QUOTED"] = "QUOTED";
    IQuoteStatus["ISSUED"] = "ISSUED";
    IQuoteStatus["CANCELED"] = "CANCELED";
    IQuoteStatus["PAID"] = "PAID";
})(IQuoteStatus || (IQuoteStatus = {}));
var IServiceEnvironment;
(function (IServiceEnvironment) {
    IServiceEnvironment["PRODUCTION"] = "PRODUCTION";
    IServiceEnvironment["DEVELOPMENT"] = "DEVELOPMENT";
    IServiceEnvironment["TESTING"] = "TESTING";
})(IServiceEnvironment || (IServiceEnvironment = {}));
var IInsurerPackageStatus;
(function (IInsurerPackageStatus) {
    IInsurerPackageStatus["AMPLIA"] = "AMPLIA";
    IInsurerPackageStatus["LIMITADA"] = "LIMITADA";
    IInsurerPackageStatus["RC"] = "RC";
})(IInsurerPackageStatus || (IInsurerPackageStatus = {}));
var IEnumQuoteStatus;
(function (IEnumQuoteStatus) {
    IEnumQuoteStatus["CANCELED"] = "CANCELED";
    IEnumQuoteStatus["APPROVED"] = "APPROVED";
    IEnumQuoteStatus["APPROVED_BY_CUSTOMER"] = "APPROVED_BY_CUSTOMER";
})(IEnumQuoteStatus || (IEnumQuoteStatus = {}));
var IMetaType;
(function (IMetaType) {
    IMetaType["INT"] = "INT";
    IMetaType["STRING"] = "STRING";
    IMetaType["FLOAT"] = "FLOAT";
    IMetaType["BOOLEAN"] = "BOOLEAN";
})(IMetaType || (IMetaType = {}));
var IServiceOption;
(function (IServiceOption) {
    IServiceOption["PRESENCIAL"] = "PRESENCIAL";
    IServiceOption["ONLINE"] = "ONLINE";
})(IServiceOption || (IServiceOption = {}));
var ICertificateType;
(function (ICertificateType) {
    ICertificateType["GENERATE_DOCUMENT"] = "GENERATE_DOCUMENT";
    ICertificateType["UPLOAD_DOCUMENT"] = "UPLOAD_DOCUMENT";
})(ICertificateType || (ICertificateType = {}));
var IInsurerType;
(function (IInsurerType) {
    IInsurerType["NATIONAL"] = "NATIONAL";
    IInsurerType["INTERNATIONAL"] = "INTERNATIONAL";
    IInsurerType["MIXED"] = "MIXED";
})(IInsurerType || (IInsurerType = {}));
var IMerchandiseStatus;
(function (IMerchandiseStatus) {
    IMerchandiseStatus["DISABLED"] = "DISABLED";
    IMerchandiseStatus["EXCLUDED"] = "EXCLUDED";
    IMerchandiseStatus["WAITING_FOR_APPROVAL"] = "WAITING_FOR_APPROVAL";
    IMerchandiseStatus["ENABLED"] = "ENABLED";
})(IMerchandiseStatus || (IMerchandiseStatus = {}));
var ITransportMode;
(function (ITransportMode) {
    ITransportMode["SEA"] = "SEA";
    ITransportMode["AERIAL"] = "AERIAL";
    ITransportMode["TERRESTRIAL"] = "TERRESTRIAL";
    ITransportMode["INTERMODAL"] = "INTERMODAL";
})(ITransportMode || (ITransportMode = {}));
var ICoverageType;
(function (ICoverageType) {
    ICoverageType["WAREHOUSE_TO_WAREHOUSE"] = "WAREHOUSE_TO_WAREHOUSE";
    ICoverageType["HARBOR_TO_HARBOR"] = "HARBOR_TO_HARBOR";
    ICoverageType["HARBOR_TO_WAREHOUSE"] = "HARBOR_TO_WAREHOUSE";
    ICoverageType["WAREHOUSE_TO_HARBOR"] = "WAREHOUSE_TO_HARBOR";
})(ICoverageType || (ICoverageType = {}));
var IPolicyType;
(function (IPolicyType) {
    IPolicyType["UNIQUE_CLIENT"] = "UNIQUE_CLIENT";
    IPolicyType["MULTICLIENT"] = "MULTICLIENT";
})(IPolicyType || (IPolicyType = {}));
var IPaymentResponsable;
(function (IPaymentResponsable) {
    IPaymentResponsable["CLIENT"] = "CLIENT";
    IPaymentResponsable["INSURER"] = "INSURER";
})(IPaymentResponsable || (IPaymentResponsable = {}));
var IIssueStatus;
(function (IIssueStatus) {
    IIssueStatus["REMESADO"] = "REMESADO";
    IIssueStatus["POR_REMESAR"] = "POR_REMESAR";
    IIssueStatus["RECHAZADO"] = "RECHAZADO";
    IIssueStatus["AUDITAR"] = "AUDITAR";
})(IIssueStatus || (IIssueStatus = {}));
var ICertificateStatusFrom;
(function (ICertificateStatusFrom) {
    ICertificateStatusFrom["ADMINISTRATOR"] = "ADMINISTRATOR";
    ICertificateStatusFrom["PUBLIC_USER"] = "PUBLIC_USER";
})(ICertificateStatusFrom || (ICertificateStatusFrom = {}));
var ICertificateMovementType;
(function (ICertificateMovementType) {
    ICertificateMovementType["REJECTION"] = "REJECTION";
    ICertificateMovementType["APPROVAL"] = "APPROVAL";
})(ICertificateMovementType || (ICertificateMovementType = {}));
var Iitus_PaymentTerm;
(function (Iitus_PaymentTerm) {
    Iitus_PaymentTerm["CASH"] = "CASH";
    Iitus_PaymentTerm["CREDIT"] = "CREDIT";
})(Iitus_PaymentTerm || (Iitus_PaymentTerm = {}));
var IInvoicingMethod;
(function (IInvoicingMethod) {
    IInvoicingMethod["BY_CERTIFICATE"] = "BY_CERTIFICATE";
    IInvoicingMethod["GLOBAL"] = "GLOBAL";
})(IInvoicingMethod || (IInvoicingMethod = {}));
var IInvoicingPeriod;
(function (IInvoicingPeriod) {
    IInvoicingPeriod["INMEDIATE"] = "INMEDIATE";
    IInvoicingPeriod["WEEKLY"] = "WEEKLY";
    IInvoicingPeriod["FORTNIGHT"] = "FORTNIGHT";
    IInvoicingPeriod["MONTHLY"] = "MONTHLY";
})(IInvoicingPeriod || (IInvoicingPeriod = {}));
var IContractorType;
(function (IContractorType) {
    IContractorType["MULTICLIENT"] = "MULTICLIENT";
    IContractorType["ONECLIENT"] = "ONECLIENT";
})(IContractorType || (IContractorType = {}));
var IPolicyStatus;
(function (IPolicyStatus) {
    IPolicyStatus["REMESADO"] = "REMESADO";
    IPolicyStatus["POR_REMESAR"] = "POR_REMESAR";
})(IPolicyStatus || (IPolicyStatus = {}));
var IContactType;
(function (IContactType) {
    IContactType["COLLECTION"] = "COLLECTION";
    IContactType["GENERAL"] = "GENERAL";
    IContactType["EMAILINVOICING"] = "EMAILINVOICING";
    IContactType["INVOICINGMODALITY"] = "INVOICINGMODALITY";
})(IContactType || (IContactType = {}));
var IEnumStudenteVerify;
(function (IEnumStudenteVerify) {
    IEnumStudenteVerify["VERIFIED"] = "VERIFIED";
    IEnumStudenteVerify["INCORRECT"] = "INCORRECT";
    IEnumStudenteVerify["TO_BE_CHECKED"] = "TO_BE_CHECKED";
})(IEnumStudenteVerify || (IEnumStudenteVerify = {}));
var IEnumAttendanceStatus;
(function (IEnumAttendanceStatus) {
    IEnumAttendanceStatus["ON_SCHOOL"] = "ON_SCHOOL";
    IEnumAttendanceStatus["TUTOR_ARRIVED"] = "TUTOR_ARRIVED";
    IEnumAttendanceStatus["COMING_OUT"] = "COMING_OUT";
    IEnumAttendanceStatus["ON_HOME"] = "ON_HOME";
    IEnumAttendanceStatus["ABSENT"] = "ABSENT";
})(IEnumAttendanceStatus || (IEnumAttendanceStatus = {}));
var IEnumFCurrency;
(function (IEnumFCurrency) {
    IEnumFCurrency["PESO"] = "PESO";
    IEnumFCurrency["DOLLAR"] = "DOLLAR";
    IEnumFCurrency["UDI"] = "UDI";
    IEnumFCurrency["EURO"] = "EURO";
})(IEnumFCurrency || (IEnumFCurrency = {}));
var IEnumBonoType;
(function (IEnumBonoType) {
    IEnumBonoType["EMISSION"] = "EMISSION";
    IEnumBonoType["CANCEL"] = "CANCEL";
    IEnumBonoType["PRODUCTION"] = "PRODUCTION";
    IEnumBonoType["ANOTHER"] = "ANOTHER";
})(IEnumBonoType || (IEnumBonoType = {}));
var ITypeAgentProvider;
(function (ITypeAgentProvider) {
    ITypeAgentProvider["SURETY"] = "SURETY";
    ITypeAgentProvider["INSURANCE_CARRIER"] = "INSURANCE_CARRIER";
})(ITypeAgentProvider || (ITypeAgentProvider = {}));
var IEnumPolicePaymentType;
(function (IEnumPolicePaymentType) {
    IEnumPolicePaymentType["MONTHLY"] = "MONTHLY";
    IEnumPolicePaymentType["BIMONTHLY"] = "BIMONTHLY";
    IEnumPolicePaymentType["QUARTERLY"] = "QUARTERLY";
    IEnumPolicePaymentType["CASH_PAYMENT"] = "CASH_PAYMENT";
    IEnumPolicePaymentType["BIANNUAL"] = "BIANNUAL";
    IEnumPolicePaymentType["ANNUAL"] = "ANNUAL";
    IEnumPolicePaymentType["FORTNIGTHLY"] = "FORTNIGTHLY";
    IEnumPolicePaymentType["WEEKLLY"] = "WEEKLLY";
    IEnumPolicePaymentType["FOURTEEN"] = "FOURTEEN";
})(IEnumPolicePaymentType || (IEnumPolicePaymentType = {}));
var IEnumPoliceStatus;
(function (IEnumPoliceStatus) {
    IEnumPoliceStatus["DISABLED"] = "DISABLED";
    IEnumPoliceStatus["N_OR_A"] = "N_OR_A";
    IEnumPoliceStatus["IN_PROCESS"] = "IN_PROCESS";
    IEnumPoliceStatus["OT_CANCELED"] = "OT_CANCELED";
    IEnumPoliceStatus["TO_START"] = "TO_START";
    IEnumPoliceStatus["VALID"] = "VALID";
    IEnumPoliceStatus["CANCALED"] = "CANCALED";
    IEnumPoliceStatus["EXPIRED"] = "EXPIRED";
    IEnumPoliceStatus["RENEWED"] = "RENEWED";
    IEnumPoliceStatus["UNRENEWED"] = "UNRENEWED";
    IEnumPoliceStatus["PRE_CANCELED"] = "PRE_CANCELED";
    IEnumPoliceStatus["ACTIVE_BY_A_ENDORSEMENT"] = "ACTIVE_BY_A_ENDORSEMENT";
    IEnumPoliceStatus["INACTIVE_BY_D_ENDORSEMENT"] = "INACTIVE_BY_D_ENDORSEMENT";
    IEnumPoliceStatus["INACTIVE_INITIAL_BY_CANCELATION"] = "INACTIVE_INITIAL_BY_CANCELATION";
    IEnumPoliceStatus["INACTIVE_A_ENDORSEMENT_BY_CANCELATION"] = "INACTIVE_A_ENDORSEMENT_BY_CANCELATION";
    IEnumPoliceStatus["INACTIVE_BY_EXPIRED_POLICY"] = "INACTIVE_BY_EXPIRED_POLICY";
    IEnumPoliceStatus["INACTIVE_BY_RENEWED_POLICY"] = "INACTIVE_BY_RENEWED_POLICY";
})(IEnumPoliceStatus || (IEnumPoliceStatus = {}));
var IEnumPoliceDocumentType;
(function (IEnumPoliceDocumentType) {
    IEnumPoliceDocumentType["POLICY"] = "POLICY";
    IEnumPoliceDocumentType["POLICY_GROUP"] = "POLICY_GROUP";
    IEnumPoliceDocumentType["SUBGROUP"] = "SUBGROUP";
    IEnumPoliceDocumentType["CATEGORY"] = "CATEGORY";
    IEnumPoliceDocumentType["CERTIFICATE"] = "CERTIFICATE";
    IEnumPoliceDocumentType["BAIL"] = "BAIL";
    IEnumPoliceDocumentType["BAIL_COVER"] = "BAIL_COVER";
    IEnumPoliceDocumentType["BAIL_CATEGORY"] = "BAIL_CATEGORY";
    IEnumPoliceDocumentType["BAIL_CERTIFICATE"] = "BAIL_CERTIFICATE";
    IEnumPoliceDocumentType["COLLECTIVITIES"] = "COLLECTIVITIES";
    IEnumPoliceDocumentType["COLLECTIVITIES_POLICY"] = "COLLECTIVITIES_POLICY";
})(IEnumPoliceDocumentType || (IEnumPoliceDocumentType = {}));
var IEnumPoliceAdministrationType;
(function (IEnumPoliceAdministrationType) {
    IEnumPoliceAdministrationType["SIMPLIFIED"] = "SIMPLIFIED";
    IEnumPoliceAdministrationType["SELFMANAGED"] = "SELFMANAGED";
    IEnumPoliceAdministrationType["DETAILED"] = "DETAILED";
})(IEnumPoliceAdministrationType || (IEnumPoliceAdministrationType = {}));
var IEnumPoliceRenew;
(function (IEnumPoliceRenew) {
    IEnumPoliceRenew["RENEWABLE"] = "RENEWABLE";
    IEnumPoliceRenew["UNRENEWABLE"] = "UNRENEWABLE";
})(IEnumPoliceRenew || (IEnumPoliceRenew = {}));
var IEnumPoliceRenewalStatus;
(function (IEnumPoliceRenewalStatus) {
    IEnumPoliceRenewalStatus["THERE_IS_NO_SUBSEQUENT_RENEWAL"] = "THERE_IS_NO_SUBSEQUENT_RENEWAL";
    IEnumPoliceRenewalStatus["RENEW_IN_PROCESS"] = "RENEW_IN_PROCESS";
    IEnumPoliceRenewalStatus["COMPLETEW_RENOVATION"] = "COMPLETEW_RENOVATION";
    IEnumPoliceRenewalStatus["ERROR_THERE_ARE_MULTIPLE_RENOVATIONS"] = "ERROR_THERE_ARE_MULTIPLE_RENOVATIONS";
})(IEnumPoliceRenewalStatus || (IEnumPoliceRenewalStatus = {}));
var IEnumPoliceReceipts;
(function (IEnumPoliceReceipts) {
    IEnumPoliceReceipts["POLICY"] = "POLICY";
    IEnumPoliceReceipts["SUBGROUP"] = "SUBGROUP";
    IEnumPoliceReceipts["CATEGORY"] = "CATEGORY";
})(IEnumPoliceReceipts || (IEnumPoliceReceipts = {}));
var IEnumPayScheme;
(function (IEnumPayScheme) {
    IEnumPayScheme["TRADITIONAL"] = "TRADITIONAL";
    IEnumPayScheme["MINIMUM_PRIMA"] = "MINIMUM_PRIMA";
})(IEnumPayScheme || (IEnumPayScheme = {}));
var IEnumPoliceConcept;
(function (IEnumPoliceConcept) {
    IEnumPoliceConcept["PRECANCELED"] = "PRECANCELED";
    IEnumPoliceConcept["CAPTURE_ERROR"] = "CAPTURE_ERROR";
    IEnumPoliceConcept["REISSUE"] = "REISSUE";
    IEnumPoliceConcept["NON_PAYMENT"] = "NON_PAYMENT";
    IEnumPoliceConcept["ANOTHER"] = "ANOTHER";
    IEnumPoliceConcept["NOT_APPLY"] = "NOT_APPLY";
})(IEnumPoliceConcept || (IEnumPoliceConcept = {}));
var IEnumPoliceEmisionStatus;
(function (IEnumPoliceEmisionStatus) {
    IEnumPoliceEmisionStatus["DOCUMENTS_RECEIVED"] = "DOCUMENTS_RECEIVED";
    IEnumPoliceEmisionStatus["DOCUMENT_PENDING"] = "DOCUMENT_PENDING";
    IEnumPoliceEmisionStatus["DOCUMENT_UPLODAD"] = "DOCUMENT_UPLODAD";
    IEnumPoliceEmisionStatus["IN_AUTHORIZATION"] = "IN_AUTHORIZATION";
    IEnumPoliceEmisionStatus["EMMITED"] = "EMMITED";
})(IEnumPoliceEmisionStatus || (IEnumPoliceEmisionStatus = {}));
var IEnumPoliceBussinessLine;
(function (IEnumPoliceBussinessLine) {
    IEnumPoliceBussinessLine["COMERTIAL"] = "COMERTIAL";
    IEnumPoliceBussinessLine["PERSONAL"] = "PERSONAL";
    IEnumPoliceBussinessLine["ANOTHER"] = "ANOTHER";
})(IEnumPoliceBussinessLine || (IEnumPoliceBussinessLine = {}));
var IEnumPolicyType;
(function (IEnumPolicyType) {
    IEnumPolicyType["OPEN"] = "OPEN";
    IEnumPolicyType["CLOSED"] = "CLOSED";
})(IEnumPolicyType || (IEnumPolicyType = {}));
var IEnumConductChoise;
(function (IEnumConductChoise) {
    IEnumConductChoise["UNDOMICILED"] = "UNDOMICILED";
    IEnumConductChoise["AGENT"] = "AGENT";
    IEnumConductChoise["CAC"] = "CAC";
    IEnumConductChoise["CAT_OR_DOMICILED"] = "CAT_OR_DOMICILED";
    IEnumConductChoise["PAYROLL"] = "PAYROLL";
    IEnumConductChoise["CUT"] = "CUT";
})(IEnumConductChoise || (IEnumConductChoise = {}));
var Isaam_EnumGender;
(function (Isaam_EnumGender) {
    Isaam_EnumGender["MALE"] = "MALE";
    Isaam_EnumGender["FEMALE"] = "FEMALE";
    Isaam_EnumGender["UNKNOWN"] = "UNKNOWN";
})(Isaam_EnumGender || (Isaam_EnumGender = {}));
var IEnumContractorType;
(function (IEnumContractorType) {
    IEnumContractorType["PHYSICAL"] = "PHYSICAL";
    IEnumContractorType["MORAL"] = "MORAL";
})(IEnumContractorType || (IEnumContractorType = {}));
var IEnumContractorGroupType;
(function (IEnumContractorGroupType) {
    IEnumContractorGroupType["GROUP"] = "GROUP";
    IEnumContractorGroupType["SUBGROUP"] = "SUBGROUP";
    IEnumContractorGroupType["SUBSUBGROUP"] = "SUBSUBGROUP";
})(IEnumContractorGroupType || (IEnumContractorGroupType = {}));
var IEnumSinisterRelation;
(function (IEnumSinisterRelation) {
    IEnumSinisterRelation["TITULAR"] = "TITULAR";
    IEnumSinisterRelation["SPOUSE"] = "SPOUSE";
    IEnumSinisterRelation["FIRSTBORN"] = "FIRSTBORN";
    IEnumSinisterRelation["ANOTHER"] = "ANOTHER";
})(IEnumSinisterRelation || (IEnumSinisterRelation = {}));
var IEnumSinisterKind;
(function (IEnumSinisterKind) {
    IEnumSinisterKind["PERSONAL_ACCIDENTS"] = "PERSONAL_ACCIDENTS";
    IEnumSinisterKind["MEDICAL_EXPENSES"] = "MEDICAL_EXPENSES";
    IEnumSinisterKind["HEALTH"] = "HEALTH";
    IEnumSinisterKind["LIFE"] = "LIFE";
    IEnumSinisterKind["CIVIL_LIABILITY_AND_PROFESSIONAL_RISKS"] = "CIVIL_LIABILITY_AND_PROFESSIONAL_RISKS";
    IEnumSinisterKind["MARITIME_AND_TRANSPORT"] = "MARITIME_AND_TRANSPORT";
    IEnumSinisterKind["FIRE"] = "FIRE";
    IEnumSinisterKind["AGRICULTURALAND_ANIMALS"] = "AGRICULTURALAND_ANIMALS";
    IEnumSinisterKind["AUTOMOBILES"] = "AUTOMOBILES";
    IEnumSinisterKind["CREDIT"] = "CREDIT";
    IEnumSinisterKind["HOME_CREDIT"] = "HOME_CREDIT";
    IEnumSinisterKind["FINANCIAL_GUARANTEE"] = "FINANCIAL_GUARANTEE";
    IEnumSinisterKind["DIVERSE"] = "DIVERSE";
    IEnumSinisterKind["EARTHQUAKE_AND_CATASTROPHIC_RISKS"] = "EARTHQUAKE_AND_CATASTROPHIC_RISKS";
})(IEnumSinisterKind || (IEnumSinisterKind = {}));
var IEnumSinisterReason;
(function (IEnumSinisterReason) {
    IEnumSinisterReason["ACCIDENT"] = "ACCIDENT";
    IEnumSinisterReason["DISEASE"] = "DISEASE";
    IEnumSinisterReason["BIRTH"] = "BIRTH";
})(IEnumSinisterReason || (IEnumSinisterReason = {}));
var IEnumSinisterType;
(function (IEnumSinisterType) {
    IEnumSinisterType["INITIAL"] = "INITIAL";
    IEnumSinisterType["COMPLEMENT"] = "COMPLEMENT";
})(IEnumSinisterType || (IEnumSinisterType = {}));
var IEnumSinisterPaymentType;
(function (IEnumSinisterPaymentType) {
    IEnumSinisterPaymentType["CHECK"] = "CHECK";
    IEnumSinisterPaymentType["TRANSFER"] = "TRANSFER";
})(IEnumSinisterPaymentType || (IEnumSinisterPaymentType = {}));
var IEnumSinisterStatus;
(function (IEnumSinisterStatus) {
    IEnumSinisterStatus["PENDING"] = "PENDING";
    IEnumSinisterStatus["IN_PROCESS"] = "IN_PROCESS";
    IEnumSinisterStatus["COMPLETED"] = "COMPLETED";
    IEnumSinisterStatus["CANCELED"] = "CANCELED";
    IEnumSinisterStatus["REJECTED"] = "REJECTED";
    IEnumSinisterStatus["ON_WAITING"] = "ON_WAITING";
    IEnumSinisterStatus["REPROCESS"] = "REPROCESS";
    IEnumSinisterStatus["DISCONFORMITY"] = "DISCONFORMITY";
})(IEnumSinisterStatus || (IEnumSinisterStatus = {}));
var IEnumTypeSinisterGeneral;
(function (IEnumTypeSinisterGeneral) {
    IEnumTypeSinisterGeneral["ACCIDENTS_AND_DISEASES"] = "ACCIDENTS_AND_DISEASES";
    IEnumTypeSinisterGeneral["CAR_DAMAGES"] = "CAR_DAMAGES";
    IEnumTypeSinisterGeneral["NON_CARS_DAMAGE"] = "NON_CARS_DAMAGE";
    IEnumTypeSinisterGeneral["LIFE"] = "LIFE";
})(IEnumTypeSinisterGeneral || (IEnumTypeSinisterGeneral = {}));
var IEnumSinisterCarType;
(function (IEnumSinisterCarType) {
    IEnumSinisterCarType["COLLISION"] = "COLLISION";
    IEnumSinisterCarType["FIRE"] = "FIRE";
    IEnumSinisterCarType["OVERTURN"] = "OVERTURN";
    IEnumSinisterCarType["TOTAL_THEFT"] = "TOTAL_THEFT";
    IEnumSinisterCarType["PARTIAL_THIEF"] = "PARTIAL_THIEF";
    IEnumSinisterCarType["GLASS"] = "GLASS";
    IEnumSinisterCarType["FLOODS"] = "FLOODS";
    IEnumSinisterCarType["CRANE_SERVICE"] = "CRANE_SERVICE";
    IEnumSinisterCarType["TOTAL_LOSS"] = "TOTAL_LOSS";
    IEnumSinisterCarType["VANDALISM"] = "VANDALISM";
    IEnumSinisterCarType["SCOPE_AND_PROOJECTION"] = "SCOPE_AND_PROOJECTION";
    IEnumSinisterCarType["DAMAGES"] = "DAMAGES";
    IEnumSinisterCarType["NATUAL_PHENOMENA"] = "NATUAL_PHENOMENA";
    IEnumSinisterCarType["AFFECTED_BY_COLISION"] = "AFFECTED_BY_COLISION";
    IEnumSinisterCarType["TIRE_DAMAGE"] = "TIRE_DAMAGE";
    IEnumSinisterCarType["ROADSIDE_ASSISTANCE"] = "ROADSIDE_ASSISTANCE";
    IEnumSinisterCarType["RUN_OVER"] = "RUN_OVER";
    IEnumSinisterCarType["ADMINISTRATIVE_TRANSACTIONS"] = "ADMINISTRATIVE_TRANSACTIONS";
    IEnumSinisterCarType["PARTIAL_LOSS"] = "PARTIAL_LOSS";
})(IEnumSinisterCarType || (IEnumSinisterCarType = {}));
var IEnumSinisterCarSubType;
(function (IEnumSinisterCarSubType) {
    IEnumSinisterCarSubType["CONCLUSION_DE_AJUSTE_O_PETICIONES_EN_GENERAL"] = "CONCLUSION_DE_AJUSTE_O_PETICIONES_EN_GENERAL";
    IEnumSinisterCarSubType["LEGAL"] = "LEGAL";
    IEnumSinisterCarSubType["VALUATION"] = "VALUATION";
    IEnumSinisterCarSubType["RERAIR"] = "RERAIR";
    IEnumSinisterCarSubType["MATERIAL_DAMAGE"] = "MATERIAL_DAMAGE";
    IEnumSinisterCarSubType["THEFT"] = "THEFT";
    IEnumSinisterCarSubType["THEFT_LOCATED"] = "THEFT_LOCATED";
    IEnumSinisterCarSubType["REIMBURSEMENT_OF_MEDICAL_EXPENSES"] = "REIMBURSEMENT_OF_MEDICAL_EXPENSES";
    IEnumSinisterCarSubType["REIMBURSEMENT_OF_FUNERAL_EXPENSES"] = "REIMBURSEMENT_OF_FUNERAL_EXPENSES";
    IEnumSinisterCarSubType["CRANE_REINBURSEMENT"] = "CRANE_REINBURSEMENT";
    IEnumSinisterCarSubType["CRANE_REIMBURSEMENT_FOR_ASSISTANCE"] = "CRANE_REIMBURSEMENT_FOR_ASSISTANCE";
    IEnumSinisterCarSubType["GLASS_REINBURSEMENT"] = "GLASS_REINBURSEMENT";
    IEnumSinisterCarSubType["REFUND_OR_DEDUCTIBLE_OR_DAMAGES_TO_THIRD_PARTIES"] = "REFUND_OR_DEDUCTIBLE_OR_DAMAGES_TO_THIRD_PARTIES";
    IEnumSinisterCarSubType["PAYMENT_OF_DAMAGES"] = "PAYMENT_OF_DAMAGES";
    IEnumSinisterCarSubType["PT_LETTER_AND_AMOUTS"] = "PT_LETTER_AND_AMOUTS";
    IEnumSinisterCarSubType["REJECTION_LETTER"] = "REJECTION_LETTER";
    IEnumSinisterCarSubType["DEDUCTIBLE_BILL"] = "DEDUCTIBLE_BILL";
})(IEnumSinisterCarSubType || (IEnumSinisterCarSubType = {}));
var IEnumSinisterCarSubSubType;
(function (IEnumSinisterCarSubSubType) {
    IEnumSinisterCarSubSubType["DOCUMENT_REVIEW"] = "DOCUMENT_REVIEW";
    IEnumSinisterCarSubSubType["COMPENSATION"] = "COMPENSATION";
})(IEnumSinisterCarSubSubType || (IEnumSinisterCarSubSubType = {}));
var IEnumSinisterLifeReason;
(function (IEnumSinisterLifeReason) {
    IEnumSinisterLifeReason["NATURAL"] = "NATURAL";
    IEnumSinisterLifeReason["ACCIDENTAL"] = "ACCIDENTAL";
    IEnumSinisterLifeReason["ORGANIC_LOSSES"] = "ORGANIC_LOSSES";
    IEnumSinisterLifeReason["DISABILITY"] = "DISABILITY";
    IEnumSinisterLifeReason["FUNERALS"] = "FUNERALS";
})(IEnumSinisterLifeReason || (IEnumSinisterLifeReason = {}));
var IEnumSAType;
(function (IEnumSAType) {
    IEnumSAType["PERMANENT"] = "PERMANENT";
    IEnumSAType["RULE_IN_MONTHS"] = "RULE_IN_MONTHS";
    IEnumSAType["ANOTHER"] = "ANOTHER";
})(IEnumSAType || (IEnumSAType = {}));
var IEnumEntorsementType;
(function (IEnumEntorsementType) {
    IEnumEntorsementType["A"] = "A";
    IEnumEntorsementType["B"] = "B";
    IEnumEntorsementType["D"] = "D";
})(IEnumEntorsementType || (IEnumEntorsementType = {}));
var IEnumPoliceReceiptStatus;
(function (IEnumPoliceReceiptStatus) {
    IEnumPoliceReceiptStatus["PAID"] = "PAID";
    IEnumPoliceReceiptStatus["CANCELED"] = "CANCELED";
    IEnumPoliceReceiptStatus["EXTENDED"] = "EXTENDED";
    IEnumPoliceReceiptStatus["PAY_PENDING"] = "PAY_PENDING";
    IEnumPoliceReceiptStatus["LIQUIDATE"] = "LIQUIDATE";
    IEnumPoliceReceiptStatus["RECONCILED"] = "RECONCILED";
    IEnumPoliceReceiptStatus["CLOSED"] = "CLOSED";
    IEnumPoliceReceiptStatus["DISABLED"] = "DISABLED";
    IEnumPoliceReceiptStatus["PRECANCELED"] = "PRECANCELED";
    IEnumPoliceReceiptStatus["PRTIAL_PAYMENT"] = "PRTIAL_PAYMENT";
    IEnumPoliceReceiptStatus["PRE_CANCELED"] = "PRE_CANCELED";
})(IEnumPoliceReceiptStatus || (IEnumPoliceReceiptStatus = {}));
var IEnumPoliceReceiptType;
(function (IEnumPoliceReceiptType) {
    IEnumPoliceReceiptType["POLICY"] = "POLICY";
    IEnumPoliceReceiptType["A_ENDORSEMENT"] = "A_ENDORSEMENT";
    IEnumPoliceReceiptType["D_ENDORSEMENT_CREDIT_NOTE"] = "D_ENDORSEMENT_CREDIT_NOTE";
    IEnumPoliceReceiptType["BOND"] = "BOND";
    IEnumPoliceReceiptType["CERTIFICATE"] = "CERTIFICATE";
})(IEnumPoliceReceiptType || (IEnumPoliceReceiptType = {}));
var IEnumBank;
(function (IEnumBank) {
    IEnumBank["ABC_CAPITAL"] = "ABC_CAPITAL";
    IEnumBank["ACCIVAL"] = "ACCIVAL";
    IEnumBank["ACTINVER"] = "ACTINVER";
    IEnumBank["AFIRME"] = "AFIRME";
    IEnumBank["AKALA"] = "AKALA";
    IEnumBank["AMERICAN_EXPRESS"] = "AMERICAN_EXPRESS";
    IEnumBank["AUTOFIN"] = "AUTOFIN";
    IEnumBank["AXA"] = "AXA";
    IEnumBank["AZTECA"] = "AZTECA";
    IEnumBank["BAJIO"] = "BAJIO";
    IEnumBank["BAMSA"] = "BAMSA";
    IEnumBank["BANCO_FAMSA"] = "BANCO_FAMSA";
    IEnumBank["BANCO_INBURSA"] = "BANCO_INBURSA";
    IEnumBank["BANCOMEXT"] = "BANCOMEXT";
    IEnumBank["BANCOPPEL"] = "BANCOPPEL";
    IEnumBank["BANJERCITO"] = "BANJERCITO";
    IEnumBank["BANK_OF_AMERICA"] = "BANK_OF_AMERICA";
    IEnumBank["BANOBRAS"] = "BANOBRAS";
    IEnumBank["BANORTE"] = "BANORTE";
    IEnumBank["BANREGIO"] = "BANREGIO";
    IEnumBank["BANSEFI"] = "BANSEFI";
    IEnumBank["BANSI"] = "BANSI";
    IEnumBank["BARCLAYS"] = "BARCLAYS";
    IEnumBank["B_AND_B"] = "B_AND_B";
    IEnumBank["BBASE"] = "BBASE";
    IEnumBank["BBVA"] = "BBVA";
    IEnumBank["BITAL"] = "BITAL";
    IEnumBank["BMONEX"] = "BMONEX";
    IEnumBank["BMULTIVA"] = "BMULTIVA";
    IEnumBank["BULLTICK_CB"] = "BULLTICK_CB";
    IEnumBank["BX"] = "BX";
    IEnumBank["BXM"] = "BXM";
    IEnumBank["CA"] = "CA";
    IEnumBank["CB_ACTINVER"] = "CB_ACTINVER";
    IEnumBank["CBDEUTSCHE"] = "CBDEUTSCHE";
    IEnumBank["CB_INTERCAM"] = "CB_INTERCAM";
    IEnumBank["CB_JPMORGAN"] = "CB_JPMORGAN";
    IEnumBank["CIBANCO"] = "CIBANCO";
    IEnumBank["CI_BOLSA"] = "CI_BOLSA";
    IEnumBank["CITI_BANAMEX"] = "CITI_BANAMEX";
    IEnumBank["CLS"] = "CLS";
    IEnumBank["COMPARTAMOS"] = "COMPARTAMOS";
    IEnumBank["CONSUBANCO"] = "CONSUBANCO";
    IEnumBank["CREDIT_SUISSE"] = "CREDIT_SUISSE";
    IEnumBank["DEUTSCHE"] = "DEUTSCHE";
    IEnumBank["DS"] = "DS";
    IEnumBank["CASH"] = "CASH";
    IEnumBank["ESTRUCTURADORES"] = "ESTRUCTURADORES";
    IEnumBank["EVERCORE"] = "EVERCORE";
    IEnumBank["FAMSA"] = "FAMSA";
    IEnumBank["FIESTA_REWARDS_PLATINUM"] = "FIESTA_REWARDS_PLATINUM";
    IEnumBank["FINAMEX"] = "FINAMEX";
    IEnumBank["FINCOMUN"] = "FINCOMUN";
    IEnumBank["GBM"] = "GBM";
    IEnumBank["HDI_SEGUROS"] = "HDI_SEGUROS";
    IEnumBank["HIPOTECARIAFEDERAL"] = "HIPOTECARIAFEDERAL";
    IEnumBank["HSBC"] = "HSBC";
    IEnumBank["INBURSA"] = "INBURSA";
    IEnumBank["INDEVAL"] = "INDEVAL";
    IEnumBank["ING"] = "ING";
    IEnumBank["INTERACCIONES"] = "INTERACCIONES";
    IEnumBank["INTERBANCO"] = "INTERBANCO";
    IEnumBank["INTERNATIONAL_BANK_OF_COMERCE"] = "INTERNATIONAL_BANK_OF_COMERCE";
    IEnumBank["INVERLAT"] = "INVERLAT";
    IEnumBank["INVEX"] = "INVEX";
    IEnumBank["IXE"] = "IXE";
    IEnumBank["JP_MORGAN"] = "JP_MORGAN";
    IEnumBank["KUSPIT"] = "KUSPIT";
    IEnumBank["LAREDO_NATIONAL_BANK"] = "LAREDO_NATIONAL_BANK";
    IEnumBank["LB"] = "LB";
    IEnumBank["LIBERTAD"] = "LIBERTAD";
    IEnumBank["LIVERPOOL"] = "LIVERPOOL";
    IEnumBank["MAPFRE"] = "MAPFRE";
    IEnumBank["MASARI"] = "MASARI";
    IEnumBank["MASTER_CARD"] = "MASTER_CARD";
    IEnumBank["MERRILL_LYNCH"] = "MERRILL_LYNCH";
    IEnumBank["MSI"] = "MSI";
    IEnumBank["MIFEL"] = "MIFEL";
    IEnumBank["MONEXCB"] = "MONEXCB";
    IEnumBank["NAFIN"] = "NAFIN";
    IEnumBank["OACTIN"] = "OACTIN";
    IEnumBank["OPCIONES_EMPRESARIALES_DEL_NOROESTE"] = "OPCIONES_EMPRESARIALES_DEL_NOROESTE";
    IEnumBank["ORDER"] = "ORDER";
    IEnumBank["OTROS"] = "OTROS";
    IEnumBank["PROFUTURO"] = "PROFUTURO";
    IEnumBank["REFORMA"] = "REFORMA";
    IEnumBank["SANTANDER"] = "SANTANDER";
    IEnumBank["SCOTIABANK"] = "SCOTIABANK";
    IEnumBank["SEGMTY"] = "SEGMTY";
    IEnumBank["SKANDIA"] = "SKANDIA";
    IEnumBank["SOFIEXPRESS"] = "SOFIEXPRESS";
    IEnumBank["STERLING"] = "STERLING";
    IEnumBank["STP"] = "STP";
    IEnumBank["SU_CASITA"] = "SU_CASITA";
    IEnumBank["TC"] = "TC";
    IEnumBank["TELECOMM"] = "TELECOMM";
    IEnumBank["THE_ROYAL_BANK"] = "THE_ROYAL_BANK";
    IEnumBank["TIBER"] = "TIBER";
    IEnumBank["TOKYO"] = "TOKYO";
    IEnumBank["TRANSFER"] = "TRANSFER";
    IEnumBank["UBS_BANK"] = "UBS_BANK";
    IEnumBank["UNAGRA"] = "UNAGRA";
    IEnumBank["UNICA"] = "UNICA";
    IEnumBank["VALMEX"] = "VALMEX";
    IEnumBank["VALUE"] = "VALUE";
    IEnumBank["VECTOR"] = "VECTOR";
    IEnumBank["VE_POR_MAS"] = "VE_POR_MAS";
    IEnumBank["VISA"] = "VISA";
    IEnumBank["VOLKSWAGEN"] = "VOLKSWAGEN";
    IEnumBank["WAL_MART"] = "WAL_MART";
    IEnumBank["ZURICH"] = "ZURICH";
})(IEnumBank || (IEnumBank = {}));
var IEnumReferrerClosed;
(function (IEnumReferrerClosed) {
    IEnumReferrerClosed["NON_PAYMENT"] = "NON_PAYMENT";
    IEnumReferrerClosed["IN_ACCOUNT"] = "IN_ACCOUNT";
    IEnumReferrerClosed["CLOSED"] = "CLOSED";
})(IEnumReferrerClosed || (IEnumReferrerClosed = {}));
var IEnumPoliceReceiptPaymentMethod;
(function (IEnumPoliceReceiptPaymentMethod) {
    IEnumPoliceReceiptPaymentMethod["UNKNOWN"] = "UNKNOWN";
    IEnumPoliceReceiptPaymentMethod["CHECK"] = "CHECK";
    IEnumPoliceReceiptPaymentMethod["CASH"] = "CASH";
    IEnumPoliceReceiptPaymentMethod["TRANSFER"] = "TRANSFER";
    IEnumPoliceReceiptPaymentMethod["CREDIT_NOTE"] = "CREDIT_NOTE";
    IEnumPoliceReceiptPaymentMethod["DEPOSIT_PRIMA"] = "DEPOSIT_PRIMA";
    IEnumPoliceReceiptPaymentMethod["BANK_DEPOSIT"] = "BANK_DEPOSIT";
    IEnumPoliceReceiptPaymentMethod["CREDIT_CARD"] = "CREDIT_CARD";
    IEnumPoliceReceiptPaymentMethod["DEBIT_CARD"] = "DEBIT_CARD";
    IEnumPoliceReceiptPaymentMethod["ACCOUNT_STATUS"] = "ACCOUNT_STATUS";
    IEnumPoliceReceiptPaymentMethod["COMPANY"] = "COMPANY";
})(IEnumPoliceReceiptPaymentMethod || (IEnumPoliceReceiptPaymentMethod = {}));
var IEnumAutoType;
(function (IEnumAutoType) {
    IEnumAutoType["CAR"] = "CAR";
    IEnumAutoType["MOTORCYCLE"] = "MOTORCYCLE";
    IEnumAutoType["TRACT"] = "TRACT";
    IEnumAutoType["BUS"] = "BUS";
    IEnumAutoType["PICK_UP"] = "PICK_UP";
    IEnumAutoType["TRUCK_1_5_TON"] = "TRUCK_1_5_TON";
    IEnumAutoType["DRIVER_APP"] = "DRIVER_APP";
    IEnumAutoType["TRAILER"] = "TRAILER";
    IEnumAutoType["TRUCK_PLUS_1_5_TON"] = "TRUCK_PLUS_1_5_TON";
})(IEnumAutoType || (IEnumAutoType = {}));
var IEnumChargeType;
(function (IEnumChargeType) {
    IEnumChargeType["A"] = "A";
    IEnumChargeType["B"] = "B";
    IEnumChargeType["C"] = "C";
    IEnumChargeType["UNKNOWN"] = "UNKNOWN";
})(IEnumChargeType || (IEnumChargeType = {}));
var IEnumProcedent;
(function (IEnumProcedent) {
    IEnumProcedent["RESICENCE"] = "RESICENCE";
    IEnumProcedent["TOURIST"] = "TOURIST";
    IEnumProcedent["LEGALIZED"] = "LEGALIZED";
    IEnumProcedent["FRONTIER"] = "FRONTIER";
    IEnumProcedent["UNSPECIFIED"] = "UNSPECIFIED";
})(IEnumProcedent || (IEnumProcedent = {}));
var IEnumFormDamageType;
(function (IEnumFormDamageType) {
    IEnumFormDamageType["N_A"] = "N_A";
    IEnumFormDamageType["ANOTHER"] = "ANOTHER";
    IEnumFormDamageType["FAMILIAR"] = "FAMILIAR";
    IEnumFormDamageType["HOUSE_ROOM"] = "HOUSE_ROOM";
    IEnumFormDamageType["CONDOMINIUM"] = "CONDOMINIUM";
    IEnumFormDamageType["BUILDING"] = "BUILDING";
    IEnumFormDamageType["MULTIPLE_BUSSINESS"] = "MULTIPLE_BUSSINESS";
    IEnumFormDamageType["ONLY_FIRE"] = "ONLY_FIRE";
    IEnumFormDamageType["PLANE"] = "PLANE";
    IEnumFormDamageType["SHIP"] = "SHIP";
    IEnumFormDamageType["STATEMENT"] = "STATEMENT";
    IEnumFormDamageType["DRONE"] = "DRONE";
    IEnumFormDamageType["PLEASURE_BOATS"] = "PLEASURE_BOATS";
    IEnumFormDamageType["SPECIFY"] = "SPECIFY";
    IEnumFormDamageType["HELICOPTER"] = "HELICOPTER";
    IEnumFormDamageType["PROGNOSIS"] = "PROGNOSIS";
    IEnumFormDamageType["ANIMALS"] = "ANIMALS";
    IEnumFormDamageType["CROPS"] = "CROPS";
    IEnumFormDamageType["GENERAL_CREDIT"] = "GENERAL_CREDIT";
    IEnumFormDamageType["HOME_CREDIT"] = "HOME_CREDIT";
    IEnumFormDamageType["DOCUMENTOS_QUE_SEAN_OBJETO_DE_OFERTA_PUBLICA_O_DE_INTERMEDIACION_EN_MERCADOS_DE_VALORES"] = "DOCUMENTOS_QUE_SEAN_OBJETO_DE_OFERTA_PUBLICA_O_DE_INTERMEDIACION_EN_MERCADOS_DE_VALORES";
    IEnumFormDamageType["SECURITIES_EMISSIONS"] = "SECURITIES_EMISSIONS";
    IEnumFormDamageType["CREDIT_TITLES"] = "CREDIT_TITLES";
    IEnumFormDamageType["ADMINISTRATION"] = "ADMINISTRATION";
    IEnumFormDamageType["ARCHITECTS"] = "ARCHITECTS";
    IEnumFormDamageType["CONTRACTOR"] = "CONTRACTOR";
    IEnumFormDamageType["CRIME"] = "CRIME";
    IEnumFormDamageType["ATOS"] = "ATOS";
    IEnumFormDamageType["OFFICERS"] = "OFFICERS";
    IEnumFormDamageType["MISCELLANEOUS_E_AND_O"] = "MISCELLANEOUS_E_AND_O";
    IEnumFormDamageType["BUSSINESS"] = "BUSSINESS";
    IEnumFormDamageType["EVENT"] = "EVENT";
    IEnumFormDamageType["FAMILIAR_AND_CONDOMINIUM"] = "FAMILIAR_AND_CONDOMINIUM";
    IEnumFormDamageType["HOLE_IN_ONE"] = "HOLE_IN_ONE";
    IEnumFormDamageType["ENGINEERING"] = "ENGINEERING";
    IEnumFormDamageType["FINANCIAL_INSTITUTIONS"] = "FINANCIAL_INSTITUTIONS";
    IEnumFormDamageType["FINANCIAL_LINES"] = "FINANCIAL_LINES";
    IEnumFormDamageType["DOCTORS"] = "DOCTORS";
    IEnumFormDamageType["CATASTRHOPHIC_RISKS"] = "CATASTRHOPHIC_RISKS";
    IEnumFormDamageType["BOILERS_AND_PRESSURE_VESSELS"] = "BOILERS_AND_PRESSURE_VESSELS";
    IEnumFormDamageType["MONEY_AND_VALUES"] = "MONEY_AND_VALUES";
    IEnumFormDamageType["EQ_CONTRACTORS_AND_HEAVY_MACHINE"] = "EQ_CONTRACTORS_AND_HEAVY_MACHINE";
    IEnumFormDamageType["EQ_ELLECTRONIC"] = "EQ_ELLECTRONIC";
    IEnumFormDamageType["MACHINERY_ASSEMBLY"] = "MACHINERY_ASSEMBLY";
    IEnumFormDamageType["CIVIL_WORKS_UNDER_CONSTRUCCION"] = "CIVIL_WORKS_UNDER_CONSTRUCCION";
    IEnumFormDamageType["FINISHED_CIVIL_WORKS"] = "FINISHED_CIVIL_WORKS";
    IEnumFormDamageType["GLASS_BREAK"] = "GLASS_BREAK";
    IEnumFormDamageType["MACHINERY_BREAK"] = "MACHINERY_BREAK";
    IEnumFormDamageType["CRIME_OR_BBB"] = "CRIME_OR_BBB";
    IEnumFormDamageType["D_AND_O"] = "D_AND_O";
    IEnumFormDamageType["FIPI"] = "FIPI";
    IEnumFormDamageType["CYBER"] = "CYBER";
    IEnumFormDamageType["VCAPS"] = "VCAPS";
    IEnumFormDamageType["MEDICAL_RCP"] = "MEDICAL_RCP";
    IEnumFormDamageType["POLITICAL_RISK"] = "POLITICAL_RISK";
    IEnumFormDamageType["RC_PUBLIC_SERVERS"] = "RC_PUBLIC_SERVERS";
    IEnumFormDamageType["RCP"] = "RCP";
})(IEnumFormDamageType || (IEnumFormDamageType = {}));
var IEnumConstructionType;
(function (IEnumConstructionType) {
    IEnumConstructionType["SOLID"] = "SOLID";
    IEnumConstructionType["WOOD"] = "WOOD";
    IEnumConstructionType["LEAF"] = "LEAF";
    IEnumConstructionType["ANOTHER"] = "ANOTHER";
})(IEnumConstructionType || (IEnumConstructionType = {}));
var IEnumContractorGroupingType;
(function (IEnumContractorGroupingType) {
    IEnumContractorGroupingType["ENTERPRISE"] = "ENTERPRISE";
    IEnumContractorGroupingType["COLLEGE"] = "COLLEGE";
    IEnumContractorGroupingType["INDIVIDUAL"] = "INDIVIDUAL";
})(IEnumContractorGroupingType || (IEnumContractorGroupingType = {}));
var IEnumReferrerPaymentType;
(function (IEnumReferrerPaymentType) {
    IEnumReferrerPaymentType["CLABE"] = "CLABE";
    IEnumReferrerPaymentType["ACCOUNT_NUMBER"] = "ACCOUNT_NUMBER";
    IEnumReferrerPaymentType["CARD_NUMBER"] = "CARD_NUMBER";
    IEnumReferrerPaymentType["CASH"] = "CASH";
})(IEnumReferrerPaymentType || (IEnumReferrerPaymentType = {}));
var IEnumReferrerFrequency;
(function (IEnumReferrerFrequency) {
    IEnumReferrerFrequency["WEEKLY"] = "WEEKLY";
    IEnumReferrerFrequency["FORTNIGHTLY"] = "FORTNIGHTLY";
    IEnumReferrerFrequency["MONTHLY"] = "MONTHLY";
})(IEnumReferrerFrequency || (IEnumReferrerFrequency = {}));
var IEnumReferrerAccountState;
(function (IEnumReferrerAccountState) {
    IEnumReferrerAccountState["PRE_APPROVED"] = "PRE_APPROVED";
    IEnumReferrerAccountState["CLOSED"] = "CLOSED";
    IEnumReferrerAccountState["REJECTED"] = "REJECTED";
})(IEnumReferrerAccountState || (IEnumReferrerAccountState = {}));
var IEnumPoliceQuoteStatus;
(function (IEnumPoliceQuoteStatus) {
    IEnumPoliceQuoteStatus["DISABLED"] = "DISABLED";
    IEnumPoliceQuoteStatus["IN_PROCESS"] = "IN_PROCESS";
    IEnumPoliceQuoteStatus["EMITTED"] = "EMITTED";
    IEnumPoliceQuoteStatus["BATTED"] = "BATTED";
})(IEnumPoliceQuoteStatus || (IEnumPoliceQuoteStatus = {}));
var IEnumInsurerReminderType;
(function (IEnumInsurerReminderType) {
    IEnumInsurerReminderType["AUTOMATIC"] = "AUTOMATIC";
    IEnumInsurerReminderType["FREE"] = "FREE";
    IEnumInsurerReminderType["FROM_RECORD"] = "FROM_RECORD";
})(IEnumInsurerReminderType || (IEnumInsurerReminderType = {}));
var IEnumInsurerReminderInstanceType;
(function (IEnumInsurerReminderInstanceType) {
    IEnumInsurerReminderInstanceType["POLICY_NOT_RENEWED_VALIDITY_DATE"] = "POLICY_NOT_RENEWED_VALIDITY_DATE";
    IEnumInsurerReminderInstanceType["PAY_PENDING_RECEIPTS_START_VALIDITY_DATE"] = "PAY_PENDING_RECEIPTS_START_VALIDITY_DATE";
    IEnumInsurerReminderInstanceType["PAY_PENDING_RECEIPTS_END_VALIDITY_DATE"] = "PAY_PENDING_RECEIPTS_END_VALIDITY_DATE";
    IEnumInsurerReminderInstanceType["PAY_PENDING_RECEIPTS_PROMISE_DATE"] = "PAY_PENDING_RECEIPTS_PROMISE_DATE";
    IEnumInsurerReminderInstanceType["SINISTER_COMPROMISE_DATE"] = "SINISTER_COMPROMISE_DATE";
})(IEnumInsurerReminderInstanceType || (IEnumInsurerReminderInstanceType = {}));
var IEnumInsurerCommentModel;
(function (IEnumInsurerCommentModel) {
    IEnumInsurerCommentModel["POLICE"] = "POLICE";
    IEnumInsurerCommentModel["CONTRACTOR"] = "CONTRACTOR";
    IEnumInsurerCommentModel["RECEIPTS"] = "RECEIPTS";
    IEnumInsurerCommentModel["SINISTER"] = "SINISTER";
    IEnumInsurerCommentModel["RENOVATIONS"] = "RENOVATIONS";
    IEnumInsurerCommentModel["COMMISSIONS_RECEIPTS"] = "COMMISSIONS_RECEIPTS";
    IEnumInsurerCommentModel["GROUPS"] = "GROUPS";
    IEnumInsurerCommentModel["PACKAGE"] = "PACKAGE";
    IEnumInsurerCommentModel["ENDORSEMENT"] = "ENDORSEMENT";
    IEnumInsurerCommentModel["AGENTPROVIDER"] = "AGENTPROVIDER";
    IEnumInsurerCommentModel["ACCOUNT_STATUS"] = "ACCOUNT_STATUS";
    IEnumInsurerCommentModel["BAIL"] = "BAIL";
    IEnumInsurerCommentModel["BONDS"] = "BONDS";
    IEnumInsurerCommentModel["COMMENTS"] = "COMMENTS";
    IEnumInsurerCommentModel["LOG"] = "LOG";
    IEnumInsurerCommentModel["LETTERS"] = "LETTERS";
    IEnumInsurerCommentModel["COLLECTIVITIES"] = "COLLECTIVITIES";
    IEnumInsurerCommentModel["GRAPHS"] = "GRAPHS";
    IEnumInsurerCommentModel["NOTES"] = "NOTES";
    IEnumInsurerCommentModel["BAIL_CLAIM"] = "BAIL_CLAIM";
    IEnumInsurerCommentModel["TASKS"] = "TASKS";
    IEnumInsurerCommentModel["FINISHED_TASKS"] = "FINISHED_TASKS";
    IEnumInsurerCommentModel["EVENTS"] = "EVENTS";
    IEnumInsurerCommentModel["CERTIFICATE"] = "CERTIFICATE";
    IEnumInsurerCommentModel["REPORTS"] = "REPORTS";
    IEnumInsurerCommentModel["APP_MNOTIFICATIONS"] = "APP_MNOTIFICATIONS";
    IEnumInsurerCommentModel["FLOTILLAS"] = "FLOTILLAS";
    IEnumInsurerCommentModel["MAILING_TEMPLATE"] = "MAILING_TEMPLATE";
    IEnumInsurerCommentModel["REMINDERS"] = "REMINDERS";
})(IEnumInsurerCommentModel || (IEnumInsurerCommentModel = {}));
var IEnumEmaiModel;
(function (IEnumEmaiModel) {
    IEnumEmaiModel["OT_REQUEST"] = "OT_REQUEST";
    IEnumEmaiModel["OT_REGISTER"] = "OT_REGISTER";
    IEnumEmaiModel["ACCIDENT_REQUEST"] = "ACCIDENT_REQUEST";
    IEnumEmaiModel["ACCIDENT_END"] = "ACCIDENT_END";
    IEnumEmaiModel["REMINDER"] = "REMINDER";
    IEnumEmaiModel["PAYMENT"] = "PAYMENT";
    IEnumEmaiModel["CREATED_NOTE"] = "CREATED_NOTE";
    IEnumEmaiModel["APPLIED_NOTE"] = "APPLIED_NOTE";
    IEnumEmaiModel["POLICE_RENEW"] = "POLICE_RENEW";
    IEnumEmaiModel["REMINDER_POLICE_RENEW"] = "REMINDER_POLICE_RENEW";
    IEnumEmaiModel["ACCIDENT_IN_PROCESS"] = "ACCIDENT_IN_PROCESS";
    IEnumEmaiModel["ACCIDENT_CANCELED"] = "ACCIDENT_CANCELED";
    IEnumEmaiModel["ACCIDENT_REJECTED"] = "ACCIDENT_REJECTED";
    IEnumEmaiModel["ACCIDENT_ON_QUEUE"] = "ACCIDENT_ON_QUEUE";
})(IEnumEmaiModel || (IEnumEmaiModel = {}));
var IEnumEmailFrequency;
(function (IEnumEmailFrequency) {
    IEnumEmailFrequency["MONTHLY"] = "MONTHLY";
    IEnumEmailFrequency["FORTNIGTHLY"] = "FORTNIGTHLY";
    IEnumEmailFrequency["WEEKLY"] = "WEEKLY";
    IEnumEmailFrequency["OVERDUE"] = "OVERDUE";
    IEnumEmailFrequency["LATER_WEEK"] = "LATER_WEEK";
    IEnumEmailFrequency["LATER_FORTNIGTH"] = "LATER_FORTNIGTH";
    IEnumEmailFrequency["LATER_MONTH"] = "LATER_MONTH";
    IEnumEmailFrequency["OVERDUE_POLICE_TO_RENEW"] = "OVERDUE_POLICE_TO_RENEW";
    IEnumEmailFrequency["TWENTY_DATYS_AFTER"] = "TWENTY_DATYS_AFTER";
    IEnumEmailFrequency["TWENTY_DATYS_BEFORE"] = "TWENTY_DATYS_BEFORE";
})(IEnumEmailFrequency || (IEnumEmailFrequency = {}));
var IEnumEmailRamo;
(function (IEnumEmailRamo) {
    IEnumEmailRamo["LIFE"] = "LIFE";
    IEnumEmailRamo["ACIDENTS_AND_DISEASES"] = "ACIDENTS_AND_DISEASES";
    IEnumEmailRamo["DAMAGES"] = "DAMAGES";
    IEnumEmailRamo["ALL"] = "ALL";
})(IEnumEmailRamo || (IEnumEmailRamo = {}));
var IEnumEmailType;
(function (IEnumEmailType) {
    IEnumEmailType["POLICE"] = "POLICE";
    IEnumEmailType["IND_POLICE_OF_COLECTIVITY"] = "IND_POLICE_OF_COLECTIVITY";
    IEnumEmailType["GROUP_POLICE"] = "GROUP_POLICE";
    IEnumEmailType["ALL"] = "ALL";
})(IEnumEmailType || (IEnumEmailType = {}));
var IEnumEmailChargeType;
(function (IEnumEmailChargeType) {
    IEnumEmailChargeType["DOMICILED"] = "DOMICILED";
    IEnumEmailChargeType["UNDOMICILED"] = "UNDOMICILED";
    IEnumEmailChargeType["ALL"] = "ALL";
    IEnumEmailChargeType["UNDOMICILIED_AND_AGENT"] = "UNDOMICILIED_AND_AGENT";
})(IEnumEmailChargeType || (IEnumEmailChargeType = {}));
var IEnumEmailDateType;
(function (IEnumEmailDateType) {
    IEnumEmailDateType["VALIDITY_BEGIN"] = "VALIDITY_BEGIN";
    IEnumEmailDateType["OVERDUE"] = "OVERDUE";
})(IEnumEmailDateType || (IEnumEmailDateType = {}));
var IEnumPoliceReceiptFolioPaymentMethod;
(function (IEnumPoliceReceiptFolioPaymentMethod) {
    IEnumPoliceReceiptFolioPaymentMethod["CHECK"] = "CHECK";
    IEnumPoliceReceiptFolioPaymentMethod["CASH"] = "CASH";
    IEnumPoliceReceiptFolioPaymentMethod["TRANSFER"] = "TRANSFER";
    IEnumPoliceReceiptFolioPaymentMethod["BANK_DEPOSIT"] = "BANK_DEPOSIT";
    IEnumPoliceReceiptFolioPaymentMethod["CREDIT_CARD"] = "CREDIT_CARD";
    IEnumPoliceReceiptFolioPaymentMethod["DEBIT_CARD"] = "DEBIT_CARD";
    IEnumPoliceReceiptFolioPaymentMethod["ACCOUNT_STATUS"] = "ACCOUNT_STATUS";
    IEnumPoliceReceiptFolioPaymentMethod["COMPANY"] = "COMPANY";
    IEnumPoliceReceiptFolioPaymentMethod["UNKNOWN"] = "UNKNOWN";
})(IEnumPoliceReceiptFolioPaymentMethod || (IEnumPoliceReceiptFolioPaymentMethod = {}));
var IEnumInsurerLogEvent;
(function (IEnumInsurerLogEvent) {
    IEnumInsurerLogEvent["CREATE"] = "CREATE";
    IEnumInsurerLogEvent["DELETE"] = "DELETE";
    IEnumInsurerLogEvent["UPDATE"] = "UPDATE";
    IEnumInsurerLogEvent["CANCEL"] = "CANCEL";
})(IEnumInsurerLogEvent || (IEnumInsurerLogEvent = {}));
var IEnumInsurerTicketPriority;
(function (IEnumInsurerTicketPriority) {
    IEnumInsurerTicketPriority["LOW"] = "LOW";
    IEnumInsurerTicketPriority["MEDIUM"] = "MEDIUM";
    IEnumInsurerTicketPriority["HIGH"] = "HIGH";
})(IEnumInsurerTicketPriority || (IEnumInsurerTicketPriority = {}));
var IEnumInsurerTicketConcept;
(function (IEnumInsurerTicketConcept) {
    IEnumInsurerTicketConcept["ENDORSEMENT"] = "ENDORSEMENT";
    IEnumInsurerTicketConcept["EMISSION"] = "EMISSION";
    IEnumInsurerTicketConcept["QUOTE"] = "QUOTE";
    IEnumInsurerTicketConcept["CORRECTION"] = "CORRECTION";
    IEnumInsurerTicketConcept["CANCELATION"] = "CANCELATION";
    IEnumInsurerTicketConcept["RENEW"] = "RENEW";
    IEnumInsurerTicketConcept["ANOTHER"] = "ANOTHER";
    IEnumInsurerTicketConcept["REFUND"] = "REFUND";
    IEnumInsurerTicketConcept["SURGERY_SCHEDULING"] = "SURGERY_SCHEDULING";
    IEnumInsurerTicketConcept["B_ENDORSEMENT"] = "B_ENDORSEMENT";
    IEnumInsurerTicketConcept["D_ENDORSEMENT"] = "D_ENDORSEMENT";
    IEnumInsurerTicketConcept["RECOGNITION_ANTIQUITY"] = "RECOGNITION_ANTIQUITY";
    IEnumInsurerTicketConcept["ANTIQUITY_LETTER"] = "ANTIQUITY_LETTER";
})(IEnumInsurerTicketConcept || (IEnumInsurerTicketConcept = {}));
var IEnumNotificationType;
(function (IEnumNotificationType) {
    IEnumNotificationType["NOTIFICATION"] = "NOTIFICATION";
    IEnumNotificationType["PROMOTION"] = "PROMOTION";
})(IEnumNotificationType || (IEnumNotificationType = {}));
var IEnumMonth;
(function (IEnumMonth) {
    IEnumMonth["JANUARY"] = "JANUARY";
    IEnumMonth["FEBRUARY"] = "FEBRUARY";
    IEnumMonth["MARCH"] = "MARCH";
    IEnumMonth["APRIL"] = "APRIL";
    IEnumMonth["MAY"] = "MAY";
    IEnumMonth["JUNE"] = "JUNE";
    IEnumMonth["JULY"] = "JULY";
    IEnumMonth["AUGUST"] = "AUGUST";
    IEnumMonth["SEPTEMBER"] = "SEPTEMBER";
    IEnumMonth["OCTOBER"] = "OCTOBER";
    IEnumMonth["NOVEMBER"] = "NOVEMBER";
    IEnumMonth["DECEMBER"] = "DECEMBER";
})(IEnumMonth || (IEnumMonth = {}));
var IEnumResponsableArea;
(function (IEnumResponsableArea) {
    IEnumResponsableArea["EMITION"] = "EMITION";
    IEnumResponsableArea["EJECUTIVE"] = "EJECUTIVE";
    IEnumResponsableArea["COMERTIAL"] = "COMERTIAL";
    IEnumResponsableArea["COLLECTION"] = "COLLECTION";
    IEnumResponsableArea["SINISTER"] = "SINISTER";
})(IEnumResponsableArea || (IEnumResponsableArea = {}));
var Iexchange_Status;
(function (Iexchange_Status) {
    Iexchange_Status["INPROCESS"] = "INPROCESS";
    Iexchange_Status["EXCHANGED"] = "EXCHANGED";
})(Iexchange_Status || (Iexchange_Status = {}));
var IMovementType;
(function (IMovementType) {
    IMovementType["CODEREGISTRATION"] = "CODEREGISTRATION";
    IMovementType["EXCHANGE"] = "EXCHANGE";
})(IMovementType || (IMovementType = {}));
var IPrizeCodeStatus;
(function (IPrizeCodeStatus) {
    IPrizeCodeStatus["AVAILABLE"] = "AVAILABLE";
    IPrizeCodeStatus["EXCHANGED"] = "EXCHANGED";
})(IPrizeCodeStatus || (IPrizeCodeStatus = {}));
var IHttpStatusCode;
(function (IHttpStatusCode) {
    IHttpStatusCode["CONTINUE"] = "CONTINUE";
    IHttpStatusCode["SWITCHING_PROTOCOLS"] = "SWITCHING_PROTOCOLS";
    IHttpStatusCode["PROCESSING"] = "PROCESSING";
    IHttpStatusCode["EARLY_HINTS"] = "EARLY_HINTS";
    IHttpStatusCode["OK"] = "OK";
    IHttpStatusCode["CREATED"] = "CREATED";
    IHttpStatusCode["ACCEPTED"] = "ACCEPTED";
    IHttpStatusCode["NON_AUTHORITATIVE_INFORMATION"] = "NON_AUTHORITATIVE_INFORMATION";
    IHttpStatusCode["NO_CONTENT"] = "NO_CONTENT";
    IHttpStatusCode["RESET_CONTENT"] = "RESET_CONTENT";
    IHttpStatusCode["PARTIAL_CONTENT"] = "PARTIAL_CONTENT";
    IHttpStatusCode["MULTI_STATUS"] = "MULTI_STATUS";
    IHttpStatusCode["ALREADY_REPORTED"] = "ALREADY_REPORTED";
    IHttpStatusCode["IM_USED"] = "IM_USED";
    IHttpStatusCode["AMBIGUOUS"] = "AMBIGUOUS";
    IHttpStatusCode["MOVED"] = "MOVED";
    IHttpStatusCode["REDIRECT"] = "REDIRECT";
    IHttpStatusCode["REDIRECT_METHOD"] = "REDIRECT_METHOD";
    IHttpStatusCode["NOT_MODIFIED"] = "NOT_MODIFIED";
    IHttpStatusCode["USE_PROXY"] = "USE_PROXY";
    IHttpStatusCode["UNUSED"] = "UNUSED";
    IHttpStatusCode["TEMPORARY_REDIRECT"] = "TEMPORARY_REDIRECT";
    IHttpStatusCode["PERMANENT_REDIRECT"] = "PERMANENT_REDIRECT";
    IHttpStatusCode["BAD_REQUEST"] = "BAD_REQUEST";
    IHttpStatusCode["UNAUTHORIZED"] = "UNAUTHORIZED";
    IHttpStatusCode["PAYMENT_REQUIRED"] = "PAYMENT_REQUIRED";
    IHttpStatusCode["FORBIDDEN"] = "FORBIDDEN";
    IHttpStatusCode["NOT_FOUND"] = "NOT_FOUND";
    IHttpStatusCode["METHOD_NOT_ALLOWED"] = "METHOD_NOT_ALLOWED";
    IHttpStatusCode["NOT_ACCEPTABLE"] = "NOT_ACCEPTABLE";
    IHttpStatusCode["PROXY_AUTHENTICATION_REQUIRED"] = "PROXY_AUTHENTICATION_REQUIRED";
    IHttpStatusCode["REQUEST_TIMEOUT"] = "REQUEST_TIMEOUT";
    IHttpStatusCode["CONFLICT"] = "CONFLICT";
    IHttpStatusCode["GONE"] = "GONE";
    IHttpStatusCode["LENGTH_REQUIRED"] = "LENGTH_REQUIRED";
    IHttpStatusCode["PRECONDITION_FAILED"] = "PRECONDITION_FAILED";
    IHttpStatusCode["REQUEST_ENTITY_TOO_LARGE"] = "REQUEST_ENTITY_TOO_LARGE";
    IHttpStatusCode["REQUEST_URI_TOO_LONG"] = "REQUEST_URI_TOO_LONG";
    IHttpStatusCode["UNSUPPORTED_MEDIA_TYPE"] = "UNSUPPORTED_MEDIA_TYPE";
    IHttpStatusCode["REQUESTED_RANGE_NOT_SATISFIABLE"] = "REQUESTED_RANGE_NOT_SATISFIABLE";
    IHttpStatusCode["EXPECTATION_FAILED"] = "EXPECTATION_FAILED";
    IHttpStatusCode["MISDIRECTED_REQUEST"] = "MISDIRECTED_REQUEST";
    IHttpStatusCode["UNPROCESSABLE_ENTITY"] = "UNPROCESSABLE_ENTITY";
    IHttpStatusCode["LOCKED"] = "LOCKED";
    IHttpStatusCode["FAILED_DEPENDENCY"] = "FAILED_DEPENDENCY";
    IHttpStatusCode["UPGRADE_REQUIRED"] = "UPGRADE_REQUIRED";
    IHttpStatusCode["PRECONDITION_REQUIRED"] = "PRECONDITION_REQUIRED";
    IHttpStatusCode["TOO_MANY_REQUESTS"] = "TOO_MANY_REQUESTS";
    IHttpStatusCode["REQUEST_HEADER_FIELDS_TOO_LARGE"] = "REQUEST_HEADER_FIELDS_TOO_LARGE";
    IHttpStatusCode["UNAVAILABLE_FOR_LEGAL_REASONS"] = "UNAVAILABLE_FOR_LEGAL_REASONS";
    IHttpStatusCode["INTERNAL_SERVER_ERROR"] = "INTERNAL_SERVER_ERROR";
    IHttpStatusCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    IHttpStatusCode["BAD_GATEWAY"] = "BAD_GATEWAY";
    IHttpStatusCode["SERVICE_UNAVAILABLE"] = "SERVICE_UNAVAILABLE";
    IHttpStatusCode["GATEWAY_TIMEOUT"] = "GATEWAY_TIMEOUT";
    IHttpStatusCode["HTTP_VERSION_NOT_SUPPORTED"] = "HTTP_VERSION_NOT_SUPPORTED";
    IHttpStatusCode["VARIANT_ALSO_NEGOTIATES"] = "VARIANT_ALSO_NEGOTIATES";
    IHttpStatusCode["INSUFFICIENT_STORAGE"] = "INSUFFICIENT_STORAGE";
    IHttpStatusCode["LOOP_DETECTED"] = "LOOP_DETECTED";
    IHttpStatusCode["NOT_EXTENDED"] = "NOT_EXTENDED";
    IHttpStatusCode["NETWORK_AUTHENTICATION_REQUIRED"] = "NETWORK_AUTHENTICATION_REQUIRED";
})(IHttpStatusCode || (IHttpStatusCode = {}));
var IEnumGender;
(function (IEnumGender) {
    IEnumGender["MASCULINE"] = "MASCULINE";
    IEnumGender["FEMININE"] = "FEMININE";
})(IEnumGender || (IEnumGender = {}));
var IEnumInsurerSubBranch;
(function (IEnumInsurerSubBranch) {
    IEnumInsurerSubBranch["AXA"] = "AXA";
    IEnumInsurerSubBranch["CHUBB"] = "CHUBB";
    IEnumInsurerSubBranch["SURA"] = "SURA";
    IEnumInsurerSubBranch["ZURICH"] = "ZURICH";
    IEnumInsurerSubBranch["MAPFRE"] = "MAPFRE";
    IEnumInsurerSubBranch["QUALITAS"] = "QUALITAS";
    IEnumInsurerSubBranch["BANORTE"] = "BANORTE";
    IEnumInsurerSubBranch["ANA_SEGUROS"] = "ANA_SEGUROS";
    IEnumInsurerSubBranch["AFIRME"] = "AFIRME";
    IEnumInsurerSubBranch["HDI"] = "HDI";
})(IEnumInsurerSubBranch || (IEnumInsurerSubBranch = {}));
var IEnumIdProduct;
(function (IEnumIdProduct) {
    IEnumIdProduct["AMPLIA"] = "AMPLIA";
    IEnumIdProduct["AMPLIA_PLUS"] = "AMPLIA_PLUS";
    IEnumIdProduct["LIMITADA"] = "LIMITADA";
})(IEnumIdProduct || (IEnumIdProduct = {}));
var IEnumMethodPayment;
(function (IEnumMethodPayment) {
    IEnumMethodPayment["CASH"] = "CASH";
    IEnumMethodPayment["CREDIT_CARD"] = "CREDIT_CARD";
})(IEnumMethodPayment || (IEnumMethodPayment = {}));
var IEnumTypePerson;
(function (IEnumTypePerson) {
    IEnumTypePerson["FISICA"] = "FISICA";
    IEnumTypePerson["MORAL"] = "MORAL";
})(IEnumTypePerson || (IEnumTypePerson = {}));
var IEnumInterval;
(function (IEnumInterval) {
    IEnumInterval["DAY"] = "DAY";
    IEnumInterval["WEEK"] = "WEEK";
    IEnumInterval["MONTH"] = "MONTH";
    IEnumInterval["YEAR"] = "YEAR";
})(IEnumInterval || (IEnumInterval = {}));
var IEnumInsurer;
(function (IEnumInsurer) {
    IEnumInsurer["CHUBB"] = "CHUBB";
    IEnumInsurer["ANA"] = "ANA";
    IEnumInsurer["QUALITAS"] = "QUALITAS";
    IEnumInsurer["GNP"] = "GNP";
    IEnumInsurer["HDI"] = "HDI";
    IEnumInsurer["POTOSI"] = "POTOSI";
    IEnumInsurer["MAPFRE"] = "MAPFRE";
    IEnumInsurer["ZURICH"] = "ZURICH";
})(IEnumInsurer || (IEnumInsurer = {}));
var IPdfType;
(function (IPdfType) {
    IPdfType["MEDICRECIPE"] = "MEDICRECIPE";
    IPdfType["PRESCRIPTION_THERAPY"] = "PRESCRIPTION_THERAPY";
    IPdfType["CONSULT"] = "CONSULT";
    IPdfType["BACKGROUND"] = "BACKGROUND";
})(IPdfType || (IPdfType = {}));
var IStatus;
(function (IStatus) {
    IStatus["ACTIVE"] = "ACTIVE";
    IStatus["PENDING"] = "PENDING";
    IStatus["INACTIVE"] = "INACTIVE";
})(IStatus || (IStatus = {}));
var IProblemStatus;
(function (IProblemStatus) {
    IProblemStatus["OPEN"] = "OPEN";
    IProblemStatus["PENDING"] = "PENDING";
    IProblemStatus["CLOSED"] = "CLOSED";
})(IProblemStatus || (IProblemStatus = {}));
var IApplyPolicy;
(function (IApplyPolicy) {
    IApplyPolicy["BEFORE_RESOLVER"] = "BEFORE_RESOLVER";
    IApplyPolicy["AFTER_RESOLVER"] = "AFTER_RESOLVER";
})(IApplyPolicy || (IApplyPolicy = {}));

export { Alert, AtomBanner, AtomButton, AtomCarrousell as AtomCarruosell, AtomCartShop, ContactComponent as AtomContactComponent, Container as AtomContainer, RecursiveDropdownHook as AtomDropdown, AtomDropdownSidebarAdmin, AtomDropdownSidebarDefault, AtomDropdownSidebarLinks, AtomFilterCategory, AtomFilterRange, AtomFilterSearch, AtomFilterSort, AtomFormSeo, Icon$1 as AtomIcon, Image$2 as AtomImage, InputImageEditor as AtomImageEditor, Input as AtomInput, InputSelectWtihPagination as AtomInputPagination, AtomInputTextError, Link$1 as AtomLink, Loader as AtomLoader, Maps as AtomMap, AtomModal, AtomModalBox, AtomModalImage as AtomModalImages, AtomNotification, AtomPagination, ProgressBar as AtomProgressBar, Seo as AtomSeo, SeoPage as AtomSeoPage, Separator as AtomSeparator, Table$1 as AtomTable, AtomTableQuery, AtomTabs, Text$2 as AtomText, AtomTextEditor$1 as AtomTextEditor, AtomTextEditor as AtomTextEditorHermer, AtomUserDefault, Wrapper$2 as AtomWrapper, AtomWrapperScroll, BurgerBUtton as BurgerButton, ButtonsCartShop, CartShop, ContainerPublicLinks, DownloadFile as DownLoadFileComponent, Footer, FooterColumnsComponent as FooterColumns, FooterLogoComponent as FooterLogo, FooterSolicialLinks, Header, HeaderLink, HeaderLinkPublic, HeaderLogo, Sidebar$1 as HeaderSidebar, IApplyPolicy, IArticleLanguage, IArticleStatus, IBackgroundTypesOptions, IBeginType, IBillingForm, ICertificateMovementType, ICertificateStatusFrom, ICertificateType, IContactType, IContractorType, ICostingType, ICouponRuleType, ICourseLevel, ICourseModality, ICourseType, ICoverageType, IEnumAttendanceStatus, IEnumAutoType, IEnumBank, IEnumBenefits, IEnumBonoType, IEnumChargeType, IEnumCivilState, IEnumConductChoise, IEnumConstructionType, IEnumContractorGroupType, IEnumContractorGroupingType, IEnumContractorType, IEnumDiscount, IEnumEmaiModel, IEnumEmailChargeType, IEnumEmailDateType, IEnumEmailFrequency, IEnumEmailRamo, IEnumEmailType, IEnumEntorsementType, IEnumFCurrency, IEnumFormDamageType, IEnumFormsPayment, IEnumGender, IEnumHiringType, IEnumIdProduct, IEnumInsideType, IEnumInsurer, IEnumInsurerCommentModel, IEnumInsurerLogEvent, IEnumInsurerReminderInstanceType, IEnumInsurerReminderType, IEnumInsurerSubBranch, IEnumInsurerTicketConcept, IEnumInsurerTicketPriority, IEnumInterval, IEnumMemberRelationStatus, IEnumMethodPayment, IEnumMonth, IEnumNameCatalog, IEnumNotificationType, IEnumOnlineQuizStatus, IEnumPayScheme, IEnumPoliceAdministrationType, IEnumPoliceBussinessLine, IEnumPoliceConcept, IEnumPoliceDocumentType, IEnumPoliceEmisionStatus, IEnumPolicePaymentType, IEnumPoliceQuoteStatus, IEnumPoliceReceiptFolioPaymentMethod, IEnumPoliceReceiptPaymentMethod, IEnumPoliceReceiptStatus, IEnumPoliceReceiptType, IEnumPoliceReceipts, IEnumPoliceRenew, IEnumPoliceRenewalStatus, IEnumPoliceStatus, IEnumPolicyType, IEnumProcedent, IEnumQuizStatus, IEnumQuoteStatus, IEnumRecordStatus, IEnumReferrerAccountState, IEnumReferrerClosed, IEnumReferrerFrequency, IEnumReferrerPaymentType, IEnumResourceQuoteStatus, IEnumResponsableArea, IEnumSAType, IEnumSinisterCarSubSubType, IEnumSinisterCarSubType, IEnumSinisterCarType, IEnumSinisterKind, IEnumSinisterLifeReason, IEnumSinisterPaymentType, IEnumSinisterReason, IEnumSinisterRelation, IEnumSinisterStatus, IEnumSinisterType, IEnumSpaceAccess, IEnumStudenteVerify, IEnumTagPosition, IEnumTransactionService, IEnumTransactionStatus, IEnumTransactionType, IEnumTypePerson, IEnumTypeSinisterGeneral, IEnumVisibility, IEventMode, IEventStatus, IEventVisibility, IFrequencyPayment, IFunctionType, IGender, IHttpStatusCode, IInsurerPackageStatus, IInsurerType, IInvoiceStatus, IInvoicingMethod, IInvoicingPeriod, IIssueStatus, IMaritalStatus, IMerchandiseStatus, IMetaType, IMovementType, IPaymentResponsable, IPaymentTerm, IPdfType, IPeriodInvoice, IPerson, IPolicyStatus, IPolicyType, IPriority, IPrizeCodeStatus, IProblemStatus, IProductModality, IProductStatus, IProductType, IProgress, IProviderType, IPurchaseQuoteStatus, IQuestionType, IQuiz_QuestionType, IQuoteGender, IQuoteStatus, IRoleType, IRuleAppliesOn, ISellStatus, IServiceEmail, IServiceEnvironment, IServiceOption, IServicePayment, IShopType, ISocialNetworkType, ISortEnumType, IStatus, IStoreType, ITemplateService, ITemplateType, ITransactionStatus, ITransactionType, ITransportMode, ITypeAgentProvider, ITypeContent, ITypeForm, ITypeInsurance, ITypeVideo, IUseCDFI, Iauth_PaymentMethod, Iexchange_Status, Iitus_PaymentTerm, Isaam_EnumGender, ItemCartShop, LayoutAnimation, MoleculeButtonCardShop, MoleculeCard, MoleculeCardComment, MoleculeCardImage, MoleculeInsertComment, MoleculeNewsLetter, Player as MoleculePlayer, MoleculeSearchBar, ChatMyMessage as MyMessage, AdminHeader as OrganismAdminHeader, OrganismAdminSidebar, DefaultFooter as OrganismDefaultFooter, DefaultHeader as OrganismDefaultHeader, OrganismSidebar as OrganismDefaultSidebar, OrganismUserDefault as OrganismDefaultUser, ChatOtherMessage as OtherMessage, Sidebar, SidebarCall, SidebarLinks, SidebarRecursive, StylesGlobal, capitalizeFirstLetter$1 as capitalizeFirstLetter, changeBrightness, convertDate, convertDateWithOptions, convertLocalDateToUTC, convertUTC, convertUTCtoLocalDate, havePermission, isBackDark, numberWithCommas as numberWithComas, translateCountry, uploadImage, uploadPrivateFile, useAlert, useDownloadFile, useLazyFetch, usePermissions, useRouterPrivate as useRouterPublic, useRouterPrivate as useRouterService, useUploadFile };
