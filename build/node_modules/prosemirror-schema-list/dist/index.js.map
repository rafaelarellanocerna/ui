{"version":3,"file":"index.js","sources":["../../../../node_modules/prosemirror-schema-list/dist/index.js"],"sourcesContent":["import { findWrapping, ReplaceAroundStep, canSplit, liftTarget } from 'prosemirror-transform';\nimport { NodeRange, Fragment, Slice } from 'prosemirror-model';\nimport { Selection } from 'prosemirror-state';\n\nconst olDOM = [\"ol\", 0], ulDOM = [\"ul\", 0], liDOM = [\"li\", 0];\n/**\nAn ordered list [node spec](https://prosemirror.net/docs/ref/#model.NodeSpec). Has a single\nattribute, `order`, which determines the number at which the list\nstarts counting, and defaults to 1. Represented as an `<ol>`\nelement.\n*/\nconst orderedList = {\n    attrs: { order: { default: 1 } },\n    parseDOM: [{ tag: \"ol\", getAttrs(dom) {\n                return { order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1 };\n            } }],\n    toDOM(node) {\n        return node.attrs.order == 1 ? olDOM : [\"ol\", { start: node.attrs.order }, 0];\n    }\n};\n/**\nA bullet list node spec, represented in the DOM as `<ul>`.\n*/\nconst bulletList = {\n    parseDOM: [{ tag: \"ul\" }],\n    toDOM() { return ulDOM; }\n};\n/**\nA list item (`<li>`) spec.\n*/\nconst listItem = {\n    parseDOM: [{ tag: \"li\" }],\n    toDOM() { return liDOM; },\n    defining: true\n};\nfunction add(obj, props) {\n    let copy = {};\n    for (let prop in obj)\n        copy[prop] = obj[prop];\n    for (let prop in props)\n        copy[prop] = props[prop];\n    return copy;\n}\n/**\nConvenience function for adding list-related node types to a map\nspecifying the nodes for a schema. Adds\n[`orderedList`](https://prosemirror.net/docs/ref/#schema-list.orderedList) as `\"ordered_list\"`,\n[`bulletList`](https://prosemirror.net/docs/ref/#schema-list.bulletList) as `\"bullet_list\"`, and\n[`listItem`](https://prosemirror.net/docs/ref/#schema-list.listItem) as `\"list_item\"`.\n\n`itemContent` determines the content expression for the list items.\nIf you want the commands defined in this module to apply to your\nlist structure, it should have a shape like `\"paragraph block*\"` or\n`\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\ngiven to assign a group name to the list node types, for example\n`\"block\"`.\n*/\nfunction addListNodes(nodes, itemContent, listGroup) {\n    return nodes.append({\n        ordered_list: add(orderedList, { content: \"list_item+\", group: listGroup }),\n        bullet_list: add(bulletList, { content: \"list_item+\", group: listGroup }),\n        list_item: add(listItem, { content: itemContent })\n    });\n}\n/**\nReturns a command function that wraps the selection in a list with\nthe given type an attributes. If `dispatch` is null, only return a\nvalue to indicate whether this is possible, but don't actually\nperform the change.\n*/\nfunction wrapInList(listType, attrs = null) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to), doJoin = false, outerRange = range;\n        if (!range)\n            return false;\n        // This is at the top of an existing list item\n        if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n            // Don't do anything if this is the top of the list\n            if ($from.index(range.depth - 1) == 0)\n                return false;\n            let $insert = state.doc.resolve(range.start - 2);\n            outerRange = new NodeRange($insert, $insert, range.depth);\n            if (range.endIndex < range.parent.childCount)\n                range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);\n            doJoin = true;\n        }\n        let wrap = findWrapping(outerRange, listType, attrs, range);\n        if (!wrap)\n            return false;\n        if (dispatch)\n            dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());\n        return true;\n    };\n}\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n    let content = Fragment.empty;\n    for (let i = wrappers.length - 1; i >= 0; i--)\n        content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));\n    let found = 0;\n    for (let i = 0; i < wrappers.length; i++)\n        if (wrappers[i].type == listType)\n            found = i + 1;\n    let splitDepth = wrappers.length - found;\n    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;\n    for (let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false) {\n        if (!first && canSplit(tr.doc, splitPos, splitDepth)) {\n            tr.split(splitPos, splitDepth);\n            splitPos += 2 * splitDepth;\n        }\n        splitPos += parent.child(i).nodeSize;\n    }\n    return tr;\n}\n/**\nBuild a command that splits a non-empty textblock at the top level\nof a list item by also splitting that list item.\n*/\nfunction splitListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to, node } = state.selection;\n        if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to))\n            return false;\n        let grandParent = $from.node(-1);\n        if (grandParent.type != itemType)\n            return false;\n        if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth == 3 || $from.node(-3).type != itemType ||\n                $from.index(-2) != $from.node(-2).childCount - 1)\n                return false;\n            if (dispatch) {\n                let wrap = Fragment.empty;\n                let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--)\n                    wrap = Fragment.from($from.node(d).copy(wrap));\n                let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1\n                    : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n                // Add a second list item with an empty default start node\n                wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n                let start = $from.before($from.depth - (depthBefore - 1));\n                let tr = state.tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\n                let sel = -1;\n                tr.doc.nodesBetween(start, tr.doc.content.size, (node, pos) => {\n                    if (sel > -1)\n                        return false;\n                    if (node.isTextblock && node.content.size == 0)\n                        sel = pos + 1;\n                });\n                if (sel > -1)\n                    tr.setSelection(Selection.near(tr.doc.resolve(sel)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n        let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        let tr = state.tr.delete($from.pos, $to.pos);\n        let types = nextType ? [null, { type: nextType }] : undefined;\n        if (!canSplit(tr.doc, $from.pos, 2, types))\n            return false;\n        if (dispatch)\n            dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n        return true;\n    };\n}\n/**\nCreate a command to lift the list item around the selection up into\na wrapping list.\n*/\nfunction liftListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        if (!dispatch)\n            return true;\n        if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\n            return liftToOuterList(state, dispatch, itemType, range);\n        else // Outer list node\n            return liftOutOfList(state, dispatch, range);\n    };\n}\nfunction liftToOuterList(state, dispatch, itemType, range) {\n    let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);\n    if (end < endOfList) {\n        // There are siblings after the lifted items, which must become\n        // children of the last item\n        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n        range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n    }\n    dispatch(tr.lift(range, liftTarget(range)).scrollIntoView());\n    return true;\n}\nfunction liftOutOfList(state, dispatch, range) {\n    let tr = state.tr, list = range.parent;\n    // Merge the list items into a single big item\n    for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n        pos -= list.child(i).nodeSize;\n        tr.delete(pos - 1, pos + 1);\n    }\n    let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;\n    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)\n        return false;\n    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;\n    let parent = $start.node(-1), indexBefore = $start.index(-1);\n    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))\n        return false;\n    let start = $start.pos, end = start + item.nodeSize;\n    // Strip off the surrounding list. At the sides where we're not at\n    // the end of the list, the existing list is closed. At sides where\n    // this is the end, it is overwritten to its end.\n    tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty)))\n        .append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n    dispatch(tr.scrollIntoView());\n    return true;\n}\n/**\nCreate a command to sink the list item around the selection down\ninto an inner list.\n*/\nfunction sinkListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        let startIndex = range.startIndex;\n        if (startIndex == 0)\n            return false;\n        let parent = range.parent, nodeBefore = parent.child(startIndex - 1);\n        if (nodeBefore.type != itemType)\n            return false;\n        if (dispatch) {\n            let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n            let inner = Fragment.from(nestedBefore ? itemType.create() : null);\n            let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n            let before = range.start, after = range.end;\n            dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true))\n                .scrollIntoView());\n        }\n        return true;\n    };\n}\n\nexport { addListNodes, bulletList, liftListItem, listItem, orderedList, sinkListItem, splitListItem, wrapInList };\n"],"names":["NodeRange","findWrapping","Fragment","ReplaceAroundStep","Slice","canSplit","liftTarget"],"mappings":"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"}